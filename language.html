<html>
<div	style="font-size:14pt">

<h1>Towards Compiler Languages for RTA1 Architecture</h1>

<p>
There are no compiler languages yet for RTA1. Every instruction in it
has been assembled with the masmx meta-assembler

<p>
The assembler code has taken two shapes. Some routines are simple
and agile.  These routines are very active at the stack top and alter the stack pointer
freely

<p>
There are also routines which structure the internal stack and use it as
a non-volatile register list

<p>
Macros support the second sort of activity,
and construct call parameter lists and dynamic variable lists in the internal
and external stacks

<p>
It is hoped that these call sequences will be useful for C compiler
developers, and that languages significantly different from C in structure and
organisation will also use exactly the same calling sequences

<p>
This macro file <b>language/stack.def</b> provides four services to "near"
routines <b>lcal ... lret</b> and to "far" routines <b>call ... fret</b>

<p>
Three services are contained in the macro <b>$head_near/far</b> and one
service is contained in the macro <b>c / lc</b>

<p>
The <b>c / lc</b> macro embeds far and near call instructions
<b>call</b> and <b>lcal</b>, first pushing parameters on the
internal stack, and afterwards clearing the internal stack

<p>
Macro <b>$head_near/far</b> constructs up to three lists of names which
are base+displacement definitions on one or other stack pointer

<p>
<b>$head_near/far</b> also constructs the data corresponding to
two of those three lists of names

<p>
<b>$head_near/far</b> has three embedded macros, <b>params() scalars() xframe()</b>

<p>
<b>params()</b> maps names onto the parameters pushed in <b>c / lc</b>

<p>
<b>scalars()</b> constructs and names the dynamic variable list in the
internal stack based on Stack Pointer sp

<p>
<b>xframe()</b> constructs a second dynamic variables list in the
in the external stack based on Frame Pointer Register fp. This is for
structures and arrays. The internal stack is only large enough for scalars
and pointers

<p>
Both <b>$head_near/far</b> and <b>c / lc</b> take increased stack
displacements into account as they add objects to the stack

<p>
This avoids saving and dedicating another index register to cover

<p>
A routine with a list of parameters and dynamic variables should not alter
the stack, except with the call sequence <b>c / lc </b>,
because even if one developer understands the swelling and
shrinking stack displacements, another developer may not. Also the
flicked displacements would be a horrifying coding method. The correct way to
save a register in mid-routine is to have a dynamic variable for it in the
<b>scalars()</b> list

<p>
<b>c / lc</b> finalises the parameter list by pushing a stack walkback before
the <b>call / lcal</b> instruction and popping the internal stack pointer on
return. If there are no parameters, it doesn't. Then the effect is the same
as issuing a <b>call</b> or <b>lcal</b> instruction directly

<p>
This assembly of a skeletal application fragment <b>stack.msm</b> is followed by a listing
of the the macro source in <b>../language/stack.def</b>

The three code routines in <b>stack.msm</b> are <b>$tree ... $root</b> blocks so that
their internal names need not be unique. Those names are visible outside the
routines as catenated after the routine name
<pre>

$ masmx stack -kln
MASMX 7r1
3/stack.msm
*EOF*
  :                            1 .	I am a demonstration code fragment
  :                            2 .	for the ../language/stack macro complex
  :                            3 
  :                            4: 	$include ../def/rta.def
  :                            5: 	$include ../language/stack.def
  :                            6 
  :                            7 
  :                            8 number_table* $proc
  :                            9 *	$tree
  :                            10 ?	$do	15,	+	1.75*+?
  :                            11 	$root
  :                            12 	$end
  :                            13 
  :                            14 
  :                            15 $(0:64)
  :                            16 
  :                            17 f1	$tree
                                	$head_near	 params(word12x,	int	;
                                				keyname,	long	;
                                				factor,		float)	;
                                							;
                                			scalars(lower,	int	;
                                				upper,	int	;
Note: stack.msm Line 24: add $$frame to sp before return
00:000040 FD0000              +24 				list,	int,	a)
00:000041 FD0000              +24 
00:000042 F80004              +24 
  :                            25 
                                	lc	f2	factor,,FLOATING		;
                                			0,,xi				;
00:000043 F8F000              +28 			list
00:000044 FD0000              +28 
00:000045 8FF00A              +28 
00:000046 FCF006              +28 
00:000047 3E004C              +28 
00:000048 38000F              +28 
  :                            29 
  :                            30 
00:000049 FCF003              +31 	push, i	$$frame, sp
00:00004A 38000F              +32 	pop	sp
00:00004B 350000              +33 	lret	0
  :                            34 	$root
  :                            35 
  :                            36 f2	$tree
                                	$head_near	 params(factor, float	;
                                				zeroflag, int	;
                                				list, int)	;
                                						;
                                			scalars(temp, int	;
                                				temp1, float	;
                                				temp2, float)	;
                                						;
                                			 xframe(primed, number_table, (number_table)	;
                                				seed1,	float,	(3.75e-1262611)		;
Note: stack.msm Line 47: add $$frame to sp before return
00:00004C FD0000              +47 				seed2,	float,	(3.75e+1262610))
00:00004D 5F0100              +47 
00:00004E 5F0100              +47 
00:00004F FDFFBC              +47 
00:000050 2F000E              +47 
00:000051 9F0002              +47 
00:000052 F80000              +47 
00:000053 54E000              +47 
00:000054 5C0102              +47 
00:000055 45000E              +47 
00:000056 3E0077              +47 
00:000057 380000              +47 
00:000058 380002              +47 
00:000059 380003              +47 
00:00005A 8F013E              +47 
00:00005B 87E03C              +47 
00:00005C 8F0142              +47 
00:00005D 87E040              +47 
Note: stack.msm Line 47: add $$xframe to fp before return
  :                            48 
  :                            49 
00:00005E FCE044              +50 	push, i	$$xframe, fp
00:00005F 38000E              +51 	pop	fp
00:000060 FCF009              +52 	push,i	$$frame, sp
00:000061 38000F              +53 	pop	sp
00:000062 350000              +54 	lret	0
  :                            55 	$root
  :                            56 
  :                            57 entry	$tree
                                	$head_far	 params(keyname, long)				;
                                									;
                                			scalars(save_caller_x, int,	x		;
                                				save_caller_a, int,	a)		;
                                									;
Note: stack.msm Line 63: add $$frame to sp before return
00:000063 F80002              +63 			 xframe(transient_key, long, keyname)
00:000064 F80004              +63 
00:000065 FDFFFE              +63 
00:000066 2F000E              +63 
00:000067 9FF005              +63 
00:000068 38E000              +63 
00:000069 38E001              +63 
Note: stack.msm Line 63: add $$xframe to fp before return
  :                            64 
  :                            65 
                                	lc	f1	12,x,i						;
                                			keyname,,LONG					;
00:00006A 5F0146              +68 			(1.875d),,PACKED_FLOATING
00:00006B 9FF009              +68 
00:00006C FCA00C              +68 
00:00006D FCF007              +68 
00:00006E 3E0040              +68 
00:00006F 38000F              +68 
  :                            69 
  :                            70 
00:000070 50F001              +71 	lx	save_caller_x
00:000071 60F000              +72 	la	save_caller_a
  :                            73 
00:000072 FCE002              +74 	push,i	$$xframe, fp
00:000073 38000E              +75 	pop	fp
  :                            76 
00:000074 FCF002              +77 	push,i	$$frame, sp
00:000075 38000F              +78 	pop	sp
00:000076 3D0000              +79 	fret	0
  :                            80 	$root
  :                            81 
00:000077 8FB000              +82 	SEGMENT_QL
00:000078 87A000              +82 
00:000079 850004              +82 
00:00007A 8D0004              +82 
00:00007B 1E0077              +82 
00:00007C 350000              +82 
00:00007D F8B000              +82 
00:00007E 38A000              +82 
00:00007F 850001              +82 
00:000080 8D0001              +82 
00:000081 1E007D              +82 
00:000082 350000              +82 
  :                            83 
  :                            84 	$do	$<256,$(0:256)
  :                            85 
*EOF*
00:000100+FFFFFFFFFFFF
00:000102+4000058C0000000000000000
400008AF0000000000000000
40000BDAC000000000000000
40000F88B800000000000000
400012AAE600000000000000
400015D59F80000000000000
4000198583B0000000000000
40001CA6E49C000000000000
40001FD09DC3000000000000
400023826299E00000000000
400026A2FB40580000000000
400029CBBA106E0000000000
40002CFEA894898000000000
4000309F295CD5F000000000
400033C6F3B40B6C00000000
00:00013e+000003F7CEC07F62DB171749
00:000142+7FFFFEB9F360BBB221C7199A
00:000146+401F00000000
:$(00):000040:000148 :$(46):000000:000002 
stack.msm: object code 1171 bytes: 0 errors: 0 undefined labels



$ cat ../language/stack.def
p		$proc	*
"$head_far"*	$name	3
"$head_near"*	$name	2
"$$list"	$set	p(0, 0)

"$SP_LOWER_LIMIT"       $equ    0


int	$equ		1
long	$equ		2
float	$equ		4
floating_packed $equ	4

params*	$func		*
param*	$func
	$do	$stack_macro_remarks^=0,	;
	$note		param
"param(1, 1)"*** $equf	$$list+iframe, sp
	$return		param(1, 2)
	$end
        $do     $stack_macro_remarks^=0,        ;
	$note		walking params
?	$do		params(),"$$list"*	$set	$$list+param(params(?))
	$return		$$list
	$end


scalars* $func

scalar*	$proc		$(0)
floating_packed $equ	-4
        $do     $stack_macro_remarks^=0,        ;
	$note		scalar

	  $if		scalar(1, 4)=sp
          $do     $stack_macro_remarks^=0,        ;
	  $note		sp is decrementing
"$$extra" $set		frame
	  $else
"$$extra" $set		0

	  $endif
	$if		scalar(1, 2)=floating_packed
frame*	  $set		frame-4
	  $if		scalar(1)>2
		fpx	scalar(1, 3)+$$extra, scalar(1, 4)
	  $else
		fpx	(-0.0:d)
	  $endif
	$else
	  $if		scalar(1, 2)=int
	    $if		scalar(1)>2
		push	scalar(1, 3)+$$extra, scalar(1, 4), scalar(1, 5)
	    $else
		push,xi	0
	    $endif
	  $elseif		scalar(1, 2)=long
	    $if		scalar(1)>2
		dpush	scalar(1, 3)+$$extra, scalar(1, 4)
	    $else
		dpush	(0:d)
	    $endif
	  $elseif		scalar(1, 2)=float
	    $if		scalar(1)>2
		qpush	scalar(1, 3)+$$extra, scalar(1, 4)
	   
	    $else
		fpx	(-0.0:d)
	    $endif
	  $elseif		(scalar(1, 2)>0)**(scalar(1, 2)<25)
	    $do	scalar(1, 2)**3,	push, xi	0
	    $do	scalar(1, 2)>3,		fpx		(0.0:d)
	    $do	scalar(1, 2)/4-1,	qpush		0, sp
	  $else
	    $flag		internal stack item size of of range
	    $return
	  $endif
frame*	$set		frame-scalar(1, 2)
	$endif


"scalar(1, 1)"***  $equf   frame, sp

	$end

        $do     $stack_macro_remarks^=0,        ;
	$note		walking scalars

frame	$set		0
?	$do	scalars(),frame	$set	frame+scalars(?, 2)

iframe* $set frame
	$if		frame
	$note		add $$frame to sp before return

$(71)
?	$do	scalars(),	scalar	scalars(?)
	$endif
	$return	frame
	$end

xframe*	$func

p	$proc		$(70)
load_string* $name
        $do     $stack_macro_remarks^=0,        ;
	$note		load string


	$if		($t(p(1, 2))=$name)++($t(p(1, 2))=$proc)
"p(1, 1)"***		p(1, 2)
	$else
"p(1, 1)"***	$res	p(1, 2)
	$endif


words	$set		$(70)-p(1, 1)

$(0)
	$if		p(1)>2
	  $if		words=1
		push	p(1, 3), p(1, 4), p(1, 5)
		pop	p(1, 1),, p(1, 6)
	  $elseif	words=2
		dpush	p(1, 3), p(1, 4)
		pop	p(1, 1)
		pop	p(1, 1)+1
	  $elseif	words=4
		qpush	p(1, 3), p(1, 4)
		qpop	p(1, 1)
	  $else
		dpush	x
		push	r
		lx, i	p(1, 1)
		ly, i	p(1, 3), p(1, 4)
		$if	words/4
		lr, xi	words/4-1
		lcal	segment_ql
		$endif
		$if	words///4
		lr, xi	words///4-1
		lcal	segment_sl
		$endif
		pop	r
		pop	x
		pop	y
	  $endif
	$endif
	 
	$end

$(0)
	push, xi	-lframe
	popA		fp

$(71)
        $do     $stack_macro_remarks^=0,        ;
	$note		walking dynamic load strings
?	$do	xframe(),	load_string	xframe(?)
	$note		add $$xframe to fp before return
	$return		$(70)
	$end

	

$(70::,fp)
$(71)

	$do	$t(iframe)=0,iframe	$set	0

?	$do	p(),part(?)*	$set	p(?, 1)
lframe		$set	$(70)
$(0)
"$$frame"*	$set	iframe
"$$xframe"*	$set	$(70)
	$end

p	$proc
c*	$name	1
lc*	$name	0

INT	$equ	100
LONG	$equ	101
PACKED_FLOATING $equ 102
FLOATING $equ	103

p	$proc
vpush*	$name

	$if	p(1, 2)=sp
"$$extra" $set	$$dispo
	$else
"$$extra" $set	0
	$endif

	$if	p(1, 3)=FLOATING
	qpush	p(1, 1)+$$extra, p(1, 2)
"$$dispo"* $set	$$dispo+4
	$elseif	p(1, 3)=PACKED_FLOATING
	fpx	p(1, 1)+$$extra, p(1, 2)
"$$dispo"* $set	$$dispo+4
	$elseif	p(1, 3)=LONG
	dpush	p(1, 1)+$$extra, p(1, 2)
"$$dispo"* $set	$$extra+2
	$else
	push	p(1, 1)+$$extra, p(1, 2), p(1, 3)
"$$dispo"* $set	$$dispo+1
	$endif

	$end

alist	$set	p()

"$$dispo" $set	0

.	la	sp
?	$do	alist-1,	vpush	p(alist+1-?)

	$do	alist>1,	;
	push	$$dispo, sp, i

	$do	p(0, 0)=c,	call	p(1)
	$do	p(0, 0)=lc,	lcal	p(1)

	$do	alist>1,	;
	pop	sp
	$end

	$end

"$vector"* $proc
	$do	$bank_index**4095^=0,	$flag	bank misaligned
	$do	$>63,			$flag	vector outside bank locations 0..63
*	$equ	$bank_index/*6++$
	j	$vector(1)
	$end

SEGMENT_QL* $proc	*

segment_ql*
	qpush	0, y
	qpop	0, x
	ax, xi	4
	ay, xi	4
	jdr	segment_ql
	lret	0

segment_sl*
	push	0, y
	pop	0, x
	ax, xi	1
	ay, xi	1
	jdr	segment_sl
	lret	0

	$end

"$stack_macro_remarks"	$set	0



</pre>
</div>
</html>

