<div    style="color:00FF60;font-family:optima;font-size:88pt;position:absolute;top:84pt">
<center>
The Next Revolution is Efficient Code
</center>
</div>



<div style=font-family:Times;position:absolute;top:0">

<center>

<h1>MASMX.7r3</h1>

<div	style="color:C0C0FF;font-family:optima;font-size:24">
The Watchmaker's Craft of Programming
<br>
<br>
</div>

<i>
Copyright Tim Cox, 2015<br>

This document describes the masmx.7r3 target-independent meta-assembler
<br>
The masmx.7r3 meta-assembler is free software licensed with the GNU General Public Licence Version 3
<br>
The same licence encompasses all accompanying software and documentation <br>
The full licence text is included with these materials<br>
See also the licensing notice at the foot of this document
</i>


<h1>The Free Meta Assembler</h1>



</center>

<h2>What's masmx?</h2>

<p>
masmx is a freeware meta-assembler for any target

<p>
Developed as a cross-assembler for embedded targets<br>
masmx ready-made binaries run as 32-bit programs on all popular PCs<br>

<p>
Freeware means free access to the downloadable source

<p>
masmx is easy to use

<p>
masmx can assemble absolute system images in one step from source.

<p>
masmx can assemble relocatable code and has an internal linker.

<p>
The cumulative linker constructs each program section as absolute or as a new relocatable

<p>
Integers and floating numbers are any format and size up to 192 bits.<br>
192 bits are not excessive because systems already compute and exchange 128-bit numbers

<div	style="color:A0A0A0">
<blockquote>

Maximum memory space depends on target architecture. The highest address where masmx
can assemble and load code is

	<blockquote>
	0FFFFFFFF:FFFFFFFF:FFFFFFFF:FFFFFFFF:FFFFFFFF:FFFFFFFF
	</blockquote>

(4 tera-peta-peta-petaquanta or 4096 exa-exa-exaquanta or 4-giga-yotta-yottaquanta<br>
of words or bytes, whichever the target address quantum is)

<p>
Memories this large are not immediately expected, but masmx
calculates and labels numbers of this size.<br>
There is no reason why an assembler for all targets should have
less maximum address range than maximum number size
</blockquote>
</div>


<p>
Segmented memory, base-displacement addressing, preprogrammed physical
memory relocation and memory address translation are all supported

<p>
masmx also assembles images for the simplest 8-bit architectures

<p>
masmx has a slender native syntax, and interprets all other assembly
source code syntax.
All existing source code assembles unchanged

<p>
Intermediate binary encoding and target S-Records or I-Records are in text

<p>
The accompanying masmx definition headers for 8051 and for PowerPC
are field proven in live commercial use.

<p>
Innovations in target architecture are tracked with updates in macro language.
Anyone who understands the target architecture can do this.

<p>
User interface is a shell or command prompt

<p>
Binaries for all popular platforms are downloadable. Installation = copy the binaries

<a href="http://timmilescox.github.io/masmx/">
        Downloads Page</a>

<p>
masmx source code is in git and download zip. Build for new developer platforms is a one-line shell command

 


<h2>Why do you want it?</h2>


<p>
masmx gives minute control of the construction and location of code and data.

<p>
Typical masmx targets are low-power targets where as few instructions
as possible are executed.

<div    style="color:A0A0A0">
<blockquote>

masmx saves electronics and energy, and may be used as the substance of thin-layer compilers.<br>
masmx makes the miniature more possible, and can multiply the performance of giant servers by ten- and twentyfold.<br>
Language compilers can be reinvented to generate a common macro-assembly language for all targets
</blockquote>
</div>

<p>
Complex EPROM and Flash structures may be described in a few cryptic lines of source code.

<p>
The maximum integer, floating point and address radix of 192 bits make
masmx a toolchain for experimental large architectures,<br>
or for multi-architecture systems with special hardware modules.

<p>
masmx is also a toolchain for the smallest architectures. The supplied definition header for 8051<br>
has been used on mission-critical projects by prestige clients.

<p>
32-bit and 64-bit PowerPC assemblies with incremental and absolute linking are illustrated<br>
in Section 9 of this manual. masmx has generated PowerPC RT kernels with the same macro text.

<p>
Target architecture definitions are source code include files.

<p>
This manual shows how to use masmx for any architecture present or future.

<p>
For assistance building macro definition text for a new target, contact masmx@gmx.ch.

<p>
masmx may be hosted on MAC OS X PowerPC G4, MAC OS X Intel ix86, Sun SPARC Solaris,<br>
UBUNTU and DEBIAN Linux x86, MS DOS and MS Windows 32-bit.


<pre>


1.  What masmx can do							1

    1.	Any Target Architecture						1.1
    2.	Any Input Syntax
	1  Legacy Source Code Unchanged					1.2.1
    	2  Number and Character String Notation				1.2.2
    3.	Any Word Size							1.3
    4.	Any Address Space						1.4
    5.	Any Floating Point Format					1.5
    6.  Structured Data and Repeat Data					1.6
	1.  Structured Data						1.6.1
	2.  Bit-Aligned Structured Data					1.6.2
    	3.  Accessing Bit-Aligned Structured Data			1.6.3
	4.  Repeat Data							1.6.4
	5.  Functionally Compartmented Name Spaces			1.6.5
    7.	Run-Time Algorithm Plotting					1.7

2.  Developer Environment						2

3.  Getting started							3

4.  The Assembly Language Source Line					4

    1.	Labels								4.1

    2.	Expressions							4.2
	1.  Operators							4.2.1
	2.  Tokens							4.2.2
	    1.	Number Strings						4.2.2.1
		1.  masmx Default Number and String Notation		4.2.2.1.1
		2.  C Language Number and String Notation		4.2.2.1.2
		3.  Motorola Old Number Notation			4.2.2.1.3
		4.  Suffix-Determined Number Notation			4.2.2.1.4
	    2.	Label References					4.2.2.2
	    3.	masmx Internal Functions				4.2.2.3
	    4.	Function Macro Reference				4.2.2.4
	    5.	Macro Parameter Reference				4.2.2.5

    3.	The Command Field						4.3
	1.  Directives							4.3.1
	2.  Storage Constants						4.3.2
	3.  Number Constants						4.3.3
	4.  Split Number Items						4.3.4
	5.  Text Strings						4.3.5
	6.  $form Items							4.3.6
	7.  $proc macro calls: instructions and structures		4.3.7

    4.  The Argument Field						4.4
	1.  Argument Expressions					4.4.1
	2.  Literal Arguments						4.4.2

    5.  Literals							4.5
	1.  A literal is						4.5.1
	2.  Literal Pools						4.5.2
	3.  Automatic Literals						4.5.3
	4.  Indirection Flag on a Literal				4.5.4
	5.  Literal Pool Tags						4.5.6
	6.  $lit Directive						4.5.6
	7.  Nested Literals						4.5.7
    
    6.  Function Macros							4.6
	1.  A Function Macro is						4.6.1
	2.  Directives used Constructing Functions			4.6.2
	    1.	$FUNC	Function Head					4.6.2.1
		1.  Second-Pass-Only Functions				4.6.2.1.1
		2.  Non-Idempotent Functions				4.6.2.1.2
		3.  Functions affecting Program Displacements		4.6.2.1.3
     	    2.	$NAME	Entry Point and Value Tag			4.6.2.2
	    3.	$RETURN	Value of Result					4.6.2.3
	    4.	$END	Function Foot					4.6.2.4
	3.  Code Generated During Function Evaluation			4.6.3

    7.  masmx Internal Functions in Detail			 	4.7

	1.  $	location counter					4.7.1
	    1.  $	this location counter				4.7.1.1
	    2.  $(..)	named location counter				4.7.1.2

	2.  $a	absolute address					4.7.2
	    1.	$a	current absolute address			4.7.2.1
	    2.	$a(..)	absolute value of expression			4.7.2.2

	3.  $b	section base address					4.7.3
                    	  
	4.  $bank_index	current memory block identifier			4.7.4

	5.  $n		short token for macro entry name value		4.7.5

	6.  $net(..)	unrelocated value of expression			4.7.6

	7.  $o(..)	value of an option flag				4.7.7

	8.  $r	region							4.7.8
	    1.	$r	identity of current location counter		4.7.8.1
	    2.	$r(..)	locator of named target				4.7.8.2

	9.  $rel(..)	relocation factor				4.7.9
	    1.	$rel	current relocation factor			4.7.9.1
	    2.  $rel(..) relocation factor of named locator		4.7.9.2

	10. $t(..)	type of a label					4.7.10
	    1.		undefined					4.7.10.1
	    2.		location					4.7.10.2
	    3.		$EQU						4.7.10.3
	    4.		$SET						4.7.10.4
	    5.		$EQUF						4.7.10.5
	    6.		$DIRECTIVE					4.7.10.6
	    7.		$FUNCTION (of masmx)				4.7.10.7
	    8.		$PROC (macro)					4.7.10.8
	    9.		$NAME						4.7.10.9
	    10. 	$FUNC (macro)					4.7.10.10
	    11. 	$FORM						4.7.10.11
	    12. 	user assigned label types			4.7.10.12

	11. $zenith	high address of section + literals		4.7.11
	    1.	$zenith		this section				4.7.11.1
	    2.	$zenith(..)	named section				4.7.11.2


5.  Iterated Code and Structured Data					5

    1.	$do and macros							5.1

    2.	Structured Data and Structured Code Name Spaces			5.2

	1.  Word-Aligned Structures $TREE / $BRANCH..$ROOT		5.2.1
	    1.  Simple Structures $TREE..$ROOT				5.2.1.1
	    2.  Overlaid Structures $BRANCH..$ROOT			5.2.1.2
	    3.  Complex Structures					5.2.1.3
	    4.  Structured Code Name Spaces				5.2.1.4
		    

	2.  Bit-Aligned Structures					5.2.2
	    1.	Bit-Aligned Data $record..$root				5.2.2.1
	    3.  Macro Code Access to Bit-Aligned Fields and Groups	5.2.2.2
	    2.	Overlaid Structures $record,$branch			5.2.2.3

6.  Run-Time Algorithm Plotter						6

    1.  Run-Time Integer Algorithm Plotter				6.1
    2.  Run-Time Floating Algorithm Plotter				6.2


7.  Constructing Program Sections					7

    1.  Absolute Location Counters					7.1

	1.  Simple Absolute Location Counters				7.7.1

	1.  Breakpointed Location Counters				7.1.2
	    1.  Physical Address Offset					7.1.2.1
	    2.  Breakpointed Location Counters: -v Option		7.1.2.2

	3.  Simple Location Counter without Breakpoint:
	    Base+Displacement in Flat Address Spaces			7.1.3

	4.  Breakpointed Location Counters:
             	    Base+Displacement in Translated Address Spaces	7.1.4

	5.  Void Segments						7.1.5

	6.  Breakpointed Location Counters: Giant Address Spaces	7.1.6

	    1.  Very Large Direct Addressed Sections			7.1.6.1

	    2.  Very Large Load Address Base-Displacement Examples	7.1.6.2

		1.  Giant Absolute Address Base-Displacement
		    Example (static referencing)			7.1.6.2.1

		2.  Giant Absolute Address Base-Displacement
		    Example (dynamic referencing)			7.1.6.2.2

	7.   Literal Pool Tag						7.1.7

    2.  Relocatable Location Counters					7.2



8.  masmx Directives							8

    1.	$ascii		set character code to ASCII			8.1
    2.	$awidth		set address width				8.2
    3.	$blank		set the globality of a future label		8.3
    4.	$branch		branch of a structured name space		8.4
    5.	$byte		set the width of a text byte			8.5

    6.	$characteristic		set floating exponent field size	8.6

    7.	$cont_char	change line continue character			8.7
    8.	$data_code	define/select character string code points	8.8
    9.	$do		generate repeated code				8.9
    10.	$else		conditional assembly				8.10
    11.	$elseif		conditional assembly				8.11
    12.	$end		foot of macro or assembly			8.12
    13.	$endif		conditional assembly				8.13
    14.	$equ		assign a value to label				8.14
    15.	$equf		assign a list of values to label		8.15
    16.	$exit		abandon assembly with a message			8.16
    17.	$flag		diagnostic, mark assembly in error		8.17

    18.	$flagf		first pass diagnostic, mark assembly in error	8.18

    19.	$floating_point set default floating number size		8.19

    20.	$form		bit fields layout template			8.20

    21.	$func		user macro to produce an operand value		8.21
    22.	$hex		set binary notation to hex			8.23

    23.	$if		conditional assembly				8.23

    24.	$include	include a source file or a binary file		8.24

	1.  $include		read a nested source file		8.24.1

	2.  $include,$binary 	linking directive:
				read a text-encoded binary file
				process its relocation information
				output the linked code			8.24.2

	3.  $include,$void	linking directive:
				include addresses from a text-encoded
				binary file, but no code from it	8.24.3

    25.	$info			linking directive:			8.25

	1.  $info,$offset	update tuple of relocation information	8.25.1

	2.  $info,$range_check		
	    $info,$range_check1	

			request linker Automatic range-checking
			of an updated field of output binary		8.25.2

    26.	$linewidth	control layout in text encoded binary		8.26

    27.	$list								8.27
	1.  $list	set inclusion nest level for listing		8.27.1
	2.  $list 0	suppress list and labels export			8.27.2

    28.	$lit		select default location counter for literals
			optionally declare literal tag			8.28

    29.	$load		linking directive:
			write revised binary information in
			output text-encoded binary file			8.30

    30.	$lterm		change comment character			8.30
    31.	$name		macro call name and value			8.31
    32.	$nop		do nothing [+ comment]				8.32
    33.	$note		informative diagnostic, not error		8.33
    34.	$notef		first pass informative diagnostic		8.34
    35.	$octal		set binary notation to octal			8.35
    36.	$path		alter include path				8.36
    37.	$plist		nest depth for listing macro expansion		8.37
    38.	$proc		head of procedural macro			8.38

    39.	$pushrel	linking directive:

			scan a relocation tuple applied to a
			word group in the text-encoded binary.

			Stack an unresolved relocation tuple
			for replay to the $MAP linking macro		8.39

    40.	$quantum	set address quantum				8.40

    41.	$quote		change quote mark				8.41


    42.	$record								8.42

	1.  $record		bit-aligned data structures		8.42.1
	2.  $record,$branch	bit-aligned structure overlay		8.42.2

    43.	$res		declare a storage buffer			8.43

    44.	$return								8.44

	1.		return a value from within $FUNC..$END		8.44.1
	2.		return from within $PROC..$END			8.44.2

    45.	$root		end of a structured name space which was	
			begun with $tree, $branch or $record		8.45

    46.	$set		assign value to a reassignable label		8.46

    47.	$set_option							8.47

	1.		set option flags				8.47.1

	2.		Interaction of Run Options
			and List Directives				8.47.2

    48.	$snap		list the label table				8.48

	1.  $snap		2nd pass				8.48.1
	2.  $snap, 1		1st pass				8.48.2
	3.  $snap[,1]	2	dynamic label table			8.48.3

    49.	$sterm		set the substring sentinel symbol		8.49
    50.	$store		set the default output file name		8.50

    51.	$suffix		suffix-determined  number string notation	8.51

    52.	$text		translate input text patterns			8.52

    53.	$trace		display value of expression			8.53
	1.  $trace	2nd pass display				8.53.1
	2.  $trace, 1	display both passes				8.53.2

    54.	$tree		simple structured name space			8.54

    55.	$twos_complement						8.55
	1.  $twos_complement	1	2s complement, default		8.55.1
	2.  $twos_complement	0	1s complement			8.55.2


    56.	$word		declare size of target computer word		8.56
    57.	$xqt_i		run-time integer algorithm plotter		8.57
    58.	$xqt_fp		run-time floating algorithm plotter		8.58
    59.	$zero_code_point  character string escaped zero value		8.59



9.  Output File Formats, Relocation and Linking
    Giant Address Spaces, Interfacing with GNU Tools			9

    1.	Text Encoded Binary Format, S-Records and Intel Hex Records	9.1

    2.	Relocation, Linking, Giant Address Space
	and Interfacing with GNU Tools					9.2

	1.  Relocation Information in Text Encoded Binary		9.2.1

	2.  masmx Linking in Principle					9.2.2

	3.  Demonstration Links						9.2.3

	    1.	The Simplest Link					9.2.3.1

	    2.	Link Collected by Sections				9.2.3.2

	    3.	Link Specific Segments					9.2.3.3

	    4.	Link an Output Relocatable				9.2.3.4

	    5.	Link an Accumulated Relocatable
		plus a New Relocatable					9.2.3.5

	    6.	The Incremental Link					9.2.3.6

	    7.	The Link in Giant Address Space				9.2.3.7

	    8.	The Incremental Link in Giant Address Space		9.2.3.8

	    9.	Linking with Void Inclusion				9.2.3.9

	    10.	Linking with void Inclusion
		in Giant Address Space					9.2.3.10


10. Describing Target Architecture in Text				10

    1.  Establishing Your Syntax					10.1
    2.	Describing the Target Architecture				10.2
	1.  $WORD, $BYTE, $QUANTUM, $AWIDTH				10.2.1
	2.  $FORM, $PROC, $NAME, $END					10.2.2
	    1.	The $FORM Template					10.2.2.1
	    2.	The $PROC Header					10.2.2.2
	    3.	The $NAME Entry Point					10.2.2.3
	    4.	The $END Macro Footer					10.2.2.4
	    5.  Minimal Instruction Macro Example			10.2.2.5
	    6.	The Two-pass $PROC					10.2.2.6
	    7.	The Out of Line $PROC					10.2.2.7
	    8.	Nested Macro Descriptions				10.2.2.8
    3.  Synthesising Legacy Automatic Macros				10.3
	1.  Synthesising Legacy Functional Macros			10.3.1
	2.  Synthesising Legacy Command Macros				10.3.2

11. masmx Internal Floating Format and Alternative Floating Formats	11
    1.	masmx Floating Format						11.1
    2.	IEEE754 Floating Values						11.2
	1.  Differences between masmx FLoating Format and IEEE754 Floating Formats
									11.2.1
	2.  Macro Language Generation of IEEE754 Floating Constants	11.2.2




Appendix A: masmx Command Line
Appendix B: What's new in 7r3?
Appendix C: The masmx Product Road Map
Appendix D: masmx's Potential for High Level Languages

Appendix E: Tuning Macro Language and Fixing Problems
	 E.1:	Fixing a Macro Parameter Reference
	 E.2:	Label Cannot Be Referenced
	 E.3:	Changed Label Value Disappears
	 E.4:	Tracing Macro Expansion
	 E.5:	Aliasing masmx Internal Functions
	 E.6:	Diagnostic about a Label Address
	 E.7:	Label fails to be Exported
	 E.8:	Literal Table overlaps Trailing Edge of Code

Appendix F: Target Descriptions
	 F.1:	8051
	 F.2:	PowerPC

	 F.3:	Definition Examples
	 F.3.1:	ColdFire
	 F.4:	Byte-Addressing Machines with 32 and 64 Bit Bus
		Managing Alignments

Appendix G: Disclaimer and Contact

</pre>


<h1>1: masmx Can Do</h1>

<h2>1.1: Any Target Architecture</h2>

<p>
Target architecture is described to masmx in macro language. See


	<blockquote>
	Section 3:  Getting Started<br><br>

	Section 10: Describing Target Architecture in Text
	</blockquote>

<h2>1.2: Any Syntax</h2>

<h3>1.2.1: Legacy Source Code Unchanged</h3>

<p>
Include files define imported syntax to masmx.
Existing source code assembles unchanged

<p>
masmx interprets imported notation for code, data and even
arithmetic and manipulation operators 

<p>
See Section 10.1: Establishing your Syntax


<h3>1.2.2:  Number String and Character String Notation</h3>


Number and character strings are assembled in masmx native
notation, C-Language notation,<br>
Motorola Old Notation or suffix-determined notation

<p>
See Section 4.2.2.1: Number Strings and Section 4.2: Expressions



<h2>1.3: masmx is for Any Word Size</h2>


<p>
Code and data are assembled in multiples of words. Directive $word
defines the size of a word from 1 to 192 bits

<p>
Integer and floating values are computed to 192-bit precision

<p>
Integer constants occupy by default their containing number of words


<p>
<h2>1.4: masmx is for Any Address Space</h2>

<p>
masmx can construct absolute arrays and instruction segments to fit
in address spaces up to 1*/192 bits.

<p>
Absolute and relocatable object code may be incremented
with new source or relocatable code

<p>
A masmx link is an assembly which uses masmx linker features.
Text-encoded-binary files are included<br>plus macro
text which processes text-encoded-binary.
See section 9.2.2: masmx Linking in Principle

<p>
The memory space in programs may be larger than any known file systems,<br>
if load code distribution in target memory is below saturation<br>
to the degree that the developer platform file system contains it

<p>
Base-displacement addressing modes are supported for accessing data or code<br>
at high effective addresses beyond the direct-address range of instruction sets.<br>
Data segments in 32-bit and 64-bit PowerPC<br>are an example of base-displacement addressing.<br>
See Section 7: Constructing Program Sections



<h2>1.5: masmx is for Any Floating Point Format</h2>

masmx default floating constant size is 96 bits rounded from 192 bits

<p>
Internally generated 192-bit floating values have 23-bit midpointed exponent
and 168-bit fractional mantissa
<pre>

	__________________________________________________________________
	|s|190 exponent 168|167          mantissa                       0|
	|_|________________|_____________________________________________|

</pre>
Negative polarity is represented with the entire value in 1s complement

<p>
Size, layout and representation of floating constants are programmable. Floating constant values are<br>
 derived from masmx 192-bit internal floating values. There is no restriction on target representations.<br>
Macro code can achieve any representation

<p>
Supplied macros generate IEEE754 floating constants in 32-bit, 64-bit and 128-bit formats,<br>
and in the popular non-IEEE754 80-bit representation

<p>
IEEE754 floating formats have an unrepresented integral bit. A sign flag alone 
represents polarity.
<pre>


	_____________________________________
	|s|exponent|mantissa fractional part|
	|_|________|________________________|
	          ^
	         |1| <- the unrepresented normalising integral bit

</pre>
For a given value IEEE754 formats encode the exponent at 2 less than masmx
native format
<pre>

$ masmx -ln
MASMX 7r3
0/-INPUT>>
	$word	32
	$quantum 8
	1.875	. masmx format positive value
	-1.875	. masmx format negative value
	$list	0
	$include ieee754.def
	$list
	ieee754_64	1.875	. ieee754 format positive value
	ieee754_64	-1.875	. ieee754 format negative value
	$end
  :                            1  $word 32
  :                            2  $quantum 8
00:00000000 400001F00000000000000000
                              +3  1.875 . masmx format positive value
00:0000000C BFFFFE0FFFFFFFFFFFFFFFFF
                              +4  -1.875 . masmx format negative value
  :                            90  $list
00:00000018 3FFE000000000000  +91  ieee754_64 1.875 . ieee754 format positive value
00:00000020 BFFE000000000000  +92  ieee754_64 -1.875 . ieee754 format negative value
  :                            93  $end
:$(00):00000000:00000028 
 
</pre>
The included macro package for generating IEEE754 constants is explained in section 11: masmx Floating<br>
Format and Alternative Formats and section 11.2: IEEE754 Floating Formats


<h2>1.6: Structured Data and Structured Code Name Spaces</h2>

<h3>1.6.1:  Structured Data</h3>

mamsx can construct complex hierarchical data. See section 4.6 Iterated Coded and
Structured Data


<h3>1.6.2: Bit-Aligned Structured Data</h3>

masmx can construct and label complex hierarchical data which does not map to the target architecture<br>
but instead groups and overlays bit-fields of arbitrarily large size. See Section 5.2.2: Bit-Aligned Structures


<h3>1.6.3: Accessing Bit-Aligned Structured Data</h3>

masmx naming techniques allow a single set of macros for a given target architecture to enable any application<br>
to access complex bit-aligned data. See Section 5.2.2.3: Macro Code Access to Bit-Aligned Structures.<br>
This feature handles bit-field structures and overlays of any complexity consistently and efficiently

<h3>1.6.4: Repeat Data</h3>

masmx generates repeating data and data structures with the $do directive and subscripted labels.<br>
See Section 5.1: $do and macros


<h3>1.6.5: Functionally Compartmented Name Spaces</h3>


Hierarchic label structures can be used to compartment name spaces like languages structured by function.<br>
See Section 5.2.1.4: Structured Code Name Spaces



<h2>1.7: Run-Time Algorithm Plotting</h2>


Directives $xqt_i and $xqt_fp combine with target-specific macro language to translate algorithmic expressions<br>
with run-time variable tokens into an instruction plan. See Section 6.1: Run-Time Integer Algorithm Plotter and<br>
Section 6.2: Run-Time Floating Algorithm Plotter

<p>
This feature is more compiler-like than assembler-like and allows algorithms involving run-time variables<br>
to be coded in the form of algebraic expressions


<h1>2: Developer Environment</h1>

masmx developer environment is a shell

<p>
Assembly examples in this document are captures from the Unix
bash shell

<p>
masmx on Microsoft platforms runs with the simple command prompt
sometimes called the DOS screen or shell

<p>
The command line is documented at Appendix A: masmx Command Line 





<h1>3: Getting Started</h1>

masmx does not know a computer architecture when it begins to run. 
The developer begins the initial source file with a line like:
<pre>

	$include        target.def

</pre>
Initially masmx knows directives ($include is a directive) 
and some special names representing internal functions, like $ 
which means "location counter"

<p>
Wrappers may be constructed to include headers without altering
existing source. File includes may be extensively nested
<pre>

	$list	0
	$include	target.def
	$list
	$include	existing_application.msm

</pre>
masmx internal directives and functions can be aliased to suit existing code.
Directives of other assemblers can also be constructed as macros

<p>
A definition file included at the head of the assembly defines: 

	<blockquote>

	assembly language syntax<br><br>

	directive and function rename and resynthesis<br><br>

	computer word size, up to 192 bits<br><br>

	initial data byte size<br><br>

	target data code, default ASCII<br><br>
 
	address space<br><br>

	address quantum<br><br>

	any address space segmentation or partitioning<br><br>

	register sets and names<br><br>

	instruction set<br><br>

	any pseudo-instructions used to generate constants<br><br>

	integer encoding and floating point formats<br><br>

	</blockquote>


See 10.1: Establishing Syntax, 10.2: Describing Target Architecture

<h1>4: The Assembly Language Source Line</h1>

<p>
The line of assembly language code has an arbitrary number of fields
<pre>

[label]	[command]	[argument1[,argument1_subfield2,...]]	[argumentN[,argumentN_subfield2,...]]	[. comment ]

</pre>
Lines may be continued. The default continuation symbol ; can be changed with directive $cont_char
<pre>

[label]	[command]	[argument1[,argument1_subfield2,...]]	;
			[argument2[,argument1_subfield2,...]]	;
			[argumentN[,argumentN_subfield2,...]] 

</pre>

Argument subfields may be divided into substrings with the current $sterm symbol
<pre>

	[command]	[substring[:substring][, substring:substring..]]	[argument2..

</pre>

See 4.2.2.2.2.5: Macro Parameters


<h2>4.1: Labels</h2>

A label starts in column one and ends in whitespace. A label may contain
<pre>

	letters digits $ _ ? ! @ :

</pre>
and starts with a letter or [ _ ? ! @ : ]

<p>
: in this list of legal label characters represents the substring separator which is
default colon : but may be another value, often period . 

<p>
If for example period . is chosen for substring character
<pre>

	$sterm	'.'

</pre>
then the list of legal label characters becomes
<pre>

	letters digits $ _ ? ! @ .

</pre>
and starts with a letter or [ _ ? ! @ . ]

<p>
A reference containing substring separator may reference a simple label or a structured location

<p>
A label may also start with $ and is then declared in quotes
<pre>

"$mylabel"

</pre>

<div    style="color:A0A0A0">
<blockquote>
$ in column one is a location counter switch.<br>
A location counter switch is a program section control with syntax <b>$(number[:attributes])</b><br>
See section 7: Constructing Program Sections
</blockquote>
</div>

<p>
A label declared in quotes starts with anything and contains anything

<p>
Without case-sensitive option -k all labels and references are translated to uppercase

<p>
A label may have an arbitrary number of subscripts
<pre>

<i>label(5,7,600)</i>

</pre>
Each subscripted instance is a different label

<p>
Reference to a subscripted label which does not exist
retrieves the count of similar labels with one subscript more 

<p>
A label <i>label_stem(<b>4,1,20</b>)</i> is for example the
count of labels <i>label_stem(<b>4,1,20</b>,&xi;)</i>

<pre>
        <i>
        label_stem(<b>4,1,20</b>,5)<br>
        label_stem(<b>4,1,20</b>,20)<br>
        ...</i>

</pre>

If no instances exist either, then the reference has the value of zero because it
counts an empty set

<p>
There is no requirement for label subscripts to fill a number space
continuously or evenly
<p>
Subscripted labels need not be in ascending order or any order, but may be
generated by loop control
<pre>

MANY	$set	65536

index	$do	MANY,a_name(MANY+1-index)	99*index

</pre>
The assembler normalises subscript integer expressions to a decimal
digit string when inserting or referencing subscripted labels.

<p>
For example, the first two repeats of the $do above generate
<pre>

a_name(65536)	99*1
a_name(65535)	99*2

</pre>
and the last three generate
<pre>

a_name(3)	99*65534
a_name(2)	99*65535
a_name(1)	99*65536

</pre>
Macros generate and use labels which are discarded at the end of the macro expansion.<br>
Labels only remain available to the invoking level of assembly if they are promoted with trailing asterisk
<pre>

$ masmx -lnxk visible visible
MASMX 7r3
3/visible.msm
  :                            1 macro1*	$proc
  :                            2 	macro2
  :                            3 visible* $equ	invisible
  :                            4 	$end
  :                            5 
  :                            6 macro2* $proc
  :                            7 macro3* $proc
  :                            8 manifest****
  :                            9 private***
  :                            10 unseen
  :                            11 invisible**
  :                            12 	$end
  :                            13 	macro3
  :                            14 	$end
  :                            15 
  :                            16 $(14:0E000)
  :                            17 	macro1
  :                            18 	$end
macro1=:P1:0:000000
macro2=:P1:0:000001
manifest+=$0E:00E000
private=$0E:00E000
visible=00E000
visible.msm=0<000003
:$(0E):00E000:00E000 
visible.msm: object code 47 bytes: 0 errors: 0 undefined labels
$
$ cat visible.txo

+manifest:$0E:00E000
:$0E*000000:00E000:00E000
$

</pre>
<p>
One asterisk is added to promote a label one  macro level. An asterisk at the main
assembly level externalises the label

<p>
A label declared at the main assembly with <b>$set</b> directive cannot accidentally
be exported from the assembly by subsequent sets.<br>
<b>$set</b> labels may be changed in value but a label global to the assembly
cannot be changed to an exported label

<p>
Macros can therefore use many asterisks to make sure they are updating a
global <b>$set</b> label and not a nested macro-local <b>$set</b> label.<br>
A label name initially set to the inclusion level of the main assembly is
not accidentally exported. In this sample assembly the output file<br>
does not contain an exported label, or in this case anything at all
<pre>

$ masmx attestor -lnx
MASMX 7r3
3/attestor.msm
*EOF*
  :                            1 "$$local"	$set	1
  :                            2 
  :                            3 outward*	$proc
  :                            4 "$$local"******	$set	2
  :                            5 		$end
  :                            6 
  :                            7 		outward
  :                            8 
*EOF*
$$LOCAL=000002
OUTWARD=:P1:0:000000
attestor.msm=0<000003

attestor.msm: object code 0 bytes: 0 errors: 0 undefined labels
$ cat temp.txo
$


</pre>

<h2>4.2: Expressions</h2>
<h3>4.2.1: Operators</h3>
	
Operators by rank are

	<blockquote>
	()<br>
	=<br>
	^=<br>
	><br>
	<<br>
	--<br>
	++<br>
	/*<br>
	*/<br>
	*/-<br>
	**<br>
	*+ *-<br>
	+ -<br>
	* / // ///<br>
	&plusmn; ^unary<br>
	</blockquote>


Operators in the same rank have left-to-right precedence as they are
encountered in the expression

<p>
Operators of higher rank are evaluated first and operated last.<br>
An expression generates an integer until a decimal exponent operator *+ *- is actioned or a
decimal point is encountered

<p>
The operators are 
<pre>


	_________________________________________
	|	=	|	equal		|	=  value 1 : ^= value 0
	|_______________|_______________________|
	|	^=	|	unequal		|	^= value 1 : =  value 0
	|_______________|_______________________|
	|	>	|	greater		|	>  value 1 : &le;  value 0
	|_______________|_______________________|
	|	<	|	less		|	<  value 1 : &ge;  value 0
	|_______________|_______________________|
	|	--	|	XOR		|
	|_______________|_______________________|
	|	++	|	OR		|
	|_______________|_______________________|
	|	/*	|	shift right	|
	|_______________|_______________________|
	|	*/	|	shift left	|
	|_______________|_______________________|
	|	*/-	| right	shift algebraic	|
	|_______________|_______________________|
	|	**	|	AND		|			
	|_______________|_______________________|		
	|	*+	|      +decimal exponent|
	|_______________|_______________________|
	|	*-	|      -decimal exponent|
	|_______________|_______________________|
	|	+	|	PLUS		|
	|_______________|_______________________|
	|	-	|	MINUS		|
	|_______________|_______________________|
	|	*	|	MULTIPLY	|
	|_______________|_______________________|
	|	/	|	DIVIDE		|
	|_______________|_______________________|
	|	//	|	covered quotient|
	|_______________|_______________________|
	|	///	|	remainder	|
	|_______________|_______________________|


Only	+	PLUS
	-	MINUS
	**	AND
	/*	SHIFT RIGHT
	*/-	SHIFT RIGHT ALGEBRAIC may be applied to relocatable tokens


	+ PLUS - MINUS may operate without restriction on mixed relocatable
	and absolute tokens	

	The token left of ** AND may be relocatable, not the mask. AND applied
	to a relocatable token suppresses range checking at the link step

	SHIFT RIGHT and SHIFT RIGHT ALGEBRAIC shift the final relocated value
	A shift count may not be relocatable

	/* SHIFT RIGHT shifts the relocated value logically right and range-checks unsigned

	shift left operator */ with negative shift count is SHIFT RIGHT ALGEBRAIC.
	Range check at link is signed. The target field contains at least one sign bit.
	The relocated value is shifted right algebraically


$ ../masmx relarith -lnk
MASMX 7r3
3/relarith.msm
*EOF*
  :                            1 	$word		32
  :                            2 	$quantum	8
  :                            3 
  :                            4 ABSOLUTE	$equ	-4096
  :                            5 MINUS8		$equ	-8
  :                            6 $(5:*1)
  :                            7 relocatable	$res	1
  :                            8 $(6:06000)
  :                            9 
(+05:00000000/*10)20+
06:00006000 00000000          +10 	+	relocatable*/-16	. signed range check after relocation
  :                            11 					. shift right algebraic 16 positions
  :                            12 
(+05)20+
06:00006004 00000000          +13 	+	relocatable*/-0		. signed range check after relocation
  :                            14 					. shift no positions
  :                            15 
(+05:00000000/*10)20+
06:00006008 00000000          +16 	+	relocatable*/(-16)	. signed range check after relocation
  :                            17 					. shift right algebraic 16 positions
  :                            18 
06:0000600C FFFFFFF0          +19 	+	ABSOLUTE*/MINUS8	. shift right algebraic 8 positions at assembly time
06:00006010 FFFFFFF0          +20 	+	ABSOLUTE*/-8		. shift right algebraic 8 positions at assembly time
06:00006014 00FFFFF0          +21 	+	0FFFFF000/*8		. shift right logical 8 positions at assembly time	
  :                            22 
(+05:00000000/*08)20
06:00006018 00000000          +23 	+	relocatable/*8		. unsigned range check after relocation
  :                            24 					. shift right logical 8 positions
  :                            25 
(+05:00000000/*0c)20+
[+0000:00000000/*0c]20+
06:0000601C 00000000          +26 	+	relocatable+EXTERNAL*/-12 . signed range check after relocation
  :                            27 					. shift right algebraic 12 positions
  :                            28 
(+05:00000000/*08)20+
06:00006020 00000000          +29 	+	relocatable*/MINUS8	. signed range check after relocation
  :                            30 					. shift right algebraic 8 positions
*EOF*
:$(05):00000000:00000001 :$(06):00006000:00006024 


</pre>




<h3>4.2.2: Tokens</h3>

<h4>4.2.2.1: Number Strings</h4>

<h4>4.2.2.1.1: masmx Default Number and String Notation</h4>

Native masmx interprets number strings with leading zero as hex or
octal, depending $octal or default $hex directives. Leading digit
1..9 means decimal

<p>
By default 1000 and 03e8 mean one thousand

<p>
With $octal 1000 and 01750 mean one thousand

<p>
character strings are space filled to containing word in absence
of -z Flag. Escaped values are typed as integers between quoted
substrings as "substring":INTEGER_EXPRESSION:"substring"

<p>
If the substring delimiter is changed with for example $sterm '.'
then escape sequence is "substring".INTEGER_EXPRESSION."substring"

<p>
A digit string starting \ is bit-pattern
<pre>


$ masmx -ln
MASMX 7r3
0/-INPUT>>
	40960++2560++0aa0000++\10101010
        $end
00:000000 000000AAAAAA        +1  40960++2560++0aa0000++\10101010
  :                            2  $end


</pre>

<p>

Characters in apostrophe are right justified value strings

<p>
Each character produces its value in the current data code and
$byte size, default 8 bits
<pre>


MASMX 7r3
3/immediat.msm
*EOF*
  :                            1         $word   32
00:00000000 0000006168657245  +2         'ahere'-32
*EOF*
:$(00):00000000:00000002 
immediat.msm: object code 62 bytes: 0 errors: 0 undefined labels


</pre>
The default data code $ascii means more exactly characters unchanged from source input and may therefore be<br>
ASCII extended to Roman-8 or UTF-8. These have the same code points 0..127 as ASCII

<p>
Character value string tokens are available to expressions whatever the
current number string notation

<p>
See also directives 8.1 $ascii, 8.8: $data_code and 8.5: $byte

<p>
If apostrophe has been chosen as the quote character, a command
token starting apostrophe is a left-justified byte string<br>
and not an integer value string, but quoted tokens in expressions are value
strings, not labels
<pre>

$ masmx -lnkz
MASMX 7r3
0/-INPUT>>
	$word		16
	$quantum	8
	$awidth		24
	$quote		''''
QDELIM='
$(10:0A0000)
place
	+place		. label reference
	+'place'	. value string
	'place'		. byte string
	$end
  :                            1  $word  16
  :                            2  $quantum 8
  :                            3  $awidth  24
  :                            4  $quote  ''''
  :                            5 $(10:0A0000)
  :                            6 place
0A:0A0000 000A0000            +7  +place   . label reference
0A:0A0004 00706C616365        +8  +'place' . value string
0A:0A000A 706C61636500        +9  'place'  . byte string
  :                            10  $end
:$(0A):0A0000:0A0010 


</pre>
If quote symbol remains at default " then a value string ' is recognised
at the start of the command field and quoted labels are recognised in
expressions

<p>
It is not in simple cases necessary to reference labels in quotes, but macro
text in some circumstances must

<pre>

$ masmx -lnkz
MASMX 7r3
0/-INPUT>>
	$word		16
	$quantum	8
	$awidth		24
$(10:0A0000)
place
	+place		. label reference
	+'place'	. value string
	'place'		. value string
	+"place"	. label reference
	"place"		. byte string
	$end
  :                            1  $word  16
  :                            2  $quantum 8
  :                            3  $awidth  24
  :                            4 $(10:0A0000)
  :                            5 place
0A:0A0000 000A0000            +6  +place    . label reference
0A:0A0004 00706C616365        +7  +'place'  . value string
0A:0A000A 00706C616365        +8  'place'   . value string
0A:0A0010 000A0000            +9  +"place"  . label reference
0A:0A0014 706C61636500        +10  "place"  . byte string
  :                            11  $end
:$(0A):0A0000:0A001A 

</pre>

Option -m Motorola Old Number Notation (4.2.2.1.3) masks labels
beginning with $ or @ unless they are referenced in quotes



<h4>4.2.2.1.2:  C-Language Number and Character String Notation</h4>

With Assembly Flag -c 1000 and 0x3e8 both mean one thousand and
leading zero without x or X is octal

<p>
-c Flag also zero-fills character strings to containing word unless
-z Flag is also asserted

<p>
-c Flag interprets character string \escaped values in both strings
and apostrophe-bounded value-string numbers 
<pre>

$ ~/masmx -lnkc
MASMX 7r3
0/-INPUT>>
	$word	64
	$quantum 8
	'ab\000c'
	"xy\xAAz"
	$end
  :                            1  $word 64
  :                            2  $quantum 8
00:00000000 0000000061620063  +3  'ab\000c'
00:00000008 7879AA7A00000000  +4  "xy\xAAz"
  :                            5  $end
:$(00):00000000:00000010 

</pre>

<h4>4.2.2.1.3:  Motorola Old Number Notation</h4>

Flag -m interprets
<pre>

	$hex
	@octal
	%bit_image

</pre> 
<h4>4.2.2.1.4:  Suffix-Determined Number Notation</h4>

Directive $suffix 2 interprets upper or lowercase last column of the number string
<pre>

	trailing H as hex
	trailing O or Q as octal
	trailing B as bit image
	trailing D as decimal default

</pre>
Directive $suffix 1 defaults leading zero to hex

<p>
Storage constant numbers in all notations may also have a storage  
words suffix [s d l t q p h o]. See 4.2.2.3: Number constants



<h4>4.2.2.2: Label References</h4>


Labels of any type (storage location line labels, equates, function
macro names, $do loop tags) may be referenced in expressions
<pre>

	+       this*that+the_other

</pre>
Most labels return an absolute or a relocatable value. Some labels work
functionally and return a computed value.<br>
See 4.2.1.2.3: Assembler-Supplied Functions and 4.2.1.2.4 Function Macro Reference

<p>
Labels may be bounded with quotes on reference
<pre>

$ masmx -lnkz
MASMX 7r3
0/-INPUT>>
ab	$equ	40
	+"ab"		. a number expression with label reference
	"ab"		. a string
	'ab'		. a number expression
	$end
  :                            1 ab $equ 40
00:000000 000028              +2  +"ab"  . a number expression with label reference
00:000001 616200              +3  "ab"   . a string
00:000002 006162              +4  'ab'   . a number expression
  :                            5  $end
:$(00):000000:000003 

</pre>
A command field bounded with quotes is not an expression but a
left-justified string of arbitrary length space or zero padded to
containing word

<p>
If $quote has been changed to ' apostrophe, labels in ' will not be detected in expressions.
The character values between ' are right justified<br>
as values juxtaposed at current $byte size and translated from input to current data code,
default 8-bits and ASCII.<br>
See also 8.8 $DATA_CODE directive and 8.5 $BYTE directive
<pre>


$ masmx -lnkz
MASMX 7r3
0/-INPUT>>
ab	$equ	40
	$quote	''''
QDELIM='
	+'ab'		. a number
	'ab'		. a string
	$end
  :                            1 ab $equ 40
  :                            2  $quote ''''
00:000000 006162              +3  +'ab'  . a number
00:000001 616200              +4  'ab'  . a string
  :                            5  $end
:$(00):000000:000002 


</pre>


<h4>4.2.2.3: masmx-Supplied Functions</h4>

See also 4.7 masmx Internal Functions in Detail.

<p>
Assembling with -k option,  directives, masmx-internal functions and all names supplied by masmx must be typed lowercase<br>
Internal functions are in summary:

<pre>


	$		current location counter value

	$(..)		named location counter value

	$a		absolute value of current location counter.

			$a is similar to $ except

				$a can generate absolute constants of
				locations in base-displacement sections

				an argument to $a(..) is an expression
 				not a location counter identity

				the expression may reference a location
				counter: + $a($(5))

	$a(..)		absolute value of expression
                    	  
	$b		start address of current program section

			in link $include,$binary
			$b is relocated start address of the segment
                    	  
	$bank_index	current memory block identifier
			where breakpoint addresses are used

	$n		macro call name
			retrieves low-order 32 bits of
			<i>macro_label</i>(0, 0) value

	$net(..)	unrelocated value of expression

	$o(..)		value of an option flag

	$r		current location counter identity

	$r(..)		location counter identity of named address

	$rel		relocation alignment of current program section
			returns zero for absolute sections and nonzero
			for relocatable sections

	$rel(..)	relocation alignment of named program section
			returns zero for absolute sections and nozero
			for relocatable sections

	$t(..)		label type

	$zenith		high address of current section + literals

	$zenith(..)	high address of named section + literals



</pre>
<h4>4.2.2.4: Function Macro Reference</h4>

Function macros deliver a value to assembly-time expressions

<p>
Here a function log2 returns the power 2 which covers the value of the input integer

<p>
Lines 2..8 are the function macro. The other lines invoke it

<pre>

$ masmx log2.msm -lnkx
MASMX 7r3
3/log2.msm
*EOF*
  :                            1 
  :                            2 f	$func
  :                            3 log2*	$name
  :                            4 fulcrum	$set	f(1, 1)-1
  :                            5 	$do	fulcrum<1,	$return	0
  :                            6 log	$do	48,	$do	1*/log>fulcrum,	$return	log
  :                            7 	$return	-1
  :                            8 	$end
  :                            9 
  :                            10 log2:zero	$equ	log2(0)
  :                            11 log2:1		$equ	log2(1)
  :                            12 log2:2		$equ	log2(2)
  :                            13 log2:3		$equ	log2(3)
  :                            14 log2:15		$equ	log2(15)
  :                            15 log2:16		$equ	log2(16)
  :                            16 log2:17		$equ	log2(17)
  :                            17 log2:16383	$equ	log2(16383)
  :                            18 log2:16384	$equ	log2(16384)
  :                            19 log2:16385	$equ	log2(16385)
  :                            20 
*EOF*
log2=:N65:F:0:000000
log2:zero=000000
log2:1=000000
log2:2=$00:000001
log2:3=$00:000002
log2:15=$00:000004
log2:16=$00:000004
log2:17=$00:000005
log2:16383=$00:00000E
log2:16384=$00:00000E
log2:16385=$00:00000F
log2.msm=0<000003


</pre>

The assembly at 4.2.2.5 shows a function macro $net_ipv4 delivering a value which represents<br>
a network address composed from dotted decimal text

<p>
For more information on the construction of function macros see 4.2.5: Function Macros

<h4>4.2.2.5: Macro Parameters</h4>


Macro actual arguments are accessed by using the label of 
the containing macro in a functional way
<pre>

p       $proc
add*    $name   1
	iform   p(0, 1), p(1, 1), p(1, 2)
	$end

</pre>
Actual arguments map to these reference paraforms when the $proc label is, for example, p 
<pre>


	command[,subcommand]	[argument[,argument,..]]	[argument[,..

	p(0,0)[, p(0, 2)]	[p(1, 1)[,p(1, 2),..]]		[p(2, 1)[,..


</pre>
The command is the first call-line word after any whitespace.
It is subfield zero of field 0, <i>macro_label</i>(0, 0)


<p>
A subcommand on the command is <i>macro_label</i>(0, 2)

<p>
Argument field numbers and their subfield numbers ascend from 1

<p>
The first subfield of the second argument field is referenced <i>macro_label</i>(2, 1)

<p>
Fields are separated by spaces. Subfields in a field are 
separated by a comma,[ and spaces]

<p>
There may also be substrings of subfields, separated by the 
substring character, default :

<p>
Here substrings have been counted and assembled as constants
containing network socket addresses

<p>
The $proc callname $net_socket is in the command field in order to generate a
constant.<br>
$net_socket obtains the value of the network part of the address
by referencing $func macro $net_ipv4

<p>
The default $sterm value : is temporarily changed to . for scanning dotted decimal
<pre>

$ masmx -lnk
MASMX 7r3
0/-INPUT>>
        $word	16
	$quantum 8

f       $func
"$net_ipv4"* $name

net     $set    0
        $sterm  '.'

?       $do     f(1, 1:),;
net     $set    net*/8++f(1, 1:?)

        $sterm  ':'

        $return net
        $end


"$netp" $form   32, 16

p       $proc
"$net_socket"* $name
        $netp   $net_ipv4(p(1, 1:1)), p(1, 1:2)
        $end

address_A	$net_socket	172.29.7.9:8080
address_B	$net_socket	172.29.6.8:23
	$end
  :                            1  $word 16
  :                            2  $quantum 8
  :                            3 
  :                            4 f       $func
  :                            5 "$net_ipv4"* $name
  :                            6 
  :                            7 net     $set    0
  :                            8         $sterm  '.'
  :                            9 
  :                            10 ?       $do     f(1, 1:),net     $set    net*/8++f(1, 1:?)
  :                            11 
  :                            12         $sterm  ':'
  :                            13 
  :                            14         $return net
  :                            15         $end
  :                            16 
  :                            17 
  :                            18 "$netp" $form   32, 16
  :                            19 
  :                            20 p       $proc
  :                            21 "$net_socket"* $name
  :                            22         $netp   $net_ipv4(p(1, 1:1)), p(1, 1:2)
  :                            23         $end
  :                            24 
00:0000 AC1D07091F90          +25 address_A $net_socket 172.29.7.9:8080
00:0006 AC1D06080017          +26 address_B $net_socket 172.29.6.8:23
  :                            27  $end
:$(00):0000:000C 



</pre>


<h3>4.3: The Command Field</h3>


The command field (the first field which is preceded by any
whitespace) can contain a directive, a constant,<br>
a name of a $proc macro, or the name of a $form template.
<pre>

[label] <i>command</i> [arguments]

</pre>



<h3>4.3.1 Directives</h3>


Directives are commands to the assembler. They are listed in Section 8: Directives

<p>
Some directives control assembly settings, for example
<pre>

	$word		<i>BITS</i>
	$quantum	<i>BITS</i>
	$list		<i>INCLUDE_DEPTH</i>

</pre>
Others declare labels
<pre>

<i>label1</i>	$set	<i>VALUE</i>
<i>label2</i>	$equf	<i>VALUE1</i>, <i>VALUE2..</i>
<i>label</i>	$equ	<i>VALUE</i>
<i>label3</i>	$name	<i>VALUE</i>

</pre>
Others govern conditional assembly
<pre>

	$if		<i>CONDITION</i>
	$elseif		<i>CONDITION</i>
	$endif

</pre>
And other directives frame macros

<p>
All directives may  be aliased to other names using the $EQU directive,
and frequently are, for example
<pre>

.equ    $equ,"$directive"       "$equ"
.macro  $equ,"$directive"       "$proc"
.macend $equ,"$directive"       "$end"

</pre>
Quotes are used in these PowerPC examples in case flag -m (Motorola old number notation) is opted.<br>
The quotes force the "$xxxxxx" tokens to be seen as labels and not as hex strings.

<p>
Four directives, $word, $byte, $awidth, $quantum, work functionally in expressions and return the value which they have set

<p>
Both user macro functions and masmx internal functions need to
be in quotes to rename their functionality. Otherwise they work
functionally
<pre>

BYTE	$equ		    $byte  . BYTE equals the actual byte size in bits
setbyte	$equ,"$directive"  "$byte" . setbyte is the same directive (and function) as $byte

</pre>
<p>
See also option -m, Motorola old Number Notation, and option -Q

<p>

A token in the command field only begins with a quote if it is a text string (4.3.5)

<p>
Directive names and macro names always are recognised in the command field without quotes

<p>
Assembling with -k option,  directives, masmx-internal functions and all names supplied by masmx must be typed lowercase

<p>
Number storage constants start with a digit, sign or single quote, or have the name
of a macro




<h3>4.3.2: Storage Constants</h3>

For complex data constants see section 5: Iterated Code and Structured Data
and 4.3.7: $proc Macro Calls: Instructions and Structures 

<p>
Simple data constants may be integers, microstructures of bit fields, 
floating numbers or text strings.




<h3>4.3.3 Number Constants</h3>

Number items start with a digit, a unary operator or character values in apostrophe
<pre>

	+	INSTANCES*FACTOR
	15
	-8.5
	'xy'

</pre>

<p>
Unary + - ^ prepended to the first token of the constant expression
exerts polarity only on the first token

<p>
Unary + - ^ separated from the constant expression by whitespace
exerts polarity over the whole expression
<pre>


$ masmx -lnk
MASMX 7r3
0/-INPUT>>
	$word		16
	$quantum	8

	1.875
	-2-2
	-	2-2
	$end
  :                            1  $word  16
  :                            2  $quantum 8
  :                            3 
00:0000 400001F00000000000000000
                              +4  1.875
00:000C FFFC                  +5  -2-2
00:000E 0000                  +6  - 2-2
  :                            7  $end
:$(00):0000:0010 

</pre>
Constants in apostrophe are character string values serving as numbers

<p>
The bytes are right-justified in the current data code and juxtaposed at the current $byte size
<pre>

$ masmx -lnk
MASMX 7r3
0/-INPUT>>
	$word	16
	$quantum 8     
$(12:65536)
	'abc'
	$data_code	97,65	. generate A for a
	'abc'
	$byte	12
	'abc'
	$ascii			. switch back to plain ASCII
	'abc'
	$byte	8
	'abc'++1*/28
	$end
  :                            1  $word 16
  :                            2  $quantum 8     
  :                            3 $(12:65536)
0C:10000 00616263              +4  'abc'
  :                            5  $data_code 97,65 . generate A for a
0C:10004 00416263              +6  'abc'
  :                            7  $byte 12
0C:10008 41062063              +8  'abc'
  :                            9  $ascii   . switch back to plain ASCII
0C:1000C 61062063              +10  'abc'
  :                            11  $byte 8
0C:10010 10616263              +12  'abc'++1*/28
  :                            13  $end
:$(0C):10000:10014 

</pre>
Number storage values are in canonical byte order, and the only way to change that is by implementing<br>
pseudo-directives (often implemented with names like DW and DD) as macros.

<p>
Number constants may have trailing length overrides. Their meanings are
<pre>

	:s or S = 1 * word size 
	:d or D = 2 * word size
	:l or L = 2 * word size
	:t or T = 3 * word size
	:q or Q = 4 * word size
	:p or P = 5 * word size
	:h or H = 6 * word size
	:o or O = 8 * word size

</pre>
Integers occupy their containing number of words in the absence of a length suffix
<pre>

$ masmx ctest -lnk
MASMX 7r3
3/ctest.msm
*EOF*
  :                            1         $word   16
00:0000 00010000              +2         4096*16
00:0002 00100000              +3         4096*256
00:0004 01000000              +4         4096*4096
  :                            5 
  :                            6 likely  $equ    15        
  :                            7 what    $equ    3
  :                            8 how     $equ    -256
  :                            9 
00:0006 FFF0                  +10         ^       likely
00:0007 FFF3                  +11         ^likely++what
00:0008 FF03                  +12         ^likely**how++what
  :                            13 
00:0009 0060                  +14         100-4
00:000A 0005                  +15         100/20
00:000B 0005                  +16         +       99//20
00:000C 0004                  +17         80//20
00:000D 0005                  +18         81//20
00:000E 0013                  +19         99///20
00:000F 004162636465666768696A6B6C6D6E6F
                              +20         'abcdefghijklmno'-(32*/(('o'-'a')*8))
00:0017 FFFF0000              +21         -       4096*16
00:0019 FFF00000              +22         -       4096*256
00:001B FF000000              +23         -       4096*4096
00:001D FFA0                  +24         -       100-4
00:001E FFFB                  +25         -       100/20
00:001F FFFB                  +26         -       99//20
00:0020 FFED                  +27         -       99///20
00:0021 0001                  +28         2>1
00:0022 0000                  +29         +       1>2
00:0023 00380000              +30         0700000/*1
00:0025 700000000000000000000000000000000000000000000000
                              +31         0700000*/168
00:0031 380000000000000000000000000000000000000000000000
                              +32         +(0700000*/168)/*1
00:003D 700000000000000000000000000000000000000000000000
                              +33         7*/188
00:0049 0001                  +34         +       1<(7*/188)
00:004A 0000                  +35         +       1>(7*/188)
  :                            36 
00:004B 0063                  +37         99
00:004C 00000063              +38         +       99d
00:004E 000000000063          +39         +       99t
00:0051 0000000000000063      +40         99q
00:0055 00000000000000000063  +41         99p
00:005A 000000000000000000000063
                              +42         +       99h
00:0060 00000000000000000000000000000063
                              +43         99o
00:0068 FF88                  +44         +  (-8)*likely
00:0069 FFFFFFFFFFFFFFFFFFFFFFFFFFFFFF88
                              +45         +  (-8)*likely:o
00:0071 000F4240              +46         1000000
00:0073 01000000              +47         01000000
00:0075 000F4240              +48         1000000:l
00:0077 4240                  +49         1000000:s
  :                            50 
*EOF*
:$(00):0000:0078 


</pre>

If the last token in the expression is a label instead of a number string
then any length override must be preceded by colon, parenthesis or quote
<pre>

	+       expression:D
	+(expression)q
	+	"expression"h

</pre>
Words flag D after a hex string also needs separation
<pre>

$ masmx -lnk
MASMX 7r3
0/-INPUT>>
	$word	16
	01d
	01:d  
	$end
  :                            1  $word 16
00:0000 001D                  +2  01d
00:0001 00000001              +3  01:d  
  :                            4  $end
:$(00):0000:0003 

</pre>
$suffix-determined number notation (4.2.2.1: Number String Notation) masks length flags [d q h o]<br>
if the length flag is not separated. Fraction strings containing decimal point are decimal and a suffix<br>
is interpreted as size in words and not as notation
<pre>

$ masmx suffix -lnk
MASMX 7r3
3/suffix.msm
CONT_CHAR=
LTERM=;
*EOF*
  :                            1 	$suffix	2
  :                            2 	$cont_char 0
  :                            3 	$lterm ';'
  :                            4 	$word	16
  :                            5 	$quantum 8
  :                            6 	$floating_point	80
  :                            7 	$characteristic	16
  :                            8 	$characteristic,64 12
  :                            9 
00:0000 007B                  +10 	123		; decimal notation, self-sizing
00:0002 00000000000000000000007B
                              +11 	+(123d)h	; decimal notation, hexaword
00:000E 123D                  +12 	123dh		; hex notation, self-sized
00:0010 00EA                  +13 	234		; decimal notation, self-sized
00:0012 009C                  +14 	234o		; octal
00:0014 009C                  +15 	234os		; single word octal
00:0016 0000009C              +16 	234ol		; octal double word
00:001A 0000001D              +17 	01dh:d		; hex double word
  :                            18 
00:001E 401C000000000000      +19 	1.5q		; fraction string, no notation suffix, quad
00:0026 40259502F90000000000  +20 	010q*+0ah	; octal mantissa, hex exponent, default 80 bits
00:0030 40259502F90000000000  +21 	8*+10		; same thing, just testing
00:003A 400007C80000000000000000
                              +22 	1.0h*+10b	; fraction string always decimal, hexaword
  :                            23 			; but bit-pattern exponent, result = 100
  :                            24 
*EOF*
:$(00):0000:0046 


</pre>
Floating numbers do not self size. Their default size is determined with
directive $floating_point

<p>
A floating number length override follows the fraction, not the exponent
<pre>

$ masmx -lnk
MASMX 7r3
0/-INPUT>>
	$word		16
	$quantum	8
	$awidth		32
        $characteristic,64	16

expression	$equ	100
downscale	$equ	2

	1.6384d*+4
	+	expression:q*-downscale
	+	1.000000006768:pe+1200000
	$end
  :                            1  $word  16
  :                            2  $quantum 8
  :                            3  $awidth  32
  :                            4         $characteristic,64 16
  :                            5 
  :                            6 expression $equ 100
  :                            7 downscale $equ 2
  :                            8 
00:00000000 40F80000          +9  1.6384d*+4
00:00000004 4001800000000000  +10  + expression:q*-downscale
00:0000000C 7CD38AD1F1D10E50078D
                              +11  + 1.000000006768:pe+1200000
  :                            12  $end
:$(00):00000000:00000016 


</pre>
Floating numbers contain a digit string with decimal point 
or the decimal scale operator, *+ *- or both
<pre>

	1.75
	175*-2

	298.5e1262611

</pre>
The scale punctuation [e[+] | e-] is also recognised after a fraction string

<p>
Floating numbers can be cached as label values and manipulated bitwise
into the floating format of the target architecture
<pre>

floating_value	$set	16384.0e+1000000

</pre>
masmx internal floating precision is 192 bits with 168-bit simple fraction and 23-bit<br>
midpointed binary exponent equivalent in range to decimal exponents [+|-]1262611
<pre>


	191	     168 167							       0
	________________________________________________________________	_________
	|s|   exponent	|		fraction-only mantissa				|
	|_|_____________|_______________________________________________	________|


</pre>
masmx default floating numbers are a 192-bit value rounded to 96 bits,
with 72-bit simple fraction and 23-bit midpointed scale
<pre>

	95	      72 71					       0
	_________________________________________________________________
	|s|   exponent	|		fraction-only mantissa		|
	|_|_____________|_______________________________________________|


</pre>
Negative numbers are represented in 1s complement
<pre>

MASMX 7r3
3/fs32.msm
*EOF*
  :                            1 	$word	32
  :                            2 
00:00000000 400001C00000000000000000
                              +3         1.5
00:00000003 BFFFFE3FFFFFFFFFFFFFFFFF
                              +4         -	1.5
00:00000006 72B049CD0D73CF08E04D576E
                              +5         1.5*+1000000
00:00000009 0D4FB9B3C73F219697B1274F
                              +6         1.5*-1000000
*EOF*
:$(00):00000000:0000000C 

</pre>
The directive $floating_point changes the default 96-bit total size of the
stored floating-point constant.

<p>
The $characteristic directive sets the characteristic size for a given
floating <i>number_size</i>
<pre>

	$characteristic,<i>number_size</i>	<i>characteristic_width</i>

</pre>
Without <i>number_size</i> subcommand, <i>characteristic_width</i> is the characteristic field size<br>
applied to floating numbers of the current default size

<p>
characteristic width is the scale field + sign, or everything except the mantissa.<br>
So for example a target which supports the 80-bit coprocessor format with 15-bit exponent might have
<pre>

	$floating_point	80
	$characteristic	16

</pre>
$characteristic 8 means one sign bit and seven exponent bits:
<pre>


MASMX/24592 1r1X
FP32.msm 5
*EOF*  :                        1:         $word   32
  :                        2:         $floating_point 32
  :                        3:         $characteristic 8
  :                        4:         $characteristic,64 16
  :                        5:         $characteristic,128 20
  :                        6: 
00:00000000 41C00000      +7         +       1.5
00:00000001 4001C00000000000+8         +       1.5d
00:00000003 40001C00000000000000000000000000
			 +9         +       1.5q
*EOF*:$(00):00000000:00000007 


</pre>
The structure
<pre>

	mid-pointed-exponent/normalised-fractional-mantissa/1s-complement

</pre>
can be escaped with macro language

<p>
Macros supplied in this package generate IEEE754 floating constants. 

<p>
See Section 11: masmx Internal Floating Format and Alternative Floating Formats

<p>
This example generates storage constants of value 1.375e+1200000 in masmx-internal format typed in various source syntax.<br>
A size override h for hexaword follows the fraction in each number, so the stored constants are all 192 bits
instead of the default 96 bits
<pre>


$ masmx -ln
MASMX 7r3
0/-INPUT>>
        $word   32
                1.375h*+1200000
                1.375he+1200000
                1375h*+1199997
floatup $set	137.5he1199998
floataway $set	1.375he1200000
floatalong $set 1.375h*+1200000
        +       floatup
        +       floataway
        +       floatalong
        $end
  :                            1         $word   32
00:00000000 7CD38B90563FA97362D8D4F8DAAE3CB167FAE1BBCD7D99BB
                              +2                 1.375h*+1200000
00:00000006 7CD38B90563FA97362D8D4F8DAAE3CB167FAE1BBCD7D99BB
                              +3                 1.375he+1200000
00:0000000C 7CD38B90563FA97362D8D4F8DAAE3CB167FAE1BBCD7D99BB
                              +4                 1375h*+1199997
  :                            5 floatup $set 137.5he1199998
  :                            6 floataway $set 1.375he1200000
  :                            7 floatalong $set 1.375h*+1200000
00:00000012 7CD38B90563FA97362D8D4F8DAAE3CB167FAE1BBCD7D99BB
                              +8         +       floatup
00:00000018 7CD38B90563FA97362D8D4F8DAAE3CB167FAE1BBCD7D99BB
                              +9         +       floataway
00:0000001E 7CD38B90563FA97362D8D4F8DAAE3CB167FAE1BBCD7D99BB
                              +10         +       floatalong
  :                            11         $end
:$(00):00000000:00000024 


</pre>
The decimal scale operator not only adds scale to a fraction string, but may also join two integer expressions<br>
to construct a floating number, with the mantissa taken from the left and the exponent from the right. Any length<br>
override is typed after the fraction and before the *+ *- operator
<pre>

$ masmx floating -lnky
MASMX 7r3
3/floating.msm
  :                            1 
  :                            2 	$word	48		. the word size of the target
  :                            3 				. processor architecture
  :                            4 
  :                            5 	$floating_point 96	. the default size of a floating constant
  :                            6 				. = 2 words
  :                            7 
  :                            8 	$characteristic		24	. the characteristic field width
  :                            9 					. for a 2-word floating number
  :                            10 					. 24 bits is the maximum characteristic
  :                            11 
  :                            12 	$characteristic,48	12	. the characteristic field width
  :                            13 					. for a 1-word floating number
  :                            14 
  :                            15 one     $equ    1
  :                            16 
00:000000000000 3FFFFDCCCCCCCCCCCCCCCCCD
                              +17 		1*-1		. floating recognised from operator
  :                            18 				. current default floating size
  :                            19 
00:000000000002 3FDCCCCCCCCD  +20 		1s*-one		. floating recognised from operator
  :                            21 				. single-word override
  :                            22 
  :                            23 
00:000000000003 3FFFFDCCCCCCCCCCCCCCCCCD
                              +24 		0.1		. floating recognised from fraction string
00:000000000005 3FDCCCCCCCCD  +25 		0.1s		. floating recognised from fraction string
  :                            26 				. single word override, 12-bit characteristic
  :                            27 
00:000000000006 3FFFFDCCCCCCCCCCCCCCCCCD
                              +28 		1.0e-1		. fraction string followed by e+ e- punctuation
  :                            29 
00:000000000008 3FFFFDCCCCCCCCCCCCCCCCCD
                              +30 	+	one*-one	. floating recognised from operator
  :                            31 				. mantissa / exponent expressions
  :                            32 				. contain any integer tokens
  :                            33 
00:00000000000A 3FDCCCCCCCCD  +34 		1s*-1		. expression sizes and rounds at
  :                            35 				. one-word override
  :                            36 
  :                            37 
00:00000000000B 3FFFFDCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCD
                              +38         	1q*-one		. four-word override
  :                            39 
00:00000000000F 3FDCCCCCCCCD  +40 		1.0s*-one  	. exponent string can be any integer tokens
  :                            41 
00:000000000010 401800000000404A00000000407C8000000040AFA0000000
                              +42 		1s*+0, 1s*+1, 1s*+2, 1s*+3q	. four words,
  :                            43 						. four floating numbers
  :                            44 
  :                            45 tagged	$equ	163.84e+2
00:000000000014 40000F800000000000000000
                              +46 	+	tagged
  :                            47 
  :                            48 	$end
:$(00):000000000000:000000000016 


</pre>

<h4>4.2.2.4: Split Integers</h4>


A split integer item is a small list of equal size fields. The size of the total is one word.<br>
The suffixes [d l t q p h o] can make the size  two, three, four, five, six or eight words.

<p>
The source syntax of split integers has commas between the fields:
<pre>

$ masmx commas -lny
MASMX 7r3
3/commas.msm
*EOF*
  :                            1         $word   48
00:000000000000 666677778888  +2                 06666, 07777, 08888
00:000000000001 0A0B0C0D0E0F  +3                 10, 11, 12, 13, 14, 15
00:000000000002 FFF00AFFF00B  +4                 -1, +10, -1, +11
00:000000000003 123456789ABC  +5                 1,2,3,4,5,6,7,8,9,10,11,12
  :                            6 left    $equ    0aaaaaaaaaaaaaaaaaaaaa
  :                            7 centre  $equ    0bbbbbbbbbbbbbbbbbbbbb
  :                            8 right   $equ    0ccccccccccccccccccccc
  :                            9 
00:000000000004 AAAACCCCBBBB  +10         +       left, right, centre
00:000000000005 AAAAAAAACCCCCCCCBBBBBBBB
                              +11         +       left, right, centre:d   
00:000000000007 AAAAAAAAAAAAAAAACCCCCCCCCCCCCCCCBBBBBBBBBBBBBBBB
                              +12         +       left, right, centre:q   
*EOF*
:$(00):000000000000:00000000000B 

</pre>
If the number of fields does not divide into the total size,
zero-filled slack bits are generated at the top.


<h3>4.3.5: Text Strings</h3>


Text strings are a row of bytes composed from
<pre>

	"text in quotes ";	. text in quotes

	:one_byte_expression	. the substring character before a 1-byte integer 

</pre>
These line-continued parts produce
<pre>

	"text_in quotes":one_byte_expression

</pre>
Text substrings and one-byte integers may be combined without restriction. There is
a substring character between each part

<p>
These lines
<pre>

$ masmx -lnk
MASMX 7r3
0/-INPUT>>
	$word	16
	$quantum 8      

	"string of text":10:;
	"another line of text ":;
	"and more of that line"
	$end
  :                            1  $word 16
  :                            2  $quantum 8      
  :                            3 
00:0000 737472696E67206F6620746578740A616E6F74686572206C
                              +4  "string of text":10:"another line of text ":"and more of that line"
00:0018 696E65206F66207465787420616E64206D6F7265206F6620
                              +4 
00:0030 74686174206C696E6520  +4 
  :                            5  $end
:$(00):0000:003A 


</pre>
are effectively
<pre>

	"string of text":10:"another line of text and more of that line"

</pre>
byte size, quote symbol and substring symbol may be set to different values
from defaults [ 8-bits " : ] with directives $byte $quote $sterm

<p>
Text string contents are read in source code as octets of Latin-1, Roman-8 or UTF-8.
256 code points including 128 ASCII code points may be translated to values set with
directive $data_code

<pre>


$ masmx -lnk
MASMX 7r3
0/-INPUT>>
	$word	16
	$quantum 8     
$(12:65536)
	"abc"
	$data_code	97,65	. generate A for a
	"abc"
	$byte   12
	"abc"
	$ascii			. switch to unchanged input
	"abc"
	$byte	8
	"abc"
	$end
  :                            1  $word 16
  :                            2  $quantum 8     
  :                            3 $(12:65536)
0C:10000 61626320              +4  "abc"
  :                            5  $data_code 97,65 . generate A for a
0C:10004 41626320              +6  "abc"
  :                            7  $byte 12
0C:10008 041062063020          +8  "abc"
  :                            9  $ascii   . switch to unchanged input
0C:1000E 061062063020          +10  "abc"
  :                            11  $byte 8
0C:10014 61626320              +12  "abc"
  :                            13  $end
:$(0C):10000:10018 


</pre>
See also Appendix A: Command Line, Options -zc for space or zero pad

<p>
Text string constants are described further in 

	<blockquote>
	Section 8.5: $byte Directive<br><br>
	Section 8.41: $quote Directive<br><br>
	Section 8.49: $sterm Directive<br><br>
	Section 8.8: $data_code Directive<br><br>
	Section 8.1: $ascii Directive
	</blockquote>

Text strings generate enough words (size set by directive $word) to 
contain a byte (size set by directive $byte) per symbol in the string.<br>
Bytes can straddle word boundaries without restriction if
$byte is not a factor of $word. New strings start at a new word

<p>
Each character between "quotes" is a symbol and an expression
after the substring mark is a symbol, as
<pre>

	"characters":10

</pre>
or
<pre>

	$sterm	'.'
LF	$equ	10

	"characters".LF
  
</pre>
If there are whole bytes unfilled in the last word of the string,
they are space-filled (zero-filled with -c flag XOR -z flag)).

<p>
If there are bits unfilled  after the last whole byte position
in the last word in the string, they are zero filled.

<p>
Byte size may be larger than word size, but may not exceed 32 bits
<pre>

$ masmx -lnkyx
MASMX 7r3
0/-INPUT>>
	$word	16
	$data_code      'a', 1*/23++'a',1*/23++'b',1*/23++'c'
	$byte	24
	"abc"
	$end
  :                            1  $word 16
  :                            2  $data_code      'a', 1*/23++'a',1*/23++'b',1*/23++'c'
  :                            3  $byte 24
00:0000 80006180006280006300  +4  "abc"
  :                            5  $end
$bits=$00:0048
-INPUT>>=0<0000
:$(00):0000:0005 

</pre>
Automatic label <b>$bits</b> indicates here that the string contains 72 bits or three 24-bit characters.<br>
The containing storage is five sixteen-bit words or 80 bits

<p>
See also Appendix F.4: Byte-Addressing Machines with 32- and 64-bit
Bus, Managing Alignments

<p>
See also escape sequences with assembly flag -c


<h3>4.3.6: $FORM Items</h3>

$FORM declares a bit layout template from one word to 192 bits in size.
The command field when using a form is the label of the $FORM:
<pre>

MASMX 7r2
3/form.msm
*EOF*
  :                            1         $word   16
  :                            2 descriptor $form 1, 1, 14, 2, 3, 3, 24
  :                            3 
00:0000 8180A4040064          +4         descriptor 1,,384, 2, 4, 4, 262144+100
00:0003 00C8F6040063          +5         descriptor  ,,200, 3, 6, 6, 262144+99
*EOF*
:$(00):0000:0006 
form.msm: object code 55 bytes: 0 errors: 0 undefined labels


</pre>

$form is the masmx building block for instruction code:
<pre>

jump_form	$form	6, 26

jump*		$proc
		jump_form	JUMP_CODE, jump(1, 1)
		$end

</pre>

<h3>4.2.3: $proc Macro Calls: Instructions and Structures</h3>


Most code lines have macro calls in the command position.
That's how instructions are in masmx.

<p>
Instruction names are not known to masmx until
they are the names of macros or macro entry points:
<pre>

instruction_form $form	8, 12, 12

p       $proc
add*    $name   6
mov*    $name   7
xor*	$name	4
	instruction_form  $n, p(1,1), p(1,2)
	$end

</pre>
The lines of application code mostly are macro calls like these:
<pre>

	add     This, That
	mov     That, There

</pre>
$proc macros assembly may be nested up to 24-deep and may include many
instructions or data structures:
<pre>

p	$proc
sum*	$name
	xor	That, That
addend	$do	p(),	add	p(addend, 1), That
	mov	That, p(0, 2)
	$end

	sum,There	This The_Next The_Third Another

</pre>	
The <b>$proc</b> label may be any label and it is the handle for reference 
to actual arguments. Inside a <b>$proc</b> with label <i>p</i> the referencing rules are
<pre>

p       $proc


	p returns a count of all the fields on the calling line
	including command field and if present label field

	p() returns a count of fields in the actual arguments

	p(expression) returns a count of subfields in 
	field number "expression" of the actual
	arguments

	p(expression1, expression2) returns the value 
	of subfield "expression2" of field "expression1"
	of the actual arguments

	p(expression1, expression2:) returns a count of 
	substrings in subfield "expression2" of field
	"expression1" of the actual arguments

	p(expression1, expression2:expression3) returns the 
	value of substring "expression3" of subfield
	"expression2" of field "expression1" of the actual
	arguments

	p(expression1, *expression2) returns 1 if subfield 
	"expression2" of field "expression1" has the prefix * 
	otherwise 0
     
	p(expression1, #expression2) returns 1 if subfield 
	"expression2" of field "expression1" has the prefix # 
	otherwise 0
        

</pre> 
p(0, 1) and  p(0, 0) return the latent value of the $name used to invoke the $PROC
<pre>

p       $proc
add*    $name   20
subtract* $name  21
	.
	.
	$end

</pre>
p(0, 0) retrieves the value 20 if the calling command is add. 

<p>
p(0, 0) returns a 192-bit value. Internal function $n
returns the same value truncated to 32 bits

<p>
p(0, 2) returns a subcommand from the command field,
for example:
<pre>


L       $EQU    2
	.
	.
	move,L  location1,location2


</pre>
p(0, 2) will return the value of L, which is 2.


<p>
One macro may send all its actual arguments to another macro by<br>
using the paraform <i>macro_label()</i>. Extra arguments may be added 
<pre>

$ masmx forward -lnky
MASMX 7r3
3/forward.msm
*EOF*
  :                            1 	$word	16
  :                            2 	$quantum 8
  :                            3 
  :                            4 p	$proc
  :                            5 first*	$name
  :                            6 	second	p()	102
  :                            7 	$end
  :                            8 
  :                            9 p	$proc
  :                            10 second*	$name
  :                            11 ?	$do	p(),	+	p(?, 1)
  :                            12 	$end
  :                            13 
00:0000 0065                  +14 	first	101	99	100
00:0002 0063                  +14 
00:0004 0064                  +14 
00:0006 0066                  +14 
  :                            15 
*EOF*
:$(00):0000:0008 

</pre>


<div	style="color:a0a0a0">
<blockquote>
Paraform <i>macro_label</i> without parenthesis sends all the text of the calling line to another macro.<br>
The fields forwarded as arguments include the command plus any label on the call line to the forwarding macro.<br>
Therefore in the newly called macro, if all the call-line text is forwarded as arguments

	<blockquote>
	<i>macro_label</i> minus <i>macro_label()</i> = 2 indicates <i>macro_label(1,1)</i>
	is the label on the call line to the forwarding macro<br><br>
	
 	<i>macro_label</i> minus <i>macro_label()</i> = 1 indicates <i>macro_label(1,1)</i>
	is the command on the call line to the forwarding macro
	</blockquote>
</blockquote>

</div>
<br>
<br>
Actual parameters forwarded individually to a nested macro
plus any new tokens may be re-ordered for the nested macro:
<pre>

	first_macro	left, right, centre	off_centre

____________________________________________________________________
first_macro receives this parameter stream:

	first_macro	left, right, centre	off_centre
____________________________________________________________________

p		$proc
first_macro*	$name
		.
	second_macro	justify	p(2, 1)-7	p(1, 1), p(1, 3), p(1, 2)
		.
		$end

____________________________________________________________________
second_macro receives this parameter stream:

	second_macro	justify	off_centre-7	left,centre,right
____________________________________________________________________

p		$proc
second_macro*	$name
		.
		.
		$end

</pre>
Macro language plus parameters can be displayed step-by step if the
value $plist is greater than current macro nesting depth,<br>
given option flags -p (display $proc macros) -q (display $func macros).

<p>
Listing and -pq displays are on the second assembly pass.

<p>
If problems encountered are so great than the second assembly pass is
not reached -r flag displays macros on the first assembly pass.

<p>
See 8.38: $plist Directive, 3.2: Command Line Options,
11.4: Tracing Macro Expansion.

<p>
$proc macros are described in detail with application to instruction
code definition in Section 6.2: Describing Target Architecture in Text


<h2>4.4: The Argument Field</h2>


<h3>4.4.1 Argument Expressions</h3>

An argument expression generates a value which fits a target field,
for example an operand field of an instruction
<pre>

		lwz	r6, STORAGE_WORD_ADDRESS	; r6 and STORAGE_WORD_ADDRESS are operand expressions

</pre>

<p>
Argument field expressions may have any tokens and operators which
constant expressions have, except for words-size tags

<p>
The size of the expression value is its target field size in the
instruction or structure at the command field


<h3>4.4.2: Literal Arguments</h3>

Literals are constants of any size generated by reference. The address
of a literal operand is placed in the address field of the instruction
<pre>

	ld    r24, .literal_pool_name(0FFFC0000A000C000L)

</pre>

The instruction contains the <i>address</i> of the 64-bit constant 0FFFC0000A000C000.<br>
The constant is generated at the end  of the program section where ".literal_pool_name" is declared.

<p>
See 7: Constructing Program Sections, 7.1.7: Literal Pool Tag, 4.5: Literals, 4.5.5: Literal Pool Tags, 4.5.6: $lit directive

<p>
With assembly flag -a an operand entirely in parentheses is an 
automatic literal
<pre>

	add	r21, (LARGE_VALUE)

</pre>
See 4.5.3: Automatic Literals

<p>
Literals are typically used where a value is too large to be encoded as an immediate operand within<br>
an instruction. Constants which are not instruction code may also  reference literals. In this example<br>
an instruction points to a literal constant which points to another literal constant
<pre>

$ masmx -lnky
MASMX 7r3
0/-INPUT>>
	$list	0
	$include ../aside.dem/ppc_64.def
LTERM=#
CONT_CHAR=\
STERM=.
	$list
	$lit	3
	$set_option	"a"
$(.text:8192)
        ld      r3, (12, ("Hello World\n")d)
	bla	message
$(.data:16384)
	$res	4096
	$end
  :                            1118  $list
  :                            1119  $lit 3
  :                            1120  $set_option "a"
  :                            1121 $(.text:8192)
01:00002000 E860500C          +1122         ld      r3, (12, ("Hello World\n")d)
[+0000:00000000/*02]18*/02
01:00002004 48000003          +1123  bla message
  :                            1124 $(.data:16384)
  :                            1125  $res 4096
  :                            1126  $end
03:00005000+48656C6C6F20576F726C640A
03:0000500c+0000000C00005000
:$(01):00002000:00002008 :$(03):00004000:00005014 


</pre>


<h2>4.5: Literals</h2>


<h3>4.5.1: A Literal is</h3>


A literal is a constant generated by reference. It is assembled at the foot of its containing program section,<br>
which may be any section regardless of where the literal is referenced. Its address goes into the instruction<br>
or structure which references it

<p>
Literals are not duplicated in any one program section. References requiring
the same value retrieve the same literal


<h3>4.5.2: The Literal Pools</h3>


Each of the 72 location counters may have one literal pool.

<p>
If a location counter is breakpointed (the section is restarted
with breakpoint steps within  the same location counter), each part
may have a literal table.

<p>
Only the first 64 breakpoint parts of a section may have literal tables



<h3>4.5.3: Automatic Literals</h3>

Automatic literals are literals which are generated
in the current default literal pool without referencing 
a literal pool tag.

<p>
The default literal pool is at the segment-end of the default
location counter for literals, initially locator $(0).

<p>
Command line flag -a opts automatic literals. Assembly source
may set this and most other option flags, typically in target
definition header files
<pre>

	$set_option	"a"

</pre>
An automatic literal is then generated where any argument in
an instruction or constant line is entirely in parentheses
<pre>

	Load    r24, (0FFFC0000s)

</pre>
<p>
In that example, 0FFFC0000 is generated at the end of the assembly or
location counter breakpoint. The address of the literal goes in the
load instruction.

<p>
A unary sign in front of the opening parenthesis prevents an expression
from being an automatic literal
<pre>

	la	a0, +(EXPRESSION)

</pre>
+(EXPRESSION) is an expression, not a literal. An attempt is made
to place value EXPRESSION in the address field of the instruction.


<h3>4.5.4: Indirection Flag on a Literal</h3>

Unary * on source code arguments is widely used to represent
an indirection flag in binary code.<br>
masmx allows macro text to retrieve * at the start of all field
and subfield arguments, including literals
<pre>

	lr	r3, *(VERY_BIG_ADDRESS)

</pre>
A literal containing VERY_BIG_ADDRESS is generated

<p>
Macro language places the address of the literal in the instruction.<br>
Macro language retrieves flag value 0 or 1 for unary * absent or present

<h3>4.5.5: Literal Pool Tags</h3>


Literal Pool Tags are labels of literal pools, and referencing them
acts functionally to generate a literal and return its address

<p>
Each literal pool may have any number of tags.

<p>
Literal Pool Tags may be generated: 
<pre>

	on the location counter control line:

$(5:DATA_SEGMENT/literal_pool_5)

	as the label of a $LIT directive:

lits7  $LIT    7

	floating_multiply	literal_pool_5(7.2e-1200000)
	quad_store		*lits7(HIGH_ADDRESS)


</pre>

<h3>4.5.6: $lit Directive</h3>


$LIT may have a label and may have an argument.
If $lit has an argument it must be the identity
of a location counter 0..71.

<p>
If $lit has no argument its effective argument
is the identity of the current location counter.

<p>
$lit sets the default location counter
for literals to the value in its argument or
to the current location counter.

<p>
The default location counter for literals is
used for automatic literals (literals which
are generated without referencing a literal
pool tag).

<p>
If $lit has a label, the label becomes a literal
tag for the literal pool.


<h3>4.5.7: Nested Literals</h3>

<p>
It is possible to generate nested literals.

There is an example of how this might usefully be done at 4.4.2: Literal Arguments.<br>
The two-word literal at 0500C contains a byte count and a pointer to a string literal at 05000
<pre>

01:00002000 E860500C          +1122         ld      r3, (12, ("Hello World\n")d)
[+0000:00000000/*02]18*/02
01:00002004 48000003          +1123  bla message
  :                            1124 $(.data:16384)
  :                            1125  $res 4096
  :                            1126  $end
03:00005000+48656C6C6F20576F726C640A
03:0000500c+0000000C00005000

</pre>
The nested literal is only generated if it both begins and ends with
parenthesis. The opening parenthesis may have a flag * token in front:
<pre>

$ masmx constanz -lnyk
MASMX 7r3
3/constanz.msm
  :                            1 	$word		32
  :                            2 constanza $form		1, 31
  :                            3 
  :                            4 	$set_option	"a"
  :                            5 	$lit		5
  :                            6 	$plist		5
  :                            7 
  :                            8 instanza*	$proc
  :                            9 	constanza	instanza(1, *1), instanza(1, 1)
  :                            10 	 $end
  :                            11 
  :                            12 $(5:050000)
05:00050000 80050003          +13  	instanza	*(instanza *(instanza *(99)))
  :                            14 	$end
05:00050001+00000063
05:00050002+80050001
05:00050003+80050002
:$(05):00050000:00050004 

</pre>
This is next example does not generate a nested literal. It contains an
expression within a literal:
<pre>

$ masmx -lnk
MASMX 7r3
0/-INPUT>>
	$word	        32
	$set_option	"a"   

$(4:16384)
	+	((99)+2)
$(0:65536)
	$end
  :                            1  $word         32
  :                            2  $set_option "a"   
  :                            3 
  :                            4 $(4:16384)
04:00004000 00010000          +5  + ((99)+2)
  :                            6 $(0:65536)
  :                            7  $end
00:00010000+00000065
:$(00):00010000:00010001 :$(04):00004000:00004001 


</pre>
<h2>4.6: Function Macros</h2>

Operand expressions may include user function macros,

<h3>4.6.1: A Function Macro is</h3>

Functions are not code subroutines (as they are in C-Language).

<p>
masmx functions are macros which return values at assembly time.

<p>
User written functions return a computed value for use in an expression.

<p>
Functions mostly contain directives, because they do not primarily
generate code: 
<pre>

simplog*	$func
		$do	simplog(1,1)=64,	$return	6
		$do	simplog(1,1)=8,		$return	3
		$flag	bucket can only be 8 bytes or 64 bytes
		$return	0
		$end

...
		shift_left	r6, simplog(BUCKET_SIZE)


</pre>
<h3>4.6.2: Directives for Constructing Functions</h3>


<h4>4.6.2.1: $FUNC -head of function</h4>
<pre>

function_name  $FUNC
	.
	.

</pre>
There must be a label when the command is $FUNC.

<h4>4.6.2.1.1: Second-Pass-Only Functions</h4>

$FUNC can have an argument
<pre>

fname*  $FUNC	*
	.
	.

</pre>
* is the only argument $FUNC can have. It means
"second pass only", or don't expand this macro on
the first assembly pass.

<p>
One reason for a second-pass-only function may be that its
value is not required on the first pass.<br> Another reason
may be that two passes of the same function have a
cumulative effect which is undesirable 

<p>
It may to the contrary be necessary to expand a function macro on both
assembly passes, because the function has determining effect how much
code is generated. See 4.6.2.1.3: Functions affecting Program Displacements


<h4>4.6.2.1.2: Non-Idempotent Functions</h4>
<p>
Second-pass-only functions are used to generate a data item
once only by reference.

<p>
They prevent the situation where the data is not generated on the
second pass because its label was generated on the first pass:
<pre>


f*      $func
	$if     $t(f(1,1))=0  . Non-existent?
"f(1,1)"** generate f(1,1)    . out-of-line $proc call generates label and data
	$endif
	$return f(1,1)        . return label value
	$end
	.
	.
	call    f(ROUTINE)

</pre>
One way of solving this problem is a literal. Literals
are generated on the second pass only and do not have
labels

<p>
However a function call may be necessary for some
action more complex than generating a literal. This
is one use of the second-pass-only function
<pre>

f*      $func	*
	$if     $t(f(1,1))=0  . Non-existent?
"f(1,1)"** generate f(1,1)    . out-of-line $proc call generate label and data
	$endif
	$return f(1,1)        . return label value
	$end
	.
	.
	call    f(ROUTINE)


</pre>

<h4>4.6.2.1.3: Functions affecting Program Displacements</h4>

If a function macro returns a value which determines the length
of code generated, it must be called on both assembly passes,
unless there are no labels and no literal table subsequent to
the point where the function macro has its effect

<p>
The following function is for example assembled to inform ColdFire
floating-point instructions of the address of a constant operand
in storage

<pre>


f       $func
"$ieee64"* $name
        $if     $t(f(2, 1))=$special_reg
        $if     f(2, 1)=l
"$UP"*  $equf   $azlit(f(1)d)
        $elseif f(2, 1)=w
"$UP"*  $equf   $azlit(f(1)s)
        $elseif f(2, 1)=b
"$UP"*  $equf   $azlit(f(1)*/8s)
        $elseif f(2, 1)=s
"$UP"*  $equf   $azlit(ieee754_32 f(1))
        $endif
        $else
"$UP"*  $equf   $azlit(ieee754_64 f(1))
        $endif
        $return $UP
        $end

</pre>

If the function is 2nd-pass-only (<b>f $func *</b>), then the blank result
from suppressing its expansion on pass one leads to the mistaken pre-assembly
of short format floating instructions with no displacement field. On pass two
the instructions get longer and the literal table starts at a conflicting
location. The assembly is marked in error
<pre>

$ masmx quickly -lnky
MASMX 7r3
3/quickly.msm
CONT_CHAR=|
LTERM=;
STERM=.
*EOF*
  :                            1 	$path		../smaragd.68k
  :                            2: 	$include	coldfire.def
  :                            3: 	$include	fpxpress.def
  :                            4 	$path
  :                            5: 	$include	espresso.def
  :                            6: 	$include	ieee754.def
  :                            7 
  :                            8 $(5:65536,a5)
  :                            9 one	$res	8
  :                            10 two	$res	8
  :                            11 
  :                            12 $(0:16384,pc/$azlit)
  :                            13 froutine
00:00000000 F22D54000000      +14 	$xqt_fp,$ieee64		one*1.6384e307+two
00:00000006 F23A54230006      +14 
00:0000000C F22D54220008      +14 
00:00000012 4E75              +15 	rts
  :                            16 
*EOF*
Error: quickly.msm Line 16: code longer on 2nd assembly pass: $(00) :0000000E:00000014
00:0000000e+7FB754E31CD072DA
:$(00):00004000:00004016 :$(05):00010000:00010010 
quickly.msm: object code 152 bytes: 1 errors: 0 undefined labels

</pre>

The corrective step is to allow function <i>$ieee64</i> to expand on both assembly
passes (<b>f $func</b> without any asterisk). Then the literal constant addressed
by the  instruction at 0x00000006 is twelve bytes beyond instruction + 2 = 0x00000014
and the assembly does not error

<pre>

$ masmx quickly -lnky
MASMX 7r3
3/quickly.msm
CONT_CHAR=|
LTERM=;
STERM=.
*EOF*
  :                            1 	$path		../smaragd.68k
  :                            2: 	$include	coldfire.def
  :                            3: 	$include	fpxpress.def
  :                            4 	$path
  :                            5: 	$include	espresso.def
  :                            6: 	$include	ieee754.def
  :                            7 
  :                            8 $(5:65536,a5)
  :                            9 one	$res	8
  :                            10 two	$res	8
  :                            11 
  :                            12 $(0:16384,pc/$azlit)
  :                            13 froutine
00:00000000 F22D54000000      +14 	$xqt_fp,$ieee64		one*1.6384e307+two
00:00000006 F23A5423000C      +14 
00:0000000C F22D54220008      +14 
00:00000012 4E75              +15 	rts
  :                            16 
*EOF*
00:00000014+7FB754E31CD072DA
:$(00):00004000:0000401C :$(05):00010000:00010010 
quickly.msm: object code 152 bytes: 0 errors: 0 undefined labels

</pre>


<h4>4.6.2.2: $NAME -entry point and invocation tag</h4>

<b>$name</b> directive allows a latent value to be associated
with a callname. Here one function is available for 8051
relative jump instructions. The address encoded in the
instruction is relative to the instruction trailing edge,
either two or three bytes after the instruction start
<pre>

f	$func
"$rel2"* $name   2
"$rel3"* $name   3
target  $set    f(1,1)-$-f(0, 0)
        $do     target<-128,    $flag   You may only jump from instr. trailing edge - 128
        $do     target>127,     $flag   You may only jump from instr. trailing edge + 127
        $return target
        $end

</pre>

The <b>$func</b> label <i>f</i> need then not be exported from the macro text
(it wears no asterisk), and this allows <i>f</i> to be reused and argument paraforms
like <i>f(1,1)</i> to be quickly recognisable in many different functions


<h4>4.6.2.3: $RETURN -value of result</h4>


The argument of $RETURN is an expression.
192 bits of it are returned:
<pre>

	$return expression

</pre>
$RETURN also leaves the containing macro, and this is true of $PROC
macros as well as $FUNC macros, although $PROC macros do not have
a result value.


<h4>4.6.2.4: $END -foot of function</h4>

$END is the last command on any subassembly.
A $FUNC is a subassembly (a macro):
<pre>

f       $func
	.
	.
	$return something
	$end

</pre>

<h3>4.6.3: Code Generated During Function Evaluation</h3> 

Code may not be generated inline to the current
location counter during a <b>$func</b>. That is treated
as an error, although the functional result may determine
more or less code generated inline

<p>
Here function <i>f</i> calls a macro <i>generate</i>
to construct a data item out of line (in locator 42), and  
attach a label to it
<pre>

f*      $func	*
	$if     $t(f(1,1))=0  . Non-existent?
"f(1,1)"** generate f(1,1)    . Generate Label and Data
	$endif
	$return f(1,1)        . return label value
	$end
	.
	.
p       $proc   $(42)        
generate* $name
*       +       address_of_resolver_routine
	"p(1, 1)"
	$end
	.
	.
	call    f(ROUTINE)


</pre>

<h2>4.7: masmx Internal Functions in Detail</h2>


<h3>4.7.1: $	location counter</h3>

<h4>4.7.1.1: $	this location counter</h4>

The expression $ returns the value of the current location counter. 
For example the sequence
<pre>

$(7:256)
	$res    4
bampot  $equ    $+1


</pre>
label bampot has the value 261
<pre>


$ masmx -lnk
MASMX 7r3
0/-INPUT>>
	$word   32
	$awidth	32:96

ASTRONOMIC	$set	07FFFF8000380000000040000
	    
$(43:1024:*ASTRONOMIC)
	
	$res	512
here
tube	$equ	$+1

	+	tube
	+	here
	$end
  :                            1  $word   32
  :                            2  $awidth 32:96
  :                            3 
  :                            4 ASTRONOMIC $set 07FFFF8000380000000040000
  :                            5      
  :                            6 $(43:1024:*ASTRONOMIC)
  :                            7  
  :                            8  $res 512
  :                            9 here
  :                            10 tube $equ $+1
  :                            11 
2B:7FFFF8000380000000040600:7FFFF8000380000000040601
                              +12  + tube
2B:7FFFF8000380000000040603:7FFFF8000380000000040600
                              +13  + here
  :                            14  $end
:$(2B):00000400:00000606 


</pre>

<h4>4.7.1.2: $(..)	named location counter</h4>

The expression $(..) returns the value of the location 
counter identified in the brackets. For example
<pre>

text    $equ    0
var     $equ    1
$(var:4096)
	$res    4
$(text:256)
CONSTANT        +       $(1)+3

</pre>
The data word at location CONSTANT to contains the value 4103


<h3>4.7.2: $a	absolute address</h3>

$a is the absolute address relative to the program space

<p>
Constants of base-displacement labels and location counters only contain
the displacement. $a adds the section base whether it is already known or
relocatable

<h4>4.7.2.1: $a	current absolute address</h4>

$a without parameter is the current absolute address. Here $a value is shown
beside the displacement value in $
<pre>

$ masmx -lnk
MASMX 7r3
0/-INPUT>>
	$word	16
$(44:0FC00,5)
	$res	10
	+	$, $a:L
	$end
  :                            1  $word 16
  :                            2 $(44:0FC00,5)
  :                            3  $res 10
2C:000A 000AFC0A              +4  + $, $a:L
  :                            5  $end
:$(2C):FC00:FC0C 


</pre>
<p>

$a constants may be within macro text invoked in many different program sections
with known or relocatable base address

<p>
$a also generates constants pointing to a base-displacement segment which is relocatable

<h4>4.7.2.2: $a(..)	absolute value of expression</h4>
<pre>

$ masmx -lnkx
MASMX 7r3
0/-INPUT>>
$(15:*8, 9)	. relocation alignment 8, base register 9
	$res	6
here
	+($a(here))d
	$end
  :                            1 $(15:*8, 9) . relocation alignment 8, base register 9
  :                            2  $res 6
  :                            3 here
(+0f)30
0F:000006 000000000006        +4  +($a(here))d
  :                            5  $end
here=$0F:000006,000009
-INPUT>>=0<000000
:$(0F):000000:000008 

</pre>
A relocation request is attached to the $a reference. A storage constant or
receiving field must be large enough to contain the linked absolute address

<p>
$a is also functional where the target address has a known absolute base but
the containing section is base-displacement addressed. Constant expressions
using $ or a base-displacement label retrieve the displacement from the start
of a base-displacement section

<pre>

$ masmx -ln
MASMX 7r3
0/-INPUT>>
$(4:0400000,2)
	$res	4
	+	$
        $end
  :                            1 $(4:0400000,2)
  :                            2  $res 4
04:000004 000004              +3  + $
  :                            4  $end
:$(04):400000:400005 
-INPUT>>: object code 44 bytes: 0 errors: 0 undefined labels
Tim-Coxs-MacBook:~ timcox$ cat temp.txo


</pre>

$a retrieves the address whether it is absolute or relocatable
<pre>

$ masmx -lnkx base_da
MASMX 7r3
3/base_da.msm
*EOF*
  :                            1 QUITE_LARGE_START_ADDRESS $equ	07FC000
  :                            2 intervening_displacement $equ	120
  :                            3 
  :                            4 $(4:QUITE_LARGE_START_ADDRESS, 9)
  :                            5 
  :                            6 	$res	intervening_displacement
  :                            7 
  :                            8 name
04:000078 7FC078              +9 	+	$a(name)
  :                            10 
*EOF*
QUITE_LARGE_START_ADDRESS=7FC000
intervening_displacement=000078
name=$04:000078,000009
base_da.msm=0<000003
:$(04):7FC000:7FC079 

</pre>
name has the base+diplacement value 
<pre>

	intervening_displacement, 9

</pre>
$a(name) has the absolute value
<pre>

	QUITE_LARGE_ADDRESS+intervening_displacement

</pre>
$a has no function for addresses in void sections, where the base
register value is not available at either assembly or link

<p>
A breakpoint value in the locator declaration indicates a physical segment load address known in advance.<br>
It is seen here that in base-displacement $a(<i>location</i>) retrieves the program-absolute address,<br>
<i>location</i> retrieves the displacement only, and the physical load address is not accessed
<pre>

$ masmx -lnkyx
MASMX 7r3
0/-INPUT>>
	$word	32
	$quantum 8
$(12:0C000:0FC0000,5)
	+	location, $a(location)d
	$res	40
location
	$end
  :                            1  $word 32
  :                            2  $quantum 8
  :                            3 $(12:0C000:0FC0000,5)
0C:00000000 000000300000C030  +4  + location, $a(location)d
  :                            5  $res 40
  :                            6 location
  :                            7  $end
location=$0C:00000030,00000005
-INPUT>>=0<00000000
:$(0C):0000C000:0000C030 

</pre>
A starred breakpoint address is not a load address translation value or index but part of program-visible<br>
addresses in the section. $a retrieves the large absolute value
<pre>

$ masmx -lnkx
MASMX 7r3
0/-INPUT>>
	$word	32
	$awidth	32:64
$(14::*00FFC800003F0000, 20)
	$res	10
here
	+($a)d
	$end
  :                            1  $word 32
  :                            2  $awidth 32:64
  :                            3 $(14::*00FFC800003F0000, 20)
  :                            4  $res 10
  :                            5 here
0E:00FFC800003F000A:00FFC800003F000A
                              +6  +($a)d
  :                            7  $end
here=$0E:0000000A,00000014
-INPUT>>=0<00000000
:$(0E):00000000:0000000C 

</pre>




<h3>4.7.3: $b	section base address</h3>

$b function in an absolute section retrieves the initial start address
of the section
<pre>

$ masmx -ln
MASMX 7r3
0/-INPUT>>
$(5:02000)
$(5:05000)
	$res	100
	+	$b
	$end
  :                            1 $(5:02000)
  :                            2 $(5:05000)
  :                            3  $res 100
05:005064 002000              +4  + $b
  :                            5  $end
:$(05):002000:005065 

</pre>
$b function in a relocatable section retrieves the link root of the
input segment within the linked section
<pre>

$ masmx -lnkx
MASMX 7r3
0/-INPUT>>
$(5:*8) 
	$res	100
base*	$equ    $b
	$store	rel_file
	$end
  :                            1 $(5:*8) 
  :                            2  $res 100
  :                            3 base* $equ    $b
  :                            4  $store rel_file
  :                            5  $end
base+=$05:000000
rel_file.txo=0<FFFFFFFF
-INPUT>>=0<000000
:$(05):000000:000064 

$ cat rel_file.txo

+base:$05:000000
:$05*FFFFF8:000000:000064

$ masmx -lnkx
MASMX 7r3
0/-INPUT>>
	$list	        0
	$include	../def/map1.def
	$list
$(5:02000)
buffer	$res	03000
	$include,$binary rel_file
rel_file.txo:$(5) 100 words decimal from hexadecimal 005000 to 005064
	$end
  :                            97  $list
  :                            98 $(5:02000)
  :                            99 buffer $res 03000
  :                            100:  $include,$binary rel_file
  :                            101  $end
buffer=$05:002000
base+=$05:005000
rel_file.txo=1<000004
../def/map1.def=1<000004
-INPUT>>=0<000000
:$(05):002000:005064

$ cat temp.txo

+base:$05:005000
:$05*000000:002000:005064

</pre>
The value of label base is 05000.



<h3>4.7.4: $bank_index -absolute or virtual memory space identity</h3>

$bank_index concerns targets which switch windows of address space between different memory blocks<br>
See 7.1.2, 7.1.4, Breakpointed Location Counters

<p>
$bank_index retrieves a load pointer which may be absolute or virtual for the memory block currently assembling.<br>
The load pointer is the <i>breakpoint_value</i> in the location counter switch statement
<pre>

$(locator_number:program_visible_base_address:<i>breakpoint_value</i>)

</pre>
If assembly flag -v is not set, <i>breakpoint_value</i> is an absolute load address.<br>
A section defined by locator number may have many breakpoints, making many parts with different load addresses<br>
of one program section. The parts may share program-visible address space

<p>
If assembly flag -v is set, <i>breakpoint_value</i> is an abstraction like a handle or block identifier,<br>
and the binary output appends it to load string addresses without interpreting it. A section defined by location counter<br>
may have many partss with different storage block identifiers. See 7.1.2.2: Breakpointed Location Counters: -v Option

<p>
Whether the section breakpoint address is absolute or a translatable value, $bank_index function retrieves the current breakpoint<br>
value without the developer supplying it. Identifying the memory block allows macro code to export an entry point or vector
<pre>



p	$proc
entryP*	$name
*	$equ	vector_value($bank_index, $)
	j	p(1, 1)
	$end


callname* entryP callroutine


</pre>

<h3>4.7.5: $n -value of instruction $NAME, macro entry tag</h3>

$n has the latent value of a $name macro entry point

<p>
$n is the same value as the paraform <i>macro_label</i>(0, 0),
but truncated to 32 bits instead of 192 bits

<p>
$n may be used in both procedural and functional macros
<pre>

p	$proc
command_name_1* $name LATENT_VALUE_1
command_name_z* $name LATENT_VALUE_Z


	$end 
	
f	$func
reference_name_x* $name LATENT_VALUE_X
reference_name_y* $name LATENT_VALUE_Y

	$return	FUNCTIONAL_VALUE
	$end

</pre>
For example where
<pre>

	$word   48
"$instruction" $form 6, 42
	.
	.
p       $proc
load*   $name   1
store*  $name   2
add*    $name   3
subtract* $name  4

	$instruction   $n, p(1,1)

	$end

</pre>
the call line
<pre>

	add     8193

</pre>
generates
<pre>

	0C0000002001

</pre>
The macro was called with the name add with latent value 3

<p>
Value 3 is in the first field and the operand value in the other field

<p>
$n can also be retrieved as parameter macro_label(0,0), in this example p(0, 0)

<p>
The size of macro_label(0, 0) is 192 bits.

<p>
The size $n is 32 bits.

<p>
This function macro uses its $n value to compute
an 8-bit address relative to the trailing edge of 
either a two- or a three-byte relative-jump instruction:
<pre>

"$rel"  $func
"$rel2"* $name   2
"$rel3"* $name   3
target  $set    $rel(1,1)-$-$n
	$do     target<-128,	$flag   You may only jump from instr. trailing edge - 128
	$do     target>127,	$flag   You may only jump from instr. trailing edge + 127
	$return target
	$end

</pre>
<p>
"cjne" calls $rel3 to obtain an 8-bit relative displacement from its own 
trailing edge, which is three bytes later than the location counter

<p>
"jc" and "jnc" call $rel2 to obtain an 8-bit relative displacement from 
their trailing edge, which is two bytes later than the location counter
<pre>

i$cjne_a        $form   8,8,8
i$cjne_r        $form   5,3,8,8
i$cjne_indirect $form   7,1,8,8

"$jumpcc"	$form 8, 8

p	$proc
cjne*	$name

        $if     ($t(p(1,1))=REGISTERS$)**(p(1,1)=A)
          $if   p(1,#2)
            i$cjne_a            0b4, p(1,2), $rel3(p(1,3))
          $else
            i$cjne_a            0b5, p(1,2), $rel3(p(1,3))
          $endif
        $elseif $t(p(1,1))=POINTER$
          $if   p(1,#2)
            i$cjne_indirect     05bh, p(1,1), p(1,2), $rel3(p(1,3))
          $else
            $flag Second Operand Must Be Immediate
          $endif
        $elseif $t(p(1,1))=RREGISTERS$
          $if  p(1,#2)
            i$cjne_r            017, p(1,1), p(1,2), $rel3(p(1,3))
          $else
            $flag Second Operand Must Be Immediate
          $endif
        $else
          $flag First Operand Must be A/Rn/@Rn
        $endif
        $end

p       $proc
jc*     $name   JC_CODE
jnc*    $name   JNC_CODE
	$jumpcc $n, $rel2(p(1,1))
	$end

</pre>

<h3>4.7.6: $net(..) -the unrelocated value of an expression</h3>

Few algebraic operations are allowed on relocatable addresses.
See 4.2.1: Operators

<p>
masmx Linking assembly guards internally against truncation on absolute relocation.

<p>
Assembling from source, range checks may be needed to prevent intermediate truncation,
or final truncation in absolute assembly.<br>
It is also desirable to to assemble relocatable and absolute with the same macro text

<p>
This test
<pre>

p	$proc
jump*	$name	
target	$set	p(1, 1)

	$do	target>16777261,	$flag	you can't jump there

</pre>
would always error where p(1, 1) is relocatable or external, because operator &gt;
is not allowed on a relocatable.

<p>
This is allowed
<pre>

	$do	$net(target)>16777261,	$flag	you can't jump there

</pre>
Targets in relocatable segments have relocation requests added to references.<br>
Labels which are not present are external and relocation requests are added to references

<p>
The operators allowed on relocatable tokens are
<pre>

	+	plus

	-	minus

	/*	shift right

        */-	algebraic shift right

	**	AND

</pre>
Other operators require <b>$net()</b> function of relocatable tokens



<h3>4.7.7: $o(.) -is this option set?</h3>


An expression whose value is 'A'..'Z' or 'a'..'z' is allowed in the
parentheses, and 1 is returned if the equivalent flag is on, for example:
<pre>

	$do	$o('k'),	$note flag -k is set

	$if	$o(65)=0
	$flag	flag -A should be set
	$endif 

</pre>
The flag is set by any of -abcdefghijklmnopqrsuvwxyzEFGQZ+ anywhere 
on the command line, or with the  $SET_OPTIONS directive.



<h3>4.7.8: $r region</h3>


<h4>4.7.8.1: $r	identity of current location counter</h4>

Returns the identity, not the value, of the current 
location counter 0..71. 


<h4>4.7.8.2: $r(<i>location</i>)	location counter containing target <i>location</i></h4>

identifies the program section where the named <i>location</i> is

<p>
The first token in expression <i>location</i> must identifiably belong to
a program section, as a location label does, in order for its section
to be identified
				  
				  
<h3>4.7.9: $rel	relocation factor of location counter</h3>

The relocation factor of a location counter is zero if the program
section is absolute and nonzero if the program counter is relocatable.<br>
A nonzero relocation factor is not guaranteed to be 1. It is the
alignment quantum of the section and it is represented as negative if the<br>
segment contains only buffers and no code

<h4>4.7.9.1:	$rel</h4>

$rel without parameter is the relocation factor of the current location counter</h4>

<h4>4.7.9.2:	$rel(<i>locator</i>)</h4>

<i>locator</i> is a value in the range 0..71

<p>
Function <b>$rel</b> may be cascaded with function <b>$r</b> to detect
if the current location or a named label is relocatable
<pre>

	$if     $rel($r(label))
	.
	.

</pre>
<h3>4.7.10: $t(label)	Label Type</h3>

The return value from the $t(..) function is a type 
associated with a label. The type is assigned either 
by the assembler or by the developer.


<h4>4.7.10.1: Label Type Undefined</h4>

A label which is not defined during the first assembly passed is external
and has the type zero meaning undefined. Any reference to it other than<br>
<b>$t()</b> function generates a link request for external resolution,
or if -u flag is set, an error.


<h4>4.7.10.2: Label Type Location</h4>


A label has the type of a storage address if it
has been encountered on column 1 of a source line,<br>
and is not the label of a $EQU, $SET, $EQUF, $PROC, 
$FUNC, a $NAME in a $PROC or $FUNC, or the counter tag<br> 
of a $DO, or the tag of a $LIT directive. 
	
<p>
The type and value of address labels cannot be changed.
However the same label name can be used independently and differently
at different macro depths
	
<p>
The type of a location or storage address label is 127. This type value does not have a masmx-supplied name
<pre>

$ masmx -lnkyx
MASMX 7r3
0/-INPUT>>
$(5:05000)
startup	+       $t(startup)
	$end
  :                            1 $(5:05000)
05:005000 00007F              +2 startup + $t(startup)
  :                            3  $end
startup=$05:005000
-INPUT>>=0<000000
:$(05):005000:005001 

</pre>
A location label is associated with a a location counter and is either absolute or relocatable.<br>
So are labels of types $set and $equ, if they are equated to a storage address
<pre>

$(5:05000)
startup	+       $t(startup)
forward	$set	startup
along	$equ	forward
	$end
  :                            1 $(5:05000)
05:005000 00007F              +2 startup +       $t(startup)
  :                            3 forward $set startup
  :                            4 along $equ forward
  :                            5  $end
along=$05:005000
forward=$05:005000
startup=$05:005000
-INPUT>>=0<000000
:$(05):005000:005001 

</pre>

<h4>4.7.10.3: Label Type $equ</h4>


The label of a $EQU line has an absolute or a relocatable 
value according to the the argument to which it is equated.

<p>
$EQU labels are not intended to be equated more than once

<p>
A label name may be defined independently and differently
at different macro depths

<p>
See 8.14: $equ directive 


<h4>4.7.10.4: Label Type $set</h4>


The label of a $set line has an absolute or a relocatable 
value according to the argument to which it is set.

<p>
$set labels may be redefined without restriction.
$set is actioned on both assembly passes.

<p>
A label name is defined independently and differently
at different macro depths.

<p>
See 8.46: $set directive 
	

<h4>4.7.10.5: Label Type $equf</h4>


$EQUF equates a label to a list of values.

<p>
A $equf name supplied as actual argument to a macro 
appears to macro text as a list of subfields. There
may be other subfields of the field in front. Extra
trailing subfields replace $equf subfield values
(line 10) starting at the second position
<pre>

$ masmx -lnky macaroon
MASMX 7r3
3/macaroon.msm
LTERM=#
CONT_CHAR=\
STERM=.
*EOF*
  :                            1: 	$include	../aside.dem/ppc_603.def
  :                            2 
  :                            3 macaroon $equf	600, r31
  :                            4 more	$equf	r3, 600, r31
  :                            5 
  :                            6 $(.text:131072)
  :                            7 
01:00020000 807F0258          +8 	lwz	r3, macaroon
01:00020004 807F0258          +9 	lwz	more
01:00020008 807E0258          +10 	lwz	more,,r30
  :                            11 
  :                            12 
*EOF*
:$(01):00020000:0002000C 

</pre>
If an $EQUF name is a token of expression, its value is its
first attribute, so macaroon+20 has a value of 620

<p>
Individual values in the $EQUF list may be retrieved with label\&xi;<br>
more\2 has the value 600

<p>
The first $equf subfield may be a relocatable address, but
<i>equf_label</i>\1 is not relocatable

<pre>

$ masmx crusti -lnky
MASMX 7r3
3/crusti.msm
LTERM=#
CONT_CHAR=\
STERM=.
*EOF*
  :                            1: 	$include	../aside.dem/ppc_603.def
  :                            2 
  :                            3 $(.data:*4)
  :                            4 croutons
  :                            5 bisque $equf croutons, r29
  :                            6 
  :                            7 $(.text:131072)
  :                            8 
(+03)10
01:00020000 80C00000          +9 	lwz	r6, croutons
(+03)10
01:00020004 80DD0000          +10 	lwz	r6, bisque
01:00020008 80DD0000          +11 	lwz	r6, bisque\1
*EOF*
:$(01):00020000:0002000C 


</pre>

<h4>4.7.10.6: Label Type $DIRECTIVE</h4>

The names of the 51 directives are labels. See Section 8
They can be given extra names which also have the label 
type directive
<pre>

MACRO   $equ,$directive $proc
MACEND  $equ,$directive $end


</pre>

<h4>4.7.10.7: Label Type $FUNCTION</h4>    


The internal functions available when the assembler begins
to execute have the type $FUNCTION. The developer may also
alias those functions by giving equates the subtype of $FUNCTION,
thus
<pre>

.       $equ,$function  "$"   ; $ is now also named .

</pre>
This only equates "." to location counter function "$" if "$"
is in quotes as shown. This retrieves the functional identity
of "$" for "."

<p>
"." now means the location counter function.

<p>
Without the quotes $ is evaluated functionally and "." receives
the current location value. That would render "." an unusable function


<h4>4.7.10.8: Label Type $PROC</h4>

The label on column 1 of the $proc directive line has the label type of $proc.<br>
The following images until a mirroring $end are a $proc command macro.<br>
Embedded $procs mat be nested inside a $proc description. 

<p>
A $proc macro may be identified in the command position of an assembly<br>
source line by its $proc label or by a $name label, whichever is exported
with trailing asterisk

<p>
Inside a $proc an reference to its own label is a parameter reference or
paraform

<pre>

this_macro*      $proc
	jump    this_macro(1, 4)
	$end

	this_macro 1, 2, 3, away

</pre>
has the effect "jump away"

<p>
Example <i>this_macro</i>* must be unique in the subassembly calling it.
$proc labels often are not unique, and then may not be exported with<br>
the trailing asterisk* These $procs contain one or more  exported
$names which may also have a latent value

<p>
An exported $proc label may be referenced in an expression and has an
identify value unique in the calling subassembly

</pre>
<h4>4.7.10.9: Label Type $NAME</h4>


$name is used within macro text $proc..$end or $func..$end
to give alternative call names with latent values
to the macro

<p>
$name labels have the type $name

<p>
$func and $proc macro labels need only be unique if they are exported.<br>
They are otherwise made callable by having unique $name labels
	
<p>
It is therefore possible to have identical and cryptic
labels for many macros, for example p
<pre>

instruction_form $form 8, 8, 16

p       $proc
grabit* $name   1
dropit* $name   2
	instruction_form   $n, p(1, 1), p(1, 2)
	$end


        grabit  r12, input_port
        dropit  r12, output_port

</pre>
The developer may have many procedural macros p. This makes the
argument reference paraforms p(1, 1) p(1, 2) similar in syntax
and easy to read in many different macros.<br>p is not used as a
call name, but the $name labels are.<br>p with no asterisk is only
a visible name within macro p, and this is why multiple macros
may have the same name

<p>
If the label on the $proc or $func line  is instead <i>pqrpqr</i> then<br>
actual parameters are referenced <i>pqrpqr(1, 1) pqrpqr(1, 2)</i>...

<p>
A macro is callable by its $proc or $func label or or by a  $name label,
whichever is exported with trailing asterisk*<br>Labels exported from macros
must be unique in the containing subassembly


<h4>4.7.10.10: Label Type $FUNC</h4> 


<p>
A $func label is the label on column 1 of a $func line.<br> 
$func..$end contains a user written value-generating macro and 
its value is the expression on the first $return line to be actioned 

<pre>

	$word	8

hi*	$func
	$return	hi(1, 1)/*8
	$end

	+	value, hi(value):L	; 16-bits little-endian


</pre>
	


<h4>4.7.10.11: Label Type $FORM</h4>


A label declared as $FORM returns the type $FORM and
describes the layout of an instruction or similar
bit-structure.

<p>
When a $FORM label is encountered in the command position
the corresponding storage structure is generated inline.

<pre>

powerpc_load_store_instruction  $form   6, 5, 5, 16


p       $proc
lwz*    $name   LWZ
stw*    $name   STW
lbz*    $name   LBZ
stb*    $name   STB
	.
	.
	powerpc_load_store_instruction $n,p(1, 1),.index\p(1, 2),p(1, 2)
	$end


</pre>

<h4>4.7.10.12: Label Types Assigned by the Developer</h4>


Label type values 128..255 are available to the developer
who may use them to associate distinct attributes with
certain names.

<p>
The developer may assign types to names and the type
may be retrieved with function $t(..)

<p>
This accommodates the frequent practice with CISC
targets like M68K of assigning one mnemonic name
reflecting functionality to several instructions
which have differing opcodes according to memory, register
or immediate operand and according to operand size

<p>
Names like ADD and MOVE may be many different
instructions which can only be fixed by understanding
what sort of operands are addressed 

<p>
A definition file for M68K might
contain
<pre>

data_register   $equ    128
address_register $equ   129
pointer_register $equ   130
special_register $equ   131

d0      $equ,data_register      0
d1      $equ,data_register      1
	.
	.
d7      $equ,data_register      7

a0      $equ,address_register   0
a1      $equ,address_register   1
	.
	.
a7      $equ,address_register   7
	.
	.
a0@     $equ,pointer_register   0
a1@     $equ,pointer_register   1
	.
	.
a7@     $equ,pointer_register   7
	.
	.
ssp     $equ,special_register   $0407
usp     $equ,special_register   $0007
cr      $equ,special_register   1

</pre>

Correspondingly the instruction part of the target definition interrogates
the operand types of the actual arguments to instructions
<pre>

p       $proc
mov.b*  $name   MOV_B
mov.w*  $name   MOV_W
mov.l*  $name   MOV_L
	$if     $t(p(1,1))=data_register     
	.
	.

</pre>
<h3>4.7.11: $zenith -High Address of Section + Literals</h3>

<b>$zenith</b> is the high address of a section including its literals.<br>
To obtain the final high address, <b>$zenith</b> is retrieved after all of the section
is assembled on the second assembly pass. Then all literals have been added.


<h4>4.7.11.1: $zenith -this Section</h4>

Example
<pre>

	$do	$zenith>LIMIT,	$flag	section overrun

</pre>


<h4>4.7.11.2: $zenith(locator) -named Section</h4>

Example
<pre>

	$do	$zenith(_STATIC)>_STATIC_LIMIT,	$flag	static section overrun	

</pre>

<h1>5: Iterated Code and Structured Data</h1>


<h2>5.1: $do Directive and $proc Macros</h2>

<b>$do</b> directive repeats a line of code. An optional label is a count value ascending from 1.

See also section <b>8.9: $do Directive</b>

<p>
It this example a routine generating floating constants with 11-bit exponent field uses a table to scale the floating number according to its decimally expressed exponent in the range &plusmn;307
<pre>

scale	$do	615,	1*+scale-308	. 1.0e[-307..+307]

</pre>

<p>

The line of code on a $do line may be a macro call

<pre>

$ masmx sockets -lnk
MASMX 7r3
3/sockets.msm
*EOF*
  :                            1 	$word		16
  :                            2 
  :                            3 p	$proc
  :                            4 port*	$name
  :                            5 *	$tree
  :                            6 next	+	p(2, 1)L 
  :                            7 local	0L
  :                            8 port	+	p(1, 1)S
  :                            9 remote	0L
  :                            10 remoteP	0
  :                            11 
  :                            12 connection_chain	. connection port
  :                            13 message_chain		. datagram_port
  :                            14 	0L
  :                            15 	$root
  :                            16 	$end
  :                            17 
  :                            18 $(10:0A000)
  :                            19 
  :                            20 UPORTS	$equ	3
  :                            21 TPORTS	$equ	3
  :                            22 
0A:A000 A002                  +23 ufree	+	uport(1)S
0A:A001 A020                  +24 tfree	+	tport(1)S
  :                            25 
0A:A002 0000A00C              +26 ?	$do	UPORTS,uport(?)	port	1023+?	uport(?+1)
0A:A004 00000000              +26 
0A:A006 0400                  +26 
0A:A007 00000000              +26 
0A:A009 0000                  +26 
0A:A00A 00000000              +26 
0A:A00C 0000A016              +26 
0A:A00E 00000000              +26 
0A:A010 0401                  +26 
0A:A011 00000000              +26 
0A:A013 0000                  +26 
0A:A014 00000000              +26 
0A:A016 00000000              +26 
0A:A018 00000000              +26 
0A:A01A 0402                  +26 
0A:A01B 00000000              +26 
0A:A01D 0000                  +26 
0A:A01E 00000000              +26 
  :                            27 
0A:A020 0000A02A              +28 ?	$do	TPORTS,tport(?)	port	1023+?	tport(?+1)
0A:A022 00000000              +28 
0A:A024 0400                  +28 
0A:A025 00000000              +28 
0A:A027 0000                  +28 
0A:A028 00000000              +28 
0A:A02A 0000A034              +28 
0A:A02C 00000000              +28 
0A:A02E 0401                  +28 
0A:A02F 00000000              +28 
0A:A031 0000                  +28 
0A:A032 00000000              +28 
0A:A034 00000000              +28 
0A:A036 00000000              +28 
0A:A038 0402                  +28 
0A:A039 00000000              +28 
0A:A03B 0000                  +28 
0A:A03C 00000000              +28 
  :                            29 
*EOF*
:$(0A):A000:A03E 


</pre>

<b>$do</b> can be cascaded

<pre>

	$include	coldfire.def

.text	$equ	0

$(.text:524288,pc)

;	translate a 32-bit unsigned integer in d0 to 12 decimal digits in d0:d1:d2 quickly
;	three * 4-byte blocks are returned in registers without editing or truncation
;	this routine may be called from others which action sign / edit / store
;	the high order two digits of the 12 are guaranteed "00"

i2string
	divu.w	#10000, d0
	moveq	#0, d1				; high-order half must be zero
	move.w	d0, d1				; quotient of first divide may be > 10000
	divu.w	#10000, d1
	swap	d0				; remainder to ls half d0
	move.l	(table, pc, d0.w*4), d2		; low-order 4 digits
	move.l	(table, pc, d1.w*4), d0 	; high-order 4 digits
	swap	d1				; remainder to ls half d1
	move.l	(table, pc, d1.w*4), d1		; 5th..8th digits
	rts

table
	$list	0
thousands	$do	10,|
hundreds	$do	10,|
tens		$do	10,|
units		$do	10,	'0'+thousands-1, '0'+hundreds-1, '0'+tens-1, '0'+units-1L



</pre>



<h2>5.2: Structured Data and Structured Code Name Spaces</h2>

<h3>5.2.1: Word-Aligned Structures $TREE / $BRANCH..$ROOT</h3>

<h4>5.2.1.1: Simple Structures $TREE..$ROOT</h4>

<p>
$TREE is used to structure a name space containing data or code.

<p>
The structure is ended with $ROOT. The tree must 
have a label:
<pre>

name    $TREE
datum1	.
datum2	.
	$ROOT

</pre>
<p>
$TREE may be inside a $PROC macro or not. If a $TREE is inside a
$PROC, the label of the $TREE may be the inherited label from
the macro call line, for example
<pre>

p       $proc
species $name
*       $tree
many    $do     p(),branch(many)   $res    4
	$root
	$end

</pre>


<p>
$TREE..$ROOT structures may be nested to depth 8.
Other examples can be found in Section
8.54: $TREE Directive.


<h4>5.2.1.2: Overlaid Structures $BRANCH..$ROOT</h4>


<p>
Structures declared with $BRANCH instead of $TREE start from
the same storage address. Values may freely be declared. The later
declared values load last:
<pre>

MASMX 7r2
3/ast.msm
*EOF*
  :                            1        $word   32
  :                            2 
  :                            3 $(4:040000)
  :                            4 
  :                            5 ast1   $branch
  :                            6 axil   $res    1
  :                            7 twig   $res    1
  :                            8 x      $do     12,leaf(x)      $res    1
04:0004000E 11111111          +9        +       011111111
  :                            10       $root
  :                            11 
  :                            12 ast2  $branch
  :                            13 x     $do     6,blossom(x)    $res    1
04:00040006 22222222          +14       +       022222222
  :                            15       $root
*EOF*

......

AST1=$04:00040000
AST1:AXIL=$04:00040000
AST1:TWIG=$04:00040001
AST1:LEAF(1)=$04:00040002
AST1:LEAF(2)=$04:00040003
AST1:LEAF(3)=$04:00040004
AST1:LEAF(4)=$04:00040005
AST1:LEAF(5)=$04:00040006
AST1:LEAF(6)=$04:00040007
AST1:LEAF(7)=$04:00040008
AST1:LEAF(8)=$04:00040009
AST1:LEAF(9)=$04:0004000A
AST1:LEAF(10)=$04:0004000B
AST1:LEAF(11)=$04:0004000C
AST1:LEAF(12)=$04:0004000D
AST2=$04:00040000
AST2:BLOSSOM(1)=$04:00040000
AST2:BLOSSOM(2)=$04:00040001
AST2:BLOSSOM(3)=$04:00040002
AST2:BLOSSOM(4)=$04:00040003
AST2:BLOSSOM(5)=$04:00040004
AST2:BLOSSOM(6)=$04:00040005
X=00000006
ast.msm=0<00000003
:$(04):00040000:0004000F 
ast.msm: object code 76 bytes: 0 errors: 0 undefined labels


</pre>
<p>
Pointer-based structures may be branched in the same way:
<pre>

$ masmx -lnkx transport
MASMX 7r3
3/transport.msm
*EOF*
  :                            1 	$word	16
  :                            2 	$quantum	8
  :                            3 	$awidth	32
  :                            4 
  :                            5 p	$proc
  :                            6 udp_datagram* $name
  :                            7 sourcep	+	p(1,1)
  :                            8 destp   +       p(1,2)
  :                            9 length  +       p(1,3)
  :                            10 checksum +      p(1,4)
  :                            11 data
  :                            12 	$end
  :                            13 
  :                            14 p	$proc
  :                            15 tcp_segment*	$name
  :                            16 sourcep	+	p(1,1)
  :                            17 destp	+	p(1,2)
  :                            18 sequence +	0:d
  :                            19 ack	+	0:d
  :                            20 hl_code	+	0
  :                            21 window	+	0
  :                            22 checksum +	0
  :                            23 urgent	+	0
  :                            24 data
  :                            25 	$end
  :                            26 
  :                            27 pointer_register $equ	15
  :                            28 
  :                            29 $(67:,pointer_register)
  :                            30 
  :                            31 user_datagram	$branch
  :                            32 		udp_datagram
  :                            33 		$root
  :                            34 
  :                            35 tcp_segmentP	$branch
  :                            36 		tcp_segment
  :                            37 		$root
  :                            38 
*EOF*
udp_datagram=:N129:P:0:0000
tcp_segment=:N129:P:0:0000
pointer_register=000F
user_datagram=$43:00000000,0000000F
user_datagram:sourcep=$43:00000000,0000000F
user_datagram:destp=$43:00000002,0000000F
user_datagram:length=$43:00000004,0000000F
user_datagram:checksum=$43:00000006,0000000F
user_datagram:data=$43:00000008,0000000F
tcp_segmentP=$43:00000000,0000000F
tcp_segmentP:sourcep=$43:00000000,0000000F
tcp_segmentP:destp=$43:00000002,0000000F
tcp_segmentP:sequence=$43:00000004,0000000F
tcp_segmentP:ack=$43:00000008,0000000F
tcp_segmentP:hl_code=$43:0000000C,0000000F
tcp_segmentP:window=$43:0000000E,0000000F
tcp_segmentP:checksum=$43:00000010,0000000F
tcp_segmentP:urgent=$43:00000012,0000000F
tcp_segmentP:data=$43:00000014,0000000F
transport.msm=0<00000003
:$(43):00000000:00000014 


</pre>

<h4>5.2.1.4: Structured Code Name Spaces</h4>

<b>$tree..$root</b> construct may be used to compartment the local names
of code routines in the manner of block-structured languages
<pre>

Tim-Coxs-MacBook:test.msm timcox$ masmx -lnkx routines
MASMX 7r3
3/routines.msm
CONT_CHAR=|
LTERM=;
STERM=.
*EOF*
  :                            1 	$path		../smaragd.68k
  :                            4 	$list
  :                            5 	$path
  :                            6 
  :                            7 .data	$equ	5
  :                            8 .text	$equ	0
  :                            9 
  :                            10 $(.data:0x5000)
  :                            11 $(.text:16384)
  :                            12 
  :                            13 routineA	$tree
  :                            14 $(.data)
05:00005000 001E              +15 counter	+	30
05:00005002 0000A000          +16 pointer	+	0x0a000L
  :                            17 $(.text)
00:00004000 30385000          +18 	move.w	counter, d0
00:00004004 20785002          +19 	movea	pointer, a0
  :                            20 
  :                            21 	;
  :                            22 	;
00:00004008 4E75              +23 	rts
  :                            24 	$root
  :                            25 
  :                            26 routineB	$tree
  :                            27 $(.data)
05:00005006 003C              +28 counter	+	60
05:00005008 0000B000          +29 pointer	+	0x0b000L
  :                            30 $(.text)
00:0000400A 30385006          +31 	move.w	counter, d0
00:0000400E 20785008          +32 	movea	pointer, a0
  :                            33 
  :                            34 	;
  :                            35 	;
00:00004012 4E75              +36 	rts
  :                            37 	$root
  :                            38 
*EOF*
.data=0005
.text=0000
routineA=$00:4000
routineA:counter=$05:5000
routineA:pointer=$05:5002
routineB=$00:400A
routineB:counter=$05:5006
routineB:pointer=$05:5008
../smaragd.68k/coldfire.def=1<00000005
routines.msm=0<00000003
:$(00):00004000:00004014 :$(05):00005000:0000500C 



</pre>

<h3>5.2.2: Bit-Aligned Structures</h3>

<h4>5.2.2.1: Bit-Aligned Data $record..$root</h4>

<b>$record</b>..<b>$root</b> structures are bit aligned

<p>
<b>$record</b> structures may be more or less complex. Fields which are not accessed
do not need a label. All fields need a length. <b>$record</b> requires a label

<p>
<b>$record</b> shares the structured name plan with <b>$tree</b> and <b>$branch</b>,
and likewise ends with </b>$root

<p>
Outermost <b>$record</b> starts at a word boundary and nested <b>$record</b>s
start at the bit location which has been reached

<p>
Any initial values are spaced arguments of the <b>$record</b> lines

<p>
An argument on a <b>$record</b> line is not a bit length but a data value for a contained field

<p>
<b>$record</b> labels acquire a group length attribute as seen below

<p>
Nested <b>$record</b>s have their own arguments. Containing <b>$record</b>s place
initial values in their own fields and not in the fields of nested <b>$records</b>

<p>
It is seen here that initial value 10 is assembled after embedded <b>inner $record</b> 

<pre>

$ masmx record.msm -lnkx
MASMX 7r3
3/record.msm
*EOF*
  :                            1 $(3:03000)
  :                            2 
  :                            3 	$word		16
  :                            4 
  :                            5 outermost $record			'o' 1 1 1 10
  :                            6 first_field	9
  :                            7 ?	$do	3,field(?)	9
  :                            8 inner	$record				6 4 6 4
  :                            9 ?	$do	4,field(?)	3
  :                            10 	$root
  :                            11 trailing 12
03:3000 378040201D3400A0      +12 	$root
  :                            13 
*EOF*
outermost=$03:3000,,,,003C
outermost:first_field=$03:3000,,,,0009
outermost:field(1)=$03:3000,,,0009,0009
outermost:field(2)=$03:3001,,,0002,0009
outermost:field(3)=$03:3001,,,000B,0009
outermost:inner=$03:3002,,,0004,000C
outermost:inner:field(1)=$03:3002,,,0004,0003
outermost:inner:field(2)=$03:3002,,,0007,0003
outermost:inner:field(3)=$03:3002,,,000A,0003
outermost:inner:field(4)=$03:3002,,,000D,0003
outermost:trailing=$03:3003,,,,000C
?=$03:0004
record.msm=0<0003
:$(03):3000:3004 


</pre>

<p>
Bit-aligned structures may be simple or overlaid in memory to any extent
and may be nested

<p>
masmx labels each field with address, bit offset, bit size and signed attribute
plus optionally base-displacement pointer register.<br>The attributes of each field
are held in one label of type <b>$equf</b>

<p>
$record does not have separate template and instance steps. Describing a $record layout is also describing an instance

<p>
For this reason $record may be found within a $proc macro

<p>
$proc macros can assign actual arguments to any nested $record in their scope



<h4>5.2.2.2: Macro Code Access to Bit-Aligned Fields and Groups</h4>


<p>
masmx labelling allows macro language specific to the target to read and
write bit-aligned fields

<p>
Here ColdFire-specific macro language retrieves fields from an inventory
<pre>

$ masmx betaille -lnk
MASMX 7r3
3/betaille.msm
CONT_CHAR=|
LTERM=;
STERM=.
*EOF*
  :                            1 	$path		../smaragd.68k
  :                            2: 	$include	coldfire.def
  :                            3: 	$include	record_x.def
  :                            4 	$path
  :                            5 
  :                            6 p	$proc
  :                            7 hameau*	$name
  :                            8 *	$record	p(1, 2), p(1, 3) p(1, 4)
  :                            9 oies	18
  :                            10 anes	12
  :                            11 moutons	16
  :                            12 	$root
  :                            13 	$end
  :                            14 
  :                            15 p	$proc
  :                            16 commune* $name
  :                            17 *	$record
  :                            18 ?	$do	p(),"p(?, 1)"	hameau	p(?)
  :                            19  	$root
  :                            20 	$end
  :                            21 
  :                            22 
  :                            23 $(5:050000)
  :                            24 communes $record
                                Vaux_les_Pres	commune	les_Cotards, 80, 5, 248	|
                                			le_Charmelot, 660, 24, 79 |
  :                            27 			village, 28, 2, 5
  :                            28 
                                Villers_Buzon	commune	centre, 10, 1, 30	|
05:00005000 0014001403E00294018004F000700080014000A001001E00
                              +30 			Combe_au_Loup, 15,,315
05:00005018 03C00004EC00      +31 	$root
  :                            32 
  :                            33 $(0:16384)
  :                            34 
00:00004000 2038501A          +35 	retrieve	communes.Villers_Buzon.Combe_au_Loup.moutons
00:00004004 E088              +35 
00:00004006 E488              +35 
00:00004008 32385008          +36 	retrieves	communes.Vaux_les_Pres.le_Charmelot.anes	d1
00:0000400C 4841              +36 
00:0000400E 323C0014          +36 
00:00004012 E2A1              +36 
  :                            37 
00:00004014 24385016          +38 	lretrieve	communes.Villers_Buzon.Combe_au_Loup.oies	d2
00:00004018 E18A              +38 
00:0000401A E08A              +38 
00:0000401C EC8A              +38 
00:0000401E 26385010          +39 	lretrieve	communes.Villers_Buzon.centre.oies	d3
00:00004022 E18B              +39 
00:00004024 E58B              +39 
00:00004026 E08B              +39 
00:00004028 EC8B              +39 
*EOF*
:$(00):00004000:0000402A :$(05):00005000:0000501E 


</pre>


<h4>5.2.2.3: Bit-Aligned Structure Overlay and Overload: $RECORD,$BRANCH</h4>

<b>$record</b> structures can may be overlaid or redefined with the addition of
<b>,$branch</b> subfunction. The resulting unions are at bit-position precision.
<pre>

$ masmx mfeuille -lnk
MASMX 7r3
3/mfeuille.msm
CONT_CHAR=|
LTERM=;
STERM=.
*EOF*
  :                            1 	$path		../smaragd.68k
  :                            2: 	$include	coldfire.def
  :                            3: 	$include	record_x.def
  :                            4 	$path
  :                            5 
  :                            6 $(5:050000)
  :                            7 
  :                            8 layer4  $record,$branch         10 11 12 13 14 15
05:00005000 ABCDEF000000000000000000000000000000000000000000
                              +9 ?       $do     60,quartet(?)   4
  :                            10         $root
  :                            11 layer5  $record,$branch
  :                            12 ?       $do     80,quintet(?)   5s
  :                            13         $root
  :                            14 layer6  $record,$branch
  :                            15 ?       $do     40,sextet(?)    6
  :                            16 	$root
  :                            17 
  :                            18 $(64:65536)
  :                            19 
40:00010000 30385000          +20 	retrieve	layer5.quintet(2)	; substring is .
40:00010004 4840              +20 
40:00010006 EB88              +20 
40:00010008 303C001B          +20 
40:0001000C E0A0              +20 
40:0001000E 1438501D          +21 	retrieve	layer6.sextet(40)	d2
40:00010012 02820000003F      +21 
*EOF*
:$(05):00005000:00005032 :$(40):00010000:00010018 


</pre>
Initial values in overlaid locations may be overloaded. However masmx load code
is in words. Overloads on a storage word are not merged

<pre>

$ masmx -lnkx moreover.msm 
MASMX 7r3
3/moreover.msm
CONT_CHAR=|
LTERM=;
STERM=.
*EOF*
  :                            1 	$path		../smaragd.68k
  :                            5 	$list
  :                            6 	$path
  :                            7 
  :                            8 
  :                            9 $(3:03000)
  :                            10 first	$record,$branch	1 2 3
  :                            11 one	4
  :                            12 two	4
  :                            13 three	4
  :                            14 "O'Leary" 20
03:00000600 12300000          +15 	$root
  :                            16 second	$record,$branch
  :                            17 fill	4
  :                            18 second1	$record,$branch	4 5 6
  :                            19 one	4s
  :                            20 two	4
  :                            21 three	4
03:00000600 0456              +22 	$root
  :                            23 second2	$record,$branch	7 8
  :                            24 one	4
  :                            25 two	4
03:00000600 0780              +26 	$root
  :                            27 	$root
  :                            28 third	$record,$branch	63
  :                            29 longways 18
03:00000600 000FC000          +30 	$root
  :                            31 
  :                            32 new	$record	10 6
  :                            33 discriminator 4
  :                            34 first	$record,$branch	"carpets"
  :                            35 text	48
03:00000604 A636172706574000  +36 	$root
  :                            37 second	$record,$branch	10 11 12 13 14 15
  :                            38 ?	$do	9,quartet(?)	4
03:00000604 0ABCDEF00000      +39 	$root
  :                            40 marker	4
03:0000060A 0600              +41 	$root
  :                            42 
03:0000060C 400001E00000000000000000
                              +43 sum	1.75
  :                            44 	
  :                            45 $(0:64)
00:00000040 10380601          +46 	retrieve	first.three
00:00000044 E888              +46 
00:00000046 02800000000F      +46 
00:0000004C 12380600          +47 	retrieve	second.fill		d1
00:00000050 E889              +47 
00:00000052 02810000000F      +47 
00:00000058 34380600          +48 	retrieve	second.second1.one	d2
00:0000005C 4842              +48 
00:0000005E E98A              +48 
00:00000060 343C001C          +48 
00:00000064 E4A2              +48 
00:00000066 16380601          +49 	retrieve	second.second1.three	d3
00:0000006A 02830000000F      +49 
00:00000070 38380600          +50 	retrieve	second.second2		d4
00:00000074 E88C              +50 
00:00000076 0284000000FF      +50 
00:0000007C 3A380606          +51 	retrieves	new.second.quartet(5)	d5
00:00000080 4845              +51 
00:00000082 E98D              +51 
00:00000084 3A3C001C          +51 
00:00000088 EAA5              +51 
  :                            52 
*EOF*
first=$03:00000600,,,,00000020
first:one=$03:00000600,,,,00000004
first:two=$03:00000600,,,00000004,00000004
first:three=$03:00000600,,,00000008,00000004
first:O'Leary=$03:00000600,,,0000000C,00000014
second=$03:00000600,,,,00000010
second:fill=$03:00000600,,,,00000004
second:second1=$03:00000600,,,00000004,0000000C
second:second1:one=$03:00000600,,,00000004,80000004
second:second1:two=$03:00000600,,,00000008,00000004
second:second1:three=$03:00000600,,,0000000C,00000004
second:second2=$03:00000600,,,00000004,00000008
second:second2:one=$03:00000600,,,00000004,00000004
second:second2:two=$03:00000600,,,00000008,00000004
third=$03:00000600,,,,00000012
third:longways=$03:00000600,,,,00000012
new=$03:00000604,,,,00000038
new:discriminator=$03:00000604,,,,00000004
new:first=$03:00000604,,,00000004,00000030
new:first:text=$03:00000604,,,00000004,00000030
new:second=$03:00000604,,,00000004,00000024
new:second:quartet(1)=$03:00000604,,,00000004,00000004
new:second:quartet(2)=$03:00000604,,,00000008,00000004
new:second:quartet(3)=$03:00000604,,,0000000C,00000004
new:second:quartet(4)=$03:00000606,,,,00000004
new:second:quartet(5)=$03:00000606,,,00000004,00000004
new:second:quartet(6)=$03:00000606,,,00000008,00000004
new:second:quartet(7)=$03:00000606,,,0000000C,00000004
new:second:quartet(8)=$03:00000608,,,,00000004
new:second:quartet(9)=$03:00000608,,,00000004,00000004
new:marker=$03:0000060A,,,00000004,00000004
?=0009
sum=$03:060C
../smaragd.68k/record_x.def=1<00000005
../smaragd.68k/coldfire.def=1<00000005
moreover.msm=0<00000003
:$(00):00000040:0000008A :$(03):00000600:00000618 


</pre>

<h1>6: Run-Time Algorithm Plotter</h1>

<p>
Assemblers mostly resolve expressions whose tokens are all known at assembly time

<p>
<b>$xqt_fp</b> and <b>$xqt_i</b> directives code an instruction plan in a<br>
compiler-like fashion however, to solve expressions involving run-time variables<br>
first resolving subexpressions whose tokens are known at assembly time

<p>
These instruction steps are planned with the support of target-specific macros with<br>
fixed call-names known to masmx 


<h2>6.1: Run-Time Integer Algorithm Plotter $xqt_i</h2>

<b>$xqt_i</b> processes integers and can resolve all expression steps
between constants at assembly time,<br> planning the fewest possible instructions
for run time calculation

<p>
In this example the subexpression right of the OR operator <b>++</b> has been
resolved at assembly time, but left of <b>++</b> a multiply, two adds and a
shift must take place at runtime

<pre>

$ masmx -lnk boolean
MASMX 7r3
3/boolean.msm
CONT_CHAR=|
LTERM=;
STERM=.
  :                            1 	$path		../
  :                            2: 	$include	smaragd.68k/coldfire.def
  :                            3: 	$include	smaragd.68k/express.def
  :                            4 	$path
  :                            5: 	$include	espresso.def
  :                            6 
  :                            7 $(3:03000)
03:00000600 0001              +8 one	1
03:00000602 00000002          +9 two	2d
03:00000606 00000003          +10 three	3d
  :                            11 $(0:32768)
00:00008000 30380600          +12 	$xqt_i,#	two+one w*4+three*/16++12*/20
00:00008004 C1FC0004          +12 
00:00008008 D0B80602          +12 
00:0000800C D0B80606          +12 
00:00008010 E188              +12 
00:00008012 E188              +12 
00:00008014 80BC00C00000      +12 
00:0000801A 3002              +13 	$xqt_i		d2 w+d3+d4
00:0000801C D083              +13 
00:0000801E D084              +13 
  :                            14 	$do	$<256,$(0:256)
  :                            15 	$end
:$(00):00008000:00008020 :$(03):00000600:0000060A 


</pre>

Some of the identifiers in this these expressions are followed with space then <b>w</b><br>
This informs macro language that the variable input to the algorithm is a ColdFire word
of 16 bits where inputs are otherwise 32 bits

<p>
One of the <b>$xqt_i</b> directives is followed with a subcommand <b>,#</b>

<p>
This floats the symbol <b>#</b> onto the front of the constant sequences <b>16</b> and <b>12*/20</b>

<p>
Directive <b>$xqt_i</b> surrounds constant sequences with parentheses, so that target definitions<br>
which use automatic literals would generate the literals (16) and (12*/20)

<p>
Automatic literals are not opted in <b>coldfire.def</b> because this would disrupt the many parenthesised
operand expressions in accepted source syntax. For ColdFire integer arithmetic furthermore, literals
are unnecessary because integer immediate operands indicated with prefix <b>#</b> are available

<p>
The floated <b>#</b> yields in the two illustrated cases these two immediate operand clauses
<pre>

	#(16)
	#(12*/20)

</pre>
Target specific macros required for $xqt_i and $xqt_fp have the names called from this target-independent
outline scheme

<pre>

$ cat espresso.def

p	$proc
"$i_load"*	$name
	LOAD	p()
	$end

p	$proc
"$i_load_negative"*	$name
	LOAD_NEGATIVE	p()
	$end

p	$proc
"$i_testequal"*	$name
	TEST_EQUAL	p()
	$end

p	$proc
"$i_testunequal"*	$name
	TEST_NE	p()
	$end

p	$proc
"$i_testgreater"*	$name
	TEST_GREATER	p()
	$end

p	$proc
"$i_testless"*	$name
	TEST_LESS	p()
	$end

p	$proc
"$i_shift"*	$name
	SHIFT	p()
	$end

p	$proc
"$i_shift_right"*	$name
	SHIFT_RIGHT	p()
	$end

p	$proc
"$i_or"*	$name
	OR	p()
	$end

p	$proc
"$i_and"*	$name
	AND	p()
	$end

p	$proc
"$i_xor"*	$name
	XOR	p()
	$end

p	$proc
"$i_add"*	$name
	ADD	p()
	$end

p	$proc
"$i_subtract"*	$name
	SUBTRACT	p()
	$end

p	$proc
"$i_multiply"*	$name
	MULTIPLY	p()
	$end

p	$proc
"$i_divide"*	$name
	DIVIDE	p()
	$end

p	$proc
"$i_covered_quotient"*	$name
	DIVIDE_ROUNDED	p()
	$end

p	$proc
"$i_remainder"*	$name
	MODULO	p()
	$end

p	$proc
"$i_reserve"*	$name
	PUSH
	$end

p	$proc
"$i_reverse"*	$name
	REVERSE
	$end

"$i_retrieve_testequal"*	$proc
	TEST_EQUAL	STACK_TOP
	POP
	$end

"$i_retrieve_testunequal"*	$proc
	TEST_NE	STACK_TOP
	POP
	$end

"$i_retrieve_testgreater"*	$proc
	TEST_GREATER	STACK_TOP
	POP
	$end

"$i_retrieve_testless"*	$proc
	TEST_LESS	STACK_TOP
	POP
	$end

"$i_retrieve_shift"*	$proc
	SHIFT	STACK_TOP
	POP
	$end

"$i_retrieve_shift_right"*	$proc
	SHIFT_RIGHT	STACK_TOP
	POP
	$end

"$i_retrieve_or"*	$proc
	OR	STACK_TOP
	POP
	$end

"$i_retrieve_and"*	$proc
	AND	STACK_TOP
	POP
	$end

"$i_retrieve_xor"*	$proc
	XOR	STACK_TOP
	POP
	$end

"$i_retrieve_add"*	$proc
	ADD	STACK_TOP
	POP
	$end

"$i_retrieve_subtract"*	$proc
	SUBTRACT	STACK_TOP
	POP
	$end

"$i_retrieve_multiply"*	$proc
	MULTIPLY	STACK_TOP
	POP
	$end

"$i_retrieve_divide"*	$proc
	DIVIDE	STACK_TOP
	POP
	$end

"$i_retrieve_covered_quotient"*	$proc
	DIVIDE_ROUNDED	STACK_TOP
	POP
	$end

"$i_retrieve_remainder"*	$proc
	MODULO	STACK_TOP
	POP
	$end

p       $proc
"$x_load"* $name
	FP_LOAD		p()
	$end

p       $proc
"$x_load_negative"* $name
	FP_LOAD_NEGATIVE p()
	$end

p	$proc
"$x_add"*	$name
	FP_ADD		p()
	$end

p       $proc
"$x_subtract"* $name
	FP_SUBTRACT	p()
	$end

p       $proc
"$x_multiply"* $name
	FP_MULTIPLY	p()
	$end

p       $proc
"$x_divide"* $name
	FP_DIVIDE	p()
	$end

"$x_reserve"* $proc
	FPUSH
	$end

p	$proc
"$x_reverse"* $name
	FP_REVERSE
	$end

"$x_retrieve_add"* $proc
        FP_ADD		FP_STACK_TOP
        FPOP
        $end

"$x_retrieve_subtract"* $proc
        FP_SUBTRACT	FP_STACK_TOP
        FPOP
        $end

"$x_retrieve_multiply"* $proc
        FP_MULTIPLY	FP_STACK_TOP
        FPOP
        $end

"$x_retrieve_divide"* $proc
	FP_DIVIDE	FP_STACK_TOP
	FPOP
	$end

</pre>

<p>
This outline scheme can be included directly in conjunction with simple $proc macros which populate these names
with instruction code which updates a designated result register
<pre>

	LOAD		LOAD_NEGATIVE	TEST_EQUAL	TEST_NE		TEST_GREATER	TEST_LESS
	SHIFT		SHIFT_RIGHT	OR		AND		XOR
	ADD		SUBTRACT	MULTIPY		DIVIDE		DIVIDE_ROUNDED	MODULO

</pre>
These macros apply the given argument to a designated result register. Instructions in the four TEST_ macros have<br>
a runtime result of one for true and zero for untrue

<p>
The macro
<pre>

	REVERSE

</pre>
negates a accumulation in the result register to cover cases like
<pre>

	-(X*Y-Z)

</pre>
which may derive advantage from a different instruction sequence from the simple LOAD_NEGATIVE
<p>
The macro
<pre>

	PUSH

</pre>
saves the result register either in a real stack or in a list of registers<br>
managed at assembly time with macro text

<p>
The function
<pre>

	STACK_TOP

</pre>
is the most recent stored value in the stack or save register list

<p>
The macro
<pre>

	POP

</pre>
for some targets needs no separate instructions and is void. POP is however
separated in case the stacked value must be cleared,<br>
because STACK_TOP may be  a function, and function macros in masmx may not generate code.

<p>
Interim results may be in detail saved, retrieved and cleared a number of ways according
to target architecture, for example
<pre>

;		In ColdFire saves/retrieves only PUSH macro generates an instruction
;		LOAD and arithmetic macros must distinguish register / storage / immediate argument

PUSH*		$proc			; ColdFire
		move.l		d0, -(a7)
		$end

STACK_TOP*	$equf		(a7)+	; ColdFire
POP		$equ,$directive	$nop	; ColdFire

.		____________________________________

#		in PowerPC saves/retrieves, only PUSH macro generates an instruction
#		LOAD and arithmetic macros must distinguish register / storage / immediate argument
#		arithmetic macros must load storage arguments to a GPR designated as threshold

LISTP		$set	1		# PPC32
SAVE(1)		$equ	r20
SAVE(2)		$equ	r21
SAVE(3)		$equ	r22

PUSH*		$proc			# PPC32
		$do	LISTP>3,	$flag	assign more save registers
		mr	r0,SAVE(LISTP)
LISTP*		$set	LISTP+1
		$end

STACK_TOP*	$func
		$return	SAVE(LISTP-1)	# PPC32
		$end

POP*		$proc			# PPC32
LISTP**		$set	LISTP-1
		$end	


</pre>

<h2>6.2: Run-Time Floating Algorithm Plotter</h2>

<p>
<b>$xqt_fp</b> includes constants as well as variables in expressions,
but does not currently attempt assembly-time calculation of expression
steps between floating constants

<p>
<b>$xqt_fp</b> directive scans an expression and calls macro code to write an
instruction plan. The tokens which are constants appear as literals at the foot
of the program

<p>
<b>$xqt_fp</b> concerns four-function arithmetic only

<p>
<b>$xqt_fp</b> is demonstrated here with ColdFire architecture

<p>
The first simple algorithm has five inputs and is executed in five instructions, including
operand acquisition from storage. Instructions follow masmx precedence order. Three of the
five tokens are identifiers whose content is only known at runtime

<p>
The second algorith has a mixture of register, storage and pointer inputs
<pre>

$ ~/masmx -lnky r2xample.msm 
MASMX 7r3
3/r2xample.msm
CONT_CHAR=|
LTERM=;
STERM=.
*EOF*
  :                            1 
  :                            2 	$path		../smaragd.68k
  :                            3: 	$include	coldfire.def
  :                            4: 	$include	express.def
  :                            5: 	$include	fpxpress.def
  :                            6 	$path
  :                            7: 	$include	espresso.def
  :                            8: 	$include	ieee754.def
  :                            9 
  :                            10 $(4:16384,a5/$literal)
  :                            11 
  :                            12 one	$res	8
  :                            13 two	$res	8
  :                            14 three	$res	8
  :                            15 
  :                            16 westward $res	2
  :                            17 ho	$res	2
  :                            18 
  :                            19 $(5:16384+1024)
  :                            20 rastore	$res	8
  :                            21 rapointer $res	4
  :                            22 
  :                            23 $(1:131072,pc/$azlit)
  :                            24 
  :                            25 fp_routine
01:00000000 4BF84000          +26 	lea		$a(one), a5
01:00000004 F22D54000000      +27 	$xqt_fp,$ieee64	one*1.75*+307*two/3.0*-307-three
01:0000000A F23A54230064      +27 
01:00000010 F22D54230008      +27 
01:00000016 F23A54200060      +27 
01:0000001C F22D54280010      +27 
  :                            28 
01:00000022 F21B5400          +29 	$xqt_fp		d5+fp6+a2@+"-(a4)"+"a3@+"*(*rapointer)/rastore
01:00000026 20784408          +29 
01:0000002A F2105423          +29 
01:0000002E 41F84400          +29 
01:00000032 F2105420          +29 
01:00000036 F2055422          +29 
01:0000003A F2001822          +29 
01:0000003E F2125422          +29 
01:00000042 F2245422          +29 
  :                            30 
01:00000046 F22D5000001A      +31 	$xqt_fp		westward w+ho w*(*rapointer s)
01:0000004C 20784408          +31 
01:00000050 F2104423          +31 
01:00000054 F22D50220018      +31 
01:0000005A F23A54000024      +32 	$xqt_fp,$ieee64	(westward w)+(1.5 s)*(*rapointer s)
01:00000060 20784408          +32 
01:00000064 F2104423          +32 
01:00000068 F22D50220018      +32 
01:0000006E 4E75              +33 	rts
*EOF*
01:00000070+7FB8EBBB5516E5AD
01:00000078+004AF72442612915
01:00000080+3FC00000
:$(01):00020000:00020084 :$(04):00004000:0000401C :$(05):00004400:0000440C 


</pre>

The third algorithm at line 31 has ColdFire syntax flags indicating that the inputs
are respectively ColdFire word (16-bit integer) and and single (32-bit float). ColdFire
floating instructions operate 64-bit float and carry out conversions on operand acquisition.

<p>
masmx expression syntax allows attribute text to follow a token before the next operator.
The token name or value is scanned until space or comma

<p>
Macro language has been written to recognise a pointer by unary *

<p>
To avoid confusion with multiply operator, the pointer reference is shielded in parentheses

<p>
The fourth algorithm at line 34 has any tokens with attribute [ b w l s d ] in parentheses,
because this may be easier to read

<p>
<b>xqt_fp</b> has already placed all constants in the expression within parentheses.
Some target definitions use the parenthesised arguments directly as automatic literals,
but this is not appropriate for ColdFire, because accepted assembly syntax has many
operands which are not literals in parentheses. Automatic literals are not opted for
ColdFire, but <b>xqt_fp</b> prepends a literal pool tag or a function macro name from
its subfunction field to constants

<p>
A function name $ieee64 will be prepended to any constants on line 32. ColdFire floating
instructions have neither immediate operands, nor operands in directly addressed storage

<p>
Floating operands are possible at an address offset from a0..a7 or from the program counter
at (instruction + 2)

<p>
Two 64-bit ieee754 floating numbers can be seen at address (fp_routine + 0x0070).
They are the constants 1.75*+307 and 3.0*-307 in the algorithm at line 27, where
they are referenced aa (instruction @ 0x000A + 2 + 0x0064) and
(instruction @ 0x0016 + 2 + 0x0060)

<p>
A 32-bit ieee754 floating number can be seen at address (fp_routine + 0x0080).
That is the constant 1.5 in the algorithm at line 32, where it is referenced as
(instruction @ 0x005A + 2 + 0x0024)

<p>
ColdFire integer/floating conversions carried out within the floating instruction
are clearly there to be used and much faster than any conversion routines in software

<p>
masmx and <b>$xqt_fp</b> support all architectures. The inclusion of conversion
routine calls in floating algorithms is supported in the same way as the indicative
flags like [ b w l s d ] 

<p>
It is not easy to have an integer longer that 32 bits on ColdFire, and even harder
to convert it to ieee754 64-bit. This may be one reason why ColdFire can add 8-bit
integers to 64-bit floating numbers. The ASCII string can be converted to floating
without an interim conversion to long long integer. That does not of course have
a direct hardware assist, but masmx can insert a conversion subroutine call into the stream
of algorithm imstructions
<pre>

$ masmx -lnky r3xample.msm
MASMX 7r3
3/r3xample.msm
CONT_CHAR=|
LTERM=;
STERM=.
*EOF*
  :                            1 	$path		../smaragd.68k
  :                            2: 	$include	coldfire.def
  :                            3: 	$include	express.def
  :                            4: 	$include	fpxpress.def
  :                            5 	$path
  :                            6: 	$include	espresso.def
  :                            7: 	$include	ieee754.def
  :                            8 
  :                            9 $(4:16384,a5/$literal)
  :                            10 
  :                            11 one	$res	8
  :                            12 two	$res	8
  :                            13 three	$res	8
  :                            14 
  :                            15 westward $res	2
  :                            16 ho	$res	2
  :                            17 
  :                            18 $(5:16384+1024)
  :                            19 rastore	$res	8
  :                            20 rapointer $res	4
  :                            21 
  :                            22 $(1:131072,pc/$azlit)
01:00000000 3A7C4000          +23 	movea.w	#$a(one), a5
  :                            24 
01:00000004 F22D54000010      +25 	$xqt_fp	one-two+three*(*rapointer floating_string)
01:0000000A 20784408          +25 
[+0000]20
01:0000000E 4EB900000000      +25 
01:00000014 F2000423          +25 
01:00000018 F22D54220000      +25 
01:0000001E F22D54280008      +25 
  :                            26 
*EOF*
:$(01):00020000:00020024 :$(04):00004000:0000401C :$(05):00004400:0000440C 


</pre>
A string pointer is associated with a macro floating_string, which will call a
subroutine conversion and presents the resulting 64-bit floating value to the
algorithm instruction stream. This is how most conversions are carried out on
architectures with fewer hardware assists than ColdFire

<p>
The external subroutine call is seen at location 0x000E of the instruction stream
and has this appearance in text-encoded binary output
<pre>

$01:00020000
3A7C4000 F22D54000010 20784408 [0000]20:4EB900000000 F2000423
F22D54220000 F22D54280008
-s2double:[0000]
:$01*00000000:00020000:00020024
:$04*00000000:00004000:0000401C
:$05*00000000:00004400:0000440C

</pre>
The fourth instruction calls external routine s2double. A link
request tuple awaits its address for addition to the instruction
address field bits 31..0

<p>
<b>$xqt_fp</b> and ColdFire-specific macro code organise the call with these
two macros

<pre>

IEEE754_64_ACQUIRE$ $equ 1111

p       $proc
FOP*    $name
"$TYPE" $set    $t(p(1, 1))
"$RING" $set    0
        $do     p()>1,  $do     $t(p(2, 1))=$name,"$RING"       $set    p(2, 1)
        $if     $RING=IEEE754_64_ACQUIRE$
        p(2,1)  p(1)
"$FOP"* $equ,$fp_reg    fp1
        $elseif $t(p(1, 1))=$fp_reg
"$FOP"* $equ,$fp_reg    p(1, 1)
        $elseif $t(p(1, 1))=$d_reg
"$FOP"* $equ,$d_reg     p(1, 1)
        $elseif $t(p(1, 1))=$a_reg
        $flag   sending register may not be a0..a7
        $elseif ($t(p(1, 1))=$a_reg_@)++|
                ($t(p(1, 1))="$a_reg_@+")++|
                ($t(p(1, 1))="$a_reg_@-")
"$FOP"* $equ,$TYPE      p(1, 1)
        $elseif $t(p(1, 1))=127
        $if     p(1, *1)
        move    p(1, 1), a0
        $else
        lea     p(1, 1), a0
        $endif
"$FOP"* $equ,$a_reg_@   a0
        $elseif $inside\p(1, 1)=2
"$FOP"* $equf   $inside\p(1, 1), $base_a\p(1, 1)
        $elseif $itype\p(1, 1)="$a_reg"
"$FOP"* $equf   p(1, 1), $ibase\p(1, 1)
        $elseif $t(p(1, 1))=$equf
"$FOP"* $equf   p(1, 1), p(1, 2)
        $else
"$UP"*  $equf   p()
"$FOP"* $equf   $UP
        $do     $o('V'),        $trace  $FOP
        $do     $o('V'),        $trace  $FOP\2
        $endif
        $end

p       $proc
floating_string* $name  IEEE754_64_ACQUIRE$
        $do     $o('V'),        $note   call s2double
        $if     p(1, *1)
        movea   p(1, 1), a0
        $else
        lea     p(1, 1), a0
        $endif
        jsr     (s2double).l
        $end

</pre>

The first part of the first macro examines

	<blockquote>
	is the attribute label a $name as macros export them?<br><br>

	is the latent value of that name a ring number arbitrarily designated for subroutine conversions?<br><br>

	if so, assemble the macro and expect the 64-bit floating value to return in floating register fp1
	</blockquote>

The macro floating_string places the string pointer in a0 and calls s2double

<p>
s2double is shown among examples of masmx macro-language for ColdFire instruction code at Appendix F.3


<p>
masmx decides whether a token is a self-evident value or a storage reference
by these rules

	<blockquote>
	a field of digits is a value<br><br>
	a label on a line describing storage is a location<br><br>
	a label equated or set to digits is a value<br><br>
	a label equated or set to a storage label or to a location counter is a location<br><br>
	a label equated or set to another label is what that label is<br><br>
	a <b>$equf</b> label is a location<br><br>
	a label with a category 128..255 assigned by the developer is a location, typically a register
	</blockquote>

Therefore a construction
<pre>

bucket	$equ	4096

</pre>
would not cause a storage reference, but an immediate value.

<p>
The construction
<pre>

bucket	$equf	4096

</pre>
would cause a storage reference

<p>
In this assembly <b>FACTOR</b> has been generated as a constant (visible at
the foot of the program) because <b>$equ</b> connected <b>FACTOR</b> to a
number value and not a stored location
<pre>

$ ~/masmx mammoth -lnk
MASMX 7r3
3/mammoth.msm
*EOF*
  :                            1 	$path		../
  :                            2: 	$include	def/rta.def
  :                            3: 	$include	language/stack.def
  :                            4: 	$include	language/fpxpress.def
  :                            5 $(0)
00:000000 B60040              +6 mammoth* $vector	sum
  :                            7 $(3:03000)
03:003000 40000F800000000000000000
                              +8 left	16384*+0
03:003004 7CD38AFBEEFAC15E58C049D8
                              +9 right	1.2*+1200000
  :                            10 
  :                            11 $(0:64)
  :                            12 
  :                            13 FACTOR	$equ	1.875
  :                            14 
                                sum	$head_far	 params(first,	float	;
  :                            16 				second,	float	)
  :                            17 
00:000040 4FF007              +18 	$xqt_fp		-left-right+first+second*FACTOR
00:000041 770100              +18 
00:000042 6F3000              +18 
00:000043 6F3004              +18 
00:000044 67F003              +18 
00:000045 3D0000              +19 	$ret
  :                            20 	$do	$<256,$(0:256)
  :                            21 
*EOF*
00:000100+400001F00000000000000000
:$(00):000000:000104 :$(03):003000:003008 


</pre>


<h1>7: Constructing Program Sections</h1>

<h2>7.1: Absolute Location Counters</h2>
<h3>7.1.1: Simple Absolute Location Counters</h3>

The plainest use of location counter controls has the syntax
<pre>

$(counter_id:value)

</pre>
at the start of the assembly, and later
<pre>

$(counter_id)

</pre>
to switch between the program sections

<p>
If for example location counter zero has been chosen for code,
and location counter one for data:
<pre>

$(0:code_start_address)

	some code

$(1:data_start_address)

	some data

$(0)

	some more code

$(1)

	some more data

</pre>

Sections can be identified by name and all initialized together

<pre>

text	$equ	1
data	$equ	3

$(text:START_OF_TEXT)
$(data:START_OF_DATA)
.	end of header information

.	start of application information
$(data)
.	data declarations

$(text)
.	instructions

$(data)
.	more data

$(text)
.	more instructions

</pre>

A construct
<pre>

$(0:0)

</pre>
means switch to location counter 0 and initialise it 
to absolute unrelocatable 0. This the default environment
beginning of main assembly

<p>
Program sections addressing is initialised
<pre>

$(1:static_base_address)
$(2:strings_base_address/literal_pool_name)

</pre>
Code or data is added to each section
<pre>

$(1)
structure1      structure_macro_name
buffer20        $res    20
$(0)
	load_address    r6, literal_pool_name("Long Text String":10)
	call            copy_routine

</pre>
Sections can be named to match assembly language output from compilers
<pre>

CODE    $equ    0
STATIC  $equ    1
$(CODE:0/STRING_LITERALS)
$(STATIC:32768)
$(STATIC)
buffer...
$(CODE)
Start   load... ,STRING_LITERALS("Text...
	call..
	store  ...,buffer...
$(STATIC)
another_variable..
$(CODE)
	load_address ..,another_variable


</pre>
The explanation of each possible field in a location counter control
is, for absolutely addressed segments:
<pre>

$(id:address:breakpoint,base_register/literal_pool_tag)

</pre>
or
<pre>

$(id:address:*breakpoint,base_register/literal_pool_tag)

</pre>
All fields except id (0..71) may be absent.

<p>
If addresses are absent
<pre>

$(id[,base_register][/literal_pool_tag])

</pre>
then addressing in this segment picks up where it last reached.

<p>
If the base register is specified, labels of locations in the
segment have a tuple base+displacement attribute.


<h3>7.1.2: Breakpointed Location Counters</h3>

Breakpointed location counters concern targets where software assigns
memory blocks dynamically into windows of address space
<p>
<i>breakpoint value</i> in the location counter switch identifies
the load space for which the the current segment is assembling
<pre>

$(id:logical_base_address:<i>breakpoint value</i>)

</pre>

The section identified by location counter may have many segments in
different memory blocks. The segments may share program-visible addresses 

<h4>7.1.2.1 Physical Address Offset</h4>

The breakpointed location counter may be used to describe the absolute
locations of physically-relocated banks.

<p>
A locator with a breakpoint value has the syntax
<pre>

$(id:<i>logical_base_address</i>:<i>physical_address</i>)

</pre>
Load addresses are computed from <i>physical_address</i> plus location 
counter minus <i>logical_base_address</i>

<p>
Code references are relative to the logical base only (the first address).
<pre>

$(5::SEGMENT1)
.
.
$(5::SEGMENT2)
.
.

	_________________________
	| physical SEGMENT1	|
	| Logical Location 0	|
	|			|
	|			|
	|_______________________|
	| physical SEGMENT2	|
	| Logical Location 0	|
	|			|


</pre>
The segments must be loaded at the named physical locations at run time before reference.

<p>
On simple hardware without MMU this effect is sometimes obtained
by selecting part of memory with I/O operations.

<p>
All parts of all sections may be in one bank for loading. Loader
depending the breakpoint addresses may be physical or relative
to a physical load region

<p>
In this example the program has two loads in the first page of
relative space $(0::) and will switch between them dynamically
<pre>

PHYS_PAGE1	$equ	1*4096
PHYS_PAGE2	$equ	2*4096
PHYS_PAGE3	$equ	3*4096
PHYS_PAGE32	$equ	32*4096
PHYS_PAGE36	$equ	36*4096

$(0::PHYS_PAGE1)
.	program address space 0..4095
.
$(0::PHYS_PAGE2)
.	program address space 0..4095
.
$(5:20480:PHYS_PAGE3)
.	program address space 20480..240575
.
$(4:16384:PHYS_PAGE32)
.	program address space 16384..20479
.
$(8:32768:PHYS_PAGE36)
.	program address space 32768..36863
.


</pre>
In that example the pages of address space are mapped to corresponding locator
numbers and this is convenient. The locator number does not however influence
the address space. That is pointed by the base address. Here the correspondence
with locator number is abandoned with less readable effect
<pre>

$(10:8192)	. locator $(10) concerns addresses from 8192

$(3:40960)	. locator $(3) concerns addresses from 40960

</pre>
<p>
Listings show the program-logical addresses. To see the load
addresses instead, use the -d flag as well as the -l flag

Program code never accesses the physical load
address except via masmx internal function $bank_index (Section 4.6.5)

<h4>7.1.2.2: The Breakpointed Location Counter: -v Option</h4>

If -v option is applied, the treatment of breakpoint values is different.

<p>
The <i>breakpoint value</i> value in $(id:logical_start_address:<i>breakpoint value</i>)
is not assumed to be an address and is not added to the load addresses

<p>
Instead, the value is prefixed before the load addresses in the
text-encoded binary output. See Section 9.1: Output File Formats

<p>
The breakpoint value may be a memory granule or paragraph address,
a page identifier or a virtual translation index. By prefixing it
instead of adding it, masmx -v assigns the breakpoint abstract to
separate interpretation

<p>
Listings show the program-logical addresses. To see the segment selectors
and offsets instead, use the -d flag as well as the -lv flags

<pre>

$ masmx -lnkxyv
MASMX 7r3
0/-INPUT>>
	$set_option	"d"
$(4:04000:99)
	$res	10
	+	$
	+$a
	$end
  :                            1  $set_option "d"
  :                            2 $(4:04000:99)
  :                            3  $res 10
04:000063:00000A 00400A       +4  + $
04:000063:00000B 00400B       +5  +$a
  :                            6  $end
-INPUT>>=0<000000
:$(04):004000:00400C 

</pre>

<h3>7.1.3: Simple Location Counter without Breakpoint:
	 Base+Displacement in Flat Address Spaces</h3>

If the target runs with a large flat address space, or the segment is at
a high relative address in a large bank, and part of the segment is beyond
the immediate address scope of the instruction set, the developer may
cause a base register to be loaded with the a base address at run-time.

<p>
The locations in the segment are referenced as base+displacement
tuples where the displacement does not include the large load address.
But the large load address is included in the code load addresses:
<pre>

$(35:big_address_where_it_loads,r15)

</pre>
Then big_address_where_it_loads must be placed in r15 at run-time.

<p>
The following assembled base-displacement example shows: 

<p>
Line 4 declares a segment which will be accessed 
using R15 as a cover or base register.

<p>
Lines 12..13 place the section start address in r15 at runtime

<p>
Lines 14..16 retrieve operands which r15 covers.
Identifiers in section $(48) are base-displacement. r15 is referenced automatically

<pre>

$ masmx qplain -lnkyd
MASMX 7r3
3/qplain.msm
LTERM=#
CONT_CHAR=\
STERM=.
  :                            1:         $include        "../aside.dem/ppc_603.def"
  :                            2 
  :                            3 SEGMENT .equ    511*1024
  :                            4 $(48:SEGMENT,r15)
30:0007FC00 0000000000400000  +5 part1   +       2048*2048d
30:0007FC08 0000000000000064  +6 part2   +       100d
  :                            7 part3   $res    2048*2048-16
  :                            8 
30:0047FC00 0007FC10          +9 	+	.absolute(part3)
  :                            10 
  :                            11 $(0:3*65536)
00:00030000 640F0008          +12 start   oris    r15,, .absolute(part1)@ha     
00:00030004 39E0FC00          +13         addi    r15, .absolute(part1)@l 
00:00030008 806F0000          +14         lwz     r3, part1
00:0003000C 808F0008          +15         lwz     r4, part2
00:00030010 80AF0010          +16         lwz     r5, part3
00:00030014 4E800020          +17         blr
  :                            18         $end    start
:$(00):00030000:00030018 :$(30):0007FC00:0047FC04 

</pre>

<h3>7.1.4: The Breakpointed Location Counter:
             Base+Displacement in Translated Address Spaces</h3>

The following example has a base+displacement segment at a high
logical address which will be loaded at a different high absolute
address, i.e. a physical load address known at
assembly time.


<p>
Absolute here means linker-absolute not physically relocated. The
breakpoint address does not change code's view of the storage sections

<p>
The physical address HARDWARE_LOADA is not visible to the code but is
used in the load strings.

<p>
Multi-bank images for relocating hardware can be generated in this way.

<p>
The displacements used in operand reference do not reflect either
HARDWARE_LOADA or SEGMENT, but SEGMENT is in r15

<p>
The assembly is run with -d Flag to show absolute load addresses.
<pre>

$ masmx rplain -lnkyd
MASMX 7r3
3/rplain.msm
LTERM=#
CONT_CHAR=\
STERM=.
  :                            1:         $include        "../aside.dem/ppc_603.def"
  :                            2 
  :                            3 SEGMENT .equ    511*1024
  :                            4 HARDWARE_LOADA .equ	511*32768
  :                            5 
  :                            6 $(48:SEGMENT:HARDWARE_LOADA,r15)
30:00FF8000 0000000000400000  +7 part1   +       2048*2048d
30:00FF8008 0000000000000064  +8 part2   +       100d
  :                            9 part3   $res    2048*2048-16
  :                            10 
30:013F8000 0007FC10          +11 	+	.absolute(part3)
  :                            12 
  :                            13 $(0:3*65536)
00:00030000 640F0008          +14 start   oris    r15,, .absolute(part1)@ha     
00:00030004 39E0FC00          +15         addi    r15, .absolute(part1)@l 
00:00030008 806F0000          +16         lwz     r3, part1
00:0003000C 808F0008          +17         lwz     r4, part2
00:00030010 80AF0010          +18         lwz     r5, part3
00:00030014 4E800020          +19         blr
  :                            20         $end    start
:$(00):00030000:00030018 :$(30):0007FC00:0047FC04 


</pre>
<h3>7.1.5: Void Segments</h3>

A void segment has zero base address, no breakpoint address, is not
relocatable and has a base register

<p>
Data is described in a void segment but not generated. It reserves
no storage but is a map of storage. Labels in a void segment map
to displacements on the base register
<pre>

$(id:0,rX)

</pre>
<p>
One location counter can be used for many different void segments if a
zero breakpoint value is specified
<pre>

$(66::,rX)
name1	descriptor_type_A

$(66::,rY)
name2	descriptor_type_B

</pre>
Void Segment addresses two cases, where 

	<blockquote>
	The data is supplied by a calling
	routine which hands "this" routine
	a parameter address in a register<br><br>

	The data is generated in a large
	array and based a part at a time 
	with a register
	</blockquote>

It is safe to place data-generating macros in the void segment. 
They will not generate data. This allows the same macros to construct
data and to map instances of it into a void segment for attention.
	
<p>
Macro "tree" in this example is called both in section $(55) ARRAY
where it does generate data, and segment $(56) VSEGMENT, where it doesn't.
<pre>

MASMX 7r2
3/pusingv.msm
LTERM=#
CONT_CHAR=
STERM=.
*EOF*
  :                            1:         $include        "ppc1.def"
  :                            2         $set_option     "u"
  :                            3         $plist  8
  :                            4         
  :                            5 record* $proc        
  :                            6 *       $tree
  :                            7 h       +       record(1,1)
  :                            8 t       $res    record(1,1)
  :                            9         $root
  :                            10         .align  2
  :                            11         $end
  :                            12         
  :                            13 tree*   $proc
  :                            14 *       $tree
  :                            15 times   $do     3,dibber(times) record    tree(1,1)
  :                            16         $root
  :                            17         $end
  :                            18 
  :                            19 
  :                            20 ARRAY   $equ    262144*24
  :                            21 GRANULE $equ    22//4*4*2*3//8*8
  :                            22 
  :                            23 grains*       $proc
  :                            24       $do     index=2,        $list   0
  :                            25 $(55:ARRAY+index*GRANULE-GRANULE)
  :                            26 cluster(index)* $tree
  :                            27 times   $do     2,raddle(times)  tree 18
  :                            28         $root
  :                            29       $do     index=20000/GRANULE-1,  $list  1
  :                            30         $end
  :                            31 
37:00600000 00000012          +32 index $do     20000/GRANULE,  grains
37:00600018 00000012          +32 
37:00600030 00000012          +32 
37:00600048 00000012          +32 
37:00600060 00000012          +32 
37:00600078 00000012          +32 
37:00604D10 00000012          +32 
37:00604D28 00000012          +32 
37:00604D40 00000012          +32 
37:00604D58 00000012          +32 
37:00604D70 00000012          +32 
37:00604D88 00000012          +32 
  :                            33 
  :                            34 VSEGMENT $equ    0
  :                            35 
  :                            36 $(56:VSEGMENT,r12)
  :                            37 .this_segment $equ $(55)
38:00000000                   +38 times   $do     2,raddle(times) tree    18
38:00000018                   +38 
38:00000030                   +38 
38:00000048                   +38 
38:00000060                   +38 
38:00000078                   +38 
38:00000090                   +39 raddle2 tree    30
38:000000B4                   +39 
38:000000D8                   +39 
  :                            40 $(0:32768/.lit)
00:00008000 640C0060          +41         oris    r12,0,hi16(cluster(40).raddle(1))
00:00008004 618C15F0          +42         ori     r12,r12,lo16(cluster(40).raddle(1))
00:00008008 806C0018          +43         lwz     r3,raddle(1).dibber(2)
00:0000800C 808C0000          +44         lwz     r4,raddle(1).dibber(1)
00:00008010 80AC0078          +45         lwz     r5,raddle(2).dibber(3)
00:00008014 80CC0048          +46         lwz     r6,raddle(2)
00:00008018 80EC0090          +47         lwz     r7,raddle2
00:0000801C 616C0000          +48         mr      r11,r12
00:00008020 90EB0090          +49         stw     r7,raddle2(r11)
00:00008024 A0EB0078          +50         lhz 	r7,raddle(2).dibber(3)(r11)
00:00008028 8180802C          +51       lwz r12,.lit(cluster(20).raddle(2))
*EOF*
00:0000802c+00600AF8
:$(00):00008000:00008030 :$(37):00600000:00604DA0 :$(38):00000000:000000FC 
pusingv.msm: object code 18447 bytes: 0 errors: 0 undefined labels

</pre>
<h3>7.1.6: The Breakpointed Location Counter: Giant Address Spaces</h3>

<h4>7.1.6.1: Very Large Direct Addressed Segments</h4>

If breakpoint is prefixed with an asterisk, it is a
<i>*giant_breakpoint</i> 
<pre>

$(id:<i>base</i>:*<i>giant_breakpoint</i>[,base_register][/literal_pool_tag])

</pre>
<p>
<i>giant_breakpoint</i> is an address expression up to 192 bits wide.

<p>
displacements within the breakpointed part may only reach four gigaquanta beyond <i>base</i>,
but the section may have billions of breakpointed parts at locations up to
0FFFFFFFF:FFFFFFFF:FFFFFFFF:FFFFFFFF:FFFFFFFF:FFFFFFFF (4 tera-peta-peta-petaquanta
or 4 giga-yotta-yottaquanta)

<p>
Linear load addresses in the breakpointed part start at <i>base</i> plus <i>giant_breakpoint</i>

<p>
The radix of <i>giant_breakpoint</i> is the linear address space of the target architecture,
for PowerPC64 64 bits
<pre>

	$awidth	32:64

</pre>
Load code and label references are in one linear space. Each breakpoint part may start at the
exact giant address reached in the previous part. This example is a linking assembly which
catenates four relocatables each containing space of three gigabytes. Load code is distributed
sparsely in this assembly
<pre>

$ masmx globules -lnkydx
MASMX 7r3
3/globules.msm
../result.txo/globule1.txo:$(25) 3221225476 bytes decimal from hexadecimal 00000000 to C0000004 +000FC00A80000028
../result.txo/globule2.txo:$(25) 3221225476 bytes decimal from hexadecimal 00000000 to C0000004 +000FC00B4000002C
../result.txo/globule3.txo:$(25) 3221225476 bytes decimal from hexadecimal 00000000 to C0000004 +000FC00C00000030
../result.txo/globule3.txo:$(27) 8 bytes decimal from hexadecimal 00000000 to 00000008 +000FC010000B0000
../result.txo/globule4.txo:$(25) 3221225476 bytes decimal from hexadecimal 00000000 to C0000004 +000FC00CC0000034
*EOF*
  :                            1: 	$include	../aside.dem/ppc64map.def
  :                            2 
  :                            3 $(27::*000FC010000B0000)
  :                            4 $(25::*000FC00A80000000)
19:000FC00A80000000:000FC00A80000028
                              +5 	+	globule1:d
19:000FC00A80000008:000FC00B40000030
                              +6 	+	globule2:d
19:000FC00A80000010:000FC00C00000030
                              +7 	+	globule3:d
19:000FC00A80000018:000FC00CC0000038
                              +8 	+	globule4:d
19:000FC00A80000020:000FC00D80000038
                              +9 	+	tally:d
  :                            10 	$list	2
  :                            11 $(25::*$)
  :                            12: 	$include,$binary	../result.txo/globule1
19:000FC00B40000028:0000005A  +4 0000005A
  :                            13 $(25::*$)
  :                            14: 	$include,$binary	../result.txo/globule2
19:000FC00B4000002C:0000005B  +4 0000005B
  :                            15 $(25::*$)
  :                            16: 	$include,$binary	../result.txo/globule3
19:000FC00CC0000030:0000005C  +4 0000005C
1B:000FC010000B0000:6162636465662020
                              +7 6162636465662020
  :                            17 $(25::*$)
  :                            18: 	$include,$binary	../result.txo/globule4
19:000FC00CC0000034:0000005D  +4 0000005D
  :                            19 $(25::*$)
19:000FC00D80000038:00000063  +20 tally	+	99
  :                            21 rally	$equ	$
*EOF*
$map=:N129:P:0:00000000
drastique+=$1B:000FC010000B0000
globule1+=$19:000FC00A80000028
globule2+=$19:000FC00B40000030
globule3+=$19:000FC00C00000030
globule4+=$19:000FC00CC0000038
rally=$19:000FC00D8000003C
tally=$19:000FC00D80000038
trip1+=$19:000FC00B40000028
trip2+=$19:000FC00B4000002C
trip3+=$19:000FC00CC0000030
trip4+=$19:000FC00CC0000034
../result.txo/globule4.txo=1<00000005
../result.txo/globule3.txo=1<00000005
../result.txo/globule2.txo=1<00000005
../result.txo/globule1.txo=1<00000005
../aside.dem/ppc64map.def=1<00000005
globules.msm=0<00000003

@:000FC00D80000038:$(19):00000000:00000004 
@:000FC010000B0000:$(1B):00000000:00000008 

</pre>
Another example shows 128-bit addressing, covering potentially
256 exa-exaquanta
<pre>

	$word	32
	$quantum 8
	$byte	8
	$awidth	32:128

ARRAY		$equ	5*/96
ELEMENT_SIZE	$equ	1024*1024*1024
HOW_MANY	$equ	112000

element* $proc
*	+	subscript
	$res	ELEMENT_SIZE-4
	$end
	
newpart* $proc
$(45::*ARRAY+ELEMENT_SIZE*subscript-ELEMENT_SIZE)
	$do	subscript=4,		$list	0
part(subscript)*	element
	$do	subscript=HOW_MANY-3,	$list	1
	$end

subscript	$do	HOW_MANY,	newpart

2D:00000005000000000000000000000000:00000001      +23
2D:00000005000000000000000040000000:00000002      +23 
2D:00000005000000000000000080000000:00000003      +23 
2D:000000050000000000006D5F40000000:0001B57E      +23 
2D:000000050000000000006D5F80000000:0001B57F      +23 
2D:000000050000000000006D5FC0000000:0001B580      +23 
*EOF*
:$(2d):00000000:40000000 
Object Code 5264032 Bytes: 0 Errors: 0 Undefined Labels

</pre>
In the above example, location counter 45 starts at an address of
5*/96 (five times 65536 tera tera bytes) and is stepped 112000 times
by one gigabyte.

<p>
The giant breakpoint value is not catenated but added to the location
counter rightmost bit to rightmost bit to obtain absolute addresses
<pre>

                                                   _______________
	running location counter:                  |_____________|
                                                          +
                   _______________________________________________
	step value:|_____________________________________________|


</pre>
The addresses values in location labels and in load strings are
the sum of the location counter plus step or giant breakpoint value.


<h4>7.1.6.2: Very Large Load Address Base-Displacement Examples</h4>

	<blockquote>
        <b>
	Giant Absolute Address Base-Displacement Example<br>
	With Static Base-Displacement Referencing
	</b>
	</blockquote>

This example is described as static because the base-displacement
construct and the code-generating segment are assembled together.

<p>
Base register r15 is loaded to access the first part of the array

<p>
Whether ,register is given for base-displacement or not, giant
addressing is specified by a giant breakpoint flagged with *
<pre>

$(id:<i>base</i>:*<i>giant_breakpoint</i>,<i>register</i>[/literal_pool])

</pre>
Where <i>register</i> is also stated base-displacement label references
are generated.

<p>
<i>giant_breakpoint</i> is an address expression up to 192 bits wide.

<p>
displacements within the breakpointed part may only reach four gigaquanta beyond <i>base</i>,
but the section may have billions of breakpointed parts at locations up to
0FFFFFFFF:FFFFFFFF:FFFFFFFF:FFFFFFFF:FFFFFFFF:FFFFFFFF (4 tera-peta-peta-petaquanta
or 4 giga-yotta-yottaquanta)

<p>
Linear load addresses in the breakpointed part start at <i>base</i> plus <i>giant_breakpoint</i>

<pre>

MASMX 7r2
3/modest.msm
LTERM=#
CONT_CHAR=\
STERM=.
*EOF*
  :                            1:         $include        "ppc_64.def"
  :                            2 
  :                            3 SEGMENT $set    0x00FFFC0000000000
  :                            4 $(48::*SEGMENT,r15)
30:00FFFC0000000000:0000000000400000
                              +5 part1   +       2048*2048d
30:00FFFC0000000008:0000000000000064
                              +6 part2   +       100d
  :                            7 part3   $res    2048*2048-16
  :                            8 
  :                            9 $(0:3*65536)
00:00030000 4800000D          +10 start   bl      loaded      
00:00030004 00FFFC0000000000  +11         +       SEGMENT
00:0003000C 7DE802A6          +12 loaded  mfspr   r15, LR
00:00030010 E9EF0000          +13         ld      r15,,r15
00:00030014 E86F0000          +14         ld      r3, part1
00:00030018 E88F0008          +15         ld      r4, part2
00:0003001C E8AF0010          +16         ld      r5, part3
*EOF*
:$(00):00030000:00030020 :$(30):00000000:00400000 
modest.msm: object code 217 bytes: 0 errors: 0 undefined labels


</pre>

	<blockquote>
        <b>
	Giant Absolute Address Data Example<br>
	with Dynamic Base-Displacement Reference
	</b>
	</blockquote>

This example is described as dynamic because the base-displacement
construct and the code-generating segment appear to be different segments.

<p>
The code is an array covering many times more address space than the
base-displacement construct, which can be mapped to different array
locations at different moments.

<p>
The base-displacement segment $(49) is called a void segment because
its declaration doesn't generate code. This is achieved by having a
base register but no address or relocation rule.

<p>
A giant array constructed as a stepped segment may be 
randomly accessed by basing different parts of the array 
at different moments for base-displacement addressing.

<p>
The use of a Void Segment to map  onto different parts of an array is
not confined to giant address models. See Section 4.1.2.1.1.5: Void
Segments
<pre>

MASMX 7r2
3/qbig.msm
LTERM=#
CONT_CHAR=\
STERM=.
*EOF*
  :                            1:         $include        "ppc_64.def"
  :                            2 
  :                            3 ARRAY   $equ    0x00FFFC0000000000
  :                            4 GRANULE $equ    2048*2048
  :                            5 
  :                            6 proces*	$proc
  :                            7 $(48::*ARRAY+GRANULE*x-GRANULE)
  :                            8         $do     x=3,    $list 0
  :                            9         $do     x=4094, $list 1
  :                            10 item(x)* +       x*2048*2048+ARRAY
  :                            11         $end
  :                            12 
30:00FFFC0000000000:00FFFC0000400000
                              +13 x	$do	4096,	proces
30:00FFFC0000400000:00FFFC0000800000
                              +13 
30:00FFFC03FF400000:00FFFC03FF800000
                              +13 
30:00FFFC03FF800000:00FFFC03FFC00000
                              +13 
30:00FFFC03FFC00000:00FFFC0400000000
                              +13 
  :                            14 
  :                            15 $(49::,r15)
  :                            16 h       $res    8
  :                            17 t       $res    2048*2048-8
  :                            18 
  :                            19 $(0:3*65536)
00:00030000 4800000D          +20 start   bl      loaded      
00:00030004 00FFFC017FC00000  +21         +       item(1536)
00:0003000C 7DE802A6          +22 loaded  mflr	  r15
00:00030010 E9EF0000          +23         ld	  r15,,r15
00:00030014 E86F0000          +24         ld      r3, h
00:00030018 E88F0008          +25         ld      r4, t
*EOF*
:$(00):00030000:0003001C :$(30):00000000:00000008 :$(31):00000000:00400000 
qbig.msm: object code 213163 bytes: 0 errors: 0 undefined labels

</pre>
With *giant-stepped segments, the size of the giant part of the address
is the second part of the $AWIDTH declaration, for example
<pre>

	$awidth 32:64

</pre>
The first or "ordinary" part of the $AWIDTH declaration may
not be more than 32 bits, and that sets the 4-gigaquanta limit of base in
<pre>

$(id:base:

</pre>
Base + current location counter cannot accumulate to more
than 4 gigaquanta without being stepped. The default of 
the giant part of $AWIDTH is 48 and the limit is 192.

<p>
See also Section 8.2: $AWIDTH directive
See also Section 9: Output File Formats, Relocation and Linking,
Giant Address Spaces, Interfacing with GNU Tools.


<h3>7.1.7: Literal Pool Tag</h3>

Literals may be generated in any sort of segment where code is
allowed. The only other sort of segment is a void segment, sometimes known
as a dsect. That's a base-displacement segment with no addresses
and no relocation rule.

<p>
Where <i>/literal_pool_tag</i> appears in the location counter control
<pre>

$(id[:base][:breakpoint][,base_register]/<i>literal_pool_tag</i>)

</pre>
or
<pre>

$(id[:*relocation_alignment][,base_register]/<i>literal_pool_tag</i>)

</pre>
<i>literal_pool_tag</i> gives a handle to the literal pool in the counter.

<p>
Literals are assigned to a specific program section by reference to the tag
<pre>
 
	<i>literal_pool_tag</i>(LITERAL_VALUE)

</pre>
Without -a flag, literals can only be generated via literal-pool-tag. See
4.5: Literals

<p>
The literals are produced at the end of the section or section breakpoint.

<p>
For example, in the definition header "8051.def":
<pre>

$(0:0/$literal)

</pre>
means start location counter zero at address zero, and 
gives the tag "$literal" to a literal pool at the end of 
the other code assembled in location counter zero. Tag 
"$literal" may then be referenced to assemble literals 
and return their address:
<pre>

	mov     dptr, #$literal("A Long String of Text")

</pre>
See also Sections 4.6: Function Macros and 4.5: Literals.
A forward slash signals the start of the literal pool
name. Therefore any expression which contains an operator 
/ // /// */ /* in the preceding expressions should be 
in parentheses. Or equated to a label in advance:
<pre>

OFFSET	$set	TOTAL_SIZE/GRANULE_LOGARITHM
$(.array::BASE+OFFSET/$literals_tag)

</pre>

<h2>7.2: Relocatable Location Counters</h2>

<pre>

$(<i>id:*alignment[:initial_offset][,base_reg][/literal_pool_tag]</i>)

</pre>
<i>id</i> is the number 0..71 of the location counter

<p>
<i>*alignment</i> identifies relocatable code. It gets rounded to the
containing power of 2. *alignment is recognised by leading asterisk.

<p>
<i>initial_offset</i> is optional. It declares a hole or unlabelled buffer
at the front of the segment. initial_offset is usually absent = zero.

<p>
<i>base_register</i> and <i>literal_pool_tag</i> are optional

<p>
The first section in the following assembly, $(33) at line 3
is relocatable and no base register is used to address it.
The text-encoded binary output has relocation information added to
references (line 16) in this segment.

<p>
Relocation tuples are printed just above the generated code
at the left of the listing when -ln flags are opted

<p>
The second section $(34) at line 6 in this example has a base register.
Instruction  reference to labels and literals in that section
are base+displacement

<p>
The code in the segment will be relocated and pointers to it
updated with relocation information (line 11), but base-displacement
references (lines 15, 17) are never relocatable

<pre>

$ masmx -lnk ragaline
MASMX 7r3
3/ragaline.msm
LTERM=#
CONT_CHAR=\
STERM=.
*EOF*
  :                            1: 	$include ../aside.dem/ppc_603.def
  :                            2: 	$include ieee754.def
  :                            3 $(33:*8)                                  
21:00000000 3FF8000000000000  +4 one	ieee754_64	1.5
21:00000008 3FFC000000000000  +5 two	ieee754_64	1.75
  :                            6 $(34:*8,30/.literals34)
22:00000000 BFC8000000000000  +7 first	ieee754_64	-1.5
22:00000008 BFC4000000000000  +8 second	ieee754_64	-1.75
  :                            9 $(.text:131072)
01:00020000 48000009          +10 	bl	load_base30
(+22)20
01:00020004 00000000          +11 	+	.absolute(first)
  :                            12 load_base30
01:00020008 7FC802A6          +13 	mflr	r30
01:0002000C 83DE0000          +14 	lwz	r30,,r30
01:00020010 C81E0008          +15 	lfd	0, second
(+21)10
01:00020014 C8400008          +16 	lfd	2, two
01:00020018 C89E0010          +17 	lfd	4, .literals34(ieee754_64 37.5e-115)
  :                            18 
*EOF*
22:00000010+2862783DA15ED470
:$(01):00020000:0002001C :$(21):00000000:00000010 :$(22):00000000:00000018 


</pre>


<p>
See also Section 9:	Output File Formats, Relocation and Linking,
    			Giant Address Spaces, Interfacing with GNU Tools





<h1>8: Directives:</h1>                                         

<h2>8.1:  $ASCII             Set Character Set to ASCII</h2>


<p>
$ascii switches string contents and values in apostrophes to source input
values unchanged

<p>
Directives $ascii and $data_code switch text strings between unchanged input
(ASCII / Roman-8 / Latin-1) and tabled byte translation values stored by $data_code
for code points 0..255

<p>
Source input is is octets with ASCII in code points 0..127. Language elements
outside of strings are assembled from ASCII simple

<p>
Assembly initial setting is $ascii


<h2>8.2:  $AWIDTH            Output File Load Address Width</h2>


<p>
$AWIDTH governs the width of addresses placed in the output file
for inclusion in load string formats. If it is a different value from
$WORD it must be submitted to the assembly later than $WORD. For
example, a suitable $WORD value for 8-bit microcontrollers is 8, but
a suitable $AWIDTH is 16:
<pre>

	$WORD   8       . 8-bit microcontroller
	$AWIDTH 16      . Load Strings have a 16-bit address

</pre>
<p>
A suitable $WORD for M68K is 16, but a suitable $AWIDTH is 32
<pre>

	$WORD   16      ; Standard Size Generated Data Item is 16 bits
	$AWIDTH 32      ; Load Strings have a 32-bit address 
	
</pre>
<p>
If giant address spaces are used, then the giant part of the address
is stated after the primary part.
<pre>

	$AWIDTH 32:64

</pre>
<p>
The maximum size of the first or "net" part is 32 bits.

<p>
The maximum size of the second or giant-stepped part is 192 bits.

<p>
See Section 4.1.2.1: Describing the Address Space: Location Counter Controls.

<p>
See Section 9: Output File Formats, Relocation and Linking,
Giant Address Spaces, Interfacing with GNU Tools.


<h2>8.3:  $BLANK		Set the Globality of a Future Label</h2>


<p>
$BLANK sets the globality of a label which is not yet declared,
for example
<pre>

entry_point*	$blank	0
	.
	.
entry_point
	la	r1, #initial_stack
	.
	.

</pre>

<h2>8.4:  $BRANCH		Structure Overlay</h2>


<p>
$BRANCH is the start of a structure overlay. The following assembly
with part of its label listing shows an  example of overlaid
storage definition
<pre>

MASMX 7r2
3/welblech.msm
*EOF*
  :                            1 p      $proc
  :                            2 yooz*  $name
  :                            3 *      $tree
  :                            4 yo*    $branch
  :                            5        +       7
  :                            6        +       8
  :                            7        +       9
  :                            8        $root
  :                            9 ho*    $branch
  :                            10       +       12
  :                            11       $root
  :                            12       $root
  :                            13       $end
  :                            14 
  :                            15 $(6:06000)
  :                            16 well $tree
  :                            17 switch $res 1
  :                            18 blech $branch
06:006001 000001              +19 up + 1
06:006002 000007              +20 halfway yooz
06:006003 000008              +20 
06:006004 000009              +20 
06:006002 00000C              +20 
06:006005 000063              +21 down  +       99
  :                            22  $root
  :                            23 
  :                            24 fest  $branch
06:006001 000002              +25 left  +       2
06:006002 000007              +26 centre        yooz
06:006003 000008              +26 
06:006004 000009              +26 
06:006002 00000C              +26 
06:006005 000064              +27 right +       100
  :                            28       $root
  :                            29       $root
  :                            30 
06:006006 006002              +31       +       well:blech:halfway:ho
06:006007 006002              +32       +       well:fest:centre:yo
06:006008 006005              +33       +       well:blech:down
06:006009 006001              +34       +       well:fest:left
*EOF*
.
.
.
WELL=$06:006000
WELL:SWITCH=$06:006000
WELL:BLECH=$06:006001
WELL:BLECH:UP=$06:006001
WELL:BLECH:HALFWAY=$06:006002
WELL:BLECH:HALFWAY:YO=$06:006002
WELL:BLECH:HALFWAY:HO=$06:006002
WELL:BLECH:DOWN=$06:006005
WELL:FEST=$06:006001
WELL:FEST:LEFT=$06:006001
WELL:FEST:CENTRE=$06:006002
WELL:FEST:CENTRE:YO=$06:006002
WELL:FEST:CENTRE:HO=$06:006002
WELL:FEST:RIGHT=$06:006005
YOOZ=:N1:P:0:000000
welblech.msm=0<000003
:$(06):006000:00600A 
welblech.msm: object code 215 bytes: 0 errors: 0 undefined labels


</pre>

<h2>8.5:  $BYTE              Set the Width of a Data Character</h2>


<p>
$BYTE is defaulted to 8, and is only likely to be anything different
if the target machine's address quantum is other than a byte, for
example a word of 30 or 48 or 60 bits. See Section 8.41: $QUANTUM,
Appendix F.4: Byte-Addressing Machines with 32 and 64 Bit Bus: Managing 
Alignments	

<p>
$BYTE also applies with +'symbols' bounded by single quote in number
expressions. ASCII is read in source code, but the +'expression' token
has a value in the current character set and size.

<p>
See also 8.8: $DATA_CODE directive.

<p>
Here is an example of an assembly for a 48-bit architecture generating
string constants first of 8-bit then 6-bit bytes.
<pre>

MASMX/-240 1r1X
big48.msm 5
*EOF*  :                        1:         $word   48
  :                        2:         $quantum 48
00:00000000 496E697469616C20537472696E6773206F6620382D626974
			 +3         "Initial Strings of 8-bit data"
00:00000004 206461746120  +3 
  :                        4:         $byte   6
00:00000005 B21D25C80CF4CA9BA7CC0BE6034A67A34B39030863AE5900
			 +5         "Later Strings of Tightly Packed Data"
00:00000009 921D21000000  +5 
*EOF*:$(00):0000000A 
Object Code 150 Bytes: 0 Errors: 0 Undefined Labels

</pre>
<p>
Where the width of $BYTE is less than 7 and the character code is still
ASCII, the character values are compressed by discarding bit 5 and
placing 6-bits right justified in the target field. Truncation then
takes place if the target field is less than 6 bits.
<pre>

	________________________________________________________________|
	|   0   |   d   |discard|   d   |   d   |   d   |   d   |   d   |
Input   |_______|_______|_______|_______|_______|_______|_______|_______|
		    |               |       |       |       |       |   |
		    |_______        |       |       |       |       |   |
			____|_______|_______|_______|_______|_______|___|
			|   d   |   d   |   d   |   d   |   d   |   d   |
Receiving Field         |_______|_______|_______|_______|_______|_______|
									|

</pre>
<p>
$data_code directive tables and activates byte translate values for strings

<p>
If $word is not a  multiple of the $byte, bytes in strings straddle words.
New strings start at a word, expect in bit-aligned $record structures
<pre>

$ ../masmx qzuli -ln
MASMX 7r2
3/qzuli.msm
*EOF*
  :                            1         $set_option "e"
  :                            2         $word   30
  :                            3         $octal
  :                            4         $byte   7
000:0000000000  3757677375 7677375767 7375767737 5767737576 7737576773 7576773757
                              +5         "???????????????????????????????"
Note: qzuli.msm Line 5: trailing zero bits in last data word of string
000:0000000006  6773757677 3750040200
                              +5 
000:0000000010  3757677375 7677375767 7375767737 5767737576 7737576773 7576773757
                              +6         "??????????????????????????":127:127:127:127
000:0000000016  7777777777     +6 
*EOF*
:$(0):0000000000:0000000017 
qzuli.msm: object code 162 bytes: 0 errors: 0 undefined labels

</pre>

<p>
<b>$octal</b> directive shows the 30-bit words and adresses in octal.

<p>
In line 4, the assembler added three 7-bit space characters to fill the
last data word, but still needed to add two trailing zero bits.

<p>
The first 30 characters had exactly filled seven data words, but the last
character left 23 bits.

<p>
Space fill in the last word is added without comment. <b>-c</b> or
<b>-z</b> flag causes zero fill instead of space.
<b>-zc</b> flags combined fill with space

<p>
Slack bits remaining after the last character position are zeroed
and a message is output

<p>
The constant in line 5 exactly fills 210 bits or seven data words.

<p>
Setting $WORD automatically sets $QUANTUM.

<p>
Best known architectures have an address quantum of 8 and a word
size 16 or 32. For these, quantum must be set to 8 after word size.

<p>
This 30-bit architecture has a 30-bit quantum. So only 15 locations
have been filled.

<p>
The <b>-e</b> flag causes a space to be printed between each word of generated
code. This makes readable when the word size does not fit an exact number of
hex or octal symbols

<p>
Another case of a text string being placed in a field not a multiple
of $BYTE can arise where the target field is in a $FORM:
<pre>

$ masmx ldes -ln
MASMX 7r2
3/ldes.msm
*EOF*
  :                            1         $word   32
  :                            2         $quantum 8
  :                            3         $byte   8
  :                            4 label_descriptor $form  8, 8, 16, 4, 60   
  :                            5 
00:00000000 0700FFF63404C4142454C310
                              +6      label_descriptor 7,0,-10,3,"@LABEL1"
*EOF*
:$(00):00000000:0000000C 
ldes.msm: object code 70 bytes: 0 errors: 0 undefined labels

</pre>
<p>
In this example the characters @LABEL1 have been placed 
in the first 56 bits of their 60-bit field, and four zero 
bits appended.

<p>
Quoted character fields in a $FORM structure are zero-padded
in any untyped columns. The columns can be typed as space to force
space, as "@VOL2&nbsp;&nbsp;" distinct from "@VOL1" here
<pre>
$ masmx ldes2 -ln
MASMX 7r2
3/ldes2.msm
*EOF*
  :                            1         $word   32
  :                            2         $quantum 8
  :                            3         $byte   8
  :                            4 label_descriptor $form  8, 8, 16, 4, 60   
  :                            5 
00:00000000 0700FFF6340564F4C3100000
                              +6 	label_descriptor 7,0,-10,3,"@VOL1"
00:0000000C 0707000A740564F4C3220200
                              +7 	label_descriptor 7,7, 0a,7,"@VOL2  "
*EOF*
:$(00):00000000:00000018 
ldes2.msm: object code 95 bytes: 0 errors: 0 undefined labels

</pre>
<p>
A quoted string in a macro macro expansion may contain parameter
references:
<pre>

MASMX/-240 1r1X
bdw.msm 5
*EOF*  :                        1: bdw     $form   24,12,6,6,48
  :                        2: p       $proc   5
  :                        3: bd      $name        
  :                        4:         $byte   6
  :                        5:         bdw     p(1, 1), 0, 0, p(1, 2), "p(1, 1)"
  :                        6:         $byte   8
  :                        7:         $end
  :                        8: 
00:00000000 0000000000038A1BAB440000+9         bd      bank1, 3
00:00000004 0000000000078A1BAB450411+10         bd      bank1001, 7
*EOF*:$(00):00000008 
Object Code 127 Bytes: 0 Errors: 2 Undefined Labels

</pre>
<p>
The right half of the first structure contains the text
"bank1   " compressed to 6-bit characters.

<p>
The right half of the second structure contains the text "bank1001"
compressed to 6-bit characters (bit 5 of each ASCII symbol is dropped):
<pre>

	    62     61     6e     6b     31     20     20     20
	100010 100001 101110 101011 010001 000000 000000 000000

	    62     61     6e     6b     31     30     30     31
	100010 100001 101110 101011 010001 010000 010000 010001

</pre>
<p>
The macro references "bank1 and "bank1001" as well as capturing the
names as text. External references have been marked 
in the output file. Those are the two undefined labels.


<h2>8.6:  $CHARACTERISTIC    Set Floating Point Characteristic Size</h2>

<p>
$CHARACTERISTIC sets the size or sizes of the characteristic part
(sign + exponent) of floating point items. If the $CHARACTERISTIC
directive has a subcommand, for example:
<pre>

	$characteristic,64      SIZE 
	
</pre>
<p>
then size is the characteristic size of a 64-bit floating point item.

<p>
Without the subcommand, SIZE is the characteristic size of a
default-size floating point item. 

<p>
A default-size floating point item is 96 bits unless $FLOATING_POINT directive has changed it.

<p>
The default 96-bit floating point item has the default characteristic
size 24 bits, and the mid-pointed exponent is 23 bits:
<pre>


	_______________________________________________________________
	|s|94 exponent 72|71          mantissa                       0|
	|_|______________|____________________________________________|


</pre>
<p>
In the following example, a default sized floating point 
item is 32 bits, set by the $FLOATING_POINT directive, 
but there may also be 64-bit and 80-bit floating constants 
generated, which each require a different width of characteristic 
from the default of 8.

<p>
The largest characteristic size possible is 24 bits. The largest
floating point item size possible is 192 bits.
<pre>


$ masmx -ln dfp16
MASMX 7r2
3/dfp16.msm
*EOF*
  :                            1         $word   16
  :                            2         $quantum 8
  :                            3         $awidth 32
  :                            4         $floating_point 32
  :                            5         $characteristic 8
  :                            6         $characteristic,64 12
  :                            7         $characteristic,80 16
  :                            8 $(2:*8:256)        
02:00000100 41C00000          +9 one     +1.5
02:00000104 401E000000000000  +10 two     +1.75:q
02:0000010C 4001C000000000000000
                              +11 three   +15.0e-1:p
02:00000116 B837FFFF          +12 four    -100.0
02:0000011A 47C80000          +13 	+100.0
02:0000011E 438CC2DC14A740E08BDA
                              +14 five    +33*+20000:p
*EOF*
:$(02):00000000:00000128 
dfp16.msm: object code 145 bytes: 0 errors: 0 undefined labels

</pre>
<p>
Here, 64-bit floating point items (quadwords where $WORD 
is 16) are given  a 12-bit characteristic, and 80-bit 
floating point items (pentawords) have a 16-bit characteristic. 

<p>
The default floating model has a mid-pointed exponent 
occupying all the $CHARACTERISTIC width except the high-order 
sign bit, the mantissa is normalised fraction-only with no 
integral part either represented or imputed, and negative 
representation is the ones complement of the entire item.

<p>
This is not IEEE 754 encoding. IEEE 754, or any 
other encoding different from masmx default, is generated 
with macros which use the <b>$set</b> directive to capture
and manipulate a number argument.

<p>
Macro language does reversed byte order if needed. 

<p>
Code written for other assemblers has constant-generating
pseudo-directives (for example, .float).

<p>
Macros implement these directives for masmx.

<p>
Floating point values are calculated to 192 bits precision, and
the default output is 96 bits:
<pre>

$ masmx -ln gflo
MASMX 7r2
3/gflo.msm
*EOF*
00:000000 BFFFFE3FFFFFFFFFFFFFFFFF
                              +1         -1.5
00:000004 72B04D80286861658C3056A5
                              +2         +15*+1000000
00:000008 0D4FBCE0B90EE9FC3D9D7123
                              +3         +15*-1000000
*EOF*
:$(00):000000:00000C 
gflo.msm: object code 112 bytes: 0 errors: 0 undefined labels


</pre>
<p>
24 is the maximum characteristic width, and the default for floating-point
items three or more words in size. The default for a single floating-point
word is 8 bits and for a double 12:
<pre>

$ masmx hflo -lnky
MASMX 7r3
3/hflo.msm
*EOF*
  :                            1         $word   32
  :                            2         $quantum 8
  :                            3         $awidth 32
  :                            4         $floating_point 32
00:00000000 41C00000          +5         +1.5
00:00000004 401C000000000000  +6         +1.5d
00:0000000C 400001C00000000000000000
                              +7         +0.15t*+1
00:00000018 400001C0000000000000000000000000
                              +8         +15:q*-1
00:00000028 400001C000000000000000000000000000000000
                              +9         +1.5p
00:0000003C BFFFFE3FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
                              +10         -1.5h
Note: hflo.msm Line 11: floating number is maximum words
00:00000054 400001C00000000000000000000000000000000000000000
                              +11         +1.5o
*EOF*
:$(00):00000000:0000006C 

</pre>
<p>
The request to generate an octaword item only resulted in
a hexaword, because 192 bits is the limit of masmx.
Octawords may be generated when $WORD is 24 or less.

<p>
Floating point items are not auto-sized like integers.

<p>
Floating point items are the default <b>$floating_point</b> size, 
or a words-size after the mantissa and before any scale
<pre>

	+(MANTISSA)[s d l t q p h o][{*+|*-}SCALE]

	S for single (one word)
	D or L for double 
	T for triple
	Q for quadword
	P for pentaword
	H for hexaword
	O for octaword

</pre>
<p>
These trailing letters may be upper or lower case and may have a
colon before them or parenthesis or quote
<pre>

	67.5t

	+MANTISSA:q*+1200000

	+(MANTISSA)p*+800

	+	20*"MANTISSA"d*+307

</pre>
Period may only appear in a decimal digit string. Where period
appears the scale notation [ e e+ e- E E+ E- ] can be typed in
place of the masmx scale operator <b>*+</b> or <b>*-</b>

<p>
Where period does not appear, only <b>*+</b> or <b>*-</b> scale
operator and not [ e e+ e- E E+ E- ] indicates a floating point number.

<p>
To generate floating values using every type of expression token,
see 4.2.2.2.5: The Decimal Scale Operator
<b>*+ *-</b>


<h2>8.7:  $CONT_CHAR          Change Line Continuation Character</h2>

<p>
Default $CONT_CHAR is semicolon. The line is catenated with the
first noncomment non-white-space non-continuation character
on the next line:
<pre>

MASMX/-240 1r1X
leggy.msm 5
*EOF*00:00000000 00055555      +10         +       262144;
       	       					  ++65536;
	     					  ++16384;      
						   ++4096;
					  	   ++1024;
					   	    ++256;
					    	     ++64;
		  				     ++16;
						      ++4;
		   				      ++1
		 
*EOF*:$(00):00000001 
Object Code 25 Bytes: 0 Errors: 0 Undefined Labels


</pre>
<p>
To use semicolon for comment or for anything else,
continuation must be changed first.

<p>
Then semicolon is immediately available for reassignment
as comment character (and then period is immediately available for
reassignment as substring terminator).
<pre>

	$cont_char      0
	$lterm          ';'

</pre>
<p>
Setting continuation to zero means there is no line continuation.

<p>
If another character is wanted for line continuation,
then the $CONT_CHAR argument is not zero, but the value
of the required character. All of these are tilde ~
<pre>

	$cont_char       '~'
	$cont_char       07e
	$cont_char       126

</pre>
<p>
To get space into a continued line, the space must be before the
continuation character, because leading whitespace on the next line
is skipped:
<pre>

	$cont_char	'\'

	command		field1	\
			field2	\
			field3

</pre>

<p>
Line continue character does not act if a nonspace token follows
it immediately:
<pre>

$ masmx -ln
MASMX 7r2
0/-INPUT>>
	$cont_char       '\'
CONT_CHAR=\
	$word		32
	+		\10101010\	bit pattern 0xAA and line continue
			*/16\		shift left 16 and line continue
			++3     	. OR 3
	$end
  :                            1  $cont_char '\'
  :                            2  $word  32
00:00000000 00AA0003          +3  +  \10101010*/16++3  . OR 3
  :                            4  $end
:$(00):00000000:00000001 
-INPUT>>: object code 54 bytes: 0 errors: 0 undefined labels

</pre>


<h2>8.8:  $DATA_CODE             Set Alternative Character Set</h2>

<p>
$data_code tables and activates byte translate values for quoted
text strings and value strings in apostrophe

<p>
masmx input is octets containing ASCII values in code points 0..127.
$data_code directive allows "text strings" and +'character value constants'
to be composed in another character code
<pre>

MASMX/-240 1r1X
code.msm 5
*EOF*  :                        1:         $word   32
  :                        2:         $quantum  8
  :                        3:         $byte   8
  :                        4:         $awidth 32
00:00000000 41424320      +5         "ABC"
  :                        6:         $data_code  'A', 0c1, 0c2, 0c3, 0c4, 0c5, 0c6, 0c7, 0c8, 0c9
  :                        7:         $data_code  32, 64
00:00000004 C1C2C3C4C5C64040+8         "ABCDEF"
  :                        9:         $ascii
00:0000000C 4142434445462020+10         "ABCDEF"
  :                        11:         $data_code
00:00000014 C1C2C340      +12         "ABC"
*EOF*:$(00):00000018 
Object Code 73 Bytes: 0 Errors: 0 Undefined Labels

</pre>
<p>
Here the $data_code has generated alternative 
values for the first nine letters of the alphabet, and for the 
space character.

<p>
$data_code also switches to the alternative data code as it constructs it.

<p>
$ascii directive switches to the assembly initial setting of unchanged
input values (ASCII / Roman-8 / Latin-1 / UTF-8) for strings, but leaves
the tabled translate values available

<p>
$data_code with or without arguments switches to byte translate. The initial
translate table has all code points unchanged. $data_code may table translate
values for code points 0..255

<p>
Both assembly passes begin in $ascii mode


<h2>8.9: $DO                Generate Repeated Code</h2>     

$DO repeats code.

<p>
The arguments are the repeat count, a comma, and the line of code
to be repeated:
<pre>

MASMX 7r2
3/do1.msm
*EOF*
00:000000 000021              +1         $do      5, +   33
00:000001 000021              +1 
00:000002 000021              +1 
00:000003 000021              +1 
00:000004 000021              +1 
*EOF*
:$(00):000000:000005 
do1.msm: object code 72 bytes: 0 errors: 0 undefined labels

</pre>

<p>
$DO may be nested and the label on the $DO line represents a relative-1
ascending counter:
<pre>


        $word	32

hunthou	$do	10,;
hundred $do     10,;
ten     $do     10,;
unit    $do     10, + hunthou+'0'-1, hundred+'0'-1, ten+'0'-1, unit+'0'-1


MASMX 7r2
3/dotable.msm
*EOF*
  :                            1         $word	32
  :                            2 
00:00000000 30303030          +6 hunthou	$do	10,;
hundred $do     10,;
ten     $do     10,;
unit    $do     10, + hunthou+'0'-1, hundred+'0'-1, ten+'0'-1, unit+'0'-1
00:00000001 30303031          +6 
00:00000002 30303032          +6 
00:00000003 30303033          +6 
00:00000004 30303034          +6 
00:00000005 30303035          +6 
.
.
.
00:0000270B 39393935          +6 
00:0000270C 39393936          +6 
00:0000270D 39393937          +6 
00:0000270E 39393938          +6 
00:0000270F 39393939          +6 
*EOF*
:$(00):00000000:00002710 
dotable.msm: object code 90045 bytes: 0 errors: 0 undefined labels

</pre>
<p>
The counter argument to $DO is evaluated to a precision of 192 bits.
32 bits of the expression's final value are used as a count.
	
Therefore the expression
<pre>

	$DO     label>07FF0000000000000000000

</pre>
<p>
Is evaluated correctly. The value of the expression
<pre>

		label>07FF0000000000000000000

</pre>
is either one for "greater" or zero for "not greater". 
<p>
A repeat count expression sometimes has possible values
only of zero or one, as:
<pre>

	x=y

	x^=y
	
	$o('x')

</pre>
<p>
Then  $DO has the effect of a decision. The code line argument is
assembled once or not.

<p>
When the count argument of $DO is zero, the code line argument
is not assembled.

<p>
A label on a $DO has an incrementing value starting from 1:
<pre>

MASMX 7r2
0/-INPUT>>
count_up        $do     5,      +       6-count_up
        $end
00:000000 000005              +1 count_up $do 5, + 6-count_up
00:000001 000004              +1 
00:000002 000003              +1 
00:000003 000002              +1 
00:000004 000001              +1 
  :                            2  $end
:$(00):000000:000005 
-INPUT>>: object code 72 bytes: 0 errors: 0 undefined labels

</pre>
<p>
$DO can only iterate one line of code, but that line can be a macro call.


<h2>8.10: $ELSE              Conditional Assembly</h2>
      

<p>
Part of conditional assembly
<pre>

	$if     expression1
	.
	.
	$elseif expression2
	.
	.
	$else
	.
	.
	$endif

</pre>
<h2>8.11: $ELSEIF            Conditional Assembly</h2>                

<p>
Part of conditional assembly
<pre>

	$if     expression1
	.
	.
	$elseif expression2
	.
	.
	$else
	.
	.
	$endif


</pre>

<h2>8.12: $END               End of Macro or Assembly</h2>          

<p>
This image is required at the end of all subassemblies (macros)
<pre>

name_of* $proc
	.
	.
	$end

tag_of*	$func
	.
	.
	$end

</pre>
<p>
If $END is encountered in the main assembly, its effect is end of
assembly. In the main assembly a program transfer address may be supplied
as an argument to $END
<pre>

	$end    program_transfer_address

</pre>
<p>
$END in an include file doesn't stop the assembly, so $END can be
used in an include file to give a transfer address.



<h2>8.13: $ENDIF             Conditional Assembly</h2>              

<p>
Part of conditional assembly
<pre>

	$if     expression1
	.
	.
	$elseif expression2
	.
	.
	$else
	.
	.
	$endif



</pre>
<h2>8.14: $EQU               Assign Value to Label</h2>


<p>
$EQU assigns a value to a label for the duration of the 
assembly or subassembly (macro). 

<p>
The label may be assigned any value which can be expressed
in 192 bits.
<pre>

label   $equ    10*44*/180

</pre>
<p>
If a label is equated again, a warning note is output
and the label is given the new value.

<p>
A label is equated on the second assembly pass if it does not yet exist.

<p>
If the label is equated for the first time on the second assembly pass
(see Functions which Generate Code and Second Pass Only Functions,
Section 8.22.1), then only its first equate is actioned.

<p>
Labels mostly cannot be changed in type between location, $EQU, $SET etc,
although $SET labels may be $SET again to new values. See Section 8.46:
$SET Directive.

<p>
$EQU may have a subfunction which assigns a TYPE to the label.
Two types supplied within the assembler, $DIRECTIVE and $FUNCTION,
may be used for aliasing:
<pre>

.macro  $equ,$directive $proc
.endm   $equ,$directive $end

.       $equ,"$function" "$"

</pre>
<p>
$FUNCTION means assembler supplied functions, like the location
counter, not user-written $FUNC..$END macro functions.

<p>
To make . functionally the same as $ location counter, "$" is in
quotes. Otherwise $ returns its functional value, the current location.

<p>
The developer may use a range of type values 128..191 to type,
for example, register sets:
<pre>

data_register   $equ    128
address_register $equ   129

d0      $equ,data_register      0
d1      $equ,data_register      1
	.
	.
d7      $equ,data_register      7

a0      $equ,address_register   0
a7      $equ,address_register   7
	.
	.
a7      $equ,address_register   7

</pre>
<p>
This allows the actual parameters of instruction macros to have a type.
The type of a tag can be retrieved with the $T internal function:
<pre>

p       $proc
move.w  $name
	$if     $t(p(1,1))=address_register
	.
	.

</pre>
<p>
This is useful in dialects where many instructions have the same
name but the encodings change for different operand types.



<h2>8.15: $EQUF              Assign List of Values to Label</h2>

<p>
$EQUF equates a label to a list of values.

<p>
Macro expansion can then retrieve each value individually as a
separate argument. 

<p>
Each value corresponds to a subfield in the FIELD, SUBFIELD
paradigm.

<p>
$EQUF typically equates a base-displacement tuple plus possibly
further attributes like indirection or field-size:
<pre>

aName   $equf   buffer, r9, halfaword
	.
	.
	addto   r6, aName

</pre>
<p>
has the effect
<pre>

	addto   r6, buffer, r9, halfaword

</pre>
<p>
Arithmetic is possible on the first or principal $EQUF value:
<pre>

	addto   r6, aName+5

</pre>
<p>
has the effect
<pre>

	addto   r6, buffer+5, r9, halfwaword

</pre>
<p>
The $EQUF name must be on the left of any +- expression or the
other attributes aren't retrieved.

<p>
That is,
<pre>

	addto   r6, aName+5

</pre>
<p>
works as
<pre>

	addto   r6, buffer+5, r9, halfwaword

</pre>
<p>
but
<pre>

	addto   r6, 5+aName

<p>
only works as

	addto   r6, 5+buffer


</pre>
<p>
In "addto r6,aName+5", the addto macro receives for its
arguments:
<pre>

	addto(1, 1)     is      r6
	addto(1, 2)     is      buffer+5
	addto(1, 3)     is      r9
	addto(1, 4)     is      halfaword

</pre>
<p>
Each binary token in the $EQUF may have a retrievable 
unary * flag, as subfields always can

<p>
Where
<pre>

aName   $equf   buffer, *r9, halfaword
	.
	.
	addto   r4, aName

</pre>
<p>
Then
<pre>

	addto(1, *3)    is      1

</pre>
<p>
*R9 is only the second subfield of aName, but R4 is a subfield before
aName. addto can see four subfields.

<p>
Where r9 is supplied, not *r9, the value of "addto(1, *3)" is zero.
Either way, the value of "addto(1, 3)" is r9.

<p>
It's possible to override the trailing attributes. Where:
<pre>

aName   $equf   buffer, r9, halfaword
	.
	.
	addto   r6, aName,,all_of_aword

</pre>
<p>
The effect is
<pre>

	addto   r6, buffer, r9, all_of_aword

</pre>
<p>
And the effect of
<pre>

	addto   r6, aName+20, r7

</pre>
<p>
is
<pre>

	addto   r6, buffer+20, r7, halfaword

</pre>
<p>
Only one subfield in a field of actual arguments can be a 
$EQUF label. Developers wanting to use $EQUF for each of
two operands in a two-address instruction set 
would need to notate each operand as a separate field:
<pre>

left    $equf   input_buffer, a0, d0.w, 4, L        
right   $equf   output_buffer, a1@+,,, L
	.
	.
	eor.l   left right

NOT:::  eor.l   left, right     

</pre>
<p>
In the following assembly, a procedural macro "p" 
retrieves some integer tokens from the $EQUF laBEL and 
uses them to generate integer constants. A flag * can 
be set and retrieved for each subfield. * has a value 
of 1 when it is present.
<pre>

MASMX 7r2
3/equf.msm
*EOF*
  :                            1         $word   32
  :                            2 p*      $proc
  :                            3         +       p(1, 1):S
  :                            4         +       p(1, 2):s
  :                            5         +       p(1, 3)s
  :                            6         +       p(1, 4)s
  :                            7         +       p(1, *1)s
  :                            8         +       p(1, *4)s
  :                            9         $end
  :                            10 
  :                            11 laBEL   $equf   5, 4, 3, *2
00:00000000 00000005          +12         p       laBEL
00:00000001 00000004          +12 
00:00000002 00000003          +12 
00:00000003 80000002          +12 
00:00000004 00000000          +12 
00:00000005 00000001          +12 
*EOF*
:$(00):00000000:00000006 
equf.msm: object code 99 bytes: 0 errors: 0 undefined labels

</pre>
<p>
laBEL is the only argument on the 
"p laBEL" line, and it delivers subfields 1,1 1,2 1,3
and 1,4 (the first four subfields of field 1) to the macro.

<p>
Where a $EQUF label is the second subfield in the field:
<pre>

	mnemonic   register_tag,EQUF_LABEL

</pre>
<p>
then EQUF_LABEL supplies parameters 1,2 1,3 1,4 ...  

<p>
If there are two actual arguments before EQUF_LABEL, the argument
subfields supplied by EQUF_LABEL are 1,3 1,4 1,5...
<pre>

	mnemonic        register_tag, another_register_tag, EQUF_LABEL

</pre>
<p>
Macro language calls its formal arguments <b>p(argument numbers)</b>
if the macro is called <b>p</b>. The macro can be called anything
and can have extra names each attached to a latent parameter value
<p>
The following assembly is for a 32-bit RISC architecture.

<p>
The load/add/store macro generates instructions with a register left-side
operand and a storage right-side operand.

<p>
The left-side operand is a register tag in the range 0..15.

<p>
This register tag is one formal argument on the instruction call line,
and is the first subfield <b>p(1,1)</b> of the one argument field.

<p>
There are 1..3 more formal arguments, and they all describe the
storage operand.

<p>
Macro language calls these last three formal arguments 
<b>p(1,2) p(1,3) p(1,4)</b>. The formal arguments get translated
to the actual arguments

<p>
<b>p(1, 2)</b> is the operand address.

<p>
<b>p(1, 3)</b> is an optional index register tag.

<p>
<b>p(1, 4)</b> is an optional tag describing the size and bit-position of
the operand.

<p>
The RISC architecture has an address quantum of 32 bits.

<p>
Some of its instructions can access fields within 32-bit words using 
a selector encoded in the second quartet of the instruction layout.

<p>
$EQUF names INPUT1 INPUT2 OUTPUT hold an address and maybe an index register and a field designator:
<pre>

MASMX 7r2
3/equf32.msm
*EOF*
  :                            1         $word   32
  :                            2 "$instru" $form        4, 4, 4, 4, 16
  :                            3 
  :                            4 b1      $equ    4
  :                            5 b2      $equ    5
  :                            6 b3      $equ    6
  :                            7 b4      $equ    7
  :                            8 
  :                            9 immediate $equ  1
  :                            10 h1      $equ    2
  :                            11 h2      $equ    3
  :                            12 
  :                            13 r0      $equ    0
  :                            14 r1      $equ    1
  :                            15 r5      $equ    5
  :                            16 r6      $equ    6
  :                            17 r15     $equ    15
  :                            18 
  :                            19 p       $proc
  :                            20 load*   $name   1
  :                            21 add*    $name   2
  :                            22 store*  $name   3
  :                            23         $instru       $n, p(0,2)++p(1,4), p(1, 1), p(1,3), p(1,2)
  :                            24         $end
  :                            25 
  :                            26 code    $equ    1
  :                            27 static  $equ    2
  :                            28 $(static:16384)
  :                            29 buffer  $res    1024
  :                            30 $(code:256)
  :                            31 
  :                            32 INPUT1  $equf   buffer+512, r5, b1
  :                            33 INPUT2  $equf   buffer
  :                            34 OUTPUT  $equf   buffer, r1, h2
  :                            35 
01:00000100 14F54200          +36         load    r15, input1
01:00000101 20F04000          +37         add     r15, input2
01:00000102 33F14000          +38         store   r15, output
  :                            39 
01:00000103 16654200          +40         load    r6, INPUT1,,b3
01:00000104 33654000          +41         store   r6, OUTPUT,r5
01:00000105 33614063          +42         store   r6, OUTPUT+99
*EOF*
:$(01):00000100:00000106 :$(02):00004000:00004400 
equf32.msm: object code 131 bytes: 0 errors: 0 undefined labels

</pre>
<p>
See also base-displacement segments (Sections 4.1.2.1:
Describing Address Spaces: Location Counter Controls).

<p>
With flag <b>-i</b>, sign extended addressing, subfields of a <b>$EQUF</b>
may not be *flagged
<pre>
MASMX 7r2
3/see2it.msm
*EOF*
  :                            1 		$word	16
  :                            2 
  :                            3 r9		$equ	9
  :                            4 r7		$equ	7
  :                            5 
  :                            6 		$set_option	"i"
  :                            7 
  :                            8 
  :                            9 WRITABLE	$equ	1
  :                            10 WRITE_PROTECTED	$equ	-WRITABLE
  :                            11 STACK_FRAME 	$equ	64
  :                            12 
  :                            13 
  :                            14 frame		$equ	-STACK_FRAME
  :                            15 eprom		$equ	0F000
  :                            16 
Error: see2it.msm Line 17: sign extended address may not be *flagged
  :                            17 parameter1	$equf	*frame, r9, WRITABLE
  :                            18 parameter2	$equf	eprom, r7, WRITE_PROTECTED
  :                            19 
  :                            20 . If the flag is retrieved it is the sign bit of the address
  :                            21 
  :                            22 macro*		$proc
  :                            23 		+	macro(1, *1)
  :                            24 		+	macro(1,  2)
  :                            25 		+	macro(1, *3)
  :                            26 		+	macro(1,  3)
  :                            27 		+	macro(1,  1)q
  :                            28 		$end
  :                            29 
00:0000 0001                  +30 		macro	parameter1
00:0001 0009                  +30 
00:0002 0000                  +30 
00:0003 0001                  +30 
00:0004 FFFFFFFFFFFFFFC0      +30 
  :                            31 
00:0008 0000                  +32 		macro	parameter2
00:0009 0007                  +32 
00:000A 0001                  +32 
00:000B FFFF                  +32 
00:000C 000000000000F000      +32 
  :                            33 
*EOF*
:$(00):0000:0010 
see2it.msm: object code 103 bytes: 1 errors: 0 undefined labels
</pre>
<p>
If <b>-i</b> is set and the *flag is retrieved, it is the sign bit
of the address.

<p>
$EQUF is mainly for parameter lists for macros.

<p>
The field values may also be retrieved without a macro.

<p>
The  $EQUF label is referenced directly plus a backslash and a number,
label\?
<pre>

zylabel	$equf	buffer+2047, r15, left_hand_half_extended

</pre>
<p>
zylabel\1 returns the address buffer+2047

<p>
zylabel\2 returns the value represented by tag r15

<p>
zylabel\3 returns the encoding assigned the name "left_hand_half_extended"

<p>
Any values retrieved in this way are net of any relocation attribute.

<p>
The values retrieved are sign-extended to 192 bits.


<p>
The large number of attributes possible in a $EQUF label (six) is aimed
at high-level language development requiring complex attribute information.


<h2>8.16: $EXIT              Stop the Assembly with a Message</h2>

<p>
$EXIT outputs the argument text and exits the assembly, for example:
<pre>

case_required $proc
	$if     $o(k)=0
	$exit   Option -k Required
	$end

</pre>
<p>
The developer needed <b>-k</b> flag (case significant labels) to be set on the
command line.


<h2>8.17: $FLAG              Diagnostic, Mark Assembly in Error</h2>


<p>
Display a message and mark the assembly in error. $FLAG
is actioned on the second pass. Example:
<pre>

	$if     address>64*1024*1024*1024*1024
	$flag   That was a mistake
	$endif

</pre>
<p>
File and line number are listed with the message.


<h2>8.18: $FLAGF             First Pass Diagnostic, Mark in Error</h2>


<p>
Display a message and mark the assembly in error. $FLAGF
is actioned on the first pass and the second pass is not
begun. Example:
<pre>

	$if     length>64*1024*1024*1024*1024
	$flagf  That's never going to work
	$endif

</pre>
<p>
File and line number are listed with the message.


<h2>8.19: $FLOATING_POINT    Default Size of Floating Point Item</h2> 


<p>
$FLOATING_POINT sets the default size of floating point items.

<p>
The default is initially 96 bits:
<pre>

	_______________________________________________________________
	|s|94 exponent 72|71          mantissa                       0|
	|_|______________|____________________________________________|


</pre>
<p>
Floating point numbers are generated automatically when a number
item (command code + - ^) has a decimal point or a scale operator
*+ or *-
<pre>

	+	1.9
	-	MANTISSA*+1200000
	+	1.37*-SCALE

</pre>
<p>
masmx internal floating-point numbers have an all-fractional mantissa with no
integral part whether hidden or represented. The value can be converted to
constants in other formats

<p>
Exponent is midpointed.

<p>
Negative polarity is represented by the entire item in 1-s complement.
Sign-bit 1 indicates that all bits are inverted.

<p>
This is not IEEE 754 format. That is supported with macros.
See Section 1.5: Any floating-point format, Section 10: ieee754


<p>
Octaword on line 11 with 32-bit <b>$word</b> generates 192 bits the same as hexaword.
Numbers in masmx are not larger than 192 bits.

<p>
Scale expression beginning [ e E e+ E+ e- E- ] is only detected in
an all-decimal string containing a decimal point
<pre>

$ masmx hflo -lnky
MASMX 7r3
3/hflo.msm
*EOF*
  :                            1         $word   32
  :                            2         $quantum 8
  :                            3         $awidth 32
  :                            4         $floating_point 32
00:00000000 41C00000          +5         +1.5
00:00000004 401C000000000000  +6         +1.5d
00:0000000C 400001C00000000000000000
                              +7         +0.15t*+1
00:00000018 400001C0000000000000000000000000
                              +8         +15:q*-1
00:00000028 400001C000000000000000000000000000000000
                              +9         +1.5p
00:0000003C BFFFFE3FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
                              +10         -1.5h
Note: hflo.msm Line 11: floating number is maximum words
00:00000054 400001C00000000000000000000000000000000000000000
                              +11         +1.5o
*EOF*
:$(00):00000000:0000006C 

</pre>
<p>
$FLOATING_POINT sets both the default size of a floating number constant,
and also the default range and layout of $set and $equ values which have
floating number arguments
<pre>

	__________________________________________________________________
	|s|190 exponent 168|167          mantissa                       0|
	|_|________________|_____________________________________________|



</pre>
<h2>8.20: $FORM             Map Layout of Bit Structure or Instruction</h2>


<p>
$FORM declares layouts of bitfields into which instruction 
codes and operand addresses and tags can be assembled.

<p>
$FORM can also be used for structures which are not instructions.

<p>
An example of a $FORM is the template of load and store 
instructions in PowerPC:
<pre>

i$type_load_store $form 6, 5, 5, 16

</pre>
<p>
The label of the $FORM is the command name in the code-generating
line of the instruction macro:
<pre>

p       $proc
lwz     $name   32
stw     $name   36
lhz     $name   40
	.
	.
	i$type_load_store $n, p(1, 1), index$\p(1, 2), p(1, 2)
	$end

index$  $func
	$return index$(1, 1)
	$end

</pre>
<p>
The code fragment:
<pre>

ADDRESS $equ    4094        
	lwz     r6, ADDRESS(R31) 
	
</pre>
<p>
is structured per $FORM i$type_load_store to fields of
six, five, five, and sixteen bits containing 32.6.31.4094, or
0x80df0ffe:
<pre>

MASMX/-240 1r1X
q.msm 5
LTERM=#
CONT_CHAR=
STERM=.
*EOF*  :                        2: ADDRESS $equ    4094
00:00000000 80DF0FFE      +3         lwz     r6, ADDRESS(R31)
*EOF*:$(00):00000000:00000004 
Object Code 58 Bytes: 0 Errors: 0 Undefined Labels

</pre>
<p>
A function <b>index$</b> to haul up a base register value from parentheses allows
source code written with the syntax <b>address(Register)</b> to assemble.

<p>
masmx macro language for one-address computers can be written with
the base register as third subfield
<pre>

	lwz	r6, ADDRESS, r31

</pre>
<p>
And the code-generating line can then be
<pre>

	i$type_load_store $n, p(1, 1), p(1, 3), p(1, 2)

</pre>
<p>
The supplied definition "ppc_603.def" processes either syntax.


<h2>8.21: $FUNC              Macro to Produce Operand Value</h2>      

<b>$func</b> is the directive at the head of a function macro, which
returns a value to be used as a token in an assembly-time expression
<pre>

functio* $func	[*]
	.
	.
	$return	<i>VALUE</i>
	$end



f	$func	[*]
fname1*	$name	<i>LATENT_VALUE1</i>
fname2*	$name	<i>LATENT_VALUE2</i>
	.
	.
	$return	<i>VALUE</i>
	$end


</pre>
<p>

See Section <b>4.6: Function Macros</b> for examples

<p>
The optional argument of asterisk on <b>$FUNC</b> directive suppresses
expansion of the <b>$func</b> macro on the first assembly pass

<p>
This is to inhibit a preliminary expansion of a non-idempotent <b>$FUNC</b> macro

<p>
However second-pass-only expansion may cause an anomaly between the first
and second assembly passes, and then the asterisk must be omitted and the
<b>$FUNC</b> macro expands on both assembly passes



<h2>8.22: $HEX               Set Binary Notation to Hex</h2>

<p>
Default binary notation is hex.

<p>
A number string beginning ascii zero is in current binary notation. 

<p>
Therefore 1000 and 03e8 both mean one thousand, unless the opposite
directive
<pre>

	$OCTAL

</pre>
<p>
has been issued. Then 03e8 means three and 01750 means one thousand,
but 1000 still means one thousand.

<p>
the $HEX directive
<pre>

	$HEX

</pre>
<p>
gets hex back.

<p>
Each assembly pass begins in hex mode.

<p>
When hex is on, display is also in hex

<p>
When octal is on, display is also in octal

<p>
$SUFFIX directive (see section 8.50: $SUFFIX Directive) changes
the interpretation of number strings. 

<p>
The <b>-c</b> flag changes number syntax to C language for hex and octal.

<p>
The <b>-m</b> option turns on Motorola $hex syntax and %bit_pattern.



<h2>8.23: $IF                Conditional Assembly</h2>

Part of conditional assembly
<pre>

	$if     expression1
	.
	.
	$elseif expression2
	.
	.
	$else
	.
	.
	$endif




</pre>
<h2>8.24:	$INCLUDE	Include a Source File or a Binary File</h2>		

<h3>8.24.1:	$INCLUDE	Read a Nested Source File</h3>           


<p>
Read and assemble a nested source file. Nesting can recurse
to a depth of 16. 
<pre>

	$include        "target.def"

</pre>
<p>
The default filename extension is .msm

<p>
Therefore
<pre>

	$include	application

</pre>
<p>
reads application.msm

<p>
The following are defaults until definition files change them:

<p>
semicolon is a line continuation character

<p>
The substring separator is colon

<p>
The quote character is "

<p>
The comment character is initially period, but comment character period
is never actioned if it is immediately followed by a nonspace token:
<pre>

	$include	file2.src	
	+		1.5	. floating number	

</pre>
<p>
If an include definition has changed the quote character,
subsequent includes names cannot be bound with "" but may
be bound with the new quote character.

<p>
Special symbols like comment and line continue are not actioned
within quotes
<pre>

	$include	"rough looking;; file. name. "


</pre>

<h3>8.24.2: $INCLUDE,$BINARY	Read a Text Encoded Binary File</h3>

<p>
Linking Directive
<pre>

	$include,$binary	file	$(n, n, n,...

</pre>
<p>
Reads a text encoded binary and submits each text line in it to
the developer-supplied link macro $MAP

<p>
The optional second argument selects and orders the segments to be taken
from the file.

<p>
Without the second argument, all sections are taken from the file and if
they are relocatable, default behaviour collects the segments
exactly in order of appearance.

<p>
Option flag <b>-b</b> causes instead all the relocatable segments of all
the binary files included to be collated by section.

<p>
A cumulative link (where the inputs are relocatable and so are the
outputs) always has the effect of gathering by section.

<p>
Absolute address in the included binaries have the effect
of giving an absolute start addresses to the link.

<p>
An absolute location counter switch before the binary includes
gives an absolute start address to the link:
<pre>

$(0:65536)
	$include,$binary	rel_file1
	$include,$binary	rel_file2

</pre>
<p>
A relocatable location counter switch before the binary includes
causes relocatable segments to be gathered by section and output as
new relocatable segments:
<pre>

$(0:*4)
	$include,$binary	rel_file_A
	$include,$binary	rel_file_B

</pre>
<p>
Specific handling can be applied to each segment of each input file.
See Sections 9.2.2 masmx Linking in Principle, 9.2.3: Demonstration
Links (PowerPC).
The link macro definition including $MAP macro must be already included.

<p>
The default file name extension is txo, as
<pre>

	$include,$binary	"rel_file.txo"

</pre>
<p>
The binary includes must be Text Encoded Binary format. See Section 9:
Output File Formats, Relocation and Linking,
Giant Address Spaces, Interfacing with GNU Tools



<h3>8.24.3: $INCLUDE,$VOID		Bind to an Independent Text Encoded Binary</h3>

<p>
Linking Directive. The default filename extension is .txo
<pre>

	$include,$void	kernel
	$include,$void	absolute_library_bank

</pre>
<p>
include addresses from a text encoded binary file, but do not include
code from it:

<p>
See also Section 9: Output File Formats, Relocation and Linking,
Giant Address Spaces, Interfacing with GNU Tools


<h2>8.25: $INFO       Linking Directive used within $MAP macro</h2>
<h3>8.25.1: $INFO, $OFFSET     Replace Information at the Relocation Stack Top</h3>

<p>
Update relocation information from relocatable input to relocatable
output.

<p>
Applied to the offset value in the tuple at the relocation stack top.

<p>
$offset is the equivalent of addend value in ELF environment.
<pre>

	$info,$offset	expression

</pre>
<p>
Subsequently the $LOAD directive will rewrite the relocation clause to
Text Encoded Binary output from the adjusted relocation tuple on the
internal relocation stack.

<p>
Not all relocation tuples include an offset value, only those which
indicate manipulation (shift/truncate) of the value after relocation.

<p>
In the absence of offset+shift information, the offset is obtained from the code.

<p>
See Section 9: Output File Formats, Relocation and Linking,
Giant Address Spaces, Interfacing with GNU Tools

<p>
New offset carries an adjusted value forward in cumulative links.

<p>
Macro language must take this action where three circumstances combine:
<pre>

	There is a right-shift to be carried out on the offset
	(and therefore there is an extracted offset in the
	relocation clause)

	A segment base address used in the field value
	has moved as a result of relocation

	The output is relocatable

</pre>
<p>
When there is no extracted offset in the relocation tuple, the necessary
adjustment is made by macro language on the code and the relocation tuple
need not be adjusted.

<p>
When the output is absolute, no relocation tuple is stacked.

<h3>8.25.2: $INFO, $RANGE_CHECK
   and   $INFO, $RANGE_CHECK1: Request Linker Automatic Range Checking</h3>
<pre>

	$info,$range_check	value

</pre>
<p>
requests the linker section of masmx to range check value for the
current field size described at the relocation stack top.

<p>
masmx linker section derives the allowable range geometrically according
to the known field size and signed/unsigned attribute at the relocation
stack top.

<p>
Version $RANGE_CHECK of range check is used where the $MAP macro
maintains a 192-bit offset during the successive accumulation of
relocation clauses for one field.

<p>
The check errors if the final value applied does not fit the field.
See Sections 9.2.3.7-8, 9.10: Linking in Giant Space.

<p>
$RANGE_CHECK1 requests more stringent behaviour than $RANGE_CHECK:
where more than one relocation clause applies to one field of code

<pre>

	$info,$range_check1	value

</pre>
$RANGE_CHECK1  also requests masmx linker to range check value for the
field at the relocation stack top. In contrast to RANGE_CHECK, each
addition of a successive relocation tuple (where they are more than one)
to the target field must stay in range.

<p>
If a rightward shift after relocation is requested, intermediate results
must fit a 48-bit offset maintained in the relocation stack. The final result must fit the target field.

<p>
Otherwise each add/subtract must fit the target field.

<p>
See Linker Examples in Section 9.2.3.



<h2>8.26: $LINEWIDTH      Text Encoded Binary Line Length</h2>

<p>
Set the guideline maximum line length for the Text Encoded Binary
outupt. The default is 60 columns.
<pre>

	$LINEWIDTH      expression


</pre>
<h2>8.27: $LIST              Set Inclusion Nest Level for Listing</h2>

<p>
<i><b>$list 0, masking names from list/export</b></i>

<p>
$LIST is initially set to 1, which means the primary assembly
input file is listed but include files are not listed.

<p>
When $LIST is cleared
<pre>

	$list   0

</pre>
<p>
Nothing will be listed. When <b>$LIST</b> is set to more than 1, then 
with option <b>-l</b>, included source is listed to an include nesting
depth of the <b>$LIST</b> value.

<p>
Labels are not catalogued for listing or export when <b>$LIST</b> is 0.

<p>
This allows developers to list the labels in applications without
listing all the names in a complex target machine definition:
<pre>

	$list		0
	$include	ppc_603.def
	$list

</pre>
<p>
However labels which are not catalogued for listing are also not
exported.

<p>
In this example
<b>yasimi</b> is listed  and exported and <b>yadont</b> is not.
<b>yasimi</b> and <b>yadont</b> are both available in this assembly
<pre>

$ cat yasimi.msm
	$word		32
	$quantum	8

$(4:1024)
yasimi*	+	yadont
	$list	0
yadont*	+	yasimi

	

$ masmx -lnxy yasimi yasimi
MASMX 7r2
3/yasimi.msm
*EOF*
  :                            1 	$word		32
  :                            2 	$quantum	8
  :                            3 
  :                            4 $(4:1024)
04:00000400 00000404          +5 yasimi*	+	yadont
*EOF*
YASIMI+=$04:00000400
yasimi.msm=0<00000003
:$(04):00000400:00000408 
yasimi.msm: object code 84 bytes: 0 errors: 0 undefined labels

$ cat yasimi.txo

$04:00000400
00000404 00000400
+YASIMI:$04:00000400
:$04*00000000:00000400:00000408


</pre>

<p>
Here is an extract from a cumulative link source. The
names in reloca.txo must be passed on. But here it is not wished or
needed to list the text encoded binary code from reloca.txo
<pre>

	$list		0
	$include	ppc_map.def
	$list		-1
	$include, $binary reloca
	$list		2
	$include, $binary my_reloc
	$store		newreloc

</pre>
<p>
The names in reloca.txo are catalogued and exported because -1
is not zero. In fact the default <b>$LIST</b> value of 1 would have the
same effect here, because <b>$LIST 1</b> does not list any files
which are included in other files.

<p>
Whenever source is listed, so is any code generated from each 
source line. The following assembled example generates 7500 
labels which have the values name(1)..name(7500) and generates
7500 constants with the value of each label.

<p>
Listing is turned off before name(3) and turned on again
before name(7497)
<pre>


3/names.msm
*EOF*
  :                            1 
  :                            2 this*  $proc
  :                            3         $do     times=3,   $list 0
  :                            4         $do     times=7497, $list 1
  :                            5 name(times)*        +       name(times)
  :                            6         $end
  :                            7 
00:000000 000000              +8 times  $do     7500,   this
00:000001 000001              +8 
00:001D48 001D48              +8 
00:001D49 001D49              +8 
00:001D4A 001D4A              +8 
00:001D4B 001D4B              +8 
*EOF*
:$(00):000000:001D4C 
names.msm: object code 52537 bytes: 0 errors: 0 undefined labels


</pre>
<h2>8.28: $LIT               Set Default Location Counter for Literals</h2>
<pre>

[label] $lit    expression

</pre>
<p>
Identifies the location counter 0..71 in which automatic literals
are generated.

<p>
Automatic literals are by default in counter 0.

<p>
If $LIT has no argument, automatic literals are in
the current location counter.

<p>
If there is a label on a $LIT line, the label is a literal pool tag.

<p>
See Section 4.1.2.1: Describing Address Spaces: Location Counter Controls,
Section 4.2.3.2.2.4.11: Label Types, and 
Section 5: Functions and Literals.

<p>
Automatic literals are literals not triggered by a literal pool
tag (see section 5.2: Literals), but by a leading parenthesis 
on expressions encountered at some syntactical points, chiefly
instruction operands.

<p>
Automatic literals may be generated if option flag <b>-a</b> is on.

<p>
Developers not wishing leading parenthesis on an operand to 
trigger literal generation can let option <b>-a</b> default.

<p>
By default option <b>-a</b> is off, and automatic literals are not
generated.

<p>
Developers who want automatic literals can include option -<b>a</b>
in a target definition include file:
<pre>

	$set_option     "a"

</pre>
<p>
The places where automatic literals may be generated are:
<ul>
	
	If parenthesis is the first symbol of an actual parameter to
	a $form, for example an operand to an instruction:
<pre>

		load    r11, (from_very_high_address)

</pre>
	If parenthesis is the first symbol in an expression in
	a number constant, for example
<pre>

		+       (0ffffff0000000000)
		+       (1*/90), 10:d


</pre>
</ul>
<p>
Line 3 in the following assembly allows automatic literals.

<p>
Lines 5..12 define a minimal instruction set and register set.

<p>
Line 14 defines an address too large to place in the 16-bit
operand address field of the instructions.

<p>
Line 16 initialises location counter 7 to absolute 07000 hex.

<p>
Line 17 switches to location counter 0 and initialises it at 64.

<p>
Line 19 specifies that automatic literals are generated at the
end of locator 7.

<p>
Line 21 loads the address of the literal 00fffc0000000000 into
R11. The assembler first generates the literal 00fffc0000000000
at the address 07000, then places 07000 in the operand field
of the LOAD instruction.

<p>
Line 22 loads the 64-bit value 00fffc0000000000 into R11 from
the address 07000 which had been loaded into R11.

<p>
Line 24 is 64-bit integer value 00fffc0000000000 generated
inline.

<p>
Line 25 is the same as line 24. The parentheses do not make a 
literal, because the leading parenthesis is not the first symbol 
in the expression. The unary plus is.

<p>
In line 26, + signals an integer item, but the expression
when it is encountered begins with a parenthesis. The integer
literal 00fffc0000000000 is found at 00007000 and the item
generated inline is 00007000. The literal is not new, It was
generated at line 21.

<p>
In line 27, the comma between the expressions causes two 16-bit
values to be placed in one 32-bit item. The first of the two
expressions is the literal (00fffc0000000000) which is the literal
at 07000. 07000 is placed in the left half of the word. The
right half is 15 or 000F.

<p>
Line 28 is another pair of 16-bit values. The first is not a
literal because +(0xffee), begins with plus not parenthesis. 
The second is a literal (0xffee) generated at 7008. The
inline result is 0ffee7008.
<pre>


MASMX 7r2
3/lit.msm
*EOF*
  :                            1         $word   32
  :                            2         $quantum 8
  :                            3         $set_option     "a"
  :                            4 
  :                            5 instruction     $form   8, 4, 4, 16
  :                            6 
  :                            7 r11     $equ    11
  :                            8 
  :                            9 p       $proc
  :                            10 load*   $name   99
  :                            11         instruction     $n, p(1,1), p(1,3), p(1, 2)
  :                            12         $end
  :                            13 
  :                            14 with_a_very_high_address $equ   00fffc0000000000
  :                            15 
  :                            16 $(7:07000)
  :                            17 $(0:64)
  :                            18 
  :                            19         $lit    7
  :                            20 
00:00000040 63B07000          +21         load    r11, (with_a_very_high_address)
00:00000044 63BB0000          +22         load    r11,,r11
  :                            23 
00:00000048 00FFFC0000000000  +24         +       00fffc0000000000
00:00000050 00FFFC0000000000  +25         +(00fffc0000000000)
00:00000058 00007000          +26         +       (00fffc0000000000)
00:0000005C 7000000F          +27         +       (00fffc0000000000), 15
00:00000060 FFEE7008          +28         +       +(0ffee), (0ffee)
  :                            29 
*EOF*
07:00007000+00FFFC0000000000
07:00007008+0000FFEE
:$(00):00000040:00000064 :$(07):00007000:0000700C 
lit.msm: object code 196 bytes: 0 errors: 0 undefined labels


</pre>
<h2>8.29: $LOAD		Output Text Encoded Binary</h2>

<p>
Linking Directive
<pre>

	$load,$bits	expression

</pre>
<p>
is used in the developer-supplied $MAP macro to write updated code
to the new Text Encoded Binary output file.

<p>
The subcommand is the code size in bits of the written superword.

<p>
$LOAD is the counterpart of $SET,$BINARY which caches Text Encoded
Binary Input in a label and automatically sets label $BITS to the
size of the superword which has been read:
<pre>

data_label	$set,$binary	superword_parameter

		.
		.

		$load,$bits	data_label

</pre>
<p>
The subcommand does not have to be the automatic label $BITS, but
the same size superword must be written as read.


<h2>8.30: $LTERM             Change Comment Sentinel</h2>
     

<p>
The default $LTERM is period.

<p>
This declaration:
<pre>      
	
	$lterm  03b

</pre>
<p>
or this:
<pre>

	$lterm  ';'

</pre>
<p>
will change the comment sentinel to semicolon. $LTERM can be changed
to any ASCII graphic symbol which is not required for something else.
<pre>

	$lterm  '#'

</pre>
<p>
is the same as
<pre>

	$lterm  023

</pre>
<p>
If # is used as the comment sentinel, it cannot 
also be used as a flag value on the front of 
operand expressions (see Section 4.2.3.2.2.3: 
Macro Parameters.


<h2>8.31: $NAME              Declare Macro Entry Point</h2>         

$NAME is a species of equate.
<pre>

tag     $name   value

</pre>
<p>
When declared within the body of of a procedural macro $PROC
or a functional macro $FUNC, $NAME is used to equate a mnemonic
to an opcode or an input parameter. The purpose of this is to
allow many similar instructions or functions to be declared
in one macro. Then the name must be exported from the macro

tag*	$name	value

<p>
This example from a PowerPC definition shows
the mnemonic in the command field of a line acting as an
entry point to the procedural macro or $PROC, p. 

<p>
The value assigned to the call mnemonic by $NAME
is retrieved during macro expansion as parameter p(0, 1).
This yields the operation code required by the developer.

<p>
32 bits of the value of p(0, 1) may be retrieved via the 
internal function $N in masmx, but $N is not used in the 
PowerPC file because Motorola Hex Notation may be switched on.

<p>
In this example the instruction layout i$4 is filled first with 
a 6-bit opcode p(0, 1). That's followed by a 5-bit register
tag p(1, 1) and a 16-bit storage operand address p(1, 2). 

<p>
A base register may be parenthesised on the trailing end of the 
storage operand  
<pre>

	stw     r2, address(R15)

</pre>
<p>
And that has to be encoded in five bits before the address.

<p>
For efficiency the definition "ppc_603.def" also accepts the plain masmx
syntax for one-address computers and by default adusts source on read:
<pre>

	stw	r2, address, r15

</pre>
<p>
The definition shown instead assigns the parenthesed part of the actual
parameter to a function .f with the function call <b>.f\p(1, 2)</b>
<pre>


i$4     $form   6, 5, 5, 16

.f*     $func
	$return .f(1, 1)
	$end

p       $proc

lwz*     $name   32
lwzu*    $name   33
lbz*     $name   34
lbzu*    $name   35
stw*     $name   36
stwu*    $name   37
stb*     $name   38
stbu*    $name   39
lhz*     $name   40
lhzu*    $name   41
lha*     $name   42
lhau*    $name   43
sth*     $name   44
sthu*    $name   45
lmw*     $name   46
stmw*    $name   47
lfs*     $name   48
lfsu*    $name   49
lfd*     $name   50
lfdu*    $name   51
stfs*    $name   52
stfsu*   $name   53
stfd*    $name   54
stfdu*   $name   55
	
	i$4     p(0, 1), p(1, 1), .f\p(1, 2), p(1, 2)
	$end

</pre>
<p>
An assembly using this definition:
<pre>


MASMX/24592 1r1X
name.msm 5
LTERM=#
CONT_CHAR=
STERM=.
*EOF*  :                        2: 
  :                        3: from    .equ    $ee84
  :                        4: to      .equ    0xc008
  :                        5: 
00:00000000 80C0EE84      +6         lwz     r6, from
00:00000004 98CEC008      +7         stb     r6, to(r14)
00:00000008 4E800020      +8         blr
*EOF*:$(00):00000000:0000000C 
Object Code 76 Bytes: 0 Errors: 0 Undefined Labels

</pre>
<p>
The name LWZ has been recognised and 32 has been placed in the
upper 6 bits of the instruction on line 6. The name STB has been
recognised and 38 has been placed in the upper 6 bits of the
instruction on line 7.


<h2>8.32: $NOP               Do Nothing [+ comment]</h2>
                  
<p>
$NOP directive can introduce a comment without using the comment character
<pre>

	$nop	comment-text

</pre>
<p>
Header files included in assemblies of differing syntax can use $NOP directive
instead of $LTERM character to allow code to be commented.
<p>
$LTERM (comment character) may have a different value (for example # ; .)
in each of many assemblies.
<p>
$NOP may also annul any unused directives in legacy code, for example:
<pre>

preset  equ,$directive     $nop


</pre>
<h2>8.33: $NOTE              Informative Diagnostic, Not Error</h2>   

<p>
$NOTE causes a message to be displayed without causing the 
assembly to fail.

<p>
The push/pop macro nn the definition "8051.def" alerts the
developer to a risky practice with a $NOTE message:
<pre>

p       $proc
push    $name   0c0        
pop     $name   0d0
	$if     p(1,#1)++($t(p(1,1))=POINTER$)++($t(p(1,1))=REGISTERS$)
	  $flag PUSH/POP Direct Addressed IRAM Location or SFR Only
	$else
	  $if $t(p(1,1))=RREGISTERS$
	    $note Caution: RRegister bank might not be at address 0..7
	  $endif
	  i$mova_direct   $n, p(1,1)
	$endif
	$end

</pre>
<p>
There is also a $FLAG in the macro which marks the assembly in error
if the operand is illegal.

<p>
$NOTE displays on the second assembly pass.


<h2>8.34: $NOTEF             First Pass Informative Diagnostic</h2>

<p>
$NOTEF is similar to $NOTE, except it displays on the first
assembly pass.


<h2>8.35: $OCTAL             Set Binary Notation to Octal</h2>         


<p>
$OCTAL causes input number strings with leading zero to be
interpreted as octal and listings to be octal. 
<pre>

	$OCTAL

</pre>
<p>
The default rule is hexadecimal. Assembly always starts in hexadecimal.

<p>
See also 8.22: $HEX directive

<p>
See also Section 6.1: Establishing Your Syntax,
Section 8.51: The <b>$SUFFIX</b> Directive, Section 4.2.3.2.2.1: 
Number Strings (C-Language Octal/Hex Notataion, Motorola 
Hex and Bit-List Notation), and Section 3.1: Command
Line (option flags <b>-mc</b>).


<h2>8.36: $PATH      	     Alter Include Path</h2>

<p>
<b>$path</b> sets a text value to which is prefixed to the
filename arguments of <b>$include</b> directive.

<p>
This encourages related files to be functionally grouped in directories
where a wrapper file may include its functional relations from its own
directory, without naming that directory. So
<pre>

	$path		../math_libs
	$include	math_libs
	$path		../network/ipv4
	$include	netservice.def
	$path		../electromechanical/stepper_type5
	$include	stepper5
	$path
	$include	application7

</pre>
<p>
Then directory <b>../math_libs</b> may contain
<pre>

	ieee754_scan_in.msm	ieee754_format_out.msm
	ieee754_calculate.msm	math_libs.msm

</pre>
<p>
And source file <b>../math_libs/math_libs.msm</b> may contain
<pre>

	$include	ieee754_scan_in
	$include	ieee754_format_out
	$include	ieee754_calculate

</pre>
<p>
Directory <b>../network</b> may contain
<pre>

	../ipv4/	../ipv6/

</pre>
<p>
Directory <b>../network/ipv4</b> may contain
<pre>

	socket.def	netservice.def	rpc.def		xdr.def

</pre>
<p>
Source file <b>../network/ipv4/netservice.def</b> may contain
<pre>

	$include	socket.def
	$include	rpc.def
	$include	xdr.def

</pre>
<p>
Finally the directive <b>$path</b> without an argument cancels
the path prefix, and the next includes are relative to the current
directory.

<p>
Note that Microsoft operating systems recognise the path separator <b>/</b>
as well as <b>\</b> when open calls are made from <b>masmx</b>.

<p>
Therefore there is no need to change any <b>$include</b> or <b>$path</b>
arguments when moving between Unix / Linux developer platforms and Microsoft machines. Just always use <b>/</b>

<h2>8.37: $PLIST             Set Depth for Listing Macro Expansion</h2>


<p>
$PLIST sets the subassembly recursion level to which macro text will
be listed. The default is 0, which means no macro expansions are 
listed.
<pre>

	$plist  3

</pre>
<p>
causes source to be listed to two nested levels of subassembly or
macro expansion, but only if option flag <b>-p</b> or <b>-q</b> is asserted. 

<p>
If <b>-p</b> is off, no <b>$PROC</b> text listed. 
<p>
If <b>-q</b> is off, no <b>$FUNC</b> text listed.

<p>
If <b>-r</b> is on, <b>$PROC</b> and <b>$FUNC</b> text is listed
on the first assembly pass if $PLIST is high enough.
This for problems in macro language which
do not allow the second pass to be reached. Otherwise nothing is
ever listed until the second assembly pass.

<p>
Generated code is listed according to the <b>$LIST</b> level
and <b>-l</b> option, not the <b>$PLIST</b> level and <b>-pq</b> options.


<h2>8.38: $PROC              Declare Procedural Macro</h2>
   

<p>
The head of a procedural macro. $PROC must have a label, but the
label need not be unique. If the label on the $PROC image is not
unique it may not be promoted*, the macro body must contain $NAME entry
points which have unique labels and which are made visible*.

<p>
A $PROC line must be matched with a $END line:
<pre>

aname   $proc
entry*  $name   value        
	.
	.
	$end

</pre>
<p>
When a promoted* label of $PROC or $NAME is in the instruction 
field of a source line, the macro is subassembled.

<p>
This assembly is made more visible futher down. The ljmp/lcall macro
and the nop/ret/reti macro are exposed.
<pre>

MASMX 7r2
3/forjoy.msm
CONT_CHAR=
LTERM=;
QDELIM='
STERM=.
*EOF*
  :                            1:         $include        "8051_7r2.def"
  :                            2 
00:0000 0203EB                +3         ljmp    for.joy
  :                            4         $res    1000
  :                            5 
00:03EB 1203EF                +6 for.joy lcall    for.more
00:03EE 32                    +7          reti
  :                            8 
  :                            9 for.more 
00:03EF 00                    +10         nop
00:03F0 22                    +11         ret
*EOF*
:$(00):0000:03F1 :$(01):0400:0400 
forjoy.msm: object code 81 bytes: 0 errors: 0 undefined labels



</pre>
<p>
One macro defines LJMP and LCALL instructions. The other
defines RET, RETI and NOP instructions.

<p>
Macros don't need unique $PROC names unless they are invoked
by their $PROC names. Both macros in this sample are called 
P. They can only be called by their $NAME entry points, and then
only because the * asterisks make the names* visible.

<p>
Line 165 directs the assembler to start listing lines
from the included 8051 definition header file.

<p>
Line 166 is the structure template for long jump instructions.

<p>
Line 168, not shown, directs the assembler to stop listing 
the include file.

<p>
Line 414 directs the assembler to start listing the include file.

<p>
Line 415 starts declaring a procedural macro called P

<p>
Line 416 declares that if this macro is called by the name
LCALL, it has an nominal value of 18. This value may be retrieved
via the parameter reference p(0,1) or p(0, 0) or the masmx internal
function $N.

<p>
Line 417 declares that if this macro is called by the name
LJMP, it has a nominal value of 2, and 2 will be returned
for p(0, 1) or p(0, 0) or $N.

<p>
Line 418 will generate a 24-bit structure with the nominal call
value $N in the first 8 bits whenever the macro is expanded.

<p>
The second field of the i$long_jump form is given the value of the
first actual argument subfield. That is macro name plus numbers: p(1, 1)

<p>
Line 419 ends the macro.

<p>
Line 421 is not listed because it directed the assembler
to stop listing.

<p>
Line 522 directs the assembler to list the include file.

<p>
Line 523 declares another procedural macro called P

<p>
Line 524 says that if P is called by the name NOP, $n is 0.

<p>
Line 525 says that if P is called by the name RET, $n is 34.

<p>
Line 526 says that if P is called by the name RETI, $n is 50.

<p>
Line 527 generates one data word with the value $n.
The data word is 8 bits in size.

<p>
Line 528 ends of the macro.

<p>
Line 530 is not listed. It directed the assembler to stop
listing the include file.

<p>
The line numbers step down because they are line numbers
of the main file, not an include file.

<p>
Line 3 is an LJMP (long jump, direct address) to location
for.joy.

<p>
Line 4 is a buffer of 1000*address quantum, = 1000 bytes.

<p>
Line 6 is for.joy which is 1000+3 bytes beyond the start
of the assembly. for.joy calls for.more

<p>
Line 9 is for.more
<p>
Line 10 is a 8051 hardware NOP instruction (not a $NOP directive).
<p>
Line 11 is a RET (return) instruction.

<p>
Line 7 is a RETI (interrupt return instruction).
<pre>


MASMX/24592 1r1X
forjoy.msm 5
CONT_CHAR=
LTERM=;
QDELIM='
STERM=.
*EOF*  :                        165:         $list   2
  :                        166: i$long_jump     $form   8,16
  :                        167:         
  :                        414:         $list   2
  :                        415: p       $proc
  :                        416: lcall*  $name   012
  :                        417: ljmp*   $name   002
  :                        418:         i$long_jump     $n, p(1,1)
  :                        419:         $end
  :                        420:         
  :                        522:         $list   2
  :                        523: p       $proc
  :                        524: nop*    $name   0        
  :                        525: ret*    $name   022
  :                        526: reti*   $name   032
  :                        527:         +       $n
  :                        528:         $end
  :                        529:         
  :                        2: 
00:0000 0203EB        +3         ljmp    for.joy
  :                        4:         $res    1000
  :                        5: 
00:03EB 1203EF        +6 for.joy lcall    for.more
00:03EE 32            +7          reti
  :                        8: 
  :                        9: for.more 
00:03EF 00            +10         nop
00:03F0 22            +11         ret
*EOF*:$(00):0000:03F1 :$(01):0400:0400 
Object Code 89 Bytes: 0 Errors: 0 Undefined Labels


</pre>
<p>
A new layer or frame of the label table is constructed in
subassembly, and removed at the end of subassembly. Labels
declared in the macro expansion are not visible to more 
inclusive assembly layers except by design. Labels are 
unique in their subassembly layer (macro depth). 

<p>
Where more than one assembly layer has declared a label with
the same name, references to the label resolve to the declaration
in the most deeply nested macro.

<p>
The subassembly can access all the labels that currently exist.

<p>
To make a label more permanent than the macro expansion 
which declares it, asterisk(s) are suffixed to the label, 
one for each subassembly layer to which the label is promoted:
<pre>

mymacro*   $proc
	.
	.
"label1:p(1,1)"*
"labelx:p(1,1)"**
labely  .
	.
	$end

Start_of_Assembly
	.
	.
	mymacro   athing
	.
	.

</pre>
<p>
In the above example, "label1:athing" is visible to the whole
assembly, because it has one asterisk. 

<p>
Actual parameters can be included in labels names in quotes.

<p>
"labelx:athing" is visible to the whole assembly and to links. 
It has one more asterisk than the macro depth.

<p>
"labely" isn't visible outside the macro expansion.


<p>
If a $PROC macro has forward references to local labels, the macro must
be scanned twice on the second assembly pass. These $PROCs are called
two-pass $PROCs. They are marked by an asterisk argument of asterisk *
on the $PROC line:
<pre>


PUSHACC* $proc	*
	PUSH    ACC
	MOV     stackcheck,SP
	JB      stackcheck.7, StackOk
	JMP     ColdBoot
StackOk:
	$end

</pre>
<p>
The label StackOK is not exported from the macro expansion. Therefore
it stopped existing when the macro exited on the first assembly pass.
So the macro needs a preliminary pass on the second main assembly pass.

<p>
A $PROC line can have a location counter argument in syntax $(n)
as first argument or second argument after the 2-pass flag:
<pre>

p	$proc	$(20)
nomen*	$name
	.
	.
	$end

macby*	$proc	* $(50)
	.
	.
	$end

</pre>
<p>
Then code generated in the proc is in the named segment, and
location counter at the time of calling is switched back after.

<p>
If any line in a $PROC contains a label of * asterisk alone,
the label on the $PROC call line is reassigned as if it
appeared where the asterisk is.

<p>
In this assembly, "buffer1" and "buffer2" are declared in 
location counter 1. There is no break between the instructions
generated in location counter 0.
<pre>


MASMX/24592 1r1X
var.msm 5
CONT_CHAR=
LTERM=;
QDELIM='
STERM=.
*EOF*  :                        125:         $list   2
  :                        126: var*    $proc   $(1)
  :                        127: *       $res    var(1,1)
  :                        128:         $end
  :                        677:         $list   2
  :                        678: $(1:1024)
  :                        679: $(0:0)
00:0000 020006        +2         jmp     here
00:0003 020009        +3         jmp     there
  :                        4: buffer1 var     1024
  :                        5: buffer2 var     512
00:0006 900400        +6 here    mov     dptr, #buffer1
00:0009 900800        +7 there   mov     dptr, #buffer2
  :                        8: 
*EOF*:$(00):0000:000C :$(01):0400:0A00 
Object Code 92 Bytes: 0 Errors: 0 Undefined Labels


</pre>

<h2>8.39: $PUSHREL	Acquire a Relocation Tuple from a Superword</h2>

<p>
Linking directive
<pre>

parameter_label		$pushrel	relocation_clause

</pre>
<p>
used in the $MAP macro. $PUSHREL scans a relocation clause in Text
Encoded Binary input and tables the relocation attributes in the label
of the $PUSHREL line.

<p>
Therefore $PUSHREL must have a label.

<p>
$PUSHREL gives this label the type $EQUF. Macro Language can now use
it as a list containing three or five values.

<p>
The address value, subfield 1 of the $EQUF, is the relocation
base to be applied.

<p>
These attributes can be retrieved:
<pre>

parameter_label\1 	is the relocation value to be added to the
			superword data (i. e. to the code)

parameter_label\2	the number of bits in the target field to
			which the relocation value is added

parameter_label\3	is the left shift scale at which the relocation
			value is added to the superword data

_______________________________________________________________________
Parts \4 and \5 present if the target field is split or right-shifted
_______________________________________________________________________

parameter_label\4	is the addend value if it needed to be encoded
			separately in Text Encoded Binary.

			This offset value is normally in the superword
			data, but if assembly macro language shifted
			a relocatable value right: 

			part \4 contains the unrelocated and unshifted
			value;

			and part \5 contains the right shift count:

parameter_label\5	right shift count encoded as a negative integer:
 			to be applied to the separately delivered
			offset in part \4 after it has been relocated


</pre>
<p>
When the absolute address space is 32 bits or less, the relocation
value is the address part of the $pushrel label. This is the same
as part \1 of the pushrel label, except for sign extension.

<p>
The expression
<pre>

	parameter_label\1

</pre>
<p>
would be sign-extended from bit 31, so it is better to extract the
principal $EQUF value address-fashion:
<pre>

value	$set	parameter_label

</pre>
<p>
And that yields 32 bits unsigned, or signed if Flag -I is set.

<p>
When the absolute address space is between 33 and 192 bits, the
large relocation value is retrieved with a second $PUSHREL and
not from the label holding the parameter list:
<pre>

value	$pushrel,$long_absolute		relocation_clause

</pre>
<p>
A $MAP link macro consists of an outer loop which submits superwords
from the line of Text Encoded Binary to an inner macro, and of an inner
macro which caches the code part of the superword, and submits each
relocation tuple attached to it to another macro where the relocation
is applied to the code: 
<pre>

p	$proc
"$map"*	$name

p	$proc
superword* $name
clauses	$set	p(1,1:)	. The relocation clauses in TXO are substrings
			. The last substring is the code

data	$set,$binary	p(1,1:clauses)	. cache the code = last substring


clause	$do	clauses-1,	relocate	p(1,1:clause)

	load,$bits	data	. $bits is automatic from $set,$binary
				. write the code

	$end	. of SUPERWORD

p	$proc
relocate* $name

rel_params $pushrel	p(1, 1)

value	$set	rel_params\1

bits    $set    rel_params\2
scale   $set    rel_params\3
offset  $set    rel_params\4
descant $set    label1\5

limit   $set    1*/bits
mask    $set    limit-1
unmask  $set    ^(mask*/scale)

	$do	ENVIRONMENT=64,;
value	$PUSHREL,$LONG_ABSOLUTE	p(1, 1)

	$if	descant<0
field	$set	value+offset
	$info,$range_check1	field
	$info,$offset		field
field	$set	field*/descant
	$else
field	$set	value+(($data/*scale)**mask)
	$info,$range_check1	field
	$endif

"$data"* $set	((field**mask)*/scale)++($data**unmask)

.  label data* must be promoted in order to be the label "data" known
.  to the calling macro and not a new "data" only known in this macro

	$end	. of RELOCATE

index	$do	p(),	superword	p(index, 1)
	$end	. of $MAP

</pre>
<p>
If a relocation clause does not go absolute at $PUSHREL, $PUSHREL also tables a relocation tuple internally.

<p>
This relocation tuple may need adjusting with $INFO directive, because
a new in-segment displacement may have been summed.

<p>
$LOAD outputs all relocation tuples not absolutely resolved as new
relocation clauses in the output Text Encoded Binary.

<p>
Output code generation, of which $LOAD is an example, forwards
unresolved relocation tuples. All internally stacked  relocation
tuples have been actioned and are removed.

<p>
See Section 9: Output File Formats, Relocation and Linking,
Giant Address Spaces, Interfacing with GNU Tools


<h2>8.40: $QUANTUM           Select Bit Size of Addressed Object</h2>

<p>
$QUANTUM must be set to 8 for target machines which address bytes.

<p>
$WORD directive sets $QUANTUM to the value of $WORD. If the address
quantum is not the word size, $QUANTUM must follow $WORD:
<pre>

	$word   32
	$quantum 8


</pre>
<h2>8.41: $QUOTE            Select Character for Bounding Text Strings</h2>


<p>
Sets the quote character
<pre>

	$quote	''''

</pre>
<p>
Default is " character.

<p>
When the quote character is encountered in the instruction field,
or in a field of a  $FORM, it bounds a text string:
<pre>

	"Text Constant"
	.
	.
descriptor $form        16, 48
	descriptor      VALUE, "Label"


</pre>
<p>
If quote character appears in column one, or in an expression, it bounds a
label. This allows labels beginning $ to be declared.
<pre>

MASMX/24592 1r1X
dollar1.msm 5
*EOF*  :                        1:         $word           16
  :                        2: $(6:06000)
  :                        3: "$handle"
  :                        4:         $res    10
06:600A 000A          +5         +       $-$handle
  :                        6: 
*EOF*:$(06):6000:600B 
Object Code 38 Bytes: 0 Errors: 0 Undefined Labels


</pre>
<p>
When -M Flag (Motorola Hex) is on, labels beginning $
can still be understood in expressions if they have quotes
around them:
<pre>

MASMX/24592 1r1X
dollar.msm 5
CONT_CHAR=
LTERM=;
STERM=.
*EOF*  :                        1:         $word           16
  :                        2:         $cont_char       0       . No Continuation
  :                        3:         $lterm          ';'     . comment is ;
  :                        4:         $sterm          '.'     ; sub.string is .
  :                        5:         $set_option     "m"     ; Motorola Hex
  :                        6: $(6:06000)                      ; Locator 6, base 24K
  :                        7: "$handle"                       ;
  :                        8:         $res    10              ; Buffer 10 Words
  :                        9: .locator $equ,"$function" "$"   ; Alias Location Counter
06:600A 0010          +10         +       .locator-"$handle"+$6
  :                        11: 
*EOF*:$(06):6000:600B 
Object Code 38 Bytes: 0 Errors: 0 Undefined Labels

</pre>
<p>
The "legal" character set for labels is       
<pre>

		$ 
		A..Z 
		a..z 
		0..9 
		@ 
		! 
		? 
		_ (underscore)

</pre>
<p>
and the currect $STERM which is default colon but often
set to period.

<p>
Labels bounded with $QUOTE may contain characters which are not 
otherwise included in labels: 

<pre>

$ masmx -l
MASMX 7r2
0/-INPUT>>
	$word	32
	$quantum 8
$(5:050000)
index   $do	9,	+	100-index
"unconventional \ rough { label"
	$res	12
	+	"unconventional \ rough { label"
	$end
  :                            1  $word 32
  :                            2  $quantum 8
  :                            3 $(5:050000)
05:00050000 00000063          +4 index $do 9, + 100-index
05:00050004 00000062          +4 
05:00050008 00000061          +4 
05:0005000C 00000060          +4 
05:00050010 0000005F          +4 
05:00050014 0000005E          +4 
05:00050018 0000005D          +4 
05:0005001C 0000005C          +4 
05:00050020 0000005B          +4 
  :                            5 "unconventional \ rough { label"
  :                            6  $res 12
05:00050030 00050024          +7  + "unconventional \ rough { label"
  :                            8  $end
:$(05):00050000:00050034 
-INPUT>>: object code 148 bytes: 0 errors: 0 undefined labels

</pre>
<p>
It's also possible to declare a label which begins with a decimal
digit, but it couldn't be referenced without $QUOTE:
<pre>

MASMX/24592 1r1X
nuri.msm 5
*EOF*  :                        1: $(4:0480)
  :                        2: 123OLeary
04:000480 000481        +3         +       "123OLeary"+1       
*EOF*:$(04):000480:000481 
Object Code 48 Bytes: 0 Errors: 0 Undefined Labels

</pre>
<p>
If quote character is changed to apostrophe, it cannot be used to bound
labels in expressions. Apostrophe has a fixed meaning in expressions.
The expression gets the bit-pattern value of the contained characters
in the current size and character code, by default 8-bit ASCII.

<p>
In this assembly an unconventional label is declared sucessfully but
can not be referenced:
<pre>

$ masmx vr -lx
MASMX 7r2
3/vr.msm
QDELIM='
  :                            1  	$quote	''''
  :                            2 
  :                            3 	$word 32
  :                            4 	$quantum 8
  :                            5 $(5:050000)
05:00050000 00000063          +6 index	$do	9,	+	100-index
05:00050004 00000062          +6 
05:00050008 00000061          +6 
05:0005000C 00000060          +6 
05:00050010 0000005F          +6 
05:00050014 0000005E          +6 
05:00050018 0000005D          +6 
05:0005001C 0000005C          +6 
05:00050020 0000005B          +6 
  :                            7 'unconventional \ rough { label'
  :                            8 	$res 12
05:00050030 656E74696F6E616C205C20726F756768207B206C6162656C
                              +9 	+	'unconventional \ rough { label'
  :                            10 	$end

  :

  :

vr.msm=0<00000003
INDEX=00000009
UNCONVENTIONAL \ ROUGH { LABEL=$05:00050024
:$(05):00050000:00050048 
vr.msm: object code 188 bytes: 0 errors: 0 undefined labels


</pre>
<h3>8.41.1: Quoted Strings and Labels within Macro Expansions</h3>


<p>
When labels are in quotes in a macro, the quotes can
contain argument paraforms which are replaced with
actual parameters.


<p>
An expression token in quotes is expected to be a label.
<pre>


MASMX 7r2
3/quo.msm
*EOF*
  :                            1 p*       $proc
  :                            2 "name:p(1,1)"
  :                            3         +       "name:p(1,1)"+0c0000
  :                            4         $snap    2
  :                            5         $end
  :                            6 $(0:64)
00:000040 0C0040              +7         p       yes
NAME:YES=$00:000040
*EOF*
:$(00):000040:000041 
quo.msm: object code 44 bytes: 0 errors: 0 undefined labels

</pre>
<p>
If the value of $QUOTE is apostrophe, a 'label' in 
column 1 can be constructed and defined, catenating 
parameters with other symbols; 

<p>
however 'characters between apostrophes' in an 
expression have  their own immediate value without 
substitution, +'label'=0000006c6162656c. 

<p>
Therefore when $QUOTE is an apostrophe or 0x27, 
labels may only be included in expressions without 
surrounding $QUOTE. Consequently, labels in the 
actual arguments may be referenced, but not catenated 
with new symbols to construct new labels for reference:
<pre>

MASMX 7r2
3/quo1.msm
QDELIM='
*EOF*
  :                            1         $quote  027
  :                            2 p*      $proc
  :                            3 'name:p(1,1)'
  :                            4         +       'name:p(1,1)'+0c0000
  :                            5         +       name:no+0a0000
  :                            6         $snap    2
  :                            7         $end
  :                            8 $(0:64)
00:000040 00006E616D65466E6F  +9         p       no
00:000043 0A0040              +9 
NAME:NO=$00:000040
*EOF*
:$(00):000040:000044 
quo1.msm: object code 63 bytes: 0 errors: 0 undefined labels


</pre>
<p>
The quote character in the command or instruction position always 
means a text string, and within a macro, parameter substition
takes place. 
<pre>

MASMX 7r2
3/quo3.msm
*EOF*
  :                            1 p*      $proc
  :                            2 "name:p(1,1)"
  :                            3         "name:p(1,1)"
  :                            4         $snap    2
  :                            5         $end
  :                            6 $(0:64)
00:000040 6E616D653A5365655F446174613F20
                              +7         p       See_Data?
NAME:SEE_DATA?=$00:000040
*EOF*
:$(00):000040:000045 
quo3.msm: object code 68 bytes: 0 errors: 0 undefined labels


</pre>
<p>
A field of a $FORM all in quotes also means a string, and in a 
macro expansion, parameter substitution takes place:
<pre>

MASMX 7r2
3/quo4.msm
*EOF*
  :                            1 f       $form   16, 104
  :                            2 p*      $proc
  :                            3 "name:p(1,1)"
  :                            4         f       -6, "!p(1,1)!"
  :                            5         $snap    2
  :                            6         $end
  :                            7 $(0:64)
00:000040 FFFA215365655F446174613F212020
                              +8         p       See_Data?
NAME:SEE_DATA?=$00:000040
*EOF*
:$(00):000040:000045 
quo4.msm: object code 68 bytes: 0 errors: 0 undefined labels


</pre>
<p>
If the "!p(1,1)!" is meant to be a label and not the string of its
character values, adding a unary sign will change the string to
an expression and the label will be searched:
<pre>

	f	-6, +"!p(,1 1)!"

</pre>

<h2>8.42: $record</h2>
<h3>8.42.1: $record		bit-aligned data structures</h3>
<h3>8.42.1: $record,$branch	bit-aligned structure overlay</h3>


<h2>8.43: $RES               Declare a Storage Buffer</h2>             

<p>
$RES declares a buffer, i.e. it advances the current location
counter.

<p>
By default no code is loaded in $RES storage

<p>
<b>-Z</b> option causes the buffer to be zero-filled instead

<p>
$RES intervals in $PROC structures generated as literals
are always zero-filled


<pre>

$(1:1024)
buffer_name     $res    100
buffer_2        $res    40

</pre>
<p>
has the effect that "buffer_name" has a value of 1024,
and represents a location 0400 in counter 1.

<p>
"buffer_2" has a value of 1124 and represents location 0464 in counter 1. 

<p>
If address quantum is less than word size, it's sometimes necessary
to align after $RES.
<pre>

MASMX 7r2
3/linitup.msm
*EOF*
  :                            1         $word   32
  :                            2         $quantum 8
  :                            3 
  :                            4 line_up* $proc
  :                            5 granule $set    line_up(1,1)    
  :                            6         $res    ($+granule-1**-granule)-$
  :                            7         $end
  :                            8 
  :                            9 $(12:0780000)
  :                            10 first_buffer    $res    17
  :                            11         line_up 4
  :                            12 second_buffer   $res    19
  :                            13         line_up 4
  :                            14 end_buffers
0C:00780028 00780000          +15         +       first_buffer
0C:0078002C 00780014          +16         +       second_buffer
0C:00780030 00780028          +17         +       end_buffers
*EOF*
:$(0C):00780000:00780034 
linitup.msm: object code 72 bytes: 0 errors: 0 undefined labels

</pre>

<h2>8.44: $RETURN            Return a Value from $FUNC..$END</h2>

<p>
$RETURN may be used to jump out of any macro <b>$PROC..$END</b>
or <b>$FUNC..$END</b>

<p>
Function $RETURN delivers the value of its argument.

<p>
The function HIGH in the following example returns the upper
8 bits of a 16-bit value:
<pre>

MASMX/24592 1r1X
high.msm 5
CONT_CHAR=
LTERM=;
QDELIM='
STERM=.
*EOF*  :                        628:         $list   2
  :                        629: high*   $func
  :                        630: v       $set    high(1,1)        
  :                        631:         $return v/*8
  :                        632:         $end
  :                        2: 
  :                        3: 
  :                        4: 
00:0000 00AA          +5         +       high(170*256)
*EOF*:$(00):0000:0002 :$(01):0400:0400 
Object Code 59 Bytes: 0 Errors: 0 Undefined Labels

</pre>
<p>
Functional results are 192 bits.
 


<h2>8.45: $ROOT              Foot of Structured Name Space</h2>

<p>
$ROOT is the end of a structured name space. See Section
8.53: $TREE, 8.4: $BRANCH



<h2>8.46: $SET               Assign Reassignable Value to Label</h2>


<p>
$SET is a temporary equate. A label may be set many times, and
$SET is actioned on both first and second assembly passes.

<p>
The label may be set to any value which can be expressed
in 192 bits.
<pre>

label   $set    262144*/160
label2	$set	262.144e+3*/160

</pre>
<p>
A <b>$set</b> label can reference itself the first time it is declared.
Its value is zero.
<pre>

increment $equ	6
label_new $set	label_new+increment

</pre>
<p>If <b>label_new</b> was never mentioned before, its value is now 6.
Otherwise undeclared labels can only be interrogated for their type,
which is zero
<pre>

	$do	$t(alabelname)=0,	....

</pre>
<h2>8.47: $SET_OPTION</h2>

<h3>8.47.1:Set Option Flags</h3>

<pre>



	$set_option     "a..z"

</pre>
<p>
sets the option flags which can otherwise be set on the command
line:
<pre>

       >masmx input [output] -a..z

</pre>
<p>
Therefore if the command line is
<pre>

       >masmx source1 -klm

</pre>
<p>
and source1.msm contains 
<pre>

	$set_option     "pno"

</pre>
<p>
The total effect is the same as
<pre>

       >masmx source1 -klmnop

</pre>
<p>
The option letters are case significant.
<b>-QZ</b> are different options from <b>-qz</b>

<p>
Flags <b>-ksy</b> are only actioned on the command line,
not via <b>$set_option</b> directive

<h3>8.47.1: Interaction of Run Options and List Directives</h3>


<p>
<b>$LIST</b> and <b>$PLIST</b> directives interact with options
<b>-lpqr</b> in these ways:
<pre>

	$list   0

</pre>
<p>
prevents source or generated code from printing at all. Labels declared
or imported while <b>$list</b> is zero are also not listed or exported.
see Section 8.28: <b>$list 0</b>, masking names from list/export
<pre>

	$list   1

</pre>
<p>
prints the main file and generated code if option <b>-l</b> is on.
The default value is 1.

<p>
The larger the <b>$list</b> value, the deeper nested includes are listed.
If flag <b>-l</b> is off, only summary information is listed.

<p>
If flag <b>-w</b> is on, assembly is silent and summary information
is not listed.

<p>
<b>$PLIST</b> directive interacts with <b>-pqr</b> options:        
<pre>
	
	$plist  0

</pre>
<p>
prevents all macro expansion from printing.
<pre>

	$plist  2

</pre>
<p>
displays <b>$PROC</b> macro language one macro deep if <b>-p</b> is on, and
<p>
displays <b>$FUNC</b> macro language one macro deep if	<b>-q</b> is on.

<p>
The larger the value of <b>$plist</b>, the deeper nested macro language
is displayed.

<p>
<b>-r</b> flag allows macro language up to <b>$plist</b> depth to be displayed
on the first assembly pass. This is for investigating serious problems
in macro language which prevent a second assembly pass. Otherwise
nothing is listed until the second assembly pass.

<p>
The option values are listed in Section 3.1: The Command Line



<h2>8.48: $SNAP              List Label Table</h2>


<p>
$SNAP lists labels. Default behaviour is to list the fixed part 
of the label table in load order, or sorted if <b>-y</b> flag has been opted.
$SNAP may take an argument
<pre>

	$SNAP	expression

</pre>
<p>
$SNAP lists the fixed part of the label table unless the argument
expression has the value 2
<pre>

	$SNAP		2

</pre>
<p>
With an argument of 2, $SNAP lists the labels which exist temporarily
during macro expansion. The $SNAP directive is inside the macro text
in order to achieve this
<pre>

mymacro* $proc
	.
	.
	$snap		2
	.
	.
	$end

</pre>
<p>
$SNAP is only actioned during the second assembly
pass, unless it has a subcommand of 1 
<pre>

	$SNAP,1		[argument 0..2]

</pre>


<h2>8.49: $STERM             Change the Substring Sentinel Character</h2>
<pre>

	$term	divider_character

</pre>
<p>
The substring character is changed to the value of the $TERM argument.
The substring character is
<ul>

	<li>-a character in a label

	<li>-the divider between substrings:of:subfields in parameter
	 actual arguments

	<li>-a join in a structured label

	<li>-a join in a text string

</ul>
<p>
The default value of $STERM is colon : 

<p>
In the following assembly

<p>
Line 4 changes $STERM to period. Here period
is a term in a label.

<p>
Line 16 in nested macro "q" resolves q(1,1) 
to the label on line 6, "p3.1" = 32+1

<p>
Line 17 in nested macro "q" resolves q(1,1:1) from "p3.1"
to the label on line 5, "p3" = 32.

<p>
The paraform q(1,1:1) looks for the substring divided by the substring
terminator. Whatever the current value of the substring terminator,
paraforms which search for substrings contain the colon character.
<pre>

then    q(1,1:2) is 1 from p3.1
	
	q(1,2:1) is -32 from -p3.1
	q(1,2:2) is 1 from -p3.1

Then "p" calls "q" again and

	there isn't a label "10.9", so q(1,1) is 10

then    q(1,1:1) is 10 from 10.9
	q(1,1:2) is 9 from 10.9....

MASMX 7r2
3/sterm.msm
CONT_CHAR=\
LTERM=;
STERM=.
*EOF*
  :                            1         $word   16
  :                            2         $cont_char '\'
  :                            3         $lterm  ';'
  :                            4         $sterm  '.'
  :                            5 p3      $equ    32
  :                            6 p3.1    $equ    32+1
  :                            7 
  :                            8 p*      $proc
  :                            9 *       $tree
  :                            10 times   $do     p(1),branch(times)*  q p(1, times), -p(1, times)
  :                            11         $root
  :                            12         $end
  :                            13 
  :                            14 q*      $proc
  :                            15 *       $tree
  :                            16 h       +       q(1,1)
  :                            17 again   $do     2,leaf(again)   + q(1,again:1), q(1,again:2)
  :                            18         $root
  :                            19         $end
  :                            20 
00:0000 0021                  +21 trunk   p       p3.1, 10.9, 8.8
00:0001 2001                  +21 
00:0002 E001                  +21 
00:0003 000A                  +21 
00:0004 0A09                  +21 
00:0005 F609                  +21 
00:0006 0008                  +21 
00:0007 0808                  +21 
00:0008 F808                  +21 
  :                            22 
00:0009 0008                  +23         +       trunk.branch(3).leaf(2)
  :                            24         
00:000A 4669727374204C696E65206F6620546578740A5365636F6E
                              +26         	"First Line of Text".10."Second Line of Text".10.\
        	"Third Line of Text".12
00:0016 64204C696E65206F6620546578740A5468697264204C696E
                              +26 
00:0022 65206F6620546578740C  +26 
  :                            27 
*EOF*
:$(00):0000:0027 
sterm.msm: object code 198 bytes: 0 errors: 0 undefined labels

</pre>
<p>
In Line 23 the $STERM character, currently ".", is used to
identify components of a hierarchic structure "trunk".."branch".."leaf"
which was constructed by nested $TREE..$ROOT directives
-see section 8.54: $TREE directive

<p>
In lines 26..27 $STERM connects parts of a text string. Here $STERM
is used to include linefeeds and formfeeds on the string.

<p>
Whatever substring terminator has been set to, macro language
interrogates for substrings with the colon : character
<pre>

	p(1,1:)		how many substrings in subfield 1

	p(1,1:1)	value substring 1 in subfield 1

	p(1,1:*1)	unary * from substring 1 in subfield 1

	p(1,1:#1)	unary # from substring 1 in subfield 1


</pre>
<h2>8.50: $STORE		Set Default Output Name</h2>

<p>
Directive <b>$STORE</b> sets a default name for the file where the output
text encoded binary is stored. A second filename on the command line
overrides the <b>$STORE</b> name
<pre>

	$store	filename

</pre>
<p>
The default filename extension is txo
<pre>

	$store	reloca1

</pre>
<p>
is the same as
<pre>

	$store	"reloca1.txo"

</pre>
<h2>8.51: $SUFFIX    Use Suffix for Number String Interpretation</h2> 


<p>
Suffix flags on number strings are supported for Intel-style source code

<p>
$SUFFIX setting can be set to 0, 1 or 2, and the default is 0.
<pre>


	$suffix 0       ; suffix letters are not used
			; for interpreting number strings

	$suffix 1       ; suffix letters ..D ..d	= DECIMAL
			;                ..H ..h 	= HEX
			;                ..B ..b	= BIT PATTERN
			;                ..Q ..q ..O ..o =OCTAL
			

			; default is decimal except leading zero = hex

	$suffix 2       ; as "$suffix 1", except default is always decimal.

</pre>
<p>
When $SUFFIX is 1, then a string beginning 0 is interpreted as
hex (or octal if $OCTAL is set ), when there is no actual suffix.

<p>
Default with first digit 1..9 is decimal

<p>
When $SUFFIX is 2, any number string is decimal when there is no actual
suffix.

<p>
Suffix letters are only examined on a number string beginning
with a digit 0..9.

<p>
decimal/hex/octal/bit-binary suffixes do not
conflict with the size flags which can appear at the
trailing end of masmx number constants.

<p>
These are 
<ul>

	:S		one word

<pre></pre>
	:D or :L	two words

<pre></pre>
	:T		three words

<pre></pre>
	:Q		four words

<pre></pre>
	:P		five words

<pre></pre>
	:H		six words

<pre></pre>
	:O		eight words


</ul>
<p>
The length override is the last token on a number item line.

<p>
It is recognised first and the value expression is inside it.

<p>
Where a notation suffix D Q H O is the last symbol in a number
string token, any size override goes after it:
<pre>

MASMX 7r2
0/-INPUT>>
        $word   16
        $suffix 2

        +0bbbbhq
        $end
  :                            1  $word 16
  :                            2         $suffix 2
  :                            3 
00:0000 000000000000BBBB      +4         +0bbbbhq
  :                            5         $end
:$(00):0000:0004 

</pre>
<p>
Number suffix notation is mostly encountered in macros, because suffixes
appear on instruction operands and on the arguments of pseudo-directives
like DD and DW. All of these are macros for masmx:
<pre>

MASMX/24592 1r1X
dde.msm 5
CONT_CHAR=
LTERM=;
QDELIM='
STERM=.
*EOF*  :                        46:         $list           2
  :                        47:         $word           8
  :                        48:         $byte           8
  :                        49:         $quantum        8
  :                        50:         $awidth         16

  :                        81:         $list   2
  :                        82: dd*     macro
  :                        83:         $do     dd(1)
  :                        84: v       $set    dd(1,$d+1)        
  :                        85:         +       v, v/*8, v/*16, v/*24:q
  :                        86:         $endo
  :                        87:         macend

00:0000 01000063      +2         dd      99*4096*4096+1, 63h*4096*4096+2 
00:0004 02000063      +2 
*EOF*:$(00):0000:0008 :$(01):0400:0400 
Object Code 71 Bytes: 0 Errors: 0 Undefined Labels


</pre>
<h2>8.52: $TEXT              Translate Input Text Patterns</h2>

<p>
$TEXT directive is used for syntax translations which cannot
be reached any other way. Examples are where source code
contains operators which are not the masmx operators:
<pre>

	$text   \ div \/\
	$text   \ shl \*/\
	$text   / and /**/

</pre>
<p>
All the <b>$TEXT</b> patterns must be placed adjacent to each other
in the assembly header. Any separated from the first block of
them will not be used.



<h2>8.53: $TRACE             Display Value</h2>
        
<p>
Directive
<pre>

	$trace	argument

</pre>
<p>
Displays the value of its argument
<pre>


p       $proc
add     $name   1
subtract $name  2
	aform   $n, p(1,1), p(1,2)
	$trace  p(1, 1)
	$end

</pre>
<p>
That would show the left side operand of the add or subtract
instruction.

<p>
To produce $TRACE on the first assembly pass, a subcommand
of value 1 is added:
<pre>

	$trace,1        ...


</pre>
<p>
When a macro actual argument is an automatic literal, $TRACE
obtains the literal value and not the literal address


<h2>8.54: $TREE              Head of Structured Name Space</h2>


<p>
$TREE is used to structure a name space containing data or code.

<p>
The structure is ended with $ROOT. The tree must 
have a label:
<pre>

name    $TREE
	.
	.
	$ROOT

</pre>
<p>
$TREE may be nested to a depth of 8 for a hierarchy of structures.
$TREE may be inside a $PROC macro or not. If a $TREE is inside a
$PROC, the label of the $TREE may be the inherited label from
the macro call line, for example
<pre>

p       $proc
species $name
*       $tree
many    $do     p(),branch(many)   $res    4
	$root
	$end

</pre>
<p>
In the following assembly, an 8051 system has four UARTs each
with their eight register files located nearly adjacent at
XRAM addresses 128..135, 144..151, 160..167, 176..191:

<p>
The input side of a device driver scans each receive channel.
The code is generated using a structure with subscripted
components. 30 bytes of code is generated to scan each UART
for input. A developer might choose to do this with a variable
pointer instead, but this sample shows how to do it with trees
of structured names:
<pre>


$ masmx uart -lnx
MASMX 7r3
3/uart.msm
CONT_CHAR=
LTERM=;
QDELIM='
STERM=.
*EOF*
  :                            3 	$list
  :                            4 
  :                            5 LSR_RDR EQU     0       ; Data In Receive FIFO
  :                            6 
  :                            7 serial*  $proc  	$(2)
  :                            8         $res    (($+15)**-16)-$
  :                            9 *       $tree          
  :                            10 rhr
  :                            11 thr     $res    1
  :                            12 ier     $res    1
  :                            13 isr     $res    1
  :                            14 lcr     $res    1
  :                            15 mcr     $res    1
  :                            16 lsr     $res    1
  :                            17 msr     $res    1
  :                            18 spr     $res    1
  :                            19         $root
  :                            20         $end
  :                            21 
  :                            22 '$bit'*	$func
  :                            23 	$do	$bit(1,1:1)<128,	$return (($bit(1,1:1)**31)*/3)++$bit(1,1:2)
  :                            24 	$return	$bit(1,1:1)++$bit(1,1:2)
  :                            25 	$end
  :                            26 
  :                            27 generate* $proc *
  :                            28 Sample:
  :                            29         jb      $bit(FULL.device),leave ; Is there any buffer space?
  :                            30         mov     dptr,#uart(device).lsr  ; Is there data on COM1 input FIFO?
  :                            31         movx    a,@dptr
  :                            32         jnb     $bit(acc.LSR_RDR), Leave; No more so Next UART
  :                            33         mov     dptr,#uart(device).rhr  ; Yes
  :                            34         movx    a,@dptr                 ; Read
  :                            35         mov     dptr,#buffer(device)    ; Find Place in Circular Input Buffer
  :                            36         mov     dpl,write_cursor(device); By Means of the Running Cursor
  :                            37         movx    @dptr,a                 ; Write the Data to XRAM
  :                            38         inc     write_cursor(device)    ; Advance the Input Cursor
  :                            39         mov     a,read_cursor(device)   ; If write starts to equal read
  :                            40         cjne    a,write_cursor(device),Sample ; Is there any more? 
  :                            41         setB    $bit(FULL.device)       ; Stop reading from FIFO to XRAM
  :                            42 leave:       
  :                            43         $end
  :                            44 
  :                            45 
  :                            46 DEVICES equ     128
  :                            47 DATA    equ     1024
  :                            48 TOTAL   equ     4
  :                            49 RTVARS  equ     64
  :                            50 FULL    equ     32
  :                            51 
  :                            52 $(3:RTVARS)
  :                            53 device  $do     TOTAL,write_cursor(device)      $res    1
  :                            54 device  $do     TOTAL,read_cursor(device)       $res    1
  :                            55 $(2:DEVICES)
  :                            56 device  $do     TOTAL,uart(device)              serial
  :                            57 $(1:DATA)
  :                            58 device  $do     TOTAL,buffer(device)            VAR    256
  :                            59 
  :                            60 
  :                            61 $(0:64)
00:0040 20011B                +62 device	$do	TOTAL,	generate
00:0043 900085                +62 
00:0046 E0                    +62 
00:0047 30E014                +62 
00:004A 900080                +62 
00:004D E0                    +62 
00:004E 900400                +62 
00:0051 854082                +62 
00:0054 F0                    +62 
00:0055 0540                  +62 
00:0057 E544                  +62 
00:0059 B540E4                +62 
00:005C D201                  +62 
00:005E 20021B                +62 
00:0061 900095                +62 
00:0064 E0                    +62 
00:0065 30E014                +62 
00:0068 900090                +62 
00:006B E0                    +62 
00:006C 900500                +62 
00:006F 854182                +62 
00:0072 F0                    +62 
00:0073 0541                  +62 
00:0075 E545                  +62 
00:0077 B541E4                +62 
00:007A D202                  +62 
00:007C 20031B                +62 
00:007F 9000A5                +62 
00:0082 E0                    +62 
00:0083 30E014                +62 
00:0086 9000A0                +62 
00:0089 E0                    +62 
00:008A 900600                +62 
00:008D 854282                +62 
00:0090 F0                    +62 
00:0091 0542                  +62 
00:0093 E546                  +62 
00:0095 B542E4                +62 
00:0098 D203                  +62 
00:009A 20041B                +62 
00:009D 9000B5                +62 
00:00A0 E0                    +62 
00:00A1 30E014                +62 
00:00A4 9000B0                +62 
00:00A7 E0                    +62 
00:00A8 900700                +62 
00:00AB 854382                +62 
00:00AE F0                    +62 
00:00AF 0543                  +62 
00:00B1 E547                  +62 
00:00B3 B543E4                +62 
00:00B6 D204                  +62 
  :                            63 
*EOF*
LSR_RDR=00
SERIAL=:P1:(2)0:22
$BIT=:F1:23
GENERATE=:P3:0:24
DEVICES=0080
DATA=0400
TOTAL=04
RTVARS=40
FULL=20
DEVICE=04
WRITE_CURSOR(1)=$03:40
WRITE_CURSOR(2)=$03:41
WRITE_CURSOR(3)=$03:42
WRITE_CURSOR(4)=$03:43
READ_CURSOR(1)=$03:44
READ_CURSOR(2)=$03:45
READ_CURSOR(3)=$03:46
READ_CURSOR(4)=$03:47
UART(1)=$02:0080
UART(1):RHR=$02:0080
UART(1):THR=$02:0080
UART(1):IER=$02:0081
UART(1):ISR=$02:0082
UART(1):LCR=$02:0083
UART(1):MCR=$02:0084
UART(1):LSR=$02:0085
UART(1):MSR=$02:0086
UART(1):SPR=$02:0087
UART(2)=$02:0090
UART(2):RHR=$02:0090
UART(2):THR=$02:0090
UART(2):IER=$02:0091
UART(2):ISR=$02:0092
UART(2):LCR=$02:0093
UART(2):MCR=$02:0094
UART(2):LSR=$02:0095
UART(2):MSR=$02:0096
UART(2):SPR=$02:0097
UART(3)=$02:00A0
UART(3):RHR=$02:00A0
UART(3):THR=$02:00A0
UART(3):IER=$02:00A1
UART(3):ISR=$02:00A2
UART(3):LCR=$02:00A3
UART(3):MCR=$02:00A4
UART(3):LSR=$02:00A5
UART(3):MSR=$02:00A6
UART(3):SPR=$02:00A7
UART(4)=$02:00B0
UART(4):RHR=$02:00B0
UART(4):THR=$02:00B0
UART(4):IER=$02:00B1
UART(4):ISR=$02:00B2
UART(4):LCR=$02:00B3
UART(4):MCR=$02:00B4
UART(4):LSR=$02:00B5
UART(4):MSR=$02:00B6
UART(4):SPR=$02:00B7
BUFFER(1)=$01:0400
BUFFER(2)=$01:0500
BUFFER(3)=$01:0600
BUFFER(4)=$01:0700
8051.def=1<0005
uart.msm=0<0003
:$(00):0000:00B8 :$(01):0400:0800 :$(02):0080:00B8 :$(03):0040:0048 


</pre>
<p>
In the following assembly, a structure is 
constructed at address 0x00037300 in PowerPC system memory. 

<p>
PowerPC definition header has <b>$sterm '.'</b>, so the structure
joins are period on reference

<p>
Some of the components are repeated and subscripted. The
repeat directive is $DO, and the $DO tag value is used
to generate a numeric label subscript (see Section 7:
Iterated Code and Structured Data, Section 7.1: $DO and macros
and Section 7.2: Subscripted Labels).

<p>
Because all the addresses are 0x00037300 or more, PowerPC
load/store instructions can't access them directly, so the
location counter declaration on line 22 instructs the assembler
to answer label references as base-displacement tuples which 
assume R12 is pointing to 0x00037300.
<pre>

MASMX 7r2
3/ppcsinga.msm
LTERM=#
CONT_CHAR=
STERM=.
*EOF*
  :                            1 record* $proc        
  :                            2 *       $tree
  :                            3 h       +       record(1,1)
  :                            4 times   $do     record(1,1),t(times)       $res  4
  :                            5         $root
  :                            6         $end
  :                            7 
  :                            8:         $include        "ppc1.def"
  :                            9 tree*   $proc
  :                            10 *       $tree
  :                            11 times   $do     3,dibber(times) record    tree(1,1)
  :                            12         $root
  :                            13         $end
  :                            14 
  :                            15 inline*       $proc
  :                            16         lwz   r8, raddle1(1).dibber(3).t(index)
  :                            17         add   r0,0,r8
  :                            18       $end
  :                            19 
  :                            20 SEGMENT $set    55*4096+768
  :                            21 
  :                            22 $(49::SEGMENT,r12)
  :                            23 this_segment    $equ    .
31:00037300 00000012          +24 times   $do     2,raddle1(times) tree    18
31:0003734C 00000012          +24 
31:00037398 00000012          +24 
31:000373E4 00000012          +24 
31:00037430 00000012          +24 
31:0003747C 00000012          +24 
31:000374C8 0000001E          +25 raddle2 tree    30
31:00037544 0000001E          +25 
31:000375C0 0000001E          +25 
  :                            26 
  :                            27 $(0:980*1024)
00:000F5000 640C0003          +28         oris    r12,,SEGMENT/*16
00:000F5004 618C7300          +29         ori     r12,r12,SEGMENT
00:000F5008 806C004C          +30         lwz     r3, raddle1(1).dibber(2)
00:000F500C 808C017C          +31         lwz     r4, raddle1(2).dibber(3).h
00:000F5010 80AC01AC          +32         lwz     r5, raddle1(2).dibber(3).t(12)
00:000F5014 80CC01C8          +33         lwz     r6, raddle2
00:000F5018 616C0000          +34         mr      r11, r12
  :                            35 
  :                            36       $if     0
  :                            37       lwz     r7, raddle2.dibber(1).t(9), r11
  :                            38       $else
00:000F501C 80EB01EC          +39         lwz     r7, raddle2.dibber(1).t(9)(r11)
  :                            40       $endif
  :                            41 
00:000F5020 810C009C          +42 index   $do     raddle1(1).dibber(3).t(),    inline
00:000F5024 7C004214          +42 
00:000F5028 810C00A0          +42 
00:000F502C 7C004214          +42 
00:000F5030 810C00A4          +42 
00:000F5034 7C004214          +42 
00:000F5038 810C00A8          +42 
00:000F503C 7C004214          +42 
00:000F5040 810C00AC          +42 
00:000F5044 7C004214          +42 
00:000F5048 810C00B0          +42 
00:000F504C 7C004214          +42 
00:000F5050 810C00B4          +42 
00:000F5054 7C004214          +42 
00:000F5058 810C00B8          +42 
00:000F505C 7C004214          +42 
00:000F5060 810C00BC          +42 
00:000F5064 7C004214          +42 
00:000F5068 810C00C0          +42 
00:000F506C 7C004214          +42 
00:000F5070 810C00C4          +42 
00:000F5074 7C004214          +42 
00:000F5078 810C00C8          +42 
00:000F507C 7C004214          +42 
00:000F5080 810C00CC          +42 
00:000F5084 7C004214          +42 
00:000F5088 810C00D0          +42 
00:000F508C 7C004214          +42 
00:000F5090 810C00D4          +42 
00:000F5094 7C004214          +42 
00:000F5098 810C00D8          +42 
00:000F509C 7C004214          +42 
00:000F50A0 810C00DC          +42 
00:000F50A4 7C004214          +42 
00:000F50A8 810C00E0          +42 
00:000F50AC 7C004214          +42 
  :                            43 
  :                            44 SEGMENT       $set    .(49)+SEGMENT
  :                            45 $(49::SEGMENT,r11)
  :                            46 new_segment $equ .
31:0003763C 00000006          +47 jessalabel tree 6
31:00037658 00000006          +47 
31:00037674 00000006          +47 
31:00037690 00000004          +48 jumbly  tree    4
31:000376A4 00000004          +48 
31:000376B8 00000004          +48 
  :                            49 $(0)
00:000F50B0 640B0003          +50         oris    r11,,SEGMENT/*16
00:000F50B4 616B763C          +51         ori     r11,r11,SEGMENT
00:000F50B8 806B0054          +52         lwz     r3, jumbly
00:000F50BC 808B0058          +53         lwz     r4, jumbly+4
00:000F50C0 906B0038          +54         stw     r3, jessalabel.dibber(3).h
00:000F50C4 90800006          +55         stw     r4, jessalabel.dibber(3).t()
00:000F50C8 80A34000          +56         lwz     r5, 0x4000(r3)
00:000F50CC 658402C0          +57         li      r4, raddle2.dibber(3)
00:000F50D0 658500E4          +58         li      r5, raddle1(2)
  :                            59 down
00:000F50D4 4800000C          +60       b       up
00:000F50D8 4BFFFFFC          +61       b       down
00:000F50DC 48000004          +62       b       up
  :                            63 up
*EOF*
:$(00):000F5000:000F50E0 :$(31):00000000:00000090 
ppcsinga.msm: object code 924 bytes: 0 errors: 0 undefined labels


</pre>
<h2>8.55: $TWOS_COMPLEMENT   Change Negative Value Representation</h2>


<p>
$TWOS_COMPLEMENT defaults to 1 and should never be set to
anything except 1 or 0.
<pre>

	$twos_complement        1

</pre>
<p>
is the default, and causes integers to generate with twos 
complement representation via twos complement calculation.
<pre>

	$twos_complement        0

</pre>
<p>
causes integers to generate with ones complement representation.
Computation of ones complement expressions uses end-around-carry.
Negative values are reached by simple bit inversion (instead
of inversion + 1 as twos complement).

<p>
$TWOS_COMPLEMENT only affects assembler output (constants and
instructions), not anything which directs the assembler's
actions, such as $DO counts. For example,
<pre>

	$WORD   32
	.
	.
	$DO     2+0FFFFFFFF

</pre>
<p>
will always cause one iteration. $IF and $ELSEIF use twos
complement arithmetic if it has been selected, but expressions
containing comparisons = # < > will find negative zero
less than zero nevertheless.
<pre>

MASMX/24592 1r1X
compo.msm 5
*EOF*  :                        1:         $word   32
  :                        2: all1s   $equ    0ffffffffffffffffffffffffffffffffffffffffffffffff        
  :                        3:         $twos_complement        0
00:00000000 00000010      +4         -8*(-2)
00:00000001 FFFFFFFF      +5         -0
00:00000002 FFFFFFEF      +6         -8*2
00:00000003 FFFFEFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
			 +7         -16*/168
  :                        8:         $if     all1s<0
00:00000009 00000001      +9         +       1+all1s:s
  :                        10:         $endif
  :                        11:         $twos_complement        1
00:0000000A 00000010      +12         -8*(-2)
00:0000000B 00000000      +13         -0
00:0000000C FFFFFFF0      +14         -8*2
00:0000000D FFFFF0000000000000000000000000000000000000000000
			 +15         -16*/168
  :                        16:         $if     all1s<0
00:00000013 00000000      +17         +       1+all1s:s
  :                        18:         $endif
*EOF*:$(00):00000000:00000014 
Object Code 221 Bytes: 0 Errors: 0 Undefined Labels


</pre>

<h2>8.56: $WORD              Set the Size of a Target Computer Word</h2>

<p>
Directive
<pre>

	$WORD	size

</pre>
<p>
sets bit multiple in which code is generated

<p>
A source line which generates any code at all generates an integral 
number of words. 

<p>
The word size may not be less than the size of the 
smallest instruction in the target instruction set.
 
<p>
A machine may have 32- (or even 64-) bit addressing and computation.

<p>
If nevertheless the machine can fetch instructions from an
odd octet address, or has single-byte instructions, 
then word size has to be 8. A machine like that would have
parameters like
<pre>

	$word   8
	$byte   8
	$quantum 8
	$awidth 32

</pre>
<p>
It does not follow that integers need to be 8 bits.

<p>
Code for machines like this usually has command names for generating
numbers, and these commands can be reproduced as macros:
<pre>


$ masmx -lnky dl
MASMX 7r3
3/dl.msm
*EOF*
  :                            1         $word   8
  :                            2         $awidth 32
  :                            3         
  :                            4 dl*	$proc
  :                            5 x       $do     dl(1),	+	dl(1,x), dl(1,x)/*8, dl(1,x)/*16, dl(1,x)/*24:q
  :                            6         $end
  :                            7 
00:00000000 010000AA          +8         dl      0AA000001, 0BB000002, 0CC000003 
00:00000004 020000BB          +8 
00:00000008 030000CC          +8 
*EOF*
:$(00):00000000:0000000C 


</pre>
<p>
$AWIDTH and $QUANTUM must be set after $WORD unless they are the same
as $WORD. A suitable parameter set for M68K is
<pre>

	$word   16
	$awidth 32
	$quantum 8

</pre>
<p>
because 68000 do not have instructions less than 16 bits in size
or fetch them from odd boundaries.

<p>
A suitable parameter set for PowerPC is
<pre>

	$word   32
	$quantum 8

</pre>
<p>
A suitable parameter set for 8-bit microcontrollers is
<pre>

	$word   8
	$awidth 16

</pre>

<h2>8.57: $xqt_i		run-time integer algorithm plotter</h2>

<b>$xqt_i</b> directive generates a runtime integer algorithm instruction stream
<pre>

	$xqt_i	<i>expression</i>
	
</pre>
See section <b>6.1: Run-Time Integer Algorithm Plotter $xqt_i

<h2>8.58: $xqt_fp		run-time floating algorithm plotter</h2>

<b>$xqt_fp</b> directive generates a runtime floating algorithm instruction stream

<pre>

	$xqt_i	<i>expression</i>
	
</pre>
See section <b>6.2: Run-Time Floating Algorithm Plotter</b>

<h2>8.59: $zero_code_point  character string escaped zero value</h2>

<b>$zero_code_point</b> directive sets the value which represents embedded zero in a quoted string
to distinguish data byte value zero from end of string or line. default 2700 hex

<pre>

	$zero_code_point	<i>expression</b>

</pre>
The default value of zero code point is 2700 hex.
Zero code point is changed from its current value if that clashes with a data value required in the string 
<pre>

$ masmx zcp -lnk
MASMX 7r3
3/zcp.msm
*EOF*
  :                            1 	$set_option	"c"
  :                            2 	$word	32
  :                            3 	$byte	16
  :                            4 
  :                            5 	$zero_code_point	0x40000000
00:00000000 27000000          +6 	"\x2700\x0000"
  :                            7 
*EOF*
:$(00):00000000:00000001 

</pre>

<h1>9: Output File Formats, Relocation, Linking, Giant Address Spaces
   Interfacing with GNU Tools</h1>


<h2>9.1: Text Encoded Binary Format, S-Records and Intel Hex Records</h2>

<p>
<i>See also <b>8.28: $LIST 0, masking names from list and export</b></i>

<p>
masmx output is in Text Encoded Binary Output format.

<p>
This assembly produces absolute .txo code:
<pre>


  :                            27 generate* $proc *
  :                            28 Sample:
  :                            29         jb      $bit(FULL.device),leave ; Is there any buffer space?
  :                            30         mov     dptr,#uart(device).lsr  ; Is there data on COM1 input FIFO?
  :                            31         movx    a,@dptr
  :                            32         jnb     $bit(acc.LSR_RDR), Leave; No more so Next UART
  :                            33         mov     dptr,#uart(device).rhr  ; Yes
  :                            34         movx    a,@dptr                 ; Read
  :                            35         mov     dptr,#buffer(device)    ; Find Place in Circular Input Buffer
  :                            36         mov     dpl,write_cursor(device); By Means of the Running Cursor
  :                            37         movx    @dptr,a                 ; Write the Data to XRAM
  :                            38         inc     write_cursor(device)    ; Advance the Input Cursor
  :                            39         mov     a,read_cursor(device)   ; If write starts to equal read
  :                            40         cjne    a,write_cursor(device),Sample ; Is there any more? 
  :                            41         setB    $bit(FULL.device)       ; Stop reading from FIFO to XRAM
  :                            42 leave:       
  :                            43         $end
  :                            44 
  :                            45 
  :                            46 DEVICES equ     128
  :                            47 DATA    equ     1024
  :                            48 TOTAL   equ     4
  :                            49 RTVARS  equ     64
  :                            50 Full    equ     32
  :                            51 
  :                            52 $(3:RTVARS)
  :                            53 device  $do     TOTAL,write_cursor(device)      $res    1
  :                            54 device  $do     TOTAL,read_cursor(device)       $res    1
  :                            55 $(2:DEVICES)
  :                            56 device  $do     TOTAL,uart(device)              serial
  :                            57 $(1:DATA)
  :                            58 device  $do     TOTAL,buffer(device)            VAR    256
  :                            59 
  :                            60 
  :                            61 $(0:64)
00:0040 20011B                +62 device        $do     TOTAL,  generate
00:0043 900085                +62 
00:0046 E0                    +62 
00:0047 30E014                +62 
00:004A 900080                +62 
00:004D E0                    +62 
00:004E 900400                +62 
00:0051 854082                +62 
00:0054 F0                    +62 
00:0055 0540                  +62 
00:0057 E544                  +62 
00:0059 B540E4                +62 
00:005C D201                  +62 
00:005E 20021B                +62 
00:0061 900095                +62 
00:0064 E0                    +62 
00:0065 30E014                +62 
00:0068 900090                +62 
00:006B E0                    +62 
00:006C 900500                +62 
00:006F 854182                +62 
00:0072 F0                    +62 
00:0073 0541                  +62 
00:0075 E545                  +62 
00:0077 B541E4                +62 
00:007A D202                  +62 
00:007C 20031B                +62 
00:007F 9000A5                +62 
00:0082 E0                    +62 
00:0083 30E014                +62 
00:0086 9000A0                +62 
00:0089 E0                    +62 
00:008A 900600                +62 
00:008D 854282                +62 
00:0090 F0                    +62 
00:0091 0542                  +62 
00:0093 E546                  +62 
00:0095 B542E4                +62 
00:0098 D203                  +62 
00:009A 20041B                +62 
00:009D 9000B5                +62 
00:00A0 E0                    +62 
00:00A1 30E014                +62 
00:00A4 9000B0                +62 
00:00A7 E0                    +62 
00:00A8 900700                +62 
00:00AB 854382                +62 
00:00AE F0                    +62 
00:00AF 0543                  +62 
00:00B1 E547                  +62 
00:00B3 B543E4                +62 
00:00B6 D204                  +62 
  :                            63 
*EOF*
:$(00):0000:00B8 :$(01):0400:0800 :$(02):0080:00B8 :$(03):0040:0048 
uart.msm: object code 381 bytes: 0 errors: 0 undefined labels

</pre>
<p>
The output code is represented in text.
It can be viewed in a text editor or a shell.

<p>
This is the output of
<pre>


PROMPT\>masmx uart uart -l

</pre>
<p>
Text Encoded Binary format represents code with hexadecimal symbols.
<pre>

$00:0040
20011B 900085 E0 30E014 900080 E0 900400 854082 F0 0540 E544
B540E4 D201 20021B 900095 E0 30E014 900090 E0 900500 854182
F0 0541 E545 B541E4 D202 20031B 9000A5 E0 30E014 9000A0 E0
900600 854282 F0 0542 E546 B542E4 D203 20041B 9000B5 E0
30E014 9000B0 E0 900700 854382 F0 0543 E547 B543E4 D204
:$00*0000:0000:00B8
:$01*0000:0400:0800
:$02*0000:0080:00B8
:$03*0000:0040:0048

</pre>
<p>
The first line shows the tag of locator zero and a 16 bit load address
equal to 64.

<p>
The following fields are superwords.

<p>
Superwords are fields representing one or more words of code.

<p>
If there is any address jump or change of location counter,
another location line like the first intervenes.

<p>
Finally there are four lines of summary information.


<p>
Converter utility <b>imx</b> generates Intel load strings from
Text Encoded Binary
<pre>

PROMPT\>imx uart.txo uart.hex

</pre>

<p>
And that produces
<pre>


:2000400020011B900085E030E014900080E0900400854082F00540E544B540E4D201200254
:200060001B900095E030E014900090E0900500854182F00541E545B541E4D20220031B9083
:2000800000A5E030E0149000A0E0900600854282F00542E546B542E4D20320041B9000B532
:1800A000E030E0149000B0E0900700854382F00543E547B543E4D2042D
:00FFFF0101


</pre>
<p>
Code for converting to Motorola S-Records is also assembled to .txo format
first:
<pre>

MASMX 7r2
3/qplain.msm
LTERM=#
CONT_CHAR=|
STERM=.
  :                            1:         $include        "ppc_603.def"
  :                            2 
  :                            3 SEGMENT .equ    511*1024
  :                            4 $(48:SEGMENT,r15)
30:0007FC00 0000000000400000  +5 part1   +       2048*2048d
30:0007FC08 0000000000000064  +6 part2   +       100d
  :                            7 part3   $res    2048*2048-16
  :                            8 
30:0047FC00 0007FC10          +9 	+	.absolute(part3)
  :                            10 
  :                            11 $(0:3*65536)
00:00030000 640F0008          +12 start   oris    r15,, SEGMENT@ha     
00:00030004 39E0FC00          +13         addi    r15, SEGMENT@l 
00:00030008 806F0000          +14         lwz     r3, part1
00:0003000C 808F0008          +15         lwz     r4, part2
00:00030010 80AF0010          +16         lwz     r5, part3
00:00030014 4E800020          +17         blr
  :                            18         $end    start
:$(00):00030000:00030018 :$(30):0007FC00:0047FC04 
qplain.msm: object code 214 bytes: 0 errors: 0 undefined labels


</pre>
PROMPT\>masmx -ld qplain qplain

<p>
Produces qplain.txo

<p>
The <b>-d</b> flag displayed the real addresses in SEGMENT instead of the
displacements.

<p>
qplain.txo contains:
<pre>

$30:0007FC00
0000000000400000 0000000000000064
$30:0047FC00
0007FC10
$00:00030000
640F0008 39E0FC00 806F0000 808F0008 80AF0010 4E800020
>00:00030000

:$00*00000000:00030000:00030018
:$30*00000000:0007FC00:0047FC04
</pre
<ul>
	a counter 48 location line with the address 0007FC00
<pre></pre>
	two two-word number values

<pre></pre>
	a counter 48 location line with the address 0047FC00

<pre></pre>
	an address constant pointing to the 16th byte of locator 48

<pre></pre>
	a counter zero location line with the address 00030000

<pre></pre>
	two instructions which load the address SEGMENT to r15

<pre></pre>
	three instructions which reference SEGMENT with base
	register R15

<pre></pre>
	a return instruction

<pre></pre>
	a transfer address symbol >00:00030000 pointing to the label start

<pre></pre>
	summary information for two absolute addressed segments


</ul>
There is no relocation information in qplain.txo. It goes
to the S-records converter, mmx:
<pre>

PROMPT\>mmx qplain.txo qplain.hex

</pre>
<p>
mmx utility writes S-records in qplain.hex:
<pre>

S00600004844521B
S3150007FC000000000000400000000000000000006443
S3090047FC000007FC10A0
S31900030000640F000839E0FC00806F0000808F000880AF00100E
S309000300144E800020F1
S70500030000F7

</pre>
<p>
A transfer address has to be present if GNU tools objcopy is used
to copy the S-records to binary. objcopy otherwise refuses. Transfer
address is the S7 record.


<h2>9.2: Relocation, Linking, Giant Addresses and Interfacing with GNU Tools</h2>


<h3>9.2.1: Relocation Information in Text Encoded Binary</h3>

<p>
To list the relocation information in a relocatable assembly,
assemble with <b>-nl</b> flags.

<p>
<b>-l</b> is for list, <b>-n</b> for list relocation information:
<pre>

	>masmx -ln zactor

MASMX 7r2
3/zactor.msm
LTERM=#
CONT_CHAR=|
STERM=.
*EOF*
  :                            1 __relocatable $set	1
  :                            2: 	$include	"ppc_603.def"
  :                            3 
  :                            4 	$if	1
  :                            5 $(.data)
03:00000000 00000063          +6 myword	.long		99
  :                            7 	$endif
  :                            8 
  :                            9 $(.text)
  :                            10 zactor*
[+0000:00008000/*10]10
01:00000000 3D200000          +11         lis 9,factor@ha
[+0000]10-
01:00000004 80090000          +12         lwz 0,factor@l(9)
  :                            13 
  :                            14 	$if	1
(+03:00008000/*10)10
01:00000008 3D400000          +15 	lis 10,myword@ha
(+03)10-
01:0000000C 816A0000          +16 	lwz 11,myword@l(10)
  :                            17 	$endif
  :                            18 
[+0001:fffffff0/*02]18*/02+
(-01:fffffff0/*02)18*/02+
01:00000010 4BFFFFF1          +19 	bl	soso
01:00000014 4E800020          +20 	blr
*EOF*
:$(01):00000000:00000018 :$(03):00000000:00000004 
zactor.msm: object code 343 bytes: 0 errors: 2 undefined labels

</pre>
<p>
And the relocation information displayed maps to the relocation
information in the Text Encoded Binary
<pre>

$03:*00000004
$03:00000000
00000063
$01:*00000004
$01:00000000
[0000:00008000/*10]10:3D200000 [0000]10-:80090000 (03:00008000/*10)10:3D400000
(03)10-:816A0000 [0001:FFFFFFF0/*02]18*/02+:(-01:FFFFFFF0/*02)18*/02+:4BFFFFF1
4E800020
+ZACTOR:$01:00000000
-FACTOR:[0000]
-SOSO:[0001]
:$01*00000004:00000000:00000018
:$03*00000004:00000000:00000004

</pre>
<ul>

	counter 3 has a relocation alignment factor 4.
	Definition "ppc_603.def" maps counter 3 to
	ELF section .data

<pre></pre>
	relocatable counter 3 starts with zero offset

<pre></pre>
	a data word contains 99

<pre></pre>
	counter 1 has a relocation alignment factor 4.
	Definition "ppc_603.def" maps counter 1 to
	ELF section .text

<pre></pre>
	relocatable counter 1 starts with zero offset

<pre></pre>
	There is one relocation clause on the first superword:
<ul>
	    [0000:00008000/*10]10:

<pre></pre>
	    [0000:xxxxxxxxxxxx]10: means add the value of the
	    unknown name FACTOR, which is encoded as the index
	    number [0000], to 16 bits of the instruction code 3D200000

<pre></pre>
	    Macro code at assembly adjusted the unrelocated value
	    00000000 with the formula +32768/*16 (macro @ha).

<pre></pre>
	    That is reflected in this linker information: 00008000/*10
	    The rounding addition is because of sign extension on
	    base-displacement references

<pre></pre>
	    This is the operand factor@ha
</ul>
<pre></pre>
	There is one relocation clause on the second superword:
<ul>
	    [0000]10-: means add the value of unknown name FACTOR
	    to 16 bits of instruction code 80090000. The trailing
	    minus means: range checking not required, truncation
	    is expected.

<pre></pre>
	    The addend offset is read out of the instruction
	    code itself. This is operand factor@l
</ul>
<pre></pre>
	There is one relocation clause on the third superword:
<ul>
	    (03:00008000/*10)10:
<pre></pre>
	    (03:xxxxxxxxxxxx)10: means add the segment base of
	    section 3 (.data) to sixteen bits of instruction code 3D400000

<pre></pre>
	    Macro code at assembly adjusted the unrelocated value
	    00000000 (first location in .data) with the formula
	    +32768/*16 (macro @ha).

<pre></pre>
	    That is reflected in this linker information: 00008000/*10
	    The rounding addition is because of sign extension on
	    base-displacement references

<pre></pre>
	    This is the operand myword@ha
</ul>
<pre></pre>
	There is one relocation clause on the fourth superword:
<ul>
	    (03)10-: means add the segment base of section 3 (.data)
	    to 16 bits of instruction code 816A0000. The trailing
	    minus means, do not check range: truncation is expected.
	   
<pre></pre>
	    The addend offset is read out of the instruction
	    code itself. This is operand myword@l
</ul>
<pre></pre>
	There are two relocation clauses on the fifth superword:
<ul>
	    [0001:FFFFFFF0/*02]18*/02+:
<pre></pre>
	    [0001:xxxxxxxxxxxx]18*/02+: means add the value of the
	    unknown name SOSO, encoded as the index number [0001],
	    to the operand address, to be encoded in 24 bits of
	    the instruction 4BFFFFF1 starting 2 bits up.
	     + means range check as signed.

<pre></pre>
	    The additional linker information FFFFFFF0/*02 means
	    take the unrelocated address information from here,
	    not from the instruction, and shift it after relocation.

<pre></pre>
	    This is a relative jump instruction. Macro code at
	    assembly applied the formula TARGET-HERE*/-2

</ul>
<pre></pre>
	    This is the jump to soso. There is a second relocation
	    tuple on this instruction, becauses the jump-from address
	    is also relocatable.
<ul>
	The second relocation tuple is
<pre></pre>
	    (-01:FFFFFFF0/*02)18*/02+
<pre></pre>
	    (-01:xxxxxxxxxxxx)18*/02+ means subtract the segment base
	    of locator 1 (.text) from the operand address 

<pre></pre>
	    the unrelocated part of HERE is known = 00000010

<pre></pre>
	    the unrelocated part of target SOSO is known = 00000000
	    because all the value of SOSO is in its relocated part

<pre></pre>
	    assembly was able to encode 00000000-00000010=FFFFFFF0

<pre></pre>
	    the link must add the relocated part of SOSO and subtract
	    the relocated part of HERE

<pre></pre>
	    the part about shift right and then store in a left
	    shifted field is because the low two address bits
	    are zero and not encoded in the instruction.
<pre></pre>
	    When there is a right shift in a relocatable operand,
	    the additional linker information here shown as
	    FFFFFFF0/*02 is output from assembly, so that the
	    whole address is relocated before shifting.
<pre></pre>
	    All relocation tuples for one field of code are
	    effectively accumulated.

</ul>
<p>
	The return instruction in the sixth superword has no
	relocation clauses.

<pre></pre>
	The label list shows ZACTOR exported, FACTOR and SOSO imported,
	relocatable counter 1 (.text) with aligment factor 4 and
	24 bytes long, relocatable counter 3 (.data) with alignment
	factor 4 and 4 bytes long.

</ul>

<h3>9.2.2:  masmx Linking in Principle</h3>


<p>
Link is a set of masmx features, and a link is an assembly

<p>
Linking begins when a Text Encoded Binary is included
<pre>

	$include,$binary	file[.txo]	$(locator, locator...

</pre>
<p>
The second argument for picking and ordering segments is optional.

<p>
macro $MAP must be declared before any binary includes.
<pre>

	$include		"map_macro.def"

	$include,$binary	file1
	$include,$binary	file2

</pre>
<p>
Files of code for inclusion are Text Encoded Binary. They may be with
or without relocation information.

<p>
The link combines files, and some of the binary includes would contain
relocatable code although not all must:
<pre>

	$include		"map_macro.def"

	$include,$binary	absolute
	$include,$binary	relative1
	$include,$binary	relative2

</pre>
<p>
$INCLUDE,$BINARY sends all the superwords in the Text Encoded Binary files
to the $MAP macro, one line of superwords at a time.

<p>
The $MAP macro is not part of the assembler. Definitions for PowerPC
linking, <b>map_ppc.def</b> and <b>ppc64map.def</b>, are in this package
and have a $MAP macro for PowerPC.

<p>
masmx itself uses the location lines and summary tables. Only the
superwords of code go to $MAP macro.

<p>
$MAP macro uses some or all of these masmx linking features:
<ul>	
	directive	$SET,$BINARY
<pre>
</pre>

	directive	$LOAD,$BITS
<pre>
</pre>

	directive	$PUSHREL
<pre>
</pre>

	directive	$PUSHREL,$LONG_ABSOLUTE
<pre>
</pre>

	directive	$INFO,$OFFSET
<pre>
</pre>

 	directive	$INFO,$RANGE_CHECK
<pre>
</pre>

 	directive	$INFO,$RANGE_CHECK1


</ul>
<p>
The outline use of the directives is
<pre>

code_label	$SET,$BINARY	superword_code_part
		$LOAD,$BITS	code_label

</pre>
<p>
code_label is a user-supplied name. $SET,$BINARY loads the value
of a code superword to code_label and sets the automatic label
$BITS to the number of bits read.

<p>
$LOAD,$BITS writes the new superword in the output Text Encoded Binary,
prefixing any oustanding relocation clauses.
<pre>

parameter_label $PUSHREL	relocation_clause

</pre>
<p>
parameter_label is a user supplied name. $PUSHREL types it as $EQUF
and it contains three or five values for adjusting the code part
of the superword.

<p>
The first of these five values is the relocation value, and is normally
retrieved
<pre>

value	$set	parameter_label

</pre>
<p>
Absolute addresses wider than 32 bits are instead retrieved with different
use of $PUSHREL
<pre>

value	$PUSHREL,$LONG_ABSOLUTE	relocation_clause

</pre>
<p>
$INFO directive
<pre>

	$INFO,$OFFSET	value

</pre>
<p>
adjusts an addend encoding. This is done when the segment root of some
addresses is changed but not yet absolute (cumulative link).

<p>
The affected addresses are exclusively addresses which assembly must encode
separately alongside the instruction code, because they will be manipulated
with a rightward shift after relocation. This allows any overflow from the
truncated part to be included correctly.

<p>
Macro language need not be aware whether the output is relocatable, because
if is safe to order <b>$info,$offset</b> whether relocation information
will be output or not. When no relocation information will be output,
no action takes place.
<pre>

	$INFO,$RANGE_CHECK	value
	$INFO,$RANGE_CHECK1	value

</pre>
<p>
These calls request masmx linker section to range check <b>value</b>
according to the size and signed-or-not character of the relocatable
field represented at the top the of the relocation stack.

<p>
<b>value</b> is the relocated value which macro language will write
to "this" field.

<p>
<b>$range_check1</b> is of higher stringency than <b>$range_check</b>. See
Section 8.26.2, and Section 9.2.3: Link Examples. A $MAP macro using
<b>$range_check</b> maintains (where multiple relocation tuples may drive
a field out of range and then again into range) intermediate results
at 192-bit precision.
<p>
$MAP is the name of a macro from outside the assembler. It is
"user written". There is a working $MAP macro for PowerPC in this
package

<p>
$MAP macro in the supplied definition "map_ppc.def" is of this structure:
<pre>

p	$proc
"$map"*	$name

p	$proc
superword*	$name
clauses	$set	p(1,1:)
"$data"	$set,$binary	p(1,1:clauses)

clause	$do	clauses-1,	relocate	p(1, 1:clause)
	$load,$bits	$data
	$end	. of SUPERWORD

p	$proc
relocate* $name

rel_params $pushrel	p(1,1)

value	$set	rel_params\1

bits    $set    rel_params\2
scale   $set    rel_params\3
offset  $set    rel_params\4
descant $set    rel_params\5

limit   $set    1*/bits
mask    $set    limit-1
unmask  $set    ^(mask*/scale)

	$if	descant<0
field	$set	value+offset
	$info,$range_check1	field
	$info,$offset		field
field	$set	field*/descant
	$else
field	$set	value+(($data/*scale)**mask)
	$info,$range_check1	field
	$endif

"$data"* $set	((field**mask)*/scale)++($data**unmask)

	$end	. of RELOCATE

index	$do	p(),	superword	p(index, 1)
	$end	. of $MAP


</pre>
<p>
$MAP macro is called for each line of Text Encoded Binary which
contains any code superwords.

<p>
The second last line of macro language calls embedded macro
superword once for each superword.

<p>
macro superword
<ul>
	caches the code from the last clause of the superword:
<pre>

	data	$set,$binary	p(1,1:clauses)

</pre>

	calls embedded macro relocate once for each relocation clause:
<pre>

	clause	$do	clauses-1,	relocate	p(1,1:clause)

</pre>

	writes out the code adjusted by relocate macro:
</ul>
<pre>

		$load,$bits	data

</pre>
<p>
macro relocate
<ul>
	updates the code according to the relocation clause,
	with update information tabled by $PUSHREL
<pre>
</pre>

	in some cases adjusts forwarded information for
	further relocation.

</ul>

<h3>9.2.3: Demonstration Links</h3>


<p>
These examples are different kinds of link and their output

<p>
First two small c files, soso.c and factor.c are compiled with
gcc -S
<pre>

$ gcc -S soso.c

	extern int       factor;
	extern int       adjustment(int *where);

	int              clanjamfrie = 55;

	static int       yasimi = 99;
	static int       startfromhere;
	static int      *cu = &startfromhere;

	int soso()
	{
	   static int    separate_static_item = 0xa5a5a5a5;
	   static long long clearly_so;

	   int           x = startfromhere++;

	   x *= factor;
	   x += adjustment(cu);
	   x -= yasimi;
	   return x;
	}

$ gcc -S factor.c

	extern int soso(int *there);

	extern int       clanjamfrie;

	int              factor = 88;

	static int      *acu = &factor;

	int     adjustment()
	{
	   return 33;
	}

	int overcoat()
	{
	   soso(acu);
	}

</pre>
<p>
Then wrapper files are constructed
<pre>

$ cat soso.msm

__relocatable $set	1
	$include	"ppc_603.def"
	$store		soso
	$list		2
	$include	soso.s

$ cat factor.msm

	$list		1
__relocatable $set	1
	$include	"ppc_603.def"
	$list		2
	$store		factor
	$include	factor.s

</pre>
<p>
and the wrapper files are assembled
<pre>

$ masmx soso -ln

MASMX 7r2
3/soso.msm
LTERM=#
CONT_CHAR=|
STERM=.
*EOF*
  :                            1 __relocatable $set	1
  :                            2: 	$include	"ppc_603.def"
  :                            3 	$store		soso
  :                            4 	$list		2
  :                            5: 	$include	soso.s
  :                            1 	.file	"soso.c"
  :                            2 	.globl clanjamfrie
  :                            3 	.section	.sdata,"aw",@progbits
  :                            4 	.align 2
  :                            5 	.type	clanjamfrie, @object
  :                            6 	.size	clanjamfrie, 4
  :                            7 clanjamfrie:
06:00000000 00000037          +8 	.long	55
  :                            9 	.section	".data"
  :                            10 	.align 2
  :                            11 	.type	yasimi, @object
  :                            12 	.size	yasimi, 4
  :                            13 yasimi:
03:00000000 00000063          +14 	.long	99
  :                            15 	.align 2
  :                            16 	.type	cu, @object
  :                            17 	.size	cu, 4
  :                            18 cu:
(+05)20
03:00000004 00000008          +19 	.long	startfromhere
  :                            20 	.lcomm	clearly_so.1543,8,8
  :                            21 	.type	clearly_so.1543, @object
  :                            22 	.align 2
  :                            23 	.type	separate_static_item.1542, @object
  :                            24 	.size	separate_static_item.1542, 4
  :                            25 separate_static_item.1542:
03:00000008 A5A5A5A5          +26 	.long	-1515870811
  :                            27 	.section	".text"
  :                            28 	.align 2
  :                            29 	.globl soso
  :                            30 	.type	soso, @function
  :                            31 soso:
01:00000000 9421FFE0          +32 	stwu 1,-32(1)
01:00000004 7C0802A6          +33 	mflr 0
01:00000008 93E1001C          +34 	stw 31,28(1)
01:0000000C 90010024          +35 	stw 0,36(1)
01:00000010 63E10000          +36 	mr 31,1
(+05:00008008/*10)10
01:00000014 3D200000          +37 	lis 9,startfromhere@ha
(+05)10-
01:00000018 81290008          +38 	lwz 9,startfromhere@l(9)
01:0000001C 913F0008          +39 	stw 9,8(31)
01:00000020 38010009          +40 	addi 0,9,1
(+05:00008008/*10)10
01:00000024 3D200000          +41 	lis 9,startfromhere@ha
(+05)10-
01:00000028 90090008          +42 	stw 0,startfromhere@l(9)
[+0000:00008000/*10]10
01:0000002C 3D200000          +43 	lis 9,factor@ha
[+0000]10-
01:00000030 81290000          +44 	lwz 9,factor@l(9)
01:00000034 801F0008          +45 	lwz 0,8(31)
01:00000038 7C0049D6          +46 	mullw 0,0,9
01:0000003C 901F0008          +47 	stw 0,8(31)
(+03:00008004/*10)10
01:00000040 3D200000          +48 	lis 9,cu@ha
(+03)10-
01:00000044 80090004          +49 	lwz 0,cu@l(9)
01:00000048 60600000          +50 	mr 3,0
[+0001:ffffffb4/*02]18*/02+
(-01:ffffffb4/*02)18*/02+
01:0000004C 4BFFFFB5          +51 	bl adjustment
01:00000050 61230000          +52 	mr 9,3
01:00000054 801F0008          +53 	lwz 0,8(31)
01:00000058 7C004A14          +54 	add 0,0,9
01:0000005C 901F0008          +55 	stw 0,8(31)
(+03:00008000/*10)10
01:00000060 3D200000          +56 	lis 9,yasimi@ha
(+03)10-
01:00000064 81290000          +57 	lwz 9,yasimi@l(9)
01:00000068 801F0008          +58 	lwz 0,8(31)
01:0000006C 7C090050          +59 	subf 0,9,0
01:00000070 901F0008          +60 	stw 0,8(31)
01:00000074 801F0008          +61 	lwz 0,8(31)
01:00000078 60600000          +62 	mr 3,0
01:0000007C 81610000          +63 	lwz 11,0(1)
01:00000080 800B0004          +64 	lwz 0,4(11)
01:00000084 7C0803A6          +65 	mtlr 0
01:00000088 83EBFFFC          +66 	lwz 31,-4(11)
01:0000008C 602B0000          +67 	mr 1,11
01:00000090 4E800020          +68 	blr
  :                            69 	.size	soso, .-soso
  :                            70 	.lcomm	startfromhere,4,4
  :                            71 	.type	startfromhere, @object
  :                            72 	.ident	"GCC: (GNU) 4.2.1"
*EOF*
:$(01):00000000:00000094 :$(03):00000000:0000000C :$(05):00000000:0000000C :$(06):00000000:00000004 
soso.msm: object code 887 bytes: 0 errors: 2 undefined labels

$ cat soso.txo

$06:*00000004
$06:00000000
00000037
$03:*00000004
$03:00000000
00000063
$03:00000004
(05)20:00000008
$03:00000008
A5A5A5A5
$01:*00000004
$01:00000000
9421FFE0 7C0802A6 93E1001C 90010024 63E10000 (05:00008008/*10)10:3D200000
(05)10-:81290008 913F0008 38010009 (05:00008008/*10)10:3D200000
(05)10-:90090008 [0000:00008000/*10]10:3D200000 [0000]10-:81290000
801F0008 7C0049D6 901F0008 (03:00008004/*10)10:3D200000
(03)10-:80090004 60600000 [0001:FFFFFFB4/*02]18*/02+:(-01:FFFFFFB4/*02)18*/02+:4BFFFFB5
61230000 801F0008 7C004A14 901F0008 (03:00008000/*10)10:3D200000
(03)10-:81290000 801F0008 7C090050 901F0008 801F0008 60600000
81610000 800B0004 7C0803A6 83EBFFFC 602B0000 4E800020
+CLANJAMFRIE:$06:00000000
+SOSO:$01:00000000
-ADJUSTMENT:[0001]
-FACTOR:[0000]
:$01*00000004:00000000:00000094
:$03*00000004:00000000:0000000C
:$05*FFFFFFFC:00000000:0000000C
:$06*00000004:00000000:00000004

</pre>
<p>
A number of superwords in the Text Encoded Binary soso.txo have
relocation tuples, some to request fixed addresses for the segments
of soso itself, others to locate external names ADJUSTMENT and FACTOR
<pre>

$ masmx -ln factor

MASMX 7r2
3/factor.msm
LTERM=#
CONT_CHAR=|
STERM=.
*EOF*
  :                            1 	$list		1
  :                            2 __relocatable $set	1
  :                            3: 	$include	"ppc_603.def"
  :                            4 	$list		2
  :                            5 	$store		factor
  :                            6: 	$include	factor.s
  :                            1 	.file	"factor.c"
  :                            2 	.globl factor
  :                            3 	.section	.sdata,"aw",@progbits
  :                            4 	.align 2
  :                            5 	.type	factor, @object
  :                            6 	.size	factor, 4
  :                            7 factor:
06:00000000 00000058          +8 	.long	88
  :                            9 	.section	".data"
  :                            10 	.align 2
  :                            11 	.type	acu, @object
  :                            12 	.size	acu, 4
  :                            13 acu:
(+06)20
03:00000000 00000000          +14 	.long	factor
  :                            15 	.section	".text"
  :                            16 	.align 2
  :                            17 	.globl adjustment
  :                            18 	.type	adjustment, @function
  :                            19 adjustment:
01:00000000 9421FFF0          +20 	stwu 1,-16(1)
01:00000004 93E1000C          +21 	stw 31,12(1)
01:00000008 63E10000          +22 	mr 31,1
01:0000000C 64000021          +23 	li 0,33
01:00000010 60600000          +24 	mr 3,0
01:00000014 81610000          +25 	lwz 11,0(1)
01:00000018 83EBFFFC          +26 	lwz 31,-4(11)
01:0000001C 602B0000          +27 	mr 1,11
01:00000020 4E800020          +28 	blr
  :                            29 	.size	adjustment, .-adjustment
  :                            30 	.align 2
  :                            31 	.globl overcoat
  :                            32 	.type	overcoat, @function
  :                            33 overcoat:
01:00000024 9421FFF0          +34 	stwu 1,-16(1)
01:00000028 7C0802A6          +35 	mflr 0
01:0000002C 93E1000C          +36 	stw 31,12(1)
01:00000030 90010014          +37 	stw 0,20(1)
01:00000034 63E10000          +38 	mr 31,1
(+03:00008000/*10)10
01:00000038 3D200000          +39 	lis 9,acu@ha
(+03)10-
01:0000003C 80090000          +40 	lwz 0,acu@l(9)
01:00000040 60600000          +41 	mr 3,0
[+0000:ffffffbc/*02]18*/02+
(-01:ffffffbc/*02)18*/02+
01:00000044 4BFFFFBD          +42 	bl soso
01:00000048 81610000          +43 	lwz 11,0(1)
01:0000004C 800B0004          +44 	lwz 0,4(11)
01:00000050 7C0803A6          +45 	mtlr 0
01:00000054 83EBFFFC          +46 	lwz 31,-4(11)
01:00000058 602B0000          +47 	mr 1,11
01:0000005C 4E800020          +48 	blr
  :                            49 	.size	overcoat, .-overcoat
  :                            50 	.ident	"GCC: (GNU) 4.2.1"
*EOF*
:$(01):00000000:00000060 :$(03):00000000:00000004 :$(06):00000000:00000004 
factor.msm: object code 594 bytes: 0 errors: 1 undefined labels

$ cat factor.txo

$06:*00000004
$06:00000000
00000058
$03:*00000004
$03:00000000
(06)20:00000000
$01:*00000004
$01:00000000
9421FFF0 93E1000C 63E10000 64000021 60600000 81610000
83EBFFFC 602B0000 4E800020
$01:00000024
9421FFF0 7C0802A6 93E1000C 90010014 63E10000 (03:00008000/*10)10:3D200000
(03)10-:80090000 60600000 [0000:FFFFFFBC/*02]18*/02+:(-01:FFFFFFBC/*02)18*/02+:4BFFFFBD
81610000 800B0004 7C0803A6 83EBFFFC 602B0000 4E800020
+ADJUSTMENT:$01:00000000
+FACTOR:$06:00000000
+OVERCOAT:$01:00000024
-SOSO:[0000]
:$01*00000004:00000000:00000060
:$03*00000004:00000000:00000004
:$06*00000004:00000000:00000004

</pre>
<p>
The call to soso is relative, so the unrelocated address is
"unknown" minus hex 00000044 = FFFFFFBC


<h4>9.2.3.1: The Simplest Link</h4>


<p>
The first link is the simplest kind. An absolute start address is
given, and all segments are placed in the order they were found.

<p>
The first link pass arranges the placement of segments
<pre>

$ masmx map1 -l

MASMX 7r2
3/map1.msm
soso.txo:$(1) 148 bytes decimal from hexadecimal 000A0000 to 000A0094
soso.txo:$(3) 12 bytes decimal from hexadecimal 000A0094 to 000A00A0
soso.txo:$(5) 12 bytes decimal from hexadecimal 000A00A0 to 000A00AC
soso.txo:$(6) 4 bytes decimal from hexadecimal 000A00AC to 000A00B0
factor.txo:$(1) 96 bytes decimal from hexadecimal 000A00B0 to 000A0110
factor.txo:$(3) 4 bytes decimal from hexadecimal 000A0110 to 000A0114
factor.txo:$(6) 4 bytes decimal from hexadecimal 000A0114 to 000A0118
*EOF*
  :                            1: 	$include	"map_ppc.def"
  :                            2 $(0:000A0000)
  :                            3 	$plist			7
  :                            4: 	$include,$binary	soso
  :                            5: 	$include,$binary	factor
  :                            6 
  :                            7 	$store			image1
*EOF*
:$(00):000A0000:000A0000 :$(01):000A0000:000A0110 :$(03):000A0094:000A0114 :$(05):000A00A0:000A00AC :$(06):000A00AC:000A0118 
map1.msm: object code 994 bytes: 0 errors: 0 undefined labels

$ cat image1.txo

$06:000A00AC
00000037
$03:000A0094
00000063
$03:000A0098
000A00A8
$03:000A009C
A5A5A5A5
$01:000A0000
9421FFE0 7C0802A6 93E1001C 90010024 63E10000 3D20000A
812900A8 913F0008 38010009 3D20000A 900900A8 3D20000A
81290114 801F0008 7C0049D6 901F0008 3D20000A 80090098
60600000 48000065 61230000 801F0008 7C004A14 901F0008
3D20000A 81290094 801F0008 7C090050 901F0008 801F0008
60600000 81610000 800B0004 7C0803A6 83EBFFFC 602B0000
4E800020
$06:000A0114
00000058
$03:000A0110
000A0114
$01:000A00B0
9421FFF0 93E1000C 63E10000 64000021 60600000 81610000
83EBFFFC 602B0000 4E800020
$01:000A00D4
9421FFF0 7C0802A6 93E1000C 90010014 63E10000 3D20000A
80090110 60600000 4BFFFF0D 81610000 800B0004 7C0803A6
83EBFFFC 602B0000 4E800020
+ADJUSTMENT:$01:000A00B0
+CLANJAMFRIE:$06:000A00AC
+FACTOR:$06:000A0114
+OVERCOAT:$01:000A00D4
+SOSO:$01:000A0000
:$00*00000000:000A0000:000A0000
:$01*00000000:000A0000:000A0110
:$03*00000000:000A0094:000A0114
:$05*00000000:000A00A0:000A00AC
:$06*00000000:000A00AC:000A0118


</pre>
<h4>9.2.3.2: Link Collected by Section</h4>


<p>
The second link uses <b>-b</b> option, which collects the segments by section.

<p>
A start address has to be given for each section.

<p>
Definition "ppc_603.def" maps these counters to ELF sections:
<pre>

	$(1)	.text
	$(3)	.data
	$(5)	.bss
	$(6)	.sdata
	$(11)	.rodata

$ masmx map2 -l

MASMX 7r2
3/map2.msm
soso.txo:$(1) 148 bytes decimal from hexadecimal 000A0000 to 000A0094
soso.txo:$(3) 12 bytes decimal from hexadecimal 000B0000 to 000B000C
soso.txo:$(5) 12 bytes decimal from hexadecimal 000B8000 to 000B800C
soso.txo:$(6) 4 bytes decimal from hexadecimal 000C0000 to 000C0004
factor.txo:$(1) 96 bytes decimal from hexadecimal 000A0094 to 000A00F4
factor.txo:$(3) 4 bytes decimal from hexadecimal 000B000C to 000B0010
factor.txo:$(6) 4 bytes decimal from hexadecimal 000C0004 to 000C0008
*EOF*
  :                            1:       $include        "map_ppc.def"
  :                            2        $set_option     "b"
  :                            3 $(1:000A0000)
  :                            4 $(3:000B0000)
  :                            5 $(5:000B8000)
  :                            6 $(6:000C0000)
  :                            7:       $include,$binary        soso
  :                            8:       $include,$binary        factor
  :                            9 
  :                            10       $store                  image2
*EOF*
:$(01):000A0000:000A00F4 :$(03):000B0000:000B0010 :$(05):000B8000:000B800C :$(06):000C0000:000C0008 
map2.msm: object code 962 bytes: 0 errors: 0 undefined labels


</pre>

<h4>9.2.3.3: Link Specific Segments</h4>


<p>
The third link picks the segments individually, in case none of the
automatic order methods is adequate:
<pre>

$ masmx map3 -l

MASMX 7r2
3/map3.msm
soso.txo:$(1) 148 bytes decimal from hexadecimal 000A0000 to 000A0094
factor.txo:$(1) 96 bytes decimal from hexadecimal 000A0094 to 000A00F4
soso.txo:$(3) 12 bytes decimal from hexadecimal 000A00F4 to 000A0100
factor.txo:$(3) 4 bytes decimal from hexadecimal 000A0100 to 000A0104
soso.txo:$(5) 12 bytes decimal from hexadecimal 000C0000 to 000C000C
soso.txo:$(6) 4 bytes decimal from hexadecimal 000C000C to 000C0010
factor.txo:$(6) 4 bytes decimal from hexadecimal 000C0010 to 000C0014
*EOF*
  :                            1:       $include        "map_ppc.def"
  :                            2 
  :                            3 text   $equ    1
  :                            4 data   $equ    3
  :                            5 bss    $equ    5
  :                            6 sdata  $equ    6
  :                            7 
  :                            8 $(1:000A0000)
  :                            9:       $include,$binary   soso    $(text)
  :                            10:      $include,$binary   factor  $(text)
  :                            11:      $include,$binary   soso    $(data)
  :                            12:      $include,$binary   factor  $(data)
  :                            13 
  :                            14 $(0:000C0000)
  :                            15:     $include,$binary soso  $(bss, sdata)
  :                            16:     $include,$binary factor $(bss,sdata)
  :                            17 
  :                            18       $store                  image3
*EOF*
:$(00):000C0000:000C0000 :$(01):000A0000:000A00F4 :$(03):000A00F4:000A0104 :$(05):000C0000:000C000C :$(06):000C000C:000C0014 
map3.msm: object code 994 bytes: 0 errors: 0 undefined labels


</pre>
<h4>9.2.3.4: Link an Output Relocatable</h4>


<p>
The fourth link is cumulative. The output is relocatable. The input
segments combine by section. Relocatable output is switched with the
relocatable location counter control <b>$(0:*4)</b>. The segment alignment
value <b>*4</b> indicates relocatable code.
<pre>

$ masmx map4 -ln

MASMX 7r2
3/map4.msm
soso.txo:$(1) 148 bytes decimal [*4] from hexadecimal 00000000 to 00000094
soso.txo:$(3) 12 bytes decimal [*4] from hexadecimal 00000000 to 0000000C
soso.txo:$(5) 12 bytes decimal [*-4] from hexadecimal 00000000 to 0000000C
soso.txo:$(6) 4 bytes decimal [*4] from hexadecimal 00000000 to 00000004
factor.txo:$(1) 96 bytes decimal [*4] from hexadecimal 00000094 to 000000F4
factor.txo:$(3) 4 bytes decimal [*4] from hexadecimal 0000000C to 00000010
factor.txo:$(6) 4 bytes decimal [*4] from hexadecimal 00000004 to 00000008
*EOF*
  :                            1: 	$include	"map_ppc.def"
  :                            2 $(0:*4)
  :                            3 	$list			2
  :                            4: 	$include,$binary	soso
06:00000000 00000037          +4 00000037
03:00000000 00000063          +7 00000063
(+05)20
03:00000004 00000008          +9 (05)20:00000008
03:00000008 A5A5A5A5          +11 A5A5A5A5
01:00000000 9421FFE0          +14 9421FFE0 7C0802A6 93E1001C 90010024 63E10000 (05:00008008/*10)10:3D200000
01:00000004 7C0802A6          +14 
01:00000008 93E1001C          +14 
01:0000000C 90010024          +14 
01:00000010 63E10000          +14 
(+05:00008008/*10)10
01:00000014 3D200000          +14 
(+05)10-
01:00000018 81290008          +15 (05)10-:81290008 913F0008 38010009 (05:00008008/*10)10:3D200000
01:0000001C 913F0008          +15 
01:00000020 38010009          +15 
(+05:00008008/*10)10
01:00000024 3D200000          +15 
(+05)10-
01:00000028 90090008          +16 (05)10-:90090008 [0000:00008000/*10]10:3D200000 [0000]10-:81290000
(+06:00008004/*10)10
01:0000002C 3D200000          +16 
(+06)10-
01:00000030 81290004          +16 
01:00000034 801F0008          +17 801F0008 7C0049D6 901F0008 (03:00008004/*10)10:3D200000
01:00000038 7C0049D6          +17 
01:0000003C 901F0008          +17 
(+03:00008004/*10)10
01:00000040 3D200000          +17 
(+03)10-
01:00000044 80090004          +18 (03)10-:80090004 60600000 [0001:FFFFFFB4/*02]18*/02+:(-01:FFFFFFB4/*02)18*/02+:4BFFFFB5
01:00000048 60600000          +18 
(-01:00000048/*02)18*/02+
(+01:00000048/*02)18*/02+
01:0000004C 48000049          +18 
01:00000050 61230000          +19 61230000 801F0008 7C004A14 901F0008 (03:00008000/*10)10:3D200000
01:00000054 801F0008          +19 
01:00000058 7C004A14          +19 
01:0000005C 901F0008          +19 
(+03:00008000/*10)10
01:00000060 3D200000          +19 
(+03)10-
01:00000064 81290000          +20 (03)10-:81290000 801F0008 7C090050 901F0008 801F0008 60600000
01:00000068 801F0008          +20 
01:0000006C 7C090050          +20 
01:00000070 901F0008          +20 
01:00000074 801F0008          +20 
01:00000078 60600000          +20 
01:0000007C 81610000          +21 81610000 800B0004 7C0803A6 83EBFFFC 602B0000 4E800020
01:00000080 800B0004          +21 
01:00000084 7C0803A6          +21 
01:00000088 83EBFFFC          +21 
01:0000008C 602B0000          +21 
01:00000090 4E800020          +21 
  :                            5: 	$include,$binary	factor
06:00000004 00000058          +4 00000058
(+06)20
03:0000000C 00000004          +7 (06)20:00000000
01:00000094 9421FFF0          +10 9421FFF0 93E1000C 63E10000 64000021 60600000 81610000
01:00000098 93E1000C          +10 
01:0000009C 63E10000          +10 
01:000000A0 64000021          +10 
01:000000A4 60600000          +10 
01:000000A8 81610000          +10 
01:000000AC 83EBFFFC          +11 83EBFFFC 602B0000 4E800020
01:000000B0 602B0000          +11 
01:000000B4 4E800020          +11 
01:000000B8 9421FFF0          +13 9421FFF0 7C0802A6 93E1000C 90010014 63E10000 (03:00008000/*10)10:3D200000
01:000000BC 7C0802A6          +13 
01:000000C0 93E1000C          +13 
01:000000C4 90010014          +13 
01:000000C8 63E10000          +13 
(+03:0000800c/*10)10
01:000000CC 3D200000          +13 
(+03)10-
01:000000D0 8009000C          +14 (03)10-:80090000 60600000 [0000:FFFFFFBC/*02]18*/02+:(-01:FFFFFFBC/*02)18*/02+:4BFFFFBD
01:000000D4 60600000          +14 
(-01:ffffff28/*02)18*/02+
(+01:ffffff28/*02)18*/02+
01:000000D8 4BFFFF29          +14 
01:000000DC 81610000          +15 81610000 800B0004 7C0803A6 83EBFFFC 602B0000 4E800020
01:000000E0 800B0004          +15 
01:000000E4 7C0803A6          +15 
01:000000E8 83EBFFFC          +15 
01:000000EC 602B0000          +15 
01:000000F0 4E800020          +15 
  :                            6 
  :                            7 	$store			rel4
*EOF*
:$(01):00000000:000000F4 :$(03):00000000:00000010 :$(05):00000000:0000000C :$(06):00000000:00000008 
map4.msm: object code 1246 bytes: 0 errors: 0 undefined labels

$ cat rel4.txo

$06:00000000
00000037
$03:00000000
00000063
$03:00000004
(05)20:00000008
$03:00000008
A5A5A5A5
$01:00000000
9421FFE0 7C0802A6 93E1001C 90010024 63E10000 (05:00008008/*10)10:3D200000
(05)10-:81290008 913F0008 38010009 (05:00008008/*10)10:3D200000
(05)10-:90090008 (06:00008004/*10)10:3D200000 (06)10-:81290004
801F0008 7C0049D6 901F0008 (03:00008004/*10)10:3D200000
(03)10-:80090004 60600000 (-01:00000048/*02)18*/02+:(01:00000048/*02)18*/02+:48000049
61230000 801F0008 7C004A14 901F0008 (03:00008000/*10)10:3D200000
(03)10-:81290000 801F0008 7C090050 901F0008 801F0008 60600000
81610000 800B0004 7C0803A6 83EBFFFC 602B0000 4E800020
$06:00000004
00000058
$03:0000000C
(06)20:00000004
$01:00000094
9421FFF0 93E1000C 63E10000 64000021 60600000 81610000
83EBFFFC 602B0000 4E800020
$01:000000B8
9421FFF0 7C0802A6 93E1000C 90010014 63E10000 (03:0000800C/*10)10:3D200000
(03)10-:8009000C 60600000 (-01:FFFFFF28/*02)18*/02+:(01:FFFFFF28/*02)18*/02+:4BFFFF29
81610000 800B0004 7C0803A6 83EBFFFC 602B0000 4E800020
+ADJUSTMENT:$01:00000094
+CLANJAMFRIE:$06:00000000
+FACTOR:$06:00000004
+OVERCOAT:$01:000000B8
+SOSO:$01:00000000
:$01*00000004:00000000:000000F4
:$03*00000004:00000000:00000010
:$05*FFFFFFFC:00000000:0000000C
:$06*00000004:00000000:00000008

</pre>
<p>
If this link is repeated with <b>-j</b> flag, the treatment of external
references is different but the final effect the same:
<pre>

$ ../masmx map4 -lj

MASMX 7r2
3/map4.msm
soso.txo:$(1) 148 bytes decimal [*4] from hexadecimal 00000000 to 00000094
soso.txo:$(3) 12 bytes decimal [*4] from hexadecimal 00000000 to 0000000C
soso.txo:$(5) 12 bytes decimal [*-4] from hexadecimal 00000000 to 0000000C
soso.txo:$(6) 4 bytes decimal [*4] from hexadecimal 00000000 to 00000004
factor.txo:$(1) 96 bytes decimal [*4] from hexadecimal 00000094 to 000000F4
factor.txo:$(3) 4 bytes decimal [*4] from hexadecimal 0000000C to 00000010
factor.txo:$(6) 4 bytes decimal [*4] from hexadecimal 00000004 to 00000008
*EOF*
  :                            1: 	$include	"map_ppc.def"
  :                            2 $(0:*4)
  :                            3 	$list			1
  :                            4: 	$include,$binary	soso
  :                            5: 	$include,$binary	factor
  :                            6 
  :                            7 	$store			rel4
*EOF*
SOSO awaiting absolute part
ADJUSTMENT awaiting absolute part
FACTOR awaiting absolute part
:$(01):00000000:000000F4 :$(03):00000000:00000010 :$(05):00000000:0000000C :$(06):00000000:00000008 
map4.msm: object code 1301 bytes: 0 errors: 0 undefined labels

$ cat rel4.txo

$06:00000000
00000037
$03:00000000
00000063
$03:00000004
(05)20:00000008
$03:00000008
A5A5A5A5
$01:00000000
9421FFE0 7C0802A6 93E1001C 90010024 63E10000 (05:00008008/*10)10:3D200000
(05)10-:81290008 913F0008 38010009 (05:00008008/*10)10:3D200000
(05)10-:90090008 [03FF:00008000/*10]10:3D200000 [03FF]10-:81290000
801F0008 7C0049D6 901F0008 (03:00008004/*10)10:3D200000
(03)10-:80090004 60600000 (-01:FFFFFFB4/*02)18*/02+:[03FE:FFFFFFB4/*02]18*/02+:4BFFFFB5
61230000 801F0008 7C004A14 901F0008 (03:00008000/*10)10:3D200000
(03)10-:81290000 801F0008 7C090050 901F0008 801F0008 60600000
81610000 800B0004 7C0803A6 83EBFFFC 602B0000 4E800020
$06:00000004
00000058
$03:0000000C
(06)20:00000004
$01:00000094
9421FFF0 93E1000C 63E10000 64000021 60600000 81610000
83EBFFFC 602B0000 4E800020
$01:000000B8
9421FFF0 7C0802A6 93E1000C 90010014 63E10000 (03:0000800C/*10)10:3D200000
(03)10-:8009000C 60600000 (-01:FFFFFF28/*02)18*/02+:[03FD:FFFFFF28/*02]18*/02+:4BFFFF29
81610000 800B0004 7C0803A6 83EBFFFC 602B0000 4E800020
+ADJUSTMENT:$01:00000094
+CLANJAMFRIE:$06:00000000
+FACTOR:$06:00000004
+OVERCOAT:$01:000000B8
+SOSO:$01:00000000
-SOSO:[03FD]
-ADJUSTMENT:[03FE]
-FACTOR:[03FF]
:$01*00000004:00000000:000000F4
:$03*00000004:00000000:00000010
:$05*FFFFFFFC:00000000:0000000C
:$06*00000004:00000000:00000008

</pre>
<p>
With <b>-j</b> option, external names which are found but are still
relocatable are requested again later.

<p>
Without <b>-j</b> option the request for an external name is changed into
a request relating to a location counter if the imported name is still
relocatable.

<p>
Because the cumulative link has moved the .text (counter 1) segment of
factor.txo from relocatable 00000000 to relocatable 00000094 hex,
the relative jump from function overcoat in factor.c to 
function soso in soso.c has changed from "unknown" minus 00000044 to
"unknown" minus 000000D8, or FFFFFF28

<p>
The adjusted offset addend in FFFFFF28 is placed in the relocation
stack by macro language in $MAP macro with the $INFO,$OFFSET directive.

<p>
This step is necessary when three circumstances combine:
<ul>

	the offset is extracted and marked up for shift
	right after relocation, as <b>(rel:offset/*shift)</b>
	or <b>[name:offset/*shift]</b>
<pre>
</pre>

	A segment base address used in the field value
	has moved as a result of relocation
<pre>
</pre>
	target is not yet absolute and the relocation clause will
	be forwarded in the output Text Encoded Binary

</ul>
<p>
Without the <b>-j</b> option, the "unknown" is instead relocatable 00000000,
which is arithmetically identical, because function soso is at the start.

<p>
So without the <b>-j</b> option, jump root and target are on output in the
same segment. The same segment base will be added and subtracted at the next
link.

<p>
Relative jumps within one segment at source time don't cause any
relocation. masmx suppresses relocation information in
<b>location_X-location_Y</b>

if <b>location_X</b> and <b>location_Y</b> are in the same segment.


<h4>9.2.3.5: Link an Accumulated Relocatable plus a New Relocatable</h4>


<p>
The fifth link adds relocatable zactor.txo to the relocatable link
output of the fourth link. The output is absolute.

<p>
<b>-b</b> option and section start addresses cause the segments to be
collected by section:
<pre>

$ masmx map5 -l

MASMX 7r2
3/map5.msm
rel4.txo:$(1) 244 bytes decimal from hexadecimal 000A0000 to 000A00F4
rel4.txo:$(3) 16 bytes decimal from hexadecimal 000B0000 to 000B0010
rel4.txo:$(5) 12 bytes decimal from hexadecimal 000B8000 to 000B800C
rel4.txo:$(6) 8 bytes decimal from hexadecimal 000C0000 to 000C0008
zactor.txo:$(1) 24 bytes decimal from hexadecimal 000A00F4 to 000A010C
zactor.txo:$(3) 4 bytes decimal from hexadecimal 000B0010 to 000B0014
*EOF*
  :                            1:       $include        "map_ppc.def"
  :                            2        $set_option     "b"
  :                            3 $(1:000A0000)
  :                            4 $(3:000B0000)
  :                            5 $(5:000B8000)
  :                            6 $(6:000C0000)
  :                            7:       $include,$binary        rel4
  :                            8:       $include,$binary        zactor
  :                            9 
  :                            10       $store                  image5
*EOF*
:$(01):000A0000:000A010C :$(03):000B0000:000B0014 :$(05):000B8000:000B800C :$(06):000C0000:000C0008 
map5.msm: object code 1072 bytes: 0 errors: 0 undefined labels


</pre>
<h4>9.2.3.6: The Incremental Link</h4>


<p>
The sixth link adds relocatable zactor.txo as an increment to an absolute.
The absolute is the earlier (2nd) -b option link of soso.txo and factor.txo

<p>
The output is identical with the link just above.
<pre>

$ ../masmx map6 -l

MASMX 7r2
3/map6.msm
image2.txo:$(1) 244 bytes decimal from hexadecimal 000A0000 to 000A00F4
image2.txo:$(3) 16 bytes decimal from hexadecimal 000B0000 to 000B0010
image2.txo:$(5) 12 bytes decimal from hexadecimal 000B8000 to 000B800C
image2.txo:$(6) 8 bytes decimal from hexadecimal 000C0000 to 000C0008
zactor.txo:$(1) 24 bytes decimal from hexadecimal 000A00F4 to 000A010C
zactor.txo:$(3) 4 bytes decimal from hexadecimal 000B0010 to 000B0014
*EOF*
  :                            1:       $include        "map_ppc.def"
  :                            2 
  :                            3        $set_option     "b"
  :                            4 
  :                            5:       $include,$binary        image2
  :                            6:       $include,$binary        zactor
  :                            7 
  :                            8        $store                  image6
*EOF*
:$(01):000A0000:000A010C :$(03):000B0000:000B0014 :$(05):000B8000:000B800C :$(06):000C0000:000C0008 
map6.msm: object code 1072 bytes: 0 errors: 0 undefined labels

$ diff -w image5.txo image6.txo

$ 

</pre>
<h4>9.2.3.7: The Link into Giant Address Space</h4>


<p>
In order to have control over code architecture in the 64-bit environment,
the next illustrations are a departure from compiler output.

<p>
In order to see all over the large address space, the entry sequence
to external-visible routines bases a literal pool, which contains
64-bit pointers to 64K parts of storage.

<p>
It would be possible to base the assembly's own static along with its
literal pool, if  components like zero-initial static, nonzero
initial static and public data were placed in one section.

<pre>

MASMX 7r2
3/gsoso.msm
LTERM=#
CONT_CHAR=
STERM=.
*EOF*
  :                            1 __giant		$set	1
  :                            2 __relocatable	$set	1
  :                            3: 	$include	"ppc_64.def"
  :                            4 	$list		2
  :                            5 __litseg $set		36
  :                            6 $(__litseg:*8,r30/__literal)
  :                            7 __base36
  :                            8: 	$include	gsoso.s
  :                            1 	.file	"soso.c"
  :                            2 	.globl clanjamfrie
  :                            3 	.section	.sdata,"aw",@progbits
  :                            4 	.align 2
  :                            5 	.type	clanjamfrie, @object
  :                            6 	.size	clanjamfrie, 4
  :                            7 clanjamfrie:
06:00000000 00000037          +8 	.int	55
  :                            9 	.section	".data"
  :                            10 	.align 2
  :                            11 	.type	yasimi, @object
  :                            12 	.size	yasimi, 4
  :                            13 yasimi:
03:00000000 00000063          +14 	.int	99
  :                            15 	.align 2
  :                            16 	.type	cu, @object
  :                            17 	.size	cu, 8
  :                            18 cu:
(+05)40
03:00000004 0000000000000008  +19 	.quad	startfromhere
  :                            20 	.lcomm	clearly_so.1543,8,8
  :                            21 	.type	clearly_so.1543, @object
  :                            22 	.align 2
  :                            23 	.type	separate_static_item.1542, @object
  :                            24 	.size	separate_static_item.1542, 4
  :                            25 separate_static_item.1542:
03:0000000C A5A5A5A5          +26 	.int	-1515870811
  :                            27 	.section	".text"
  :                            28 	.align 2
  :                            29 	.globl soso
  :                            30 	.type	soso, @function
  :                            31 
  :                            32 x	$equf	16, 31	# dynamic integer in the stack frame
  :                            33 
  :                            34 soso:
01:00000000 F821FFC1          +35 	stdu	1, -64(1)
01:00000004 7C0802A6          +36 	mflr	0
01:00000008 FBE10038          +37 	std   31, 56(1)	# save r31 just below the previous stack frame 
01:0000000C F8010048          +38 	std   0, 72(1)	# save LR value inside the previous stack frame
01:00000010 63E10000          +39 	mr    31, 1	# use a frame pointer in case the stack is pushed
01:00000014 FBDF0030          +40 	std	30, 48(31)	# save the literals base register
  :                            41 
01:00000018 4800000D          +42 	bl	__haulup
(+24)40
01:0000001C 0000000000000000  +43 	+	.absolute(__base36):d
  :                            44 __haulup
01:00000024 7FC802A6          +45 	mflr	30	# .literal segment 36 holds __literal table
  :                            46 			# which is accessed base_displacement with r30
  :                            47 	
01:00000028 EBDE0000          +48 	ld	30, 0(30) # LR was pointing to the pointer
  :                            49 
01:0000002C E93E0000          +50 	ld	9, __literal(	__upper48	startfromhere@ha)
(+05:00000008/*02)0e*/02-
01:00000030 E929000A          +51 	lwa	9, startfromhere@l(9)
01:00000034 913F0010          +52 	stw	9, x
  :                            53 
01:00000038 38010009          +54 	addi	0, 9, 1
  :                            55 
01:0000003C E93E0000          +56 	ld	9, __literal(	__upper48	startfromhere@ha)
(+05)10-
01:00000040 90090008          +57 	stw	0, startfromhere@l(9)
  :                            58 
01:00000044 E93E0008          +59 	ld	9, __literal(	__upper48	factor@ha)
[+0000:00000000/*02]0e*/02-
01:00000048 E9290002          +60 	lwa	9, factor@l(9)
01:0000004C E81F0012          +61 	lwa	0, x
  :                            62 
01:00000050 7C0049D6          +63 	mullw	0, 0, 9
01:00000054 901F0010          +64 	stw	0, x
  :                            65 
01:00000058 E93E0010          +66 	ld	9, __literal(	__upper48	cu@ha)
(+03:00000004/*02)0e*/02-
01:0000005C E8090004          +67 	ld	0, cu@l(9)
01:00000060 60600000          +68 	mr	3, 0
  :                            69 
[+0001:ffffff9c/*02]18*/02+
(-01:ffffff9c/*02)18*/02+
01:00000064 4BFFFF9D          +70 	bl	adjustment
01:00000068 61230000          +71 	mr	9, 3
01:0000006C 801F0010          +72 	lwz	0, x
  :                            73 
01:00000070 7C004A14          +74 	add	0, 0, 9
01:00000074 901F0010          +75 	stw	0, x
  :                            76 
01:00000078 E93E0018          +77 	ld	9, __literal(	__upper48	yasimi@ha)
(+03:00000000/*02)0e*/02-
01:0000007C E9290002          +78 	lwa	9, yasimi@l(9)
  :                            79 
01:00000080 E81F0012          +80 	lwa	0, x
01:00000084 7C090050          +81 	subf	0, 9, 0
  :                            82 
  :                            83 #	stw	0, x
  :                            84 #	lwz	0, x	# the compiler had these lines in
  :                            85 
01:00000088 60600000          +86 	mr	3, 0	# this ABI has r3 for results
  :                            87 
  :                            88 #	the geography of the stack frame is
  :                            89 #	LOW ADDRESS REPRESENTED HERE    ______________________________
  :                            90 #	STACK TOP R31 points to ------> |   saved SP (r1) 8 bytes    |
  :                            91 #					|............................|
  :                            92 #				+ 8	| next LR save area 8 bytes  |
  :                            93 #					|............................|
  :                            94 #				+ 16	| var x 4 bytes|/////////////|
  :                            95 #					|..............|.............|
  :                            96 
  :                            97 
  :                            98 
  :                            99 #				+ 48	|     saved r30 8 bytes      |
  :                            100 #					|............................|
  :                            101 #				+ 56	|     saved r31 8 bytes      |
  :                            102 #					|____________________________|
  :                            103 #	PREVIOUS STACK FRAME ---------> | previous saved r1 8 bytes  |
  :                            104 #					|............................|
  :                            105 #				+ 72	|  actual saved LR 8 bytes   |
  :                            106 
  :                            107 
  :                            108 
01:0000008C E9610000          +109 	ld	11, 0(1)	# there is complete confidence r1 unchanged
01:00000090 E80B0008          +110 	ld	0, 8(11)	# pick up LR
01:00000094 7C0803A6          +111 	mtlr	0
01:00000098 EBDF0030          +112 	ld	30, 48(31)
01:0000009C EBEBFFF8          +113 	ld	31, -8(11)
  :                            114 
01:000000A0 602B0000          +115 	mr	1,11
  :                            116 
01:000000A4 4E800020          +117 	blr
  :                            118 
  :                            119 	.size	soso, .-soso
  :                            120 	.lcomm	startfromhere,4,4
  :                            121 	.type	startfromhere, @object
  :                            122 	.ident	"GCC: (GNU) 4.2.1"
  :                            9 	$store		gsoso
  :                            10 	.align		3	# align for 64-bit literal pointer constants
*EOF*
24:00000000+(05:00008008/*10)30*/10:0000000000000000
24:00000008+[0000:00008000/*10]30*/10:0000000000000000
24:00000010+(03:00008004/*10)30*/10:0000000000000000
24:00000018+(03:00008000/*10)30*/10:0000000000000000
:$(01):00000000:000000A8 :$(03):00000000:00000010 :$(05):00000000:0000000C :$(06):00000000:00000004 :$(24):00000000:00000020 
gsoso.msm: object code 1138 bytes: 0 errors: 2 undefined labels
 
</pre>

<p>
Here the principle of basing a literal table for long base address
pointers has been collected in a header file.

<pre>

#*************************************************************
#
#		enter64.def
#
#		This file is enter64.def for source generating
#		RELOCATABLES which will be INCLUDED in 64-BIT LINKS
#		and for ABSOLUTE 64-BIT SOURCE
#
#		enter and leave macros:
#
#			enter64			frame_size_32_or_more
#
#               	return64,64		something_64_bits
#               	return64,__immediate	something
#               	return64		something_32_bits
#               	leave64
#
#		enter64 frame size gets rounded up to 32-byte blocks
#		exactly 32 bytes is enough without local variables
#
#		for variables, frame size is 32+variables_size
#
#		The frame is based on r31
#		and the variables start at frame+16, so for example
#
#		mylocal64	$equf	16, r31
#		mylocal32	$equf	24, r31
#		myother32	$equf	32, r31
#
#		enter64 bases the __literal pool on register 30
#		so that 64-bit pointers to anywhere in memory
#		can be picked up with
#
#			ld	rX, __literal(address)
#
#		Because literals are not duplicated in any one assembly
#		a very good density of literal use can be had with
#		literals which fix the upper 48 bits of the address
#
#			ld	rX, __literal(	__upper48	operand@ha)
#			lwa	rY, operand@l(rX)
#
#		And the good density of literal use minimises
#		the work of cache and tlb.
#
#		An assembly mostly generates only a handful of literals
#
#		The four return macros
#
#                       return64,64             something_64_bits
#                       return64,__immediate    something
#                       return64                something_32_bits
#                       leave64
#
#		all restore r30 and r31
#
#		The operands and jump targets named in literals
#		may be external or relocatable:
#
#			ld	r0, __literal(far_function:d)
#			mtlr	r0
#			blrl
#
#
#*************************************************************

.literal	$equ	36
__immediate	$equ	-16

p	$proc	*

enter64* $name

__FRAME	$set	(p(1, 1)+31)**-32

	$do	__FRAME<32,	$flag	frame size param 1 must be > 0

#**************************************************************
#
#		$(36) is a base_displacement segment
#		so that address constant literals are in reach
#
#		base_displacement references are never relocatable
#
#		a 64-bit constant of __base36 plus all its
#		relocation information must be generated just below here.
#
#		masmx internal function $a, called .absolute in ppc_*.def
#		stops __base36 from being a base_displacement name
#		and instead associates all its relocation information
#
#		in 64-bit absolute source the $a function obtains
#		the long absolute address immediately
#
#			+	.absolute(__base36):d
#
#		After linking,  that constant will contain the true
#		address of the segment $(36) containing literals
#
#**************************************************************

	stdu	1, -__FRAME(1)
	mflr	0
	std	31, __FRAME-8(1)	# save r31 just below
				# the previous stack frame

	std	0, __FRAME+8(1) 	# save LR in the second 64-bit word
				# of the previous stack frame

	mr	31, 1		# have a frame pointer in case
				# the stack is pushed

	std	30, __FRAME-16(31) # save the literals base register

	bl	__haulup
	+	.absolute(__base36):d
__haulup
	mflr	30		# .text segment holds literal table
				# which is accessed base_displacement

	ld	30,,30		# LR was pointing to the pointer
	$end

#*********************************************************************
#
#	the geography of the MINIMUM stack frame is
#	LOW ADDRESS REPRESENTED HERE    ______________________________
#	STACK TOP R31 points to ------> |   saved SP (r1) 8 bytes    |
#					|............................|
#				+ 8	| next LR save area 8 bytes  |
#					|............................|
#				+ 16	|     saved r30 8 bytes      |
#					|............................|
#				+ 24	|     saved r31 8 bytes      |
#					|____________________________|
#	PREVIOUS STACK FRAME ---------> | previous saved r1 8 bytes  |
#					|............................|
#				+ 40	|  actual saved LR 8 bytes   |
#
#*********************************************************************



#********************************************************************
#
#	the geography of A SAMPLE stack frame WITH LOCAL VARIABLES is
#	LOW ADDRESS REPRESENTED HERE    ______________________________
#	STACK TOP R31 points to ------> |   saved SP (r1) 8 bytes    |
#					|............................|
#				+ 8	| next LR save area 8 bytes  |
#					|............................|
#	FOR EXAMPLE		+ 16	| var y 8 bytes              |
#					|............................|
#	FOR EXAMPLE		+ 24	| var x 4 bytes|/////////////|
#					|..............|.............|
#					|			     |
#	per these examples
#				y	$EQUF	16, r31
#				x	$EQUF	24, r31



#	PREVIOUS STACK FRAME - 16	|     saved r30 8 bytes      |
#					|............................|
#	PREVIOUS STACK FRAME - 8	|     saved r31 8 bytes      |
#					|____________________________|
#	PREVIOUS STACK FRAME ---------> | previous saved r1 8 bytes  |
#					|............................|
#	PREVIOUS STACK FRAME + 8	|  actual saved LR 8 bytes   |
#
#
#*********************************************************************


p	$proc

return64* $name

	$if	p(0, 2)=64	#	return64,64	something_64_bits
	ld	3, p(1, 1)	# or
	$elseif	p(0, 2)=__immediate #	return64,__immediate	something
	li	3, p(1, 1)	# or
	$else			#	return64	something_32_bits
	lwa	3, p(1, 1)	# or
	$endif			#	leave64

leave64* $name
	ld	1,,31		# old SP is 1st word of this frame
	ld	0, 8, 1		# old LR is 2nd word of this other frame
	mtlr	0
	ld	30, -16, 1	# old base register is 2nd last word/frame
	ld	31,  -8, 1	# old frame pointer is last word in frame
	blr

	$end


MASMX 7r2
3/gfactor.msm
LTERM=#
CONT_CHAR=
STERM=.
*EOF*
  :                            1 __giant		$set	1
  :                            2 __relocatable	$set	1
  :                            3: 	$include	"ppc_64.def"
  :                            4: 	$include	enter64.def
  :                            5 	$list		2
  :                            6 __litseg $set           36
  :                            7 $(__litseg:*8,r30/__literal)
  :                            8 __base36
  :                            9: 	$include	gfactor.s
  :                            1 	.file	"factor.c"
  :                            2 	.globl factor
  :                            3 	.section	.sdata,"aw",@progbits
  :                            4 	.align 2
  :                            5 	.type	factor, @object
  :                            6 	.size	factor, 4
  :                            7 factor:
06:00000000 00000058          +8 	.int	88
  :                            9 	.section	".data"
  :                            10 	.align 2
  :                            11 	.type	acu, @object
  :                            12 	.size	acu, 4
  :                            13 acu:
(+06)40
03:00000000 0000000000000000  +14 	.long	factor
  :                            15 	.section	".text"
  :                            16 	.align 2
  :                            17 	.globl adjustment
  :                            18 	.type	adjustment, @function
  :                            19 adjustment:
01:00000000 F821FFE1          +20 	enter64	32
01:00000004 7C0802A6          +20 
01:00000008 FBE10018          +20 
01:0000000C F8010028          +20 
01:00000010 63E10000          +20 
01:00000014 FBDF0010          +20 
01:00000018 4800000D          +20 
(+24)40
01:0000001C 0000000000000000  +20 
01:00000024 7FC802A6          +20 
01:00000028 EBDE0000          +20 
01:0000002C 64030021          +21 	return64,__immediate	33
01:00000030 E83F0000          +21 
01:00000034 E8010008          +21 
01:00000038 7C0803A6          +21 
01:0000003C EBC1FFF0          +21 
01:00000040 EBE1FFF8          +21 
01:00000044 4E800020          +21 
  :                            22 	.size	adjustment, .-adjustment
  :                            23 	.align 2
  :                            24 	.globl overcoat
  :                            25 	.type	overcoat, @function
  :                            26 overcoat:
01:00000048 F821FFE1          +27 	enter64	32
01:0000004C 7C0802A6          +27 
01:00000050 FBE10018          +27 
01:00000054 F8010028          +27 
01:00000058 63E10000          +27 
01:0000005C FBDF0010          +27 
01:00000060 4800000D          +27 
(+24)40
01:00000064 0000000000000000  +27 
01:0000006C 7FC802A6          +27 
01:00000070 EBDE0000          +27 
01:00000074 E93E0000          +28 	ld	9, __literal(	__upper48	acu@ha)
(+03:00000000/*02)0e*/02-
01:00000078 E8090000          +29 	ld	0, acu@l(9)
01:0000007C 60600000          +30 	mr	3,0
[+0000:ffffff80/*02]18*/02+
(-01:ffffff80/*02)18*/02+
01:00000080 4BFFFF81          +31 	bl	soso
01:00000084 E83F0000          +32 	leave64
01:00000088 E8010008          +32 
01:0000008C 7C0803A6          +32 
01:00000090 EBC1FFF0          +32 
01:00000094 EBE1FFF8          +32 
01:00000098 4E800020          +32 
  :                            33 	.size	overcoat, .-overcoat
  :                            34 	.ident	"GCC: (GNU) 4.2.1"
  :                            10 	$store		gfactor
  :                            11 	.align		3
*EOF*
24:00000000+(03:00008000/*10)30*/10:0000000000000000
:$(01):00000000:000000A0 :$(03):00000000:00000008 :$(06):00000000:00000004 :$(24):00000000:00000008 
gfactor.msm: object code 847 bytes: 0 errors: 1 undefined labels


</pre>


<p>
The seventh link places relocatables in giant absolute address space.
The displayed summary information only shows the non-giant parts of
the addresses, but the label values and the text-encoded binary
(and the generated code listed because of <b>$list 2</b>) show the
whole addresses.
<pre>


$ ../masmx map7 -l

MASMX 7r2
3/map7.msm
gsoso.txo:$(1) 168 bytes decimal from hexadecimal 00000000 to 000000A8
gsoso.txo:$(3) 16 bytes decimal from hexadecimal 00000000 to 00000010
gsoso.txo:$(5) 12 bytes decimal from hexadecimal 00000000 to 0000000C
gsoso.txo:$(6) 4 bytes decimal from hexadecimal 00000000 to 00000004
gsoso.txo:$(36) 32 bytes decimal from hexadecimal 00000000 to 00000020
gfactor.txo:$(1) 160 bytes decimal from hexadecimal 000000A8 to 00000148
gfactor.txo:$(3) 8 bytes decimal from hexadecimal 00000010 to 00000018
gfactor.txo:$(6) 4 bytes decimal from hexadecimal 00000004 to 00000008
gfactor.txo:$(36) 8 bytes decimal from hexadecimal 00000020 to 00000028
*EOF*
  :                            1 __giant	$set		1
  :                            2 
  :                            3: 	$include	"ppc64map.def"
  :                            4 
  :                            5 $(1::*000A000000000000)
  :                            6 $(36::*000A800000000000)
  :                            7 $(3::*000B000000000000)
  :                            8 $(5::*000B800000000000)
  :                            9 $(6::*000C000000000000)
  :                            10 	$list			2
  :                            11: 	$include,$binary	gsoso
06:000C000000000000:00000037  +4 00000037
03:000B000000000000:00000063  +7 00000063
03:000B000000000004:000B800000000008
                              +9 (05)40:0000000000000008
03:000B00000000000C:A5A5A5A5  +11 A5A5A5A5
01:000A000000000000:F821FFC1  +14 F821FFC1 7C0802A6 FBE10038 F8010048 63E10000 FBDF0030
01:000A000000000004:7C0802A6  +14 
01:000A000000000008:FBE10038  +14 
01:000A00000000000C:F8010048  +14 
01:000A000000000010:63E10000  +14 
01:000A000000000014:FBDF0030  +14 
01:000A000000000018:4800000D  +15 4800000D (24)40:0000000000000000 7FC802A6 EBDE0000 E93E0000
01:000A00000000001C:000A800000000000
                              +15 
01:000A000000000024:7FC802A6  +15 
01:000A000000000028:EBDE0000  +15 
01:000A00000000002C:E93E0000  +15 
01:000A000000000030:E929000A  +16 (05:00000008/*02)0E*/02-:E929000A 913F0010 38010009 E93E0000
01:000A000000000034:913F0010  +16 
01:000A000000000038:38010009  +16 
01:000A00000000003C:E93E0000  +16 
01:000A000000000040:90090008  +17 (05)10-:90090008 E93E0008 [0000:00000000/*02]0E*/02-:E9290002
01:000A000000000044:E93E0008  +17 
01:000A000000000048:E9290006  +17 
01:000A00000000004C:E81F0012  +18 E81F0012 7C0049D6 901F0010 E93E0010 (03:00000004/*02)0E*/02-:E8090004
01:000A000000000050:7C0049D6  +18 
01:000A000000000054:901F0010  +18 
01:000A000000000058:E93E0010  +18 
01:000A00000000005C:E8090004  +18 
01:000A000000000060:60600000  +19 60600000 [0001:FFFFFF9C/*02]18*/02+:(-01:FFFFFF9C/*02)18*/02+:4BFFFF9D
01:000A000000000064:48000045  +19 
01:000A000000000068:61230000  +20 61230000 801F0010 7C004A14 901F0010 E93E0018 (03:00000000/*02)0E*/02-:E9290002
01:000A00000000006C:801F0010  +20 
01:000A000000000070:7C004A14  +20 
01:000A000000000074:901F0010  +20 
01:000A000000000078:E93E0018  +20 
01:000A00000000007C:E9290002  +20 
01:000A000000000080:E81F0012  +21 E81F0012 7C090050 60600000 E9610000 E80B0008 7C0803A6
01:000A000000000084:7C090050  +21 
01:000A000000000088:60600000  +21 
01:000A00000000008C:E9610000  +21 
01:000A000000000090:E80B0008  +21 
01:000A000000000094:7C0803A6  +21 
01:000A000000000098:EBDF0030  +22 EBDF0030 EBEBFFF8 602B0000 4E800020
01:000A00000000009C:EBEBFFF8  +22 
01:000A0000000000A0:602B0000  +22 
01:000A0000000000A4:4E800020  +22 
24:000A800000000000:000B800000000000
                              +25 (05:00008008/*10)30*/10:0000000000000000
24:000A800000000008:000C000000000000
                              +26 [0000:00008000/*10]30*/10:0000000000000000
24:000A800000000010:000B000000000000
                              +27 (03:00008004/*10)30*/10:0000000000000000
24:000A800000000018:000B000000000000
                              +28 (03:00008000/*10)30*/10:0000000000000000
  :                            12: 	$include,$binary	gfactor
06:000C000000000004:00000058  +4 00000058
03:000B000000000010:000C000000000004
                              +7 (06)40:0000000000000000
01:000A0000000000A8:F821FFE1  +10 F821FFE1 7C0802A6 FBE10018 F8010028 63E10000 FBDF0010
01:000A0000000000AC:7C0802A6  +10 
01:000A0000000000B0:FBE10018  +10 
01:000A0000000000B4:F8010028  +10 
01:000A0000000000B8:63E10000  +10 
01:000A0000000000BC:FBDF0010  +10 
01:000A0000000000C0:4800000D  +11 4800000D (24)40:0000000000000000 7FC802A6 EBDE0000 64030021
01:000A0000000000C4:000A800000000020
                              +11 
01:000A0000000000CC:7FC802A6  +11 
01:000A0000000000D0:EBDE0000  +11 
01:000A0000000000D4:64030021  +11 
01:000A0000000000D8:E83F0000  +12 E83F0000 E8010008 7C0803A6 EBC1FFF0 EBE1FFF8 4E800020
01:000A0000000000DC:E8010008  +12 
01:000A0000000000E0:7C0803A6  +12 
01:000A0000000000E4:EBC1FFF0  +12 
01:000A0000000000E8:EBE1FFF8  +12 
01:000A0000000000EC:4E800020  +12 
01:000A0000000000F0:F821FFE1  +14 F821FFE1 7C0802A6 FBE10018 F8010028 63E10000 FBDF0010
01:000A0000000000F4:7C0802A6  +14 
01:000A0000000000F8:FBE10018  +14 
01:000A0000000000FC:F8010028  +14 
01:000A000000000100:63E10000  +14 
01:000A000000000104:FBDF0010  +14 
01:000A000000000108:4800000D  +15 4800000D (24)40:0000000000000000 7FC802A6 EBDE0000 E93E0000
01:000A00000000010C:000A800000000020
                              +15 
01:000A000000000114:7FC802A6  +15 
01:000A000000000118:EBDE0000  +15 
01:000A00000000011C:E93E0000  +15 
01:000A000000000120:E8090010  +16 (03:00000000/*02)0E*/02-:E8090000 60600000 [0000:FFFFFF80/*02]18*/02+:(-01:FFFFFF80/*02)18*/02+:4BFFFF81
01:000A000000000124:60600000  +16 
01:000A000000000128:4BFFFED9  +16 
01:000A00000000012C:E83F0000  +17 E83F0000 E8010008 7C0803A6 EBC1FFF0 EBE1FFF8 4E800020
01:000A000000000130:E8010008  +17 
01:000A000000000134:7C0803A6  +17 
01:000A000000000138:EBC1FFF0  +17 
01:000A00000000013C:EBE1FFF8  +17 
01:000A000000000140:4E800020  +17 
24:000A800000000020:000B000000000000
                              +20 (03:00008000/*10)30*/10:0000000000000000
  :                            13 
  :                            14 	$store			image7
*EOF*
:$(01):00000000:00000148 :$(03):00000000:00000018 :$(05):00000000:0000000C :$(06):00000000:00000008 :$(24):00000000:00000028 
map7.msm: object code 1448 bytes: 0 errors: 0 undefined labels

$ cat image7.txo

@:06:000C000000000000
$06:00000000
00000037
@:03:000B000000000000
$03:00000000
00000063
$03:00000004
000B800000000008
$03:0000000C
A5A5A5A5
@:01:000A000000000000
$01:00000000
F821FFC1 7C0802A6 FBE10038 F8010048 63E10000 FBDF0030
4800000D 000A800000000000 7FC802A6 EBDE0000 E93E0000 E929000A
913F0010 38010009 E93E0000 90090008 E93E0008 E9290006
E81F0012 7C0049D6 901F0010 E93E0010 E8090004 60600000
48000045 61230000 801F0010 7C004A14 901F0010 E93E0018
E9290002 E81F0012 7C090050 60600000 E9610000 E80B0008
7C0803A6 EBDF0030 EBEBFFF8 602B0000 4E800020
@:24:000A800000000000
$24:00000000
000B800000000000 000C000000000000 000B000000000000
000B000000000000
$06:00000004
00000058
$03:00000010
000C000000000004
$01:000000A8
F821FFE1 7C0802A6 FBE10018 F8010028 63E10000 FBDF0010
4800000D 000A800000000020 7FC802A6 EBDE0000 64030021 E83F0000
E8010008 7C0803A6 EBC1FFF0 EBE1FFF8 4E800020
$01:000000F0
F821FFE1 7C0802A6 FBE10018 F8010028 63E10000 FBDF0010
4800000D 000A800000000020 7FC802A6 EBDE0000 E93E0000 E8090010
60600000 4BFFFED9 E83F0000 E8010008 7C0803A6 EBC1FFF0
EBE1FFF8 4E800020
$24:00000020
000B000000000000
+ADJUSTMENT:$01:000A0000000000A8
+CLANJAMFRIE:$06:000C000000000000
+FACTOR:$06:000C000000000004
+OVERCOAT:$01:000A0000000000F0
+SOSO:$01:000A000000000000
:$01*00000000:00000000:00000148
:$03*00000000:00000000:00000018
@:05:000B800000000000
:$05*00000000:00000000:0000000C
:$06*00000000:00000000:00000008
:$24*00000000:00000000:00000028


</pre>
<p>
Segments are always gathered by section with giant addresses. The
giant addresses can come from the link source or from the input
Text Encoded Binary

<p>
The $MAP macro used in giant space has this structure.

<p>
Where operand fields can relocate out of their range and then
relocate back into range again, because of multiple relocation
clauses for relative address calculations, a value <b>sum</b> is
maintained at 192-bits precision.

<p>
The $INFO subcommand $RANGE_CHECK requires only the last written
value to be in field range.

<p>
The $PUSHREL subcommand $LONG_ABSOLUTE allows a segment base value
or external label value 192 bits in size to be retrieved
<pre>

p	$proc
"$map"*	$name

p	$proc
superword* $name
parts	$set	p(1,1:)
"$data"	$set,$binary	p(1,1:parts)

column	$set	$bits

part	$do	parts-1,	relocate	p(1, 1:part)
	$load,$bits	$data
	$end	. SUPERWORD

p	$proc
relocate* $name


rel_params $pushrel	p(1,1)

value	$pushrel,$long_absolute	p(1,1)

bits    $set    rel_params\2
scale   $set    rel_params\3
offset  $set    rel_params\4
descant $set    rel_params\5

limit   $set    1*/bits
mask    $set    limit-1
unmask  $set    ^(mask*/scale)

	$if	scale^=column
sum*	$set	0
column*	$set	scale
	$endif

sum*	$set	value+sum

	$if	descant<0

field	$set	sum+offset
	$info,$range_check	field
field	$set	(field*/descant)**mask

	$else

field	$set	sum+(($data/*scale)**mask)

	$info,$range_check	field

	$endif


"$data"* $set	(field*/scale)++($data**unmask)

	$end	. RELOCATE

index	$do	p(),	word	p(index, 1)
	$end	. $MAP

</pre>
<h4>9.2.3.8: The Incremental Link in Giant Address Space</h4>


<p>
The eighth link increments relocatable gzactor.txo on the end of the giant
address absolute from the seventh link. 
<pre>

$ ../cat gzactor.msm
__relocatable	$set	1
__giant		$set	1

	$include	"ppc_64.def"
	$include	 enter64.def

__litseg $set           36
$(__litseg:*8,r30/__literal)
__base36

	$if	1
$(.data)
myword	.int		99
	$endif

$(.text)
zactor*
	enter64	32
        ld	9, __literal(	__upper48	factor@ha)
        lwz	0, factor@l(9)

	ld	10, __literal(	__upper48	myword@ha)
	lwz	11, myword@l(10)

	bl	soso

	leave64

	$store	gzactor

$ ../masmx map8 -l

MASMX 7r2
3/map8.msm
image7.txo:$(1) 328 bytes decimal from hexadecimal 00000000 to 00000148
image7.txo:$(3) 24 bytes decimal from hexadecimal 00000000 to 00000018
image7.txo:$(5) 12 bytes decimal from hexadecimal 00000000 to 0000000C
image7.txo:$(6) 8 bytes decimal from hexadecimal 00000000 to 00000008
image7.txo:$(36) 40 bytes decimal from hexadecimal 00000000 to 00000028
gzactor.txo:$(1) 88 bytes decimal from hexadecimal 00000148 to 000001A0
gzactor.txo:$(3) 4 bytes decimal from hexadecimal 00000018 to 0000001C
gzactor.txo:$(36) 16 bytes decimal from hexadecimal 00000028 to 00000038
*EOF*
  :                            1 __giant	$set		1
  :                            2: 	$include	"ppc64map.def"
  :                            3 	$list		 1
  :                            4 
  :                            5 .	$set_option	"b"
  :                            6 
  :                            7: 	$include,$binary	image7
  :                            8: 	$include,$binary	gzactor
  :                            9 
  :                            10 	$store			image8
*EOF*
:$(01):00000000:000001A0 :$(03):00000000:0000001C :$(05):00000000:0000000C :$(06):00000000:00000008 :$(24):00000000:00000038 
map8.msm: object code 1756 bytes: 0 errors: 0 undefined labels

$ cat image8.txo

@:06:000C000000000000
$06:00000000
00000037
@:03:000B000000000000
$03:00000000
00000063
$03:00000004
000B800000000008
$03:0000000C
A5A5A5A5
@:01:000A000000000000
$01:00000000
F821FFC1 7C0802A6 FBE10038 F8010048 63E10000 FBDF0030
4800000D 000A800000000000 7FC802A6 EBDE0000 E93E0000 E929000A
913F0010 38010009 E93E0000 90090008 E93E0008 E9290006
E81F0012 7C0049D6 901F0010 E93E0010 E8090004 60600000
48000045 61230000 801F0010 7C004A14 901F0010 E93E0018
E9290002 E81F0012 7C090050 60600000 E9610000 E80B0008
7C0803A6 EBDF0030 EBEBFFF8 602B0000 4E800020
@:24:000A800000000000
$24:00000000
000B800000000000 000C000000000000 000B000000000000
000B000000000000
$06:00000004
00000058
$03:00000010
000C000000000004
$01:000000A8
F821FFE1 7C0802A6 FBE10018 F8010028 63E10000 FBDF0010
4800000D 000A800000000020 7FC802A6 EBDE0000 64030021 E83F0000
E8010008 7C0803A6 EBC1FFF0 EBE1FFF8 4E800020
$01:000000F0
F821FFE1 7C0802A6 FBE10018 F8010028 63E10000 FBDF0010
4800000D 000A800000000020 7FC802A6 EBDE0000 E93E0000 E8090010
60600000 4BFFFED9 E83F0000 E8010008 7C0803A6 EBC1FFF0
EBE1FFF8 4E800020
$24:00000020
000B000000000000
$03:00000018
00000063
$01:00000148
F821FFE1 7C0802A6 FBE10018 F8010028 63E10000 FBDF0010
4800000D 000A800000000028 7FC802A6 EBDE0000 E93E0000 80090004
E95E0008 816A0018 4BFFFE7D E83F0000 E8010008 7C0803A6
EBC1FFF0 EBE1FFF8 4E800020
$24:00000028
000C000000000000 000B000000000000
+ADJUSTMENT:$01:000A0000000000A8
+CLANJAMFRIE:$06:000C000000000000
+FACTOR:$06:000C000000000004
+OVERCOAT:$01:000A0000000000F0
+SOSO:$01:000A000000000000
+ZACTOR:$01:000A000000000148
:$01*00000000:00000000:000001A0
:$03*00000000:00000000:0000001C
@:05:000B800000000000
:$05*00000000:00000000:0000000C
:$06*00000000:00000000:00000008
:$24*00000000:00000000:00000038

</pre>

<h4>9.2.3.9: Linking with Void Inclusion</h4>


<p>
The ninth and tenth links have void inclusions. A void inclusion integrates
the new code onto the referenced absolute without including the referenced
absolute. So the new Text Encoded Binary knows the addresses in the
referenced absolute, but is a separate load.

<p>
relocatable zactor.txo is integrated with absolute image2 = soso + factor:
<pre>

$ ../masmx map9 -l

MASMX 7r2
3/map9.msm
image2.txo:$(1) 244 bytes decimal from hexadecimal 000A0000 to 000A00F4
image2.txo:$(3) 16 bytes decimal from hexadecimal 000B0000 to 000B0010
image2.txo:$(5) 12 bytes decimal from hexadecimal 000B8000 to 000B800C
image2.txo:$(6) 8 bytes decimal from hexadecimal 000C0000 to 000C0008
zactor.txo:$(1) 24 bytes decimal from hexadecimal 000A00F4 to 000A010C
zactor.txo:$(3) 4 bytes decimal from hexadecimal 000B0010 to 000B0014
*EOF*
  :                            1:       $include        "map_ppc.def"
  :                            2 
  :                            3        $set_option     "b"
  :                            4 
  :                            5        $include,$void          image2
  :                            6:       $include,$binary        zactor
  :                            7 
  :                            8        $store                  image9
*EOF*
:$(01):000A0000:000A010C :$(03):000B0000:000B0014 :$(05):000B8000:000B800C :$(06):000C0000:000C0008 
map9.msm: object code 352 bytes: 0 errors: 0 undefined labels

$ cat image9.txo

$03:000B0010
00000063
$01:000A00F4
3D20000C 80090004 3D40000B 816A0010 4BFFFEFD 4E800020
+ADJUSTMENT:$01:000A0094
+CLANJAMFRIE:$06:000C0000
+FACTOR:$06:000C0004
+OVERCOAT:$01:000A00B8
+SOSO:$01:000A0000
+ZACTOR:$01:000A00F4
:$01*00000000:000A0000:000A010C
:$03*00000000:000B0000:000B0014
:$05*00000000:000B8000:000B800C
:$06*00000000:000C0000:000C0008


</pre>
<h4>9.2.3.10: Linking With Void Inclusion in Giant Address Space</h4>


<p>
The tenth link does a void include with giant addresses:

<pre>
$ ../masmx map10 -l

MASMX 7r2
3/map10.msm
image7.txo:$(1) 328 bytes decimal from hexadecimal 00000000 to 00000148
image7.txo:$(3) 24 bytes decimal from hexadecimal 00000000 to 00000018
image7.txo:$(5) 12 bytes decimal from hexadecimal 00000000 to 0000000C
image7.txo:$(6) 8 bytes decimal from hexadecimal 00000000 to 00000008
image7.txo:$(36) 40 bytes decimal from hexadecimal 00000000 to 00000028
gzactor.txo:$(1) 88 bytes decimal from hexadecimal 00000148 to 000001A0
gzactor.txo:$(3) 4 bytes decimal from hexadecimal 00000018 to 0000001C
gzactor.txo:$(36) 16 bytes decimal from hexadecimal 00000028 to 00000038
*EOF*
  :                            1 __giant	$set		1
  :                            2: 	$include	"ppc64map.def"
  :                            3 	$list		 2
  :                            4 
  :                            5 	$include,$void		image7
  :                            6: 	$include,$binary	gzactor
03:000B000000000018:00000063  +4 00000063
01:000A000000000148:F821FFE1  +7 F821FFE1 7C0802A6 FBE10018 F8010028 63E10000 FBDF0010
01:000A00000000014C:7C0802A6  +7 
01:000A000000000150:FBE10018  +7 
01:000A000000000154:F8010028  +7 
01:000A000000000158:63E10000  +7 
01:000A00000000015C:FBDF0010  +7 
01:000A000000000160:4800000D  +8 4800000D (24)40:0000000000000000 7FC802A6 EBDE0000 E93E0000
01:000A000000000164:000A800000000028
                              +8 
01:000A00000000016C:7FC802A6  +8 
01:000A000000000170:EBDE0000  +8 
01:000A000000000174:E93E0000  +8 
01:000A000000000178:80090004  +9 [0000]10-:80090000 E95E0008 (03)10-:816A0000 [0001:FFFFFFC4/*02]18*/02+:(-01:FFFFFFC4/*02)18*/02+:4BFFFFC5
01:000A00000000017C:E95E0008  +9 
01:000A000000000180:816A0018  +9 
01:000A000000000184:4BFFFE7D  +9 
01:000A000000000188:E83F0000  +10 E83F0000 E8010008 7C0803A6 EBC1FFF0 EBE1FFF8 4E800020
01:000A00000000018C:E8010008  +10 
01:000A000000000190:7C0803A6  +10 
01:000A000000000194:EBC1FFF0  +10 
01:000A000000000198:EBE1FFF8  +10 
01:000A00000000019C:4E800020  +10 
24:000A800000000028:000C000000000000
                              +13 [0000:00008000/*10]30*/10:0000000000000000
24:000A800000000030:000B000000000000
                              +14 (03:00008000/*10)30*/10:0000000000000000
  :                            7 
  :                            8 	$store			image10
*EOF*
:$(01):00000000:000001A0 :$(03):00000000:0000001C :$(05):00000000:0000000C :$(06):00000000:00000008 :$(24):00000000:00000038 
map10.msm: object code 732 bytes: 0 errors: 0 undefined labels

$ cat image10.txo

@:03:000B000000000000
$03:00000018
00000063
@:01:000A000000000000
$01:00000148
F821FFE1 7C0802A6 FBE10018 F8010028 63E10000 FBDF0010
4800000D 000A800000000028 7FC802A6 EBDE0000 E93E0000 80090004
E95E0008 816A0018 4BFFFE7D E83F0000 E8010008 7C0803A6
EBC1FFF0 EBE1FFF8 4E800020
@:24:000A800000000000
$24:00000028
000C000000000000 000B000000000000
+ADJUSTMENT:$01:000A0000000000A8
+CLANJAMFRIE:$06:000C000000000000
+FACTOR:$06:000C000000000004
+OVERCOAT:$01:000A0000000000F0
+SOSO:$01:000A000000000000
+ZACTOR:$01:000A000000000148
:$01*00000000:00000000:000001A0
:$03*00000000:00000000:0000001C
@:05:000B800000000000
:$05*00000000:00000000:0000000C
@:06:000C000000000000
:$06*00000000:00000000:00000008
:$24*00000000:00000000:00000038

</pre>

<h1>10:  Describing Target Architecture in Text</h1>

<h2>10.1: Establishing your Syntax</h2>


<p>
When masmx starts running,
<ul>
	semicolon is line continuation
<pre></pre>

	period is line termination (comment)
<pre></pre>

	period does not terminate the line
	if it is followed immediately with a nonspace
	token, as
        <pre>

		$include	file.name
		+		1.8	. floating value

        </pre>
	Any other comment character terminates the
	line unconditionally:
        <pre>

		$lterm		'#'

		+		1.75	#floating value

	</pre>
	No symbol inside single or double quotes terminates the line
<pre></pre>

	text string delimiter is "
<pre></pre>

	substring delimiter is colon
<pre></pre>

	leading zero on a number is hex
<pre></pre>
	numbers beginning 1..9 are decimal
<pre></pre>
	numbers beginning \ are bit-pattern binary

</ul>
<p>
If you don't want semicolon to mean line continuation
that's the first thing you change. If you don't want
line continuations at all
<pre>

	$CONT_CHAR       0

</pre>
<p>
Continuation character is not recognised if if is followed immediately
by a nonspace token
<pre>

$ masmx -ln
MASMX 7r2
0/-INPUT>>
	$cont_char       '\'
CONT_CHAR=\
	$word		32
	+		\10101010\	bit pattern 0xAA and line continue
			*/16\		shift left 16 and line continue
			++3     	. OR 3
	$end
  :                            1  $cont_char '\'
  :                            2  $word  32
00:00000000 00AA0003          +3  +  \10101010*/16++3  . OR 3
  :                            4  $end
:$(00):00000000:00000001 
-INPUT>>: object code 54 bytes: 0 errors: 0 undefined labels

</pre>
<p>
If you want comment to be semicolon
<pre>

	$LTERM  ';'

</pre>
<p>
If you want text strings to be bounded by apostrophe
<pre>

	$QUOTE  027

</pre>
<p>
or maybe
<pre>

	$QUOTE  ''''

</pre>
<p>
However macro language does not recognise parameterised label
references inside single quotes-see Section 8.42: $QUOTE directive.

<p>
If you want substring delimiter to be period
<pre>

	$STERM  '.'

</pre>
<p>
If you want inputs with leading zero to be octal and
displays to be octal
<pre>

	$OCTAL

</pre>
<p>
If you change your mind
<pre>

	$HEX

</pre>
<p>
If you have number strings in your code with trailing 
flags like 123q or 0abaH 
<pre>

	$SUFFIX 2

</pre>
<p>
If you want leading 0... to be octal and leading 0x... to be hex
<pre>

	$SET_OPTION     "c"

</pre>
If you want leading $... to be hex
<pre>

	$SET_OPTION     "m"

</pre>
If you want both
<pre>

	$SET_OPTION     "mc"

</pre>
<p>
If you've done that and you still want to access masmx-supplied
functions like location counter "$" and identity of location
counter "$r" without using quotes, you alias masmx 
function names (It's assumed here you've changed $STERM to period):
<pre>

.           $equ,"$function"    "$"
.locator_id $equ,"$function"    "$r"
.class      $equ,"$function"    "$t"

</pre>
<p>
This equates
<pre>

	.		to location counter function		"$"

	.locator_id	to function yielding id of
			current counter of reference	    	"$r"

	.class		to function yielding label type		"$t"


</pre>
<p>
if "$" "$r" "$t" are in quotes as shown. This retrieves the functional
identities of
<pre>

	"$"		for	. 

	"$r" 		for	.locator_id

	"$t"		for	.class


</pre>
<p>
Without the quotes $ $r $t return their functional value instead
of their identity.

<p>
The quotes are necessary to give "$" "$r" "$t" the new names
. .locator_id .class

<p>
Directives beginning with $ when Motorola Hex (option <b>-m</b>) is
asserted are still recognised in the command field, but not
in the subcommand or argument fields. If your code has many
directives with other names, you may alias masmx directives:
<pre>

.equ    $equ,"$directive"       "$equ"
.if     .equ,"$directive"       "$if"
.elseif .equ,"$directive"       "$elseif"
.else   .equ,"$directive"       "$else"
.endif  .equ,"$directive"       "$endif"
.macro  .equ,"$directive"       "$proc"
.macend .equ,"$directive"       "$end"

</pre>
<p>
If your code has directives with no masmx equivalent, you write
the required directives as macros.
<pre>

.org*   .macro
$(0:.org(1,1))
	.macend

.align* .macro
granule $set   1*/.align(1,1)
	$res    (.+granule-1**-granule)-.
	.macend

.globl*	.macro
".globl(1,1)"**	$blank
	.macend

</pre>

<p>
If your code contains operators that aren't
<pre>

= ^= > < -- ++ /* */ ** + - /// // / * *+ *- ^ ()

</pre>
<p>
you need to translate some text on input
<pre>

	$text   /!=/^=/
	$text	\<=\-1<\
	$text	/>=/+1>/
	$text   \%\///\
	$text   /|/++/
	$text   \<<\*/\
	$text   \>>\/*/
	$text   /&/**/
	$text   /^/--/
	$text   /~/^/

</pre>
<p>
or perhaps
<pre>

	$text   / EQ /=/
	$text   / NE /^=/
	$text   \ LT \<\
	$text   / GT />/
	$text	\ LE \-1<\
	$text	/ GE /+1>/
	$text   \ MOD \///\
	$text   / OR /++/
	$text   \ SHL \*/\
	$text   \ SHR \/*\
	$text   \ ASHR \*/-\
	$text   / AND /**/
	$text   / XOR /--/
	$text   / NOT /^/

</pre>
<p>
All $TEXT directive lines must be together in your header.
masmx will only search one sequence of $TEXT in the label
table, for efficiency.

<h2>10.2: Describing the Target Architecture</h2>


<p>
The directives which are central to masmx are described here
in related groups and described in alphabetical order in
Section 8: Directives.

<p>
All directives appear in the instruction field of the assembly 
language line.



<h3>10.2.1: $WORD, $BYTE, $QUANTUM, $AWIDTH</h3>

	       
<p>
It's nowhere assumed that your machine has a word size like
8, 16, 32 or 64, or that its address quantum is an 8-bit byte.

<p>
These four directives describe the basics of the machine
to masmx.
<pre>


	$WORD   bits_in_computer_word

</pre>
<p>
$WORD defines the smallest amount of code that can be generated 
from one source line. See also $QUANTUM. One guide to selecting 
word is the size of the smallest instruction in the instruction
set. If the machine has single-octet instructions $WORD must be
8. 32 is suitable for PowerPC, 16 for m68k or ColdFire.
<pre>

	$BYTE   bits_per_character

</pre>
<p>
$BYTE defaults to 8. It can be set to anything and character 
strings are packed accordingly.
<pre>

	$QUANTUM  bits_in_addressable_location

</pre>
<p>
$QUANTUM is the same as $WORD for very few computer 
architectures. Nevertheless $WORD automatically sets 
$QUANTUM and $AWIDTH. For PowerPC and Alpha:
<pre>

	$WORD      32
	$QUANTUM   8

</pre>
<p>
are suitable settings.
<pre>

	$AWIDTH         bits_in_address

</pre>
<p>
$AWIDTH describes how many bits are used to express 
a load address in the the assembly output file. 8-bit 
microprocessors and microcontrollers have a word size 
of 8 but usually an address width of 16, so it is 
necessary to override the default address width set 
by $WORD:
<pre>

	$WORD           8
	$AWIDTH         16

</pre>
<p>
$AWIDTH has a second part for the giant part of
address space, for example:
<pre>

	$awidth         32:64

</pre>
<p>
This allows the 32-bit location counters to be stepped
through astronomic space when constructing giant code
and data. One instruction stream or array scalar may only
be constructed to a size of 4 gigaquanta, but an array
of either may be constructed up to 2 power 192 in size

<p>
See also section 9:	Output File Formats, Relocation and Linking,
			Giant Address Spaces, Interfacing with GNU Tools


<h3>10.2.2: $FORM, $PROC, $NAME, $END</h3>


<p>
These four directives are the building blocks of machine
instructions and architectural descriptors.

<h4>10.2.2.1: The $FORM Template</h4>
<pre>

label   $FORM   bit_field_width, ...,bit_field_width

</pre>
<p>
$FORM describes a microstructure, especially an instruction 
layout, of any size up to 192 bits. For example, load/store
instructions for PowerPC have the layout
<pre>

"$load_store_instruction" $form   6, 5, 5, 16    


</pre>
<h4>10.2.2.2: The $PROC Header</h4>
<pre>      

label   $PROC

</pre>
<p>
$PROC begins an inline macro which may be used in the command field
(a $FUNC is a value-generating macro used in expressions).

<p>
The label on a $PROC or a $FUNC can only be used as a macro
call if it has an asterisk* to make it visible outside the macro.

<p>
In the following example, "p" is not visible outside the macro,
and could be used as the header label of other macros without problems.

<p>
Because "p" is not visible outside the macro, the macro can only be
called with the names "lwz" and "stw"

<p>
The label of a $PROC is used functionally to 
reference actual arguments, for example 
<pre>

p       $proc
	.
lwz*	$name	OPCODE_LWZ
stw*	$name	OPCODE_STW
	.
	$instruction_form   p(0, 1), p(1, 1) .index\p(1, 2), p(1, 2)
	$end

</pre>
<p>
p(0, 1) references the command on the call line,
p(1, 1) the first argument subfield. See Section 
4.2.3.2.2.3: Macro Parameters


<h4>10.2.2.3: The $NAME Entry Point</h4>
 <pre> 

label*   $NAME   value

</pre>
<p>
$NAME lines are entry points in $PROCs and $FUNCs.

<p>
$NAME assigns a value to the call name which can be
referenced as any of p(0, 1) or p(0, 0) or $N.

<p>
The label* on a $NAME directive can only be used to call the
macro if it is made visible outside the macro by being promoted
with an asterisk*

<p>
One $PROC macro may generate several instructions
with similar layout. Such a macro has several
$NAME entry points.

<h4>10.2.2.4: The $END Macro Footer</h4>

<p>
$END ends a subassembly (the macro or the main assembly).


<h4>6.2.2.5: Minimal Instruction Macro Example</h4>

<p>
$FORM, $PROC and $NAME and $END describe an imaginary computer
architecture to the assembler:
<pre>

standard_format $FORM   8, 16

instruction     $PROC

load*           $NAME   0
store*          $NAME   1
add*            $NAME   2
subtract*       $NAME   3

		standard_format     $N, instruction(1, 1)

		$END

</pre>
<p>
The label on a $PROC, a $FUNC or a $NAME can only be used as a macro
call if it has an asterisk* to make it visible outside the macro.

<p>
"instruction" is not visible outside the macro, and can be used as the
header label of other macros.

<p>
These lines of code
<pre>

	load    4094
	add     4097
	subtract 100
	store   2047

</pre>
<p>
will generate
<pre>

	000ffe
	021001
	030064
	0107ff

</pre>


<h4>10.2.2.6: The Two-pass $PROC</h4>


label   $PROC	*

<p>
If the first argument on a $PROC line is * then the $PROC is two-pass
in the second pass of the main assembly.

<p>
This allows forward references to local labels within the $PROC.

<p>
Labels defined in a $PROC are dropped when the $END image is encountered, unless they  are flagged*** for visibility to one or more higher assembly 
levels.

<p>
Labels should only be promoted if other parts of the assembly need them,
but they may be forward-referenced within the macro.

<p>
The forward reference need not be resolved on the first assembly pass.

<p>
On the second pass, a preliminary pass within the macro expansion is
necessary for any labels which are forward-referenced and not global.



<h4>10.2.2.7 The Out of Line $PROC</h4>


<p>
A location counter with the strict syntax $(expression) can be coded
as the first or second argument on a $PROC directive
<pre>

p	$proc	* $(4)
enter*	$name
	.
	.
	$end

aside*	$proc	$(6)
	.
	.
	$end

</pre>
<p>
The $(expression) part may be the second argument when the two-pass
asterisk * flag is the first argument.


<h4>10.2.2.8: Nested Macro Descriptions</h4>

<p>
Macros are mostly defined one at a time.  They can call each other to
a large nesting depth:
<pre>

p*	$proc
	+	$l
	q
	$end

q*	$proc
	+	$l
	r
	$end

r*	$proc
	+	$l
	$end

</pre>
<p>
A command "p" also causes "q" and "r" to assemble.

<p>
Macro descriptions may also be written in a nested way:
<pre>

one*	$proc
two*	$proc
three*	$proc
	$end
	three
	$end
	two
	$end

</pre>
<p>
This is rarely necessary but may be an advantage.

<p>
"one" causes "two" to exist and to be called, and the call "two"
causes "three" to exist and to be called.

<p>
"one" exists during the whole of the main assembly. "two" exists when
"one" is subassembling. "three" exists when "two" is subassembling.

<p>
The macros "p" "q" and "r" are now described in a nested way, which
makes "q" and "r" invisible most of the time:
<pre>

p*      $proc
        +       $l
q*      $proc
        +       $l
r*      $proc
        +       $l
        $end
        r
        $end
        q
        $end

</pre>
<p>
So command "p" causes "q" to exist and to be called, and that causes
"r" to exist and to be called.

<p>
The names of inner macros are not visible to the main assembly. 

<p>
It's possible to declare one macro within another in order to
repeat-call the inner macro at the point where it's declared
($DO only repeats one line, but that line can be a macro call):
<pre>

macro1*	$proc

	.
	.

p	$proc
copyright* $name
	load	start+A_LOT-index
	store	start+A_LOT-index+1
	$end

index	$do	A_LOT,	copyright

	.
	.

	$end

</pre>
<h2>10.3: Synthesising Legacy Automatic Macros</h2>

<h3>10.3.1: Synthesising Legacy Functional Macros</h3>

<p>
The developer using masmx can implement function macros to replace
fixed functions of other assemblers. For example:

<p>
A legacy assembler may have a fixed macro <b>@</b>, meaning
"location counter of variables".

<p>
The developer using masmx can implement this function with these lines:
<pre>

@*	$func
	$return	$(1)
	$end

</pre>
<p>
To explain these lines in detail:
<ul>

	<pre></pre><b>@</b> is a label like any other label.
	It's the label of the macro.

	<pre></pre>there is an asterisk on <b>@*</b> to make it visible
	to the calling assembly

	<pre></pre><b>$func</b> is the directive at the head
	of a function macro

	<pre></pre>a function macro is a macro which returns a value
	at assembly time. Other kinds of macros generate code

	<pre></pre>the returned value is accessed in this case with the 	label <b>@</b>

	<pre></pre>functional values are tokens in expressions:
	<b>44/@+1*2++018</b>

	<pre></pre><b>$return</b> is a directive which returns
	the value to its right

	<pre></pre>the value in this case is the current state
	of a location counter

	<pre></pre>here, the returned value is location counter one.
	In the supplied definition 8051.def, <b>$(1)</b> counts
	the locations filled by variables. <b>$</b> is a masmx internal
	function name, meaning "location counter."

	<pre></pre><b>$end</b> ends any macro started with
	<b>$func</b> or <b>$proc</b>. 

	<pre></pre><b>$end</b> outside a macro ends the assembly.

	<pre></pre>the result size of a user-written function macro
	is 192 bits


</ul>

<p>
Here are a couple of assemblies which use function macro "@"
<pre>

MASMX/24592 1r1X
@.msm 5
CONT_CHAR=
LTERM=;
QDELIM='
STERM=.
*EOF*  :                        620:         $list   2
  :                        621: @*      $func
  :                        622:         $note   You Said @ so I think you mean the
  :                        623:         $note   location counter for variables
  :                        624:         $return $(1)
  :                        625:         $end
  :                        692:         $list   2   
  :                        693: $(1:1024)
  :                        2: 
  :                        3: first_buffer VAR        2048
Note: @.msm Line 4: You Said @ so I think you mean the
Note: @.msm Line 4: location counter for variables
00:0000 0C63          +4         +       @+99
*EOF*:$(00):0000:0002 :$(01):0400:0C00 
Object Code 58 Bytes: 0 Errors: 0 Undefined Labels

</pre>
<p>
However you may need to generate little-endian.

<h3>10.3.2: Synthesising Legacy Command Macros</h3>

<p>
masmx generates big-endian number values. Pseudo-instructions which
little-endian assemblers have for constant-generation (DW, DD etc)
are implemented as macros for masmx.

<p>
For example, 8051 developers are used to a pseudo-directive <b>DW</b>
from other assemblers.

<p>
That <b>DW</b> generates 16-bits little-endian. So we implement <b>DW</b>
here to do the same thing:
<pre>


MASMX/24592 1r1X
@.msm 5
CONT_CHAR=
LTERM=;
QDELIM='
STERM=.
*EOF*  :                        72:         $list   2
  :                        73: dw*     $proc
  :			   74: ?       $do dw(1), +  dw(1,?), dw(1,?)/*8:d  
  :                        75:         $note   You like to be in Little End Land?
  :                        76:         $note   Here you am!
  :                        77:         $end
  
  :                        624:         $list   2
  :                        625: @*      $func
  :                        626:         $note   You Said @ so I think you mean the
  :                        627:         $note   location counter for variables
  :                        628:         $return $(1)
  :                        629:         $end
  
  :                        696:         $list   2   
  :                        697: $(1:1024)
  :                        2: 
  :                        3: first_buffer VAR        2048

Note: @.msm Line 4: You Said @ so I think you mean the
Note: @.msm Line 4: location counter for variables
Note: @.msm Line 4: You like to be in Little End Land?
Note: @.msm Line 4: Here you am!
00:0000 630C          +4         dw      @+99
*EOF*:$(00):0000:0002 :$(01):0400:0C00 
Object Code 58 Bytes: 0 Errors: 0 Undefined Labels

</pre>
<p>
That is an example of a user written function ("@") used as
an token in an expression. Plus an example of a user-written
procedural macro, "DW".

<p>
A procedural macro generates code and runs from the
directive $PROC to the directive $END

<p>
A function macro returns a value to an expression and runs from
the directive $FUNC to the directive $END

<p>
The "DW" macro contains (apart from $note directives) these lines:
<pre>

dw*     $proc  
?       $do     dw(1),  +       dw(1, ?), dw(1, ?)/*8:d
        $end 

</pre>
<p>
To explain the <b>DW</b> macro
<ul>

	<b>dw</b> is a label like other labels. It's the label of the macro
<pre></pre>
	<b>dw*</b> has an asterisk to make it visible to the calling
	assembly
<pre></pre>
	<b>$proc</b> is the directive at the start of a
	code-producing macro
<pre></pre>
	the application writer may string <b>dw</b> values on a
	line, with a syntax:
<pre>

		dw	144, labelname, 15*90

</pre>
	therefore the the macro uses a <b>$do</b> directive, and
	uses a tag <b>?</b> on the <b>$do</b> to index into
	the actual arguments
<pre></pre>
	<b>?</b> is a label like any other. Its choice is arbitrary.
	<b>?</b> has no asterisk, so it only exists while the macro
	<b>dw</b> is subassembling.

<pre></pre>
	The label of a <b>$DO</b>, here <b>?</b>, is an incrementing tag.
	It starts from 1 and goes up.
<pre></pre>
	<b>dw(1)</b> is the number of comma-separated
	subfields in the first argumentof <b>dw</b>. It's the repeat
	count. Here its value is one for the one actual parameter
	<b>@+99</b>
<pre></pre>
	the repeat count after any <b>$do</b>, here <b>dw(1)</b>,
	is followed by
	a comma. The rest of the line is a line of assembly code which
	gets repeated. This line usually contains some parameterised
	values.
<pre></pre>
	In the <b>dw</b> macro, the inner line of assembly code is
<pre>

		+       dw(1, ?), dw(1, ?)/*8:d

</pre>
        here this line is assembled once only, for the one actual
	parameter <b>@+99</b>
<pre></pre>
	The parameter paraform 
<pre>
		dw(1, ?)
</pre>
	is field 1, subfield [?] of macro <b>dw</b>. It's referenced twice
	per actual parameter.
<pre></pre>
	The command code of <b>+</b> means a number constant.
	<b>-</b> or <b>^</b> (1s complement) also work as number
	constant commands
<pre></pre>
	Where masmx source has something like
<pre>

		+	expression, expression

</pre>

	or
<pre>
		+	expression, expression, expression:q

</pre>
	That means put values in equal-size fields of a word or multiword.
<pre></pre>
	Supplied definition <b>8051.def</b> has 8 bits for word size.
<pre></pre>
	This line
<pre>

		+	dw(1, ?), dw(1, ?)/*8:d

</pre>
	Ends <b>:d</b> for double, so 16-bits total.
<pre></pre>
	And has one comma, so two 8-bit fields.
<pre></pre>
	The expression on the left, <b>dw(1, ?)</b> places the actual
	parameter value in the left eight bits. Truncation makes that
	the LSB.
<pre></pre>
	The expression on the right, <b>dw(1, ?)/*8</b> shifts the actual
	parameter value eight bits right,  and places that in the right
	eight bits. The shift makes this the MSB of the value.
<pre></pre>
	<b>$end</b> directive ends the macro
</ul>



<h1>11: masmx Internal Floating Format and Alternative Floating Formats</h1>


<h2>11.1: masmx Floating Format</h2>

The default masmx floating number is the the 192-bit
value rounded to 96 bits with 23-bit midpointed exponent
and 72-bit all-fractional mantissa.

<p>
The width and exponent-width of a floating item output in masmx default
format can be adjusted with the directives
<pre>

	$FLOATING_POINT

	$CHARACTERISTIC

</pre>
but the scheme
<pre>

	mid-point-exponent.normalised-fractional-mantissa.1s-complement

</pre>
is only changed with macro language

<h2>11.2: IEEE754 Floating Values</h2>


<h3>11.2.1: Differences between masmx FLoating Format at IEEE754 Floating Formats</h3>

<p>
This package contains macros for assembling 128-bit,  64- and 32-bit
IEEE754 floating constants.

<p>
Macros use the directive $set to cache floating numbers as label
values for manipulation

<p>
The masmx internal format is:
<pre>

	a fraction-only 168-bit precision mantissa,
	normalising bit is represented, immediately
	to the right of the binary point

	a mid-pointed 23-bit exponent

	the entire item is 1s-complemented for negative polarity:
	sign bit = 1 indicates that all of the bits are inverted

	__________________________________________________________________
	|s|190 exponent 168|167          mantissa                       0|
	|_|________________|_____________________________________________|



</pre>
IEEE754 32-bit, 64-bit, and 128-bit floating formats have
<pre>

	an integral mantissa part one bit in size which is not
	represented. The encoded mantissa field starts with the
	first fractional bit. The normalising bit is the absent
	integral bit which has the imputed value 1.

	a biased exponent 8, 11 or 15 bits in size

	a sign bit which determines the polarity of the number.
	The remaining bits are not inverted with negative polarity.

	_____________________________________
	|s|exponent|mantissa fractional part|
	|_|________|________________________|
	          ^
	         |1| <- the unrepresented normalising integral bit


</pre>
For a given scale the IEEE754 biased exponent is 2 less than the
masmx abstract format mid-pointed exponent.

<p>
For the value 1.75 the masmx internal format places the true fraction
1110000000... at the top of the mantissa field, at the
immediate right of the binary point, and sets the exponent at one
greater than the mid-point, indicating that the integral value is
obtained by hauling the mantissa one bit position upwards through
the binary point:
<pre>

	The masmx Abstract Format
	_____________________________________________________________
	|s| 100 0000 0000 0000 0000 0001 | 1110 0000 0000 0000 ......
	|_|______________________________|___________________________


</pre>
In the IEEE754 32-bit, 64-bit and 128-bit formats, 1.75 has a biased
exponent one less than the mid point:
<pre>

	The IEEE754 64-bit Format
	___________________________________________________________
	|s| 011 1111 1111 | 1100 0000 0000 0000 0000...............
	|_|_______________|________________________________________
	                ^
	               |1| <- the unrepresented normalising integral bit

</pre>
These differences can be seen in the this assembly.
The first generated value is the masmx default, the second ieee754:
<pre>

MASMX 7r2
0/-INPUT>>
        $list   0
        $word   32
        $include        "ieee754.def"
        $list   2
        +               1.75
        ieee754_64      1.75
        $end
  :                            41         $list   2
00:00000000 400001E00000000000000000
                              +42         +               1.75
00:00000003 3FFC000000000000  +43         ieee754_64      1.75
  :                            44         $end
:$(00):00000000:00000005 
-INPUT>>: object code 87 bytes: 0 errors: 0 undefined labels

</pre>

<h3>11.2.2: Macro-Language Generation of IEEE754 FLoating Constants</h3>

The macro language for generating IEEE754 floating values is shown here.

<p>
These macros can be a guide for implementing any other floating
format transformations:
<pre>


	$floating_point	192
	$characteristic	24

fieee754_32 $form 1, 8, 23
fieee754_64 $form 1, 11, 52
fieee754_128 $form 1, 15, 112

p       $proc
ieee754_32* $name 0

tag     $set	 p(1,1)
sign    $set    tag/*191
        
        $if     sign
tag     $set    ^tag        
        $endif

characteristic $set (((tag/*183)**128)++((tag/*168)**127))-2
mantissa $set   ((tag**(1*/168)-1)+(7*/141))/*144

	$nop	adjust any rounding outflow
	$nop	indicated by a 25th bit

	$if	mantissa**1*/24
mantissa $set	mantissa/*1
characteristic $set characteristic+1
	$endif

        $nop	bits 166..144 -> bits 22..0. Normalising Bit 167 truncated
        
        fieee754_32 sign, characteristic, mantissa 
        $end


p       $proc
ieee754_64* $name 0

tag     $set	p(1,1)
sign    $set    tag/*191
        
        $if     sign
tag     $set    ^tag        
        $endif

characteristic $set (((tag/*180)**1024)++((tag/*168)**1023))-2
mantissa $set   ((tag**(1*/168)-1)+(7*/112))/*115

	$nop	adjust any rounding outflow
	$nop	indicated by a 54th bit

	$if	mantissa**(1*/53)
mantissa $set	mantissa/*1
characteristic $set characteristic+1
	$endif

        $nop	bits 166..115 -> bits 51..0. Normalising Bit 167 truncated
        
        fieee754_64 sign, characteristic, mantissa 
        $end

p	$proc
ieee754_128* $name

tag	$set	p(1, 1)
sign	$set	tag/*191

	$do	sign,tag	$set	^tag

characteristic $set (((tag/*176)**16384)++((tag/*168**16383))-2
mantissa $set	((tag**(1*/168)-1)+(7*/52))/*55

	$nop	adjust any rounding outflow
	$nop	indicated by a 114th bit

	$if	mantissa**(1*/113)
mantissa $set	mantissa/*1
characteristic $set characteristic+1
	$endif

	$nop	bits 166..55 -> bits 111.0 Normalising bit 167 truncated

	fieee754_128	sign, characteristic, mantissa
	$end


</pre>
IEEE754 format floating numbers are supported on many
architectures as well as matching XDR layout.

<p>
The $NOP directive has been used to comment the macro code.
This is because the macros may be included in many different
assemblies with different comment characters, # ; .

<p>
<b>$floating_point</b> and <b>$characteristic</b> directives set the maximum range
and precision. The transient value is 192 bits in size

<p>
The directive $SET caches the value of the floating argument
in the label "tag"

<p>
"tag" may contain a 1s-complement value. If it does, it's inverted after
"sign" is isolated and evaluated. That's because IEEE754 formats only
invert the sign bit for negative polarity, not the whole number.

<p>
The labels "characteristic" and "mantissa" cache manipulated
fields from "tag"

<p>
sign, characteristic and mantissa are output under control of the
form-template fieee754_32, fieee754_64 or fieee754_128.

<p>
These three form-templates are defined with the $FORM directive.

<p>
The $FORM directive drives instruction layouts and other small structures.
This $form
<pre>

fieee754_32	$form	1, 8, 23

</pre>
Causes the "instruction" fieee754_32 to construct its arguments in
this layout:
<pre>

	________________________________________________
	| x | xxxx xxxx | xxx xxxx xxxx xxxx xxxx xxxx |
	|___|___________|______________________________|
         31   30     23   22                         0



</pre>
This $form
<pre>

fieee754_64	$form	1, 11, 52

</pre>
Causes the "instruction" fieee754_64 to construct its arguments in
this layout:
<pre>

	____________________________________________________    _______
	| x | xxx xxxx xxxx | xxxx xxxx xxxx xxxx xxxx xxxx .... xxxx |
	|___|_______________|_______________________________    ______|
	 63   62         52   51                                     0


</pre>
This $form
<pre>

fieee754_128	$form	1, 15, 112

</pre>
<p>
causes the "instruction" <b>fieee754_128</b> to construct its arguments in
this layout:
<pre>

	____________________________________________________    _______
	| x | xxx xxxx xxxx xxxx | xxxx xxxx xxxx xxxx xxxx .... xxxx |
	|___|____________________|__________________________    ______|
	 127  126            112   111                               0


</pre>
The labels tag, sign, characteristic and mantissa aren't promoted with
any trailing asterisk, so they only exist during the subassembly of
the macro.

<p>
All the macros shown are called "p". They don't have to be.

<p>
Argument reference paraforms start with the label on the <b>$proc</b> or <b>$func</b> line:
<pre>

	<i>macro_label</i>(x,y)

</pre>
for example in the macros shown
<pre>

	p(1,1)

</pre>
Giving many macros the same <b>$proc</b> or <b>$func</b> label means that blocks of
macro language can be cut-and-pasted between different macros.

<p>
In this example the label "p" isn't available for calling. Only labels
with asterisk* at the end can be seen outside the macro they are in.

<p>
The trailing asterisk on ieee754_32* ieee754_64* and ieee754_128* make
those names visible as macros. They're the labels on the $name lines

<p>
An asterisk on the label of the $proc line would make that label visible:
<pre>

unique_macro_label*	$proc

</pre>
Then unique_macro_label must be unique. See Section 6.2.2.2:
The <b>$proc</b> Header

<p>
Macros with non-unique labels are called by the labels on the <b>$name</b> lines,
and these names are visible* and unique*.

<p>
The label on $PROC, $NAME or $FUNC is only visible for calling outside
the macro if the LABEL* has an asterisk after it.

<p>
There is a layout directive $FORM and code-generating macros
run from $PROC to $END. That's the essence of masmx.

<p>
Macros can all have the same label on the $PROC line to make them easy 
to write. Then they must have unique names on the $NAME line
to make them possible to call
<pre>


$ masmx ieeef -ln
MASMX 7r2
3/ieeef.msm
*EOF*
  :                            1         $word   32
  :                            2:         $include "ieee754.def"
  :                            3 
00:00000000 3FE00000          +4         ieee754_32      1.75
00:00000001 BFE00000          +5         ieee754_32      -1.75
00:00000002 01B45BD15F9FB3FB  +6         ieee754_64      1.9e-300
00:00000004 3FEFFFFFFFFFFFFE  +7         ieee754_64      0.9999999999999997779553950749686919152736663818359375
  :                            8 
00:00000006 7FFFA000000000000000000000000000
                              +9 	ieee754_128	1.625
00:0000000A 4530893B3F9CA1B98E9D33873CAF6153
                              +10 	ieee754_128	1.8e400
*EOF*
:$(00):00000000:0000000E 


</pre>



<h1>Appendix A: masmx Command Line</h1>

An example assembly command may have the shape
<pre>

	% masmx [-fLAGS] [inputfile[.msm]] [-FL] [outputfile[.txo]] [-FlAgS]

</pre>
The input file extension must be supplied if it is not .msm
The output file extension must be supplied if it is not .txo

<p>
For example
<pre>

	% masmx in out -ulyke

</pre>
will read in.msm and write out.txo. The flags are case significant 
and -ulyke selects: 
<pre>

	-u       all labels must be resolved 
	
	-l       List the main file and generated code 
	
	-y       sort the label list

	-k       labels are case-significant

	-e       list the generated code word-space_word
			736f2069 74206973       "so it is"
		instead of streamed per source line
			736f206974206973        "so it is"

</pre>
in this assembly the size of word is 32 bits

<p>
The banner of flag letters is optional, is anywhere on the
command line, may be present several times, and begins - (minus)
for all developer platforms:
<pre>

prompt% masmx -flAgs source -mOrE objfilename -pq

</pre>
The one-letter case-significant flags can be -sTuCk -TogethER -o -R -nOt

<p>
The filename arguments are positional.

<p>
The input filename is the first argument that doesn't start -minus.

<p>
The output filename is the second argument that doesn't start -minus.

<p>	
The default extension for the source file name is .msm

<p>
The default extension for the output file name is .txo

<p>
These name extensions are applied where the filename contains no period.

<p>
If the second filename is not given, the output is temp.txo

<p>
If the first filename is not given, the assembler prompts for
stdin input. Source lines can be keyed including file includes.
If listing is opted, it should be suppressed around files which are
not required to be listed
<pre>

% masmx -ln

	$list		0
	$include	coldfire.def
	$list

banner	"sample"
sample	1.625

	$include	application
	$end

</pre>
$end is needed to end keyboard input

<p>
Filenames may be in quotes but need not be. When period
is the comment character, it only ends the line with a
following whitespace


The filename may be in quotes but need not be. When comment character
is the default period, it does not terminate the line if a nonspace
token FOLLOWS.IT immediately. This allows floating point expressions
and filenames:
<pre>

	$include	file.name

	1.625
	+	1.79*-200

. comment line

</pre>
$include default filename extension is for source files .msm

<p>
Therefore
<pre>

	$include	afile

</pre>
will read afile.msm

<p>
The filename must otherwise be given exactly and in full

<p>
This interactive technique can be used, for example, to assemble with
temporarily changed list nesting depth controls:
<pre>

prompt% masmx -lpq
	$plist		5	. show deeply nested macro expansion
				. when option flags -pq are on
	$include	"file.name"
	$end

</pre>
mamsx writes a source file called temp.msm when input is stdin.
temp.msm is read on the second assembly pass

<p>
The following examples assemble an application called fastpass:
<pre>

	% masmx fastpass.asm -u

</pre>
masmx reads fastpass.asm and writes temp.txo. 

<p>
Whatever the output name, fastpass is 8051 and the 
target machine wants I-records, so you follow up:
<pre>

	% imx temp.txo florida.hex

</pre>
or for example
<pre>

	% masmx fastpass.asm today -u
	% imx today.txo fastpass.hex

</pre>
imx utility does nothing clever with filename extensions. 
They are typed exactly and in full. There are no flags or 
options

<p>
The similar utility for S-records (32-bit address) is mmx

<p>
See Section 9: Output File Formats, Relocation and Linking,
Giant Address Spaces, Interfacing with GNU Tools.

<p>
This example has no link. Application called fastpass is
assembled absolute. imx is the I-Record conversion 
 
<p>
That's why -u is there. -u treats unresolved labels as 
an error. But you don't have to keep saying -u because 
the 8051 definition header says
<pre>

	$set_option     "u"

</pre>
<h2>A.2: Command Line Options</h2>


The full set of masmx command line options are
<pre>


	-a      allow automatic literals

		a literal is a storage constant which is
		generated in response to being referenced
		as an operand

		automatic literals are generated when an
		(operand) is entirely in parentheses. There may
		be a prefixed unary asterisk *(on the literal)

		unary operator +(operand) makes the operand
		an expression and not a literal. Therefore if
		-a flag is set and a non-literal expression starting
		(in parentheses) is needed, code a sign +(first)

		Default behaviour (not flag -a) only generates a
		literal when a literal pool tag is referenced outside
		the literal:
 
		literal_pool_tag(the_literal)

		-see section 5.2: Literals

	-b	linker option: collate all input files by section

	-c      C language hex and octal Notation
		C Language \escape sequences in strings
		aligned strings zero padded. See also -z option

                standard masmx behaviour so interprets number
		expressions in source code that leading zero means
		hex and any other leading digit means decimal.

		If $OCTAL directive is issued leading zero means
		instead octal, until $HEX directive is issued.

		Thus by default

		1000 and 03e8 both mean one thousand

		However with -c flag the hex expression is 0x3e8

		See also -m flag which may be asserted as well

		-c flag enables C-Language \escape sequences in
		quoted strings

		-c flag pads aligned quoted strings with zero.
		Default behaviour is space fill. See also -z option

	-d	list addresses including segment or offset information

		of meaning when a breakpoint addresses are encoded
		after start_addresses in a location counter declaration:

		$(67:base_address:breakpoint)

		-see Section 4.1.2.1:	Location Counter Controls

		-see Section 9.1:	Text-Encoded Binary Format

		-see also -v flag

	-e      list generated code in one-word fields

                This makes the output readable when the target
                machine word size does not fit an exact number
                of hex or octal symbols

	-f	flag certain errors in the second assembly pass
		instead of in the first pass. This allows a listing
		to be generated

	-g	flag certain errors in the first assembly pass instead
		of in the second pass. This prevents unnecessary
		processing

	-h	stop after the first assembly pass

		-see also option -s


	-j      has meaning when using masmx as a cumulative linker:

                When external labels are found but still relocatable,
                -j option causes references to them to remain
		outstanding, i.e. resolution of the name itself
		is requested again in subsequent links.

		Default behaviour replaces the label reference with
		a reference to offset+locator. The offset will later
		be summed with the new file segment base per this locator.

		-see section 8.24.2:	$include,$binary

		-see section 9: 	Output File Formats
					Relocation and Linking
    					Giant Address Spaces
					Interfacing with GNU Tools
	
	-k      labels are case-significant

	-l      list source and assembly when the $LIST setting is 
		higher than the current include nesting depth

	-m       Motorola Hex, Octal and Bit Notation

		-m flag is for	$hex
				@octal
				%bit-pattern

		Labels beginning $ and @ are then only
		recognised if they are in quotes "$xxx", except:

                $xxx @xxx names in the command field are recognised
                without quotes

		-m does not switch off other number notations
		guided by the $hex and $octal directives and the
		C-Syntax flag -c

                standard masmx behaviour so interprets number
		expressions in source code that leading zero means
		hex and any other leading digit means decimal.

		If $OCTAL directive is issued leading zero means
		instead octal, until $HEX directive is issued.

		Thus by default

		1000 and 03e8 both mean one thousand

		However with -m flag $3e8 also gives the value 1000.

		See also -c flag which may be asserted as well.

		If -m flag is asserted and not -c, then 03e8 and $3e8
		both mean a thousand.

		If -cm flags are asserted, 0x3e8 and $3e8 both mean 1000.

	-n	list relocation information when listing with option -l

	-o      force filenames to lowercase. This can avoid problems when
		large numbers of output files are checked using Unix tools.
		
	-p      List $PROC Text on Expansion when the $PLIST setting is
		higher than the current macro subassembly nesting depth

		-see Section 8.38: $PLIST Directive 

		-see Section 8.47.1:	Interaction of Run Options
					and List Directives

	        -also list macro text when listing labels

		-see option flags -xy

		-see Section 8.48: $SNAP directive 

	-q      List $FUNC Text on Expansion when the $PLIST setting is
		higher than the current macro subassembly nesting depth

		-see Section 8.38: $PLIST Directive 

		-see Section 8.47.1:	Interaction of Run Options
					and List Directives

	        -also list macro text when listing labels

		-see option flags -xy

		-see Section 8.48: $SNAP directive 

	-r	list $PROC or $FUNC text expansion during the first
		assembly pass when the $PLIST setting is
		higher than the current macro subassembly nesting depth

	        -also list macro text when listing labels

		-see option flags -xy

		-see Section 8.48: $SNAP directive 

	-s      Generate a source file with all text translations
		applied during the first assembly pass.

		Directly and indirectly included text is inlined.

		This output source file is called temp.msm

		This is the default behaviour when no
		input file is named on the command line.

		temp.msm is then read in the second assembly pass.

		-see Section 8.52: $TEXT translation directive

	-u      Treat unresolved labels as errors. 
		Otherwise information requesting linker
		resolution is placed in the output file.

		-see section 9: 	Output File Formats
					Relocation and Linking
    					Giant Address Spaces
					Interfacing with GNU Tools

	
	-v	of meaning when a breakpoint addresses are encoded
		after start_addresses in a location counter declaration:

		$(67:base_address:breakpoint)

		-v option causes the location counter breakpoint value
		to be written as a segment_index in the load-address
		clauses of the text-encoded binary output.

		Default behaviour is to compute load addresses
		from logical address + breakpoint address - base_address.

		(i.e. to apply absolute segment relocation
		at assembly time)

		-see Section 4.1.2.1:	Location Counter Controls

		-see section 9: 	Output File Formats
					Relocation and Linking
    					Giant Address Spaces
					Interfacing with GNU Tools
	
		-see also -d flag

	-w	silent assembly, unless there are diagnostics.
		Default behaviour is to list summary information	

	-x      List Labels at the end of the assembly.
		-see Section 8.48: $SNAP directive
		-see Section 8.28: $LIST directive
				   $list 0, masking names from list/export

	-y      Sort the label list.
		-see Section 8.48: $SNAP directive
		-see Section 8.28: $LIST directive
				   $list 0, masking names from list/export

	-z	Pad aligned quoted strings with zero.
		Default behaviour is to space fill.

		-c option also pads quoted strings with
		zero instead of space, but -zc combined
		pads quoted strings with space

                These four assemblies show the effects
                of -zc options in data word padding


		$ masmx a1 -ln
		MASMX 7r2
		3/a1.msm
*EOF*
  :                            1 	$word	32
  :                            2 	$quantum 8
00:00000000 61312020          +3 	"a1"
*EOF*
:$(00):00000000:00000004 
a1.msm: object code 54 bytes: 0 errors: 0 undefined labels

		$ masmx a1 -lnz
		MASMX 7r2
		3/a1.msm
		*EOF*
  :                            1 	$word	32
  :                            2 	$quantum 8
00:00000000 61310000          +3 	"a1"
*EOF*
:$(00):00000000:00000004 
a1.msm: object code 54 bytes: 0 errors: 0 undefined labels

		$ masmx a1 -lnc
		MASMX 7r2
		3/a1.msm
		*EOF*
  :                            1 	$word	32
  :                            2 	$quantum 8
00:00000000 61310000          +3 	"a1"
*EOF*
:$(00):00000000:00000004 
a1.msm: object code 54 bytes: 0 errors: 0 undefined labels

		$ masmx a1 -lncz
		MASMX 7r2
		3/a1.msm
		*EOF*
  :                            1 	$word	32
  :                            2 	$quantum 8
00:00000000 61312020          +3 	"a1"
*EOF*
:$(00):00000000:00000004 
a1.msm: object code 54 bytes: 0 errors: 0 undefined labels


	-E	accept new equation of a label which is already
		equated ($equ directive), with a warning diagnostic

		default behaviour retains the first and discards
		the new value with a warning diagnostic

		$set directive freely restates labels without restriction


	-F	floating point rounding guard pattern is 110
		instead of 111

	-G	floating point rounding guard pattern is 101
		instead of 111

		the mantissa is always generated longer than
		it is stored. The guard pattern bits are added
		to the most significant of the truncated bits
		and may carry into the stored mantissa

		This sketch represents the mantissa before rounding
		by means of the addition of guard bits. Of course the
		mantissa may outflow as a result of rounding. In that
		case the mantissa is shifted right one position to
		normalise again and the exponent is incremented

		The representation is of a positive magnitude mantissa
		with the value 1 at the normalising position

		A mantissa of value +-zero cannot be normalised


		 normalising value unless the mantissa value is zero
		 ___________________________________________________
		 |
		 |    mantissa for storage        truncated part
	_ _ _ _ _._______________________________________________
	 	|1xxxxxxxxxxxxxxxxxxxxxxxxxxxxxx|yyyyyyyyyyyyyyy|
	exponent|0000000000000000000000000000000|101000000000000|+
	_ _ _ _ |_______________________________|_______________|
						 | |
						 |_|____________
						 111
						 110
						 101

						 possible values of
						 the three rounding
						 guard bits



        -Q      execute a function name encountered in an
                expression even if it is in quotes

                this concerns user-written function macros
                constructed with

                        name*   $FUNC
                                .
                                .
                                $end
                or with

                        name    $FUNC
                        name1*  $NAME
                        na...*
                                .
                                .
                                $end


                default behaviour is to execute the function
                name if it is an expression token without
                quotes, but to return an identifying
                value if the the function name is in quotes

                        procedure* $proc
                                .
                                $do     ($t(procedure(1,5))=$func);
                                        **(procedure(1, 5)="lolly")     ;
                                $note   this is lolly
                                .

                                +       procedure(1, 5)

                the first mention usually detects whether the
                parameter token is function macro called lolly

                the second mention causes lolly to happen

                with option -Q the first mention in quotes
                also causes macro lolly to happen instead of
                just identifying it

        -Z      zero fill buffers declared with $RES directive
                (section 8.43)

                without -Z option no code is loaded in
                the $RES storage area

                $RES intervals in structures generated
                as literals are always zero-filled



	+	option flag -+ includes masmx internal names
		in label table lists

		masmx	-x+y
			$end

		lists the directive and internal function labels
		and names with fixed values

		-see Section 8.28: $LIST directive
				   $list 0, masking names from list/export



</pre>


<h1>Appendix B: What's new in 7r2?</h1>
<ul>

Faster

<pre></pre>
More Stable

<pre></pre>
Address Schemes Better Integrated

<pre></pre>
Inconsistencies Removed

<pre></pre>
<b>$path</b> directive helps neat and efficient inclusion
across file trees.

<pre></pre>
Has Linker

<pre></pre>
Assembles gcc Output
<pre></pre>
Macros concealed in macros:

</ul>

<pre>

one*	$proc
two*	$proc
three*	$func
	$end
	$end
	$end

</pre>
<pre></pre>
$RES buffers (section 8.43) may be zero-filled instead of void

<pre></pre>
The command line option flags are newly case significant and there are now
28 of them: <b>-abcdefghijklmnopqrsuvwxyzQZ+</b>
(section 3.2: Command Line Options)


<h1>Appendix C: The masmx Product Road Map</h1>


<p>
One further tool is planned to convert relocatable Text Encoded Binaries
to ELF, because macro language alone cannot quite do this.

<p>
Further output converters like the already-packaged imx (irec)
and mmx (srec) may be distributed on request.

<p>
It is otherwise intended mainly to distribute macro source for new
targets on request.

<p>
All requests to masmx@gmx.ch



<h1>Appendix D: masmx's Potential for High Level Languages</h1>

<h2>D.1: A Target-Independent Macro-Assembly language</h2>

<p>
masmx is independent of target architecture. It is possible for
compilers to generate a single macro language for masmx assembly
for any target.

<p>
Compilers therefore need no knowledge of target architecture and
may themselves be target-independent

<p>
Tuning, efficiency, and architectural innovation then become matters
for the implementation of the single macro language per individual target.

<p>
The development of macro language for masmx requires no builds,
compilations or links. Macro Definition is text
<pre>


	__________________		______________________
	| source program |		| high level language |
	| in high level	 |------------->| compiler	      |
	| language       |		|_____________________|
	|________________|			   |
						   |
	_________________		___________|__________
	| macro language |		| application in macro|
	| target specific|		| language common to  |
	| definition     |		| all targets         |
	|________________|		|_____________________|
		 |				   |
		 |				   |
		 |				   |
		 |				   |
		 |				   |
	_________|_________________________________|___________
	|						      |
	|			masmx			      |
	|						      |
	|_____________________________________________________|
				   |
				   |
				   |
			___________|__________
			|		      |
			|  binary application |
			|		      |
			|_____________________|



</pre>
<p>


<h2>D.2: Bit-Aligned Data Structures</h2>

Developers using masmx can assign complex typing to identifiers
with the <b>$equf</b> directive

<p>
Labels of type <b>$equf</b> are generated in bit-aligned structures <b>$record</b>..<b>$root</b>

Each bit-aligned field is labelled with address, bit offset, bit size, signed attribute
and optionally base-displacement pointer with a single label

<p>
This allows macro language specific to the target to read and
write bit-aligned fields with consistent certainty. In this way masmx solves
a problem which has produced noticeable difficulty for compiler writers

<p>
In addition to compiler support, bit-aligned structuring is intended 
for data which is compressed or formatted in ways which do not map
to the target architecture

<p>
Bit-Aligned structuring can redefine and overlay storage without limit

<p>
Word-aligned structuring <b>$tree></b>..<b>$root</b> is completely analogous to bit-aligned
structuring, but generates all fields at word boundaries

<h2>D.3: RunTime Algorithm Plotting</h2>

Directives <b>$xqt_i</b> and <b>$xqt_fp</b> generate with the help of
target-specific macro text an instruction plan to execute algorithmic
expressions at runtime from variable inputs. Constant sequences within an
integer expression are resolved at assembly time. The compiler need neither
understand the target architecture nor order the expression sequence



<h1>Appendix E: Tuning Macro Language and Fixing Problems</h1>

<h2> 11.1: Fixing a Macro Parameter Reference</h2>

<p>
If a macro appears unable to reference an actual parameter, equate a
local label to the parameter and reference the label (this problem won't
arise in an example as simple as this one):
<pre>

p	$proc
addo*	$name	0
subo*	$name	1

operand	$equ	p(1, 1)

	format	p(0, 0), operand
	$end

</pre>
<p>
It's in any case advisable to cache the parameters in local labels
if they are being referenced more than once. This is because the
actual parameter is not predictable to the macro, and referencing it
may, for example, cause functions to be called. One case of multiple
references to macro parameters is where range checks are carried out.

<h2> 11.2: Label Cannot Be Referenced</h2>

<p>
Another possible cause of confusion, is that a label can't be
referenced when it has been declared. This doesn't always mean that
the reference is spelled wrong. The cause is sometimes that the label
has remained local to a macro expansion. To be visible outside the
containing macro, the label must be promoted* with asterisks*
<pre>

p	$proc
generate* $name

"p(1, 1)_generated_name"***	. label is visible three macro nesting
				. levels higher than this level

	.
	.
	.

	$end

</pre>
<h2> 11.3: Changed Label Value Disappears</h2>

<p>
This is the same problem as the previous one. If you have
<pre>

macro1*	$proc
alabel	$set	SOMETHING
	macro2
	$end

macro2*	$proc
alabel	$set	SOMETHING_ELSE
	$end

</pre>
Calling <b>macro2</b> from <b>macro1</b> does not appear to change
<b>alabel</b>.

<p>
This is because two different labels have the name <b>alabel</b>.
If <b>macro2</b> must set <b>alabel</b> for <b>macro1</b>,
<b>macro2</b> must be coded like this, with an asterisk on <b>alabel*</b>
<pre>

macro2*	$proc
alabel*	$set	SOMETHING_ELSE
	$end

</pre>

<h2> 11.4: Tracing Macro Expansion</h2>

<p>
For monitoring the expansion of $PROC and $FUNC macros, see especially
Section 8.47.1: Interaction of Run Options and List Directives.

<p>
The path through macro language and presentation of actual parameters
to macros can be traced. <b>-p</b> Flag traces $PROC macro steps and
<b>-q</b> Flag traces $FUNC macro steps. Neither are traced unless $PLIST
directive has set a threshold higher than current macro nest depth:
<pre>

masmx	-lpq

	$plist	5

	.
	.

</pre>
<p>
Where assembly does not advance to the second assembly pass, <b>-r</b> flag
enables macro step display in the first assembly pass. Then the macro
step display is then shown out of listing context, because listings are
only produced on the second assembly pass.

<p>
See also Sections 8.48: $SNAP directive and 8.53: $TRACE directive.

<h2> 11.5: Aliasing masmx Internal Functions</h2>

<p>
If you want to give a new name to a masmx internal function <b>$ $a $b $n
$net $o $r $rel $t</b>
<pre>

absolute	$equ, $function		"$a"

</pre>
<p>
The quotes on the masmx function name, here <b>$a</b>, are necessary.

<p>
Without the quotes, absolute will not have the functional meaning
<b>$a</b>, but instead the value returned from <b>$a</b> at this
point in the assembly.


<h2> 11.6: Error Diagnostic about a Label Address</h2>


<p>
An error diagnostic is issued like the one in this assembly
<pre>

$masmx -l
MASMX 7r2
0/-INPUT>>
	$list	0
	$include 8051.def
CONT_CHAR=
LTERM=;
QDELIM='
STERM=.
	$list	2

first	var	size?

second	var	8

size?	equ	1024
	$end
  :                            677  $list 2
  :                            678 
  :                            679 first var size?
  :                            680 
SECOND [80000/40000]
Error: -INPUT>> Line 681: displacement changed between 1st and 2nd passes
Note: -INPUT>> Line 681: foregoing object has been sized by forward reference
  :                            681 second var 8
  :                            682 
  :                            683 size? equ 1024
  :                            684  $end
:$(01):0400:0808 
-INPUT>>: object code 20 bytes: 1 errors: 0 undefined labels

</pre>
<p>
The explanation and solution is: <b>size?</b> must be known when the buffer
<b>first</b> is declared. Sizes cannot be fixed by forward reference.

<p>
The problem is noticed with the label <b>second</b>, but the cause
of the problem is earlier.

<p>
The problem in the next assembly is similar, but the solution is different:
<pre>

$ masmx -l
MASMX 7r2
0/-INPUT>>

	$word	32

early	+	pattern
late	+	99
pattern	$equ	0800000000000
	$end
  :                            1 
  :                            2  $word 32
  :                            3 
00:00000000 0000800000000000  +4 early + pattern
LATE [2000000/1000000]
Error: -INPUT>> Line 5: displacement difference between 1st and 2nd passes
Note: -INPUT>> Line 5: foregoing object has been sized by forward reference
00:00000002 00000063          +5 late + 99
  :                            6 pattern $equ 0800000000000
  :                            7  $end
:$(00):00000000:00000003 
-INPUT>>: object code 71 bytes: 1 errors: 0 undefined labels
 
</pre>
<p>
The size of the integer <b>early</b> is unexpectedly two words.
The solution is to decide what size integer <b>early</b> should be:
<pre>

$ masmx -l
MASMX 7r2
0/-INPUT>>

	$word	32

early	+	pattern:d
late	+	99
pattern	$equ	0800000000000
	$end
  :                            1 
  :                            2  $word 32
  :                            3 
00:00000000 0000800000000000  +4 early + pattern:d
00:00000002 00000063          +5 late + 99
  :                            6 pattern $equ 0800000000000
  :                            7  $end
:$(00):00000000:00000003 
-INPUT>>: object code 71 bytes: 0 errors: 0 undefined labels

</pre>

<h2>11.7: Label fails to be Exported</h2>

<p>
Labels are not catalogued for listing or export if they are declared
or included while <b>$LIST</b> is zero

<p>
<b>$LIST</b> must be greater or less than zero when a label is declared
or binary-included for export

<p>
This example is a cumulative link which wants to pass labels in
the output binary. The labels imported from the input binary
<b>rel_file.txo</b> and the new label <b>location_after</b> are exported in
the output binary <b>new_rel.txo</b> because <b>$LIST</b> is other than 0
<pre>

	$list	0
	$include		linkrule.def
	$list	-1
	$include, $binary	rel_file
location_after*
	$list
	$store			new_rel	

</pre>
<p>
See also 8.28: <b>$LIST 0</b>, masking names from list and export

<h2>11.8: Literal Table overlaps Trailing Edge of Code</h2>

A literal table may originate some words back over the last code words
if literals are generated from within a second pass only function
<pre>

f	$func	*
constant* $name
	$do	f(1, 1:2)=s,	$return	literal(ieee754_32 f(1, 1))
	$return	literal(iee754_64 f(1, 1))
	$end

</pre>

If it is necessary to do this (see runtime algorithms for ColdFire), the
function must be a two-pass function and then the literal table originates
after the code
<pre>

f	$func
constant* $name
	$do	f(1, 1:2)=s,	$return	literal(ieee754_32 f(1, 1))
	$return	literal(iee754_64 f(1, 1))
	$end

</pre> 



<h1>Appendix F: Target Descriptions</h1>


<h2>F.1: 8051</h2>


8051.def header include file in this package has been
used with masmx to build mission-critical software for 
a number of prestige clients.


<h2>F.2: PowerPC</h2> 

The ppc_603.def file in this delivery has been successfully used
to generate a stable, running RT kernel.

<p>
ppc_603.def may be steered to produce absolute or relocatable code.
The equivalent header file for linking relocatables is map_ppc.def
(see Section 9: Output File Formats, Relocation and Linking,
Giant Address Spaces, Interfacing with GNU Tools)

<p>
Definitions ppc_64.def and ppc64map.def support the development of
giant address assembly and linking technique See Section 9.2: Linking.

<p>
For support developing assembly and link definitions, contact

<p>
masmx@gmx.ch



<h2>F.3: Definition Examples</h2>

  
<h2>F.3.1: ColdFire</h2>

ColdFire instruction encoding appears formidably intricate, but operand
space may be viewed simply as a set of spaces tagged by the instruction
mode field. Although this  outline is intended as conceptual, it coincides
partly with instruction layout
<pre>

	 15				 5		 3		
	_________________________________________________________________ _ _ _ _ _ _ _ _ _ _ _ _               _ _ _ _ _ _ _ _ _ _ _ _ _
	|  instruction code / register	|      mode	|    register	|		address offset 16 or 32 bits or none		|
	|_______________________________|_______________|_______________| _ _ _ _ _ _ _ _ _ _ _ _		_ _ _ _ _ _ _ _ _ _ _ _ |
									|		16-bit encoding of double-index + 8-bit offset	|
									| _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ |


</pre>

Instructions are one, two or three 16-bit words. masmx instruction macros call this function macro in common
in order to determine operand space and address attributes like pointer register and presence or absence of
an offset field. Registers have identifiable categories attached to their name

<pre>

f       $func
$iform* $name
        $do     $t(f(1, 1))=$d_reg,     $return 0++f(1, 1)*/3
        $do     $t(f(1, 1))=$a_reg,     $return 1++f(1, 1)*/3
        $do     $t("f(1, 1)")=$a_reg_@, $return 2++f(1, 1)*/3           ;       $ibase\f(1, 1)*/3
        $do     $t("f(1, 1)")="$a_reg_@+",      $return 3++f(1, 1)*/3   ;       $ibase\f(1, 1)*/3
        $do     $t("f(1, 1)")="$a_reg_@-",      $return 4++"f(1, 1)"*/3 ;       $ibase\f(1, 1)*/3
        $do     $inside\f(1, 1)=2,      $do     $type2\f(1, 1:1)=$special_reg,  |
                                        $do     $id2\f(1, 1)=pc,        $return 7++2*/3
        $do     $inside\f(1, 1)=2,      $return 5++$base_a\f(1, 1)*/3
        $do     $itype\f(1, 1)=$a_reg,  $return 5++$ibase\f(1, 1)*/3
        $do     $inside\f(1, 1)=3,      $do     $type2\f(1, 1:1)=$special_reg,  |
                                        $do     $id2\p(1, 1:1)=pc,      $return 7++3*/3
        $do     $inside\f(1, 1)=3,      $return 6++$base_a\f(1, 1)*/3
"$O"    $equ    f(1, 1)
"$X"    $equ    f(1, 2)
        $do     $o('V'),        $trace  $O
        $do     $o('V'),        $trace  $X
        $do     $X=pc,                                                  $return 7++2*/3
        $do     $X^=0,                  $return 5++$X*/3

        $do     f(1, #1),                                               $return 7++4*/3

        $do     ($t(f(1, 1:2))=$special_reg)**(f(1, 1:2)=l)++|
                ($net($O)<-32768)++|
                ($net($O)>32767),                                       $return 7++1*/3

                                                                        $return 7
        $end


</pre>

Instructions which do not correspond to all operand types mark the assembly in error
for any inappropriate operand

<p>
An instruction example which uses every possible operand type is <b>cmp</b> which this macro assembles
<pre>

p       $proc
cmp.b*  $name   0
cmp.w*  $name   1
cmp.l*  $name   2
cmp*    $name   cmp.w

        $if     $t(p(1, 2))=$d_reg
"$FO"   $set    $iform(p(1, 1))
"$MO"   $set    $FO**7
"$RO"   $set    $FO/*3

        $if     ($MO=0)++($MO=1)++($MO=2)++($MO=3)++($MO=4)
        $i_rr   11, p(1, 2), p(0, 0), $MO, $RO
        $elseif $MO=5
        $i_rm   11, p(1, 2), p(0, 0), 5, $RO, p(1, 1)
        $elseif $MO=6
        $i_rx   11, p(1, 2), p(0, 0), 6, $RO,           |
                $idx_d\p(1, 1:1), $idx_w\p(1, 1:1), 0,  |
                $displacement8\p(1, 1:1)
        $elseif $FO=7
        $i_rm   11, p(1, 2), p(0, 0), 7, 0, p(1, 1)
        $elseif $FO=7++1*/3
        $i_rl   11, p(1, 2), p(0, 0), 7, 1, p(1, 1)
        $elseif $FO=7++4*/3
          $if   p(0, 0)=cmp.l
          $i_rl 11, p(1, 2), p(0, 0), 7, 4, p(1, 1)
          $else
          $i_rm 11, p(1, 2), p(0, 0), 7, 4, p(1, 1)
          $endif
        $elseif $FO=7++2*/3
        $i_rm   11, p(1, 2), p(0, 0), 7, 2, p(1, 1)-$-2
        $elseif $FO=7++3*/3
        $i_rx   11, p(1, 2), p(0, 0), 7, 3,             |
                $idx_d\p(1, 1:1), $idx_w\p(1, 1:1), 0,  |
                $displacement8\p(1, 1:1)-$-2
        $else
        $flag   anomaly no operand style selected
        $endif

        $else
        $flag   must be comparand,d0..d7
        $endif
        $end


</pre>

There are some commands <b>$i_rr $i_rm $i_rx $i_rl</b> and these are instruction layout <b>$form</b>  templates

<pre>

"$i_rr" $form   4, 3, 3, 3, 3
"$i_rm" $form   4, 3, 3, 3, 3, 16
"$i_rl" $form   4, 3, 3, 3, 3, 32
"$i_rx" $form   4, 3, 3, 3, 3, 4, 3, 1, 8
"$i_fp" $form   4, 3, 3, 3, 3, 3, 3, 3, 7
"$i_fm" $form   4, 3, 3, 3, 3, 3, 3, 3, 7, 16
"$i_mq" $form   4, 3, 1, 8

"$b_cs" $form   8, 8
"$b_cl" $form   8, 8, 16

</pre>

<p>
masmx base-displacement addressing for ColdFire uses the program counter at instruction + 2
or a register from a1..a5, for example
<pre>

$(.data:131072,a5)

</pre>
Base-register a0..a7 maps to ColdFire operand space 5. Base-register identifiers are masmx label
type <b>$equf</b>

<p>
The subroutine referenced earlier in section 6.2<b>6.2: Run-Time Floating Algorithm Plotter</b> is
assembled here. It uses masmx base_displacement addressing to assemble instructions with operand
in mode 7.2 space 
<pre>
	
$(.text:262144,pc/$literal)

	lea	table_u+8*307, a0	; equivalent to (table_u+8*307, pc), a0

</pre>
Literals tagged with the label <b>$literal</b> are also mapped to <b>constant_storage_address-$-2, pc</b> in this assembly

<pre>

$ masmx s2double -lnk
MASMX 7r3
3/s2double.msm
CONT_CHAR=|
LTERM=;
STERM=.
*EOF*
  :                            1 	$path		../smaragd.68k
  :                            2: 	$include	coldfire.def
  :                            3 	$path
  :                            4: 	$include	ieee754.def
  :                            5 
  :                            6 	;	this demonstration code block
  :                            7 	;	reads a string in ASCII or any other data code
  :                            8 	;	and converts it to 64-bit floating in fp1
  :                            9 
  :                            10 	;	ColdFire floating instructions' ability
  :                            11 	;	to convert and use 8/16/32-bit integer operands 
  :                            12 	;	prompts this conversion directly from string
  :                            13 	;	to double float. That is very feasible, so
  :                            14 	;	there is no attempt to generate and then
  :                            15 	;	convert a long long integer
  :                            16 
  :                            17 scale_10 $equ,$d_reg	d1
  :                            18 
  :                            19 $(0:262144,pc/$literal)
  :                            20 
  :                            21 s2double*
00:00000000 F23A50801456      +22 	fmove.w		$literal(0), fp1
  :                            23 s2dscanforit
00:00000006 7000              +24 	moveq		#0, d0
00:00000008 1018              +25 	move.b		(a0)+, d0
00:0000000A 670000C6          +26 	beq		(eostringx).w
00:0000000E B07C0020          +27 	cmp.w		#' ', d0
00:00000012 67F2              +28 	beq		s2dscanforit	; walk any leading space
  :                            29 					; if there are none it costs nothing
  :                            30 
00:00000014 0680FFFFFFD5      +31 	addi		#-'+', d0	; check for leading sign
00:0000001A 671A              +32 	beq.b		read_1st_digit
00:0000001C 0680FFFFFFFE      +33 	addi		#'+'-'-', d0
00:00000022 6708              +34 	beq.b		s2dnegative
00:00000024 0680FFFFFFF3      +35 	addi		#'-'-'0'-10, d0	; well was it a digit then?
00:0000002A 6014              +36 	bra.b		check_1st_digit
  :                            37 
  :                            38 s2dnegative
00:0000002C 6108              +39 	bsr.b		read_1st_digit	; read the number then switch polarity
00:0000002E F23A50A3142A      +40 	fmul.w		$literal(-1), fp1 ; you can't just invert bits in fp1
00:00000034 4E75              +41 	rts
  :                            42 
  :                            43 read_1st_digit
00:00000036 7000              +44 	moveq		#0, d0
00:00000038 1018              +45 	move.b		(a0)+, d0
00:0000003A 0680FFFFFFC6      +46 	addi		#-'0'-10, d0	; first is it higher than '9' ?
  :                            47 
  :                            48 check_1st_digit
00:00000040 655E              +49 	bcs.b		high
00:00000042 06800000000A      +50 	addi		#10, d0		; was it then lower than '0' ?
00:00000048 6420              +51 	bcc.b		low
00:0000004A F20058A2          +52 integer	fadd.b		d0, fp1		; column 1 was in '0'..'9' and is now in 0..9
00:0000004E 7000              +53 	moveq.l		#0, d0
00:00000050 1018              +54 	move.b		(a0)+, d0	; read next column
00:00000052 0680FFFFFFC6      +55 	addi		 #-'0'-10, d0	; is it higher than '9' ?
00:00000058 6546              +56 	bcs.b		high		; if so it's the end of the integral part
00:0000005A 06800000000A      +57 	addi		#10, d0		; was it lower than '0' ?
00:00000060 6408              +58 	bcc.b		low
00:00000062 F23A50A313F8      +59 	fmul.w		$literal(10), fp1 . multiply the accumulation so far
00:00000068 60E0              +60 	bra		integer		; add the new stripped digit in 0..9
  :                            61 
  :                            62 	$if	'.'<'0'			; data code independent. If period < digit
00:0000006A 068000000002      +63 low	addi		#'0'-'.', d0	; is this the decimal point?
  :                            64 	$else
  :                            65 high	addi		#'0'+10-'.', d0	; otherwise if period > digit was this . ?
  :                            66 	$endif
  :                            67 	
00:00000070 6708              +68 	beq.b		fraction	; whatever the data code, was that decimal point
00:00000072 0680FFFFFFC9      +69 	addi		#'.'-'e', d0	; if it wasn't is this an exponent string?
00:00000078 602C              +70 	bra.b		estring?
  :                            71 
  :                            72 fraction				; decimal point has been found
00:0000007A 7000              +73 	moveq.l		#0, d0		; read the fraction
00:0000007C 1018              +74 	move.b		(a0)+, d0
00:0000007E 0680FFFFFFC6      +75 	addi		#-'0'-10, d0	; higher than '9' ?
00:00000084 651A              +76 	bcs.b		eofraction
00:00000086 06800000000A      +77 	addi		#10, d0		; lower than '0' ?
00:0000008C 6412              +78 	bcc.b		eofraction
  :                            79 					; the accumulation attributes all columns to the
00:0000008E D2BCFFFFFFFF      +80 	add		#-1, scale_10	; integral part, so keep track of the scale
00:00000094 F23A50A313C6      +81 	fmul.w		$literal(10), fp1 ; multiply the accumulation by 10
00:0000009A F20058A2          +82 	fadd.b		d0, fp1		; add the stripped digit to it
00:0000009E 60DA              +83 	bra		fraction	
  :                            84 
  :                            85 	
  :                            86 	$if	'.'<'0'			; data code independent, if period < digit
  :                            87 high					; byte was higher than a digit
  :                            88 eofraction
00:000000A0 0680FFFFFFD5      +89 	addi		#'0'+10-'e', d0	; was it letter 'e'
  :                            90 	$else				; periods are higher than digits
  :                            91 low					; byte was lower than a digit
  :                            92 eofraction
  :                            93 	addi		#'0'-'e', d0	; so was it letter 'e' ?
  :                            94 	$endif
  :                            95 
  :                            96 estring?
  :                            97 	$if	'e'^='E'		; are there different code points for 'e' and 'E' ?
00:000000A6 6708              +98 	beq.b		estring!	; if there are and it was an 'e' you've found it
00:000000A8 068000000020      +99 	addi		#'e'-'E', d0	; otherwise was it an 'E' instead?
  :                            100 	$endif
  :                            101 
00:000000AE 6606              +102 	bne.b		eostring	; it wasn't any 'e' or 'E'
  :                            103 estring!
00:000000B0 2F01              +104 	move.l		scale_10, -(a7)	; yes it was, add the e+- number
00:000000B2 6128              +105 	bsr.b		string2i
00:000000B4 D29F              +106 	add		(a7)+, scale_10	; to the scale we already have
  :                            107 
  :                            108 					; the exponent range [ -307 .. +307 ] (15 bits midpoint)
  :                            109 					; is small enough to be handled in a table
  :                            110 
  :                            111 					; listing is off for the 615 constants at table_u
  :                            112 					; generated with
  :                            113 
  :                            114 					; ?       $do     615,    ieee754_64      1.0e?-308
  :                            115 
  :                            116 					; you can't quite have
  :                            117 					;	lea	(table_u+307*8-$-2, pc, scale_10.l*8), a0
  :                            118 					; because table_u+307*8-$-2 is more than 255
  :                            119 
  :                            120 					; so we point a0 to the exponent factor in 2 instructions
  :                            121 
  :                            122 					; table_u is a base-displacement address
  :                            123 					; with the meaning on reference
  :                            124 					;	table_u-$-2, pc
  :                            125 eostring
00:000000B6 41FA0A00          +126 	lea		table_u+307*8, a0		; point to the table location 1.0e0
00:000000BA 41F01E00          +127 	lea		(0, a0, scale_10.l*8), a0	; add the accumulated scale to it
00:000000BE 427A0060          +128 	pea		table_u		; the table start is the minimum address
00:000000C2 B1DF              +129 	cmpa		(a7)+, a0	; are you lower than that?
00:000000C4 6B0E              +130 	bmi.b		outrange	; yes you are. NAN
00:000000C6 427A1390          +131 	pea		table_u+615*8	; the table ends after the last instance
00:000000CA B1DF              +132 	cmpa		(a7)+, a0	; are you lower than that?
00:000000CC 6A06              +133 	bpl.b		outrange	; no you're not. NAN
00:000000CE F21054A3          +134 	fmul.d		(a0), fp1	; the exponent is in range
  :                            135 					; multiply by [ 1.0e-307 .. 1.0e+307 ]
  :                            136 eostringx
00:000000D2 4E75              +137 	rts
  :                            138 outrange				; score a NAN
00:000000D4 F23A54801388      +139 	fmove.d		$literal(-1q), fp1
00:000000DA 4E75              +140 	rts
  :                            141 
  :                            142 string2i				; scan an integer for whatever purpose
00:000000DC 7200              +143 	moveq		#0, d1		; there won't be leading space however
00:000000DE 7000              +144 	moveq		#0, d0
00:000000E0 1018              +145 	move.b		(a0)+, d0
00:000000E2 0680FFFFFFD5      +146 	addi		#-'+', d0	; leading sign?
00:000000E8 6716              +147 	beq.b		istring_next
00:000000EA 0680FFFFFFFE      +148 	addi		#'+'-'-', d0
00:000000F0 6708              +149 	beq.b		istring_minus
00:000000F2 0680FFFFFFF3      +150 	addi		#'-'-'0'-10, d0	; well is it a digit?
00:000000F8 6010              +151 	bra.b		istring_digit?
  :                            152 
  :                            153 istring_minus				; scan the magnitude and negate it
00:000000FA 6104              +154 	bsr.b		istring_next
00:000000FC 4481              +155 	neg		d1
00:000000FE 4E75              +156 	rts
  :                            157 
  :                            158 istring_next
00:00000100 7000              +159 	moveq		#0, d0
00:00000102 1018              +160 	move.b		(a0)+, d0
00:00000104 0680FFFFFFC6      +161 	addi		#-'0'-10, d0	; is it > '9' ?
  :                            162 istring_digit?
00:0000010A 6512              +163 	bcs.b		istring_end	; if so, not more
00:0000010C 06800000000A      +164 	addi		#10, d0		; is it < '0' ?
00:00000112 640A              +165 	bcc.b		istring_end	; if so no more
00:00000114 E389              +166 	lsl		#1, d1		; multiply accumulation by 2
00:00000116 D081              +167 	add		d1, d0		; add accumulation to stripped digit
00:00000118 E589              +168 	lsl		#2, d1		; multiply accumulation by 4
00:0000011A D280              +169 	add		d0, d1		; accumulation = accumulation * 10 + digit
00:0000011C 60E2              +170 	bra		istring_next
  :                            171 
  :                            172 istring_end
00:0000011E 4E75              +173 	rts
  :                            174 
  :                            175 table_u
  :                            178 	$list
*EOF*
00:00001458+0000
00:0000145a+FFFF
00:0000145c+000A
00:0000145e+FFFFFFFFFFFFFFFF
:$(00):00040000:00041466 


</pre>


The following kernel assembly lists header file excerpts to show

	<blockquote>
	tokens like <b>-(a7)</b> and <b>w*4</b> may be labels, and labels may have a class or type.
	Different instructions may share one mnemonic name, and label types enable the
	assembly to pick the correct instruction code for storage operands and registers
	of multiple categories
<p>
	Macro language declares, references and tests in quotes labels which are otherwise not
	recognisable as labels
<pre>

	"-(a7)"		$equ,"$a_reg_@-" 	7

	"w*4"		$equ,$special_reg	0*/2++2

	$do		$t("p(1, 1)")="$a_reg_@+",	$formX	p(0, 0), p(1, 2), 3, +"p(1, 1)"

</pre>
<p>
	This prevents <b>-(a7)</b> from meaning minus <b>(a7)</b>, and for example <b>l*8</b> from meaning eight times <b>l</b>

<p>
	When a macro actual parameter is inserted in a <b>$form</b> as an instruction field, unsigned
	quotes would produce a character string. The addition of a unary sign <b>+"p(1, 1)"</b>
	produces a label value instead

<p>
	Application source code references labels like <b>l*8</b> and <b>-(a4)</b> without quotes 
<pre>

		move.w	(displacement, a0, d3.l*8), -(a4)

</pre>
<pre>

$ masmx -lnkV coldfire
MASMX 7r3
3/coldfire.msm
CONT_CHAR=|
LTERM=;
STERM=.
*EOF*
  :                            1: 	$include	"coldfire.def"
  :                            1 	$do	$o('V'),	$list	2
Note: coldfire.def Line 2: snapshot start of coldfire.def
  :                            2 	$do	$o('V'),	$note	snapshot start of coldfire.def
  :                            3 
  :                            4 	$word	16
  :                            5 	$awidth	32
  :                            6 	$quantum 8
  :                            7 	$byte	 8
  :                            8 
  :                            9 	$cont_char	'|'
  :                            10 	$lterm		';'
  :                            11 	$sterm		'.'
  :                            12 
  :                            13 	$set_option	"c"
  :                            14 
  :                            15 "$d_reg" 	$equ	128
  :                            16 "$a_reg" 	$equ	129
  :                            17 "$a_reg_@"	$equ	130
  :                            18 "$a_reg_@+" 	$equ	131
  :                            19 "$a_reg_@-"	$equ	132
  :                            20 "$special_reg"	$equ	133
  :                            21 "$fp_reg"	$equ	134
  :                            22 
  :                            23 d0	$equ,"$d_reg"	0
  :                            24 d1	$equ,"$d_reg"	1
  :                            25 d2	$equ,"$d_reg"	2
  :                            26 
  :                            52 	$do	$o('V'),	$list	2
Note: coldfire.def Line 53: snapshot equates in coldfire.def
  :                            53 	$do	$o('V'),	$note	snapshot equates in coldfire.def
  :                            54 
  :                            55 "(a5)"	$equ,"$a_reg_@"	5
  :                            56 "(a6)"	$equ,"$a_reg_@"	6
  :                            57 "(a7)"	$equ,"$a_reg_@"	7
  :                            58 
  :                            59 "-(a0)"	$equ,"$a_reg_@-"	0
  :                            60 "-(a1)"	$equ,"$a_reg_@-"	1
  :                            61 "-(a2)"	$equ,"$a_reg_@-"	2
  :                            62 
  :                            109 	$do	$o('V'),	$list	2
Note: coldfire.def Line 110: snapshot equates in coldfire.def
  :                            110 	$do	$o('V'),	$note	snapshot equates in coldfire.def
  :                            111 
  :                            112 "a5@+"	$equ,"$a_reg_@+"	5
  :                            113 "a6@+"	$equ,"$a_reg_@+"	6
  :                            114 "a7@+"	$equ,"$a_reg_@+"	7
  :                            115 
  :                            116 fp0	$equ,"$fp_reg"		0
  :                            117 fp1	$equ,"$fp_reg"		1
  :                            118 fp2	$equ,"$fp_reg"		2
  :                            119 
  :                            141 	$do	$o('V'),	$list	2
Note: coldfire.def Line 142: snapshot equates in coldfire.def
  :                            142 	$do	$o('V'),	$note	snapshot equates in coldfire.def
  :                            143 
  :                            144 "l*2"	$equ,"$special_reg"	1*/2++1
  :                            145 "l*4"	$equ,"$special_reg"	1*/2++2
  :                            146 "l*8"	$equ,"$special_reg"	1*/2++3
  :                            147 
  :                            148 ;	[ w l ] are only encoded [ 0 1 ]
  :                            149 ;	in the index width construct (a0, d0.w[ *1 *2 *4 *8])
  :                            150 
  :                            151 ;	and otherwise get their encoding values
  :                            152 ;	from instruction names, for example  move.[b w l]
  :                            153 
  :                            154 ;	however their values here combined with type $special_reg
  :                            155 ;	can be used for recognition in macro language
  :                            156 ;	and are used in the set [ b w l s d ]
  :                            157 
  :                            158 b	$equ,$special_reg	2*/2
  :                            159 s	$equ,$special_reg	3*/2
  :                            160 d	$equ,$special_reg	4*/2
  :                            161 
  :                            186 	$do	$o('V'),	$list	2
Note: coldfire.def Line 187: operand attribute scan in coldfire.def
  :                            187 	$do	$o('V'),	$note	operand attribute scan in coldfire.def
  :                            188 
  :                            189 f	$func
  :                            190 ;
  :                            191 ;	when no displacement is coded outside the parentheses
  :                            192 ;
  :                            193 "$inside"*	$name
  :                            194 	$return	f(1)
  :                            195 
  :                            196 "$displacement8"*	$name
  :                            197 	$do	f(1, 1)<-128,	$flag	displacement too low
  :                            198 	$do	f(1, 1)>127,	$flag	displacement too high
  :                            199 "$displacement"*	$name
  :                            200 	$return	f(1, 1)
  :                            201 
  :                            202 "$base_a"*	$name
  :                            203 	$do	$t(f(1, 2))^=$a_reg,	$flag base register not a0..a7
  :                            204 	$do	$t(f(1, 2))^=$a_reg,	$trace f(1, 2)
  :                            205 	$return	f(1, 2)
  :                            206 
  :                            207 "$idx_c"*	$name
  :                            208 	$return	f(1, 3:)	; how many substrings are after (disp, a0,.
  :                            209 
  :                            210 "$idx_d"*	$name		; d-register
  :                            211 	$do	$t(f(1, 3:1))=$a_reg,		$return	8++f(1, 3:1)
  :                            212 	$do	$t(f(1, 3:1))^=$d_reg,		$flag	index not d0..d7/a0..a7
  :                            213 	$return	f(1, 3:1)
  :                            214 
  :                            215 "$idx_w"*	$name		; width++scale
  :                            216 	$do	f(1, 3:)=1,	$return	"l*1"
  :                            217 	$do	$t("f(1, 3:2)")^=$special_reg,	$flag	scale not in scale
  :                            218 	$return	"f(1, 3:2)"
  :                            219 
  :                            220 	$end
  :                            221 
Note: coldfire.def Line 1308: end of include coldfire.def
  :                            2 
  :                            3 
  :                            4 __LINK_POINTER	$equ,"$a_reg"	6
  :                            5 __TCB_LOCATION	$equ		0
  :                            6 
  :                            7 
  :                            8 CPUS		$set	1
  :                            9 PRIORITIES	$set	8
  :                            10 IDLE_STACK	$set	64
  :                            11 
Note: coldfire.msm Line 13: listing off
Note: coldfire.msm Line 14: after all, the kernel structures aren't interesting
  :                            116 	$list	1
  :                            117 
00:00000400 2F08              +118 	move	a0, -(a7)
00:00000402 6100008A          +119 	bsr	p_tcb
  :                            120 
00:00000406 48E87FFF0010      +121 	movem	d0-a6, (tcb.genregs, a0)
  :                            122 
00:0000040C 2248              +123 	move	a0, a1
00:0000040E 205F              +124 	move	(a7)+, a0
00:00000410 23480030          +125 	move	a0, tcb.a_reg_0(a1)
00:00000414 234F004C          +126 	move	a7, tcb.a_reg_7(a1)
  :                            127 
00:00000418 20290004          +128 	move	tcb.h.priority(a1), d0
  :                            129 
00:0000041C 6B4E              +130 	bmi	qaside	$8_bits
00:0000041E 0C8000000007      +131 	cmpi	#PRIORITIES-1, d0
00:00000424 6E46              +132 	bgt	qaside	$8_bits
  :                            133 
Note: coldfire.msm Line 135: listing off
Note: coldfire.msm Line 136: after all, the context switch isn't interesting
  :                            162 	$list	1
  :                            163 
00:00000464 4CE9FFFF0010      +164 	movem	tcb.genregs(a1), d0-a7
00:0000046A 4E73              +165 	rte
  :                            166 
  :                            167 
  :                            168 
(+03)20
00:0000046C 4AB900000124      +169 qaside	tst	(qaside_h).l
00:00000472 670C              +170 	beq	first	$8_bits
(+03)20
00:00000474 207900000128      +171 	move	(qaside_t).l, a0
00:0000047A 21490000          +172 	move	a1, tcb.h.next(a0)
00:0000047E 6006              +173 	bra	last	$8_bits
(+03)20
00:00000480 23C900000124      +174 first	move	a1, (qaside_h).l 	
(+03)20
00:00000486 23C900000128      +175 last	move	a1, (qaside_t).l
00:0000048C 60B2              +176 	bra	pick
  :                            177 
  :                            178 
  :                            179 	$if	__LINK_POINTER
  :                            180 
                                	$do	$t(__LINK_POINTER)^=$a_reg,	|
  :                            182 	$flag	__LINK_POINTER should be a6 or similar
  :                            183 
  :                            184 ;	this is callable from c and returns pointer to tcb
  :                            185 ;	it requires that applications do not use stack frame
  :                            186 ;	link register (often a6) for anything except linking stack frames
  :                            187 
  :                            188 ;	it does not matter if functions do not use stack
  :                            189 ;	frames at all. It matters that nothing but LINK and UNLK
  :                            190 ;	instructions should change the link register
  :                            191 
00:0000048E 2F00              +192 p_tcb*	move	d0, -(a7)
  :                            193 
00:00000490 204E              +194 	move	__LINK_POINTER, a0
00:00000492 6002              +195 	bra	again?	$8_bits
00:00000494 2040              +196 again!	move	d0, a0
00:00000496 2018              +197 again?	move	(a0)+, d0
00:00000498 66FA              +198 	bne	again!
  :                            199 
00:0000049A 201F              +200 	move	(a7)+, d0
00:0000049C 4E75              +201 	rts
  :                            202 
  :                            203 
  :                            204 	$elseif	__TCB_LOCATION
  :                            205 
  :                            206 ;	this is callable from c and returns pointer to tcb
  :                            207 ;	if compilers can be directed to spare an address register,
  :                            208 ;	possibly a5 or a4, then __TCB_LOCATION can be that register
  :                            209 ;	and the encoding at the head of the assembly would be as
  :                            210 ;
  :                            211 ;	__LINK_POINTER	$equ		0
  :                            212 ;	__TCB_LOCATION	$equ,$a_reg	a5
  :                            213 ;
  :                            214 ;	otherwise __TCB_LOCATION may be a longword in RAM
  :                            215 ;	linked in location counter 3 (static data), but not if
  :                            216 ;	more than one core is running in the execution space
  :                            217 
  :                            218 	$if	$t(__TCB_LOCATION)=$a_reg
  :                            219 	$note	tcb pointer is an address register
  :                            220 	$else
  :                            221 	$note	tcb pointer is not at address register
  :                            222 	$endif
  :                            223 
  :                            224 p_tcb*	move	__TCB_LOCATION, a0
  :                            225 	rts
  :                            226 
  :                            227 	$else
  :                            228 
  :                            229 	$flag	you must have __LINK_POINTER or __TCB_LOCATION
  :                            230 
  :                            231 	$endif
*EOF*
:$(00):00000400:0000049E :$(03):00000000:0000012C :$(43):00000000:00000058 

</pre>
The same macro language can assemble an alternative Motorola syntax with tokens [] a4@ a0@+ a7@-
<pre>

$ masmx -lnk coldfir@
MASMX 7r3
3/coldfir@.msm
CONT_CHAR=|
LTERM=;
STERM=.
*EOF*
  :                            1: 	$include	"coldfire.def"
  :                            2 
  :                            3 __LINK_POINTER	$equ,"$a_reg"	6
  :                            4 __TCB_LOCATION	$equ		0
  :                            5 
  :                            6 
  :                            7 CPUS		$set	1
  :                            8 PRIORITIES	$set	8
  :                            9 IDLE_STACK	$set	64
  :                            10 
  :                            11 
Note: coldfir@.msm Line 14: listing off
Note: coldfir@.msm Line 15: after all, the kernel structures aren't interesting
  :                            115 	$list	1
  :                            116 
00:00000400 2F08              +117 	move	a0, a7@-
00:00000402 6100008A          +118 	bsr	p_tcb
  :                            119 
00:00000406 48E87FFF0010      +120 	movem	d0-a6, [tcb.genregs, a0]
  :                            121 
00:0000040C 2248              +122 	move	a0, a1
00:0000040E 205F              +123 	move	a7@+, a0
00:00000410 23480030          +124 	move	a0, [tcb.a_reg_0, a1]
00:00000414 234F004C          +125 	move	a7, [tcb.a_reg_7, a1]
  :                            126 
00:00000418 20290004          +127 	move	[tcb.h.priority, a1], d0
  :                            128 
00:0000041C 6B4E              +129 	bmi	qaside	$8_bits
00:0000041E 0C8000000007      +130 	cmpi	#PRIORITIES-1, d0
00:00000424 6E46              +131 	bgt	qaside	$8_bits
  :                            132 
  :                            133 
Note: coldfir@.msm Line 136: listing off
Note: coldfir@.msm Line 137: after all, the context switch isn't interesting
  :                            163 	$list	1
  :                            164 
00:00000464 4CE9FFFF0010      +165 	movem	[tcb.genregs, a1], d0-a7
00:0000046A 4E73              +166 	rte
  :                            167 
  :                            168 
  :                            169 
(+03)20
00:0000046C 4AB900000124      +170 qaside	tst	(qaside_h).l
00:00000472 670C              +171 	beq	first	$8_bits
(+03)20
00:00000474 207900000128      +172 	move	(qaside_t).l, a0
00:0000047A 21490000          +173 	move	a1, [tcb.h.next, a0]
00:0000047E 6006              +174 	bra	last	$8_bits
(+03)20
00:00000480 23C900000124      +175 first	move	a1, (qaside_h).l 	
(+03)20
00:00000486 23C900000128      +176 last	move	a1, (qaside_t).l
00:0000048C 60B2              +177 	bra	pick
  :                            178 
  :                            179 
  :                            180 	$if	__LINK_POINTER
  :                            181 
                                	$do	$t(__LINK_POINTER)^=$a_reg,	|
  :                            183 	$flag	__LINK_POINTER should be a6 or similar
  :                            184 
  :                            185 ;	this is callable from c and returns pointer to tcb
  :                            186 ;	it requires that applications do not use stack frame
  :                            187 ;	link register (often a6) for anything else
  :                            188 
  :                            189 ;	it does not matter if functions do not use stack
  :                            190 ;	frames at all. It matters that nothing but LINK and UNLK
  :                            191 ;	instructions should change the link register
  :                            192 
00:0000048E 2F00              +193 p_tcb*	move	d0, a7@-
  :                            194 
00:00000490 204E              +195 	move	__LINK_POINTER, a0
00:00000492 6002              +196 	bra	again?	$8_bits
00:00000494 2040              +197 again!	move	d0, a0
00:00000496 2018              +198 again?	move	a0@+, d0
00:00000498 66FA              +199 	bne	again!
  :                            200 
00:0000049A 201F              +201 	move	a7@+, d0
00:0000049C 4E75              +202 	rts
  :                            203 
  :                            204 
  :                            205 	$elseif	__TCB_LOCATION
  :                            206 
  :                            207 ;	this is callable from c and returns pointer to tcb
  :                            208 ;	if compilers can be directed to spare an address register,
  :                            209 ;	possibly a5 or a4, then __TCB_LOCATION can be that register
  :                            210 ;	and the encoding at the head of the assembly would be as
  :                            211 ;
  :                            212 ;	__LINK_POINTER	$equ		0
  :                            213 ;	__TCB_LOCATION	$equ,$a_reg	a5
  :                            214 ;
  :                            215 ;	otherwise __TCB_LOCATION may be a longword in RAM
  :                            216 ;	linked in location counter 3 (static data), but not if
  :                            217 ;	more than one core is running in the execution space
  :                            218 
  :                            219 	$if	$t(__TCB_LOCATION)=$a_reg
  :                            220 	$note	tcb pointer is an address register
  :                            221 	$else
  :                            222 	$note	tcb pointer is not at address register
  :                            223 	$endif
  :                            224 
  :                            225 p_tcb*	move	__TCB_LOCATION, a0
  :                            226 	rts
  :                            227 
  :                            228 	$else
  :                            229 
  :                            230 	$flag	you must have __LINK_POINTER or __TCB_LOCATION
  :                            231 
  :                            232 	$endif
*EOF*
:$(00):00000400:0000049E :$(03):00000000:0000012C :$(43):00000000:00000058 

</pre>


<h1>F.4: Byte-Addressing Machines with 32 and 64 Bit Bus:
Managing Alignments</h1>


<p>
If the address quantum of the target is also its word size, then
then the real architectural word size is the only possible $WORD value.


<p>
Word size set with the $WORD directive may otherwise not always mean the
architectural word size of the target.


<p>
In masmx $WORD sets the quantum of data which a line of assembly
can generate. A line may generate no code, a word or some words.

<p>
A target which can fetch instructions from any octet address and can have
instructions one or three or five bytes long must be described as having word
size one octet although its integer registers may be 32 or 64 bits in size
<pre>

	$cont_char	'|'
	$lterm		';'

	$word	8
	$awidth	32	; or however wide an address is

</pre>
<p>
32-bit and 64-bit integers are then described as quadwords and octawords,
here for a reverse-byte-order target:
<pre>

dl*	$proc
?	$do	dl(1),	+	dl(1, ?),	dl(1, ?)/*8,	|
				dl(1, ?)/*16,	dl(1, ?)/*24:q
	$end


p	$proc
long_long* $name
?	$do	p(1),	+	p(1, ?), 	p(1, ?)/*8,	|
				p(1, ?)/*16, 	p(1, ?)/*24,	|
				p(1, ?)/*32, 	p(1, ?)/*40,	|
				p(1, ?)/*48, 	p(1, ?)/*56:o
	$end

</pre>
<p>
An integer longer than than an octaword can be described with $FORM
<pre>

i128	$form	8,8,8,8, 8,8,8,8, 8,8,8,8, 8,8,8,8

d128*	$proc
	i128	d128,     d128/*8,  d128/*16, d128/*24,	|
	 	d128/*32, d128/*40, d128/*48, d128/*56,	|
	 	d128/*64, d128/*72, d128/*80, d128/*88,	|
	 	d128/*96, d128/*104,d128/*112,d128/*120
	$end

</pre>
<p>
And this would apply to most Intel targets. Aligment directives
or macros are added where needed.

<p>
This does not in any way affect the target's ability to make full use
of its 32-bit or 64-bit data path.

<p>
Some architectures are critical about the alignment of instructions and
integers

<p>
Commands with names .byte .half .ascii .asciiz .space
may leave the next available location xxxxxx01 or xxxxxx10 or xxxxxx11.
 
<p>
load/store instructions may however need xxxxxx00 alignment for 32-bit
loads and stores and xxxxxxx0 alignment for 16-bit loads and stores.

<p>
It may be necessary or advantageous to follow up .byte or .space with
a command often called .align which usually has a power-2 argument

<p>
This is how .align looks as implemented with a masmx macro. .align
is coded here for PowerPC. The expression token . is location counter
which is otherwise $
<pre>

.align* $proc
granule $set    1*/.align(1,1)
        $res    ((.+granule-1)**-granule)-.
        $end

</pre>

<h1>Appendix G: Disclaimer and Contact</h1>


<p>
The executables in this package should not harm any
systems on which you run them. No responsibility is
accepted for them. They carry no guarantee.

<p>
These are free products.

<p>
Assistance can be requested at masmx@gmx.ch

<p>
Tim Cox
<p>
+41 78 629 86 11
<p>
24. April 2015

<i>
<pre>
_______________________________________________________________________________________


LICENCE NOTE

    Copyright Tim Cox, 2012
    TimMilesCox@gmx.ch

    This document describes the masmx.7r2 target-independent meta-assembler.

    masmx.7r3 is free software. It is licensed
    under the GNU General Public Licence Version 3

    You can redistribute it and/or modify masmx.7r2
    under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    masmx.7r3 is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with masm.7r2.  If not, see &lt;http://www.gnu.org/licenses/&gt;.

</i>
</pre>



</div>
