<center

<div style=font-family:Times">
<h1>MASMX.7r2</h1>


<i>
Copyright Tim Cox, 2012<br>

This document describes the masmx.7r2 target-independent meta-assembler
<br>
The masmx.7r2 meta-assembler is free software licensed with the GNU General Public Licence Version 3
<br>
The same licence encompasses all accompanying software and documentation <br>
The full licence text is included with these materials<br>
See also the licensing notice at the foot of this document
</i>


<h1>The Free Meta Assembler</h1>



</center>

<h2>What's masmx?</h2>


<p>
masmx is a meta-assembler for any target.

<p>
masmx may interact with the GNU toolchain, and may be used independently.

<p>
masmx can assemble absolute system images in one step from source.

<p>
masmx can assemble relocatable code and has an internal linker.

<p>
The linker constructs absolute code or a new relocatable, cumulatively,
incrementally, absolutely.

<p>
The limit is 192-bit addressing, 192-bit integers, 192-bit floating-point.

<p>
masmx has a slender syntax of its own, and is able to interpret
any other assembly language syntax.

<p>
Legacy source code in any syntax assembles unchanged.

<p>
Access is entirely in text, from machine definition macros through to
S-records or I-records.

<p>
The illustrated sample assemblies show masmx's potential for any
new or existing industrial microcontroller target. 

<p>
The accompanying masmx definitions headers for 8051 and for PowerPC
are field proven in live commercial use.

<p>
Keeping pace with architectural extensions is a matter of adding more
macro language. Anyone who understands the target architecture can do this.

<p>
The distributor of masmx can also generate target definitions for you.


<h2>Why do you want it?</h2>


<p>
Typical masmx targets are low-power targets where as few instructions
as possible are executed.

<p>
masmx gives minute control of the construction and location of code and data.

<p>
Complex EPROM and Flash structures may be described in a few cryptic lines of source code.

<p>
masmx can assemble code from GNU toolchain compilations giving complete
control of the output image construction.

<p>
The maximum integer, floating point and address radix of 192 bits make
masmx a toolchain for experimental large architectures, or for multi-architecture systems with special hardware modules.

<p>
masmx is also a toolchain for the smallest architectures. The supplied
definition header for 8051 has been used on mission-critical projects by
prestige clients.

<p>
More masmx macro language has been written for PowerPC than
for any other architecture. PowerPC incremental and absolute linking is
illustrated in Section 9 of this manual. masmx has generated PowerPC RT
kernels using the macro metadata used here.

<p>
Target architecture definitions are source code include files.

<p>
This manual shows how to use masmx for any architecture present or future.

<p>
masmx is hosted on MAC OS X PowerPC G4, MAC OS X Intel ix86,
Sun SPARC Solaris, UBUNTU and DEBIAN Linux x86, MS DOS and MS Windows 32.

<p>
If you need a definition text for any target machine and don't
wish to construct it yourself, contact masmx@gmx.ch.

<p>
masmx is cost-free and for any target.

<pre>


1.  What masmx can do						1

    1.	Any Target Architecture					1.1
    2.	Any Input Syntax					1.2

	-Legacy Source Code Unchanged

	1.  Legacy Automatic Macros				1.2.1
	2.  Number String Notation				1.2.2
	3.  A Complete Aside about Repeat Data			1.2.3

    3.	Any Word Size						1.3
    4.	Any Address Space					1.4
    5.	Any Floating Point Format				1.5
    6.	Link-up with GNU tools					1.6

2.  masmx is hosted on						2

    1.	Unix Proprietary Platforms				2.1
	1.  Mac OS X / G4 Power PC				2.1.1
	2.  Mac OS X / Intel ix86				2.1.2
	3.  Sun SPARC Solaris					2.1.3

    2.	Linux Platforms						2.2
	1.  UBUNTU Linux / ix86					2.2.1
	1.  DEBIAN Linux / ix86					2.2.2

    3.	Microsoft Platforms					2.3
	1.  DOS							2.3.1
	2.  Windows 						2.3.2

3.  Getting Started						3

    1.	Command Line						3.1
    2.	Command Line Options					3.2


4.  The Core of masmx						4

    1.	The Assembly Language Source Line			4.1

	1.  Label, Command, Operands				4.1.1


	2.  The Label Field					4.1.2

	    1.  Describing Address Spaces:
	        Location Counter Controls			4.1.2.1

		1.  Absolute Location Counters			4.1.2.1.1

		    1.	The Breakpointed Location Counter:
			Hardware Segmentation			4.1.2.1.1.1

		    2.  The Breakpointed Location Counter:
			-v Option				4.1.2.1.1.2

		    3.	Simple Location Counter without Breakpoint:
			Base+Displacement in Flat Address Spaces
								4.1.2.1.1.3

		    4.	The Breakpointed Location Counter:
             		Base+Displacement in Translated Address Spaces
								4.1.2.1.1.4

		    5.	Void Segments				4.1.2.1.1.5

		    6.	The Breakpointed Location Counter:
			Giant Address Spaces			4.1.2.1.1.6

			1.  Very Large
			    Direct Addressed Segments	4.1.2.1.1.6.1

			2.  Very Large Load Address
			    Base-Displacement Examples	4.1.2.1.1.6.2

		            1.  Giant Absolute Address Base-Displacement
			        Example (static referencing)
							4.1.2.1.1.6.2.1

			    2.  Giant Absolute Address Base-Displacement
			        Example (dynamic referencing)
							4.1.2.1.1.6.2.2

		    7.	Literal Pool Tag			4.1.2.1.1.7

		2.  Relocatable Location Counters		4.1.2.1.2

    2.  Lines of Code Generally					4.2

	1.  Labels						4.2.1

	2.  The Command Field					4.2.2

	    1.  Directives					4.2.2.1

	    2.  -Data Constants					4.2.2.2

		1.  -Integer Items				4.2.2.2.1
		2.  -Split Integer Items			4.2.2.2.2
		3.  -$FORM Items				4.2.2.2.3
		4.  -Floating Point Numbers			4.2.2.2.4

		5.  -The Decimal Scale Operator *+ *-		4.2.2.2.5

		6.  -Text Strings				4.2.2.2.6

	    3.  -Macro Calls -instructions and structures	4.2.2.3

	3.  The Operand Field					4.2.3

	    1.	-Fields, Subfields and Substrings	4.2.3.1
	    2.	-Expressions				4.2.3.2
		1.  -operators				4.2.3.2.1
		    1.	Operators Used on Relocatable Tokens
							4.2.3.2.1.1

		2.  -tokens in expressions		4.2.3.2.2
		    1.  -number strings			4.2.3.2.2.1
		    2.  -label references		4.2.3.2.2.2
		    3.  -macro parameters		4.2.3.2.2.3

		    4.  -assembler-supplied functions 	4.2.3.2.2.4
	
                        1.  $ -this location counter	4.2.3.2.2.4.1

                        2.  $(..) -a location counter	4.2.3.2.2.4.2

			3.  $a -absolute address in
			    base+displacement space	4.2.3.2.2.4.3

			4.  $b -section base address
			    or -segment base address	4.3.3.2.2.4.4
                    	  
			5.  $bank_index -absolute or virtual
			    memory space identifier	4.2.3.2.2.4.5


			6.  $n -short token for macro reference name
							4.2.3.2.2.4.6

			7.  $net(..) -unrelocated value of expression
 							4.2.3.2.2.4.7

			8.  $o(..) -value of an option flag
							4.2.3.2.2.4.8

			9.  $r -region:

                     	  1.  -identity of current location counter
							4.2.3.2.2.4.9.1

			  2.   $r(..) identity of target locator
                               				4.2.3.2.2.4.9.2

			10. $rel(..) 
                            -is locator relocatable?	4.2.3.2.2.4.10

			11. $t(..) -type of a label	4.2.3.2.2.4.11

                          1.   -undefined		4.2.3.2.2.4.11.1
                          2.   -location		4.2.3.2.2.4.11.2
                          3.   $EQU			4.2.3.2.2.4.11.3
                          4.   $SET			4.2.3.2.2.4.11.4
                          5.   $EQUF			4.2.3.2.2.4.11.5
                          6.   $DIRECTIVE		4.2.3.2.2.4.11.6
                          7.   $FUNCTION (of masmx)	4.2.3.2.2.4.11.7
                          8.   $PROC (macro)		4.2.3.2.2.4.11.8
                          9.   $NAME			4.2.3.2.2.4.11.9
                         10.   $FUNC (macro)		4.2.3.2.2.4.11.10
                         11.   $FORM			4.2.3.2.2.4.11.11
                         12.   -user assigned label types
							4.2.3.2.2.4.11.12

		   5.  Function Macros			4.2.3.2.2.5

	    3.  Literals					4.2.3.3

5.  Functions and Literals					5

    1.	User-written Functions					5.1
        1.  -a function is					5.1.1
	2.  -directives for constructing functions		5.1.2
	    1.  $FUNC -head of function				5.1.2.1
            2.	$NAME -entry point and invocation tag		5.1.2.2
	    3.	$RETURN -value of result			5.1.2.3
	    4.	$END -foot of function				5.1.2.4
	3.  -code generated during function evaluation		5.1.3
	    1.  idempotent functions				5.1.3.1
            2.  last-pass-only functions			5.1.3.2

    2.	Literals						5.2
	1.  -a literal is					5.2.1
	2.  The Literal Pools					5.2.2
	3.  Literal Pool Tags					5.2.3
	4.  Re-use of Literals					5.2.4
	5.  Automatic Literals					5.2.5

6.  Describing Target Architecture in Text			6

    1.  Establishing Your Syntax				6.1
    2.	Describing the Target Architecture			6.2
	1.  $WORD, $BYTE, $QUANTUM, $AWIDTH			6.2.1
	2.  $FORM, $PROC, $NAME, $END				6.2.2
	    1.	The $FORM Template				6.2.2.1
	    2.	The $PROC Header				6.2.2.2
	    3.	The $NAME Entry Point				6.2.2.3
	    4.	The $END Macro Footer				6.2.2.4
	    5.  Minimal Instruction Macro Example		6.2.2.5
	    6.	The Two-pass $PROC				6.2.2.6
	    7.	The Out of Line $PROC				6.2.2.7
	    8.	Nested Macro Descriptions			6.2.2.8

	3.  Ready Made Target Descriptions			6.3

            1.	-8051						6.3.1

            2.	-PowerPC					6.3.2

	    3.	Fragment Samples - ColdFire/68000, MIPS, ARM	6.3.3

		1.  68000 and ColdFire				6.3.3.1
		2.  MIPS					6.3.3.2
		3.  ARM						6.3.3.3

7.  Iterated Code and Structured Data				7

    1.	$DO and macros						7.1

    2.	Subscripted Labels					7.2
        1.  Subscripted Labels plus functional subscript	7.2.1

    3.	Structured Data and Structured Code Name Spaces		7.3

	1.  Simple Structures $TREE..$ROOT			7.3.1
	2.  Branched Structures $BRANCH..$ROOT			7.3.2
	3.  Complex Structures					7.3.3

8.  The Directives:						8

    1.	$ASCII		set character code to ASCII		8.1
    2.	$AWIDTH		set address width			8.2
    3.  $BLANK		set the globality of a future label	8.3
    4.	$BRANCH		branch of a structured name space	8.4
    5.	$BYTE		set the width of a text byte		8.5

    6.	$CHARACTERISTIC	-set exponent field size
			per floating point number size		8.6

    7.	$CONT_CHAR	change line continue character		8.7
    8.	$DATA_CODE	define/select alternate character set	8.8
    9.	$DO		generate repeated code			8.9
    10.	$ELSE		conditional assembly			8.10
    11.	$ELSEIF		conditional assembly			8.11
    12.	$END		foot of macro or assembly		8.12
    13.	$ENDIF		conditional assembly			8.13
    14.	$EQU		assign a value to label			8.14
    15.	$EQUF		assign a list of values to label	8.15
    16.	$EXIT		abandon assembly with a message		8.16
    17.	$FLAG		diagnostic, mark assembly in error	8.17

    18.	$FLAGF		first pass diagnostic,
			mark assembly in error			8.18

    19.	$FLOATING_POINT set default floating number size	8.19

    20.	$FORM		layout of bit structure,
			typically an instruction layout		8.20

    21.	$FUNC		user macro to produce an operand value	8.21
    22.	$HEX		set binary notation to hex		8.23

    23.	$IF		conditional assembly			8.23

    24. $INCLUDE	include a source file or a binary file	8.24

	1.	$INCLUDE	read a nested source file	8.24.1

	2.	$INCLUDE,$BINARY linking directive:

			include a text-encoded binary file
			and process the relocation information
			within it				8.24.2

	3.	$INCLUDE,$VOID	linking directive:

			include addresses from a text-encoded
			binary file, but do not include the
			code inside it				8.24.3

    25.	$INFO		linking directive:			8.25

	1.	$INFO,$OFFSET					8.25.1

			update the relocation information
			from the input binary and write the
			new relocation information to the
			output binary

	2.	$INFO,$RANGE_CHECK
		$INFO,$RANGE_CHECK1

			Request Linker Automatic Range-Checking	8.25.2

    26.	$LINEWIDTH	control layout in text encoded binary	8.26

    27.	$LIST		set inclusion nest level for listing	8.27
			$list 0, masking names from list/export

    28.	$LIT		select default location counter for literals
			-optionally declare literal tag		8.28

    29. $LOAD		linking directive:
			write revised binary information in
			output text-encoded binary file		8.30

    30.	$LTERM		change comment character		8.30
    31.	$NAME		macro call name and value		8.31
    32.	$NOP		do nothing [+ comment]			8.32
    33.	$NOTE		informative diagnostic, not error	8.33
    34.	$NOTEF		first pass informative diagnostic	8.34
    35.	$OCTAL		set binary notation to octal		8.35
    36.	$PATH		alter include path			8.36
    37.	$PLIST		nest depth for listing macro expansion	8.37
    38.	$PROC		head of procedural macro		8.38

    39. $PUSHREL	linking directive:

			scan a relocation tuples applied to a
			word group in the text-encoded binary.

			Stack an unresolved relocation tuple
			for replay to the $MAP linking macro	8.39

    40.	$QUANTUM	set address quantum			8.40

    41.	$QUOTE		change quote mark			8.41

        1.  		quoted strings and labels
			within macro expansions			8.42.1

    42.	$RES		declare a storage buffer		8.42

    43.	$RETURN							8.43

	1.		return a value from within $FUNC..$END	8.43.1
	2.		return from within $PROC..$END		8.43.2

    44.	$ROOT		end of a structured name space which was
			begun with $TREE or $BRANCH		8.44

    45.	$SET		assign value to a reassignable label	8.45

    46.	$SET_OPTION						8.46

	1.		set option flags			8.46.1

	2.		Interaction of Run Options
			and List Directives			8.46.2

    47.	$SNAP		list the label table			8.47

    48.	$STERM		set the substring sentinel symbol	8.48
    49.	$STORE		set the default output file name	8.49

    50.	$SUFFIX		interpret number string notation
			by suffix				8.50

    51.	$TEXT		translate input text patterns		8.51
    52.	$TRACE		display value of expression		8.52
    53.	$TREE		simple structured name space		8.53

    54.	$TWOS_COMPLEMENT
			change negative integer representation	8.54
			-default is twos-complement

    55.	$WORD		declare size of target computer word	8.55



9.  Output File Formats, Relocation and Linking
    Giant Address Spaces, Interfacing with GNU Tools		9

    1.	Text Encoded Binary Format, S-Records
	and Intel Hex Records					9.1

    2.	Relocation, Linking, Giant Address Space
	and Interfacing with GNU Tools				9.2

	1.  Relocation Information in Text Encoded Binary	9.2.1

	2.  masmx Linking in Principle				9.2.2

	3.  Demonstration Links					9.2.3

	    1.	The Simplest Link				9.2.3.1

	    2.	Link Collected by Sections			9.2.3.2

	    3.	Link Specific Segments				9.2.3.3

	    4.	Link an Output Relocatable			9.2.3.4

	    5.	Link an Accumulated Relocatable
		plus a New Relocatable				9.2.3.5

	    6.	The Incremental Link				9.2.3.6

	    7.	The Link in Giant Address Space			9.2.3.7

	    8.	The Incremental Link in Giant Address Space	9.2.3.8

	    9.	Linking with Void Inclusion			9.2.3.9

	    10.	Linking With void Inclusion
		in Giant Address Space				9.2.3.10

10. Byte-Addressing Machines with 32 and 64 Bit Bus
    Managing Alignments						10

11. Tuning Macro Language and Fixing Problems			11

    1	Fixing a Macro Parameter Reference			11.1
    2	Label Cannot Be Referenced				11.2
    3	Changed Label Value Disappears				11.3
    4	Tracing Macro Expansion					11.4
    5	Aliasing masmx Internal Functions			11.5
    6	Diagnostic about a Label Address			11.6
    7	Label fails to be Exported				11.7

Appendix A: What's new in 7r2?
Appendix B: The masmx Product Road Map
Appendix C: masmx's Potential for High Level Languages
Appendix D: Disclaimer and Contact


</pre>


<h1>1: masmx Can Do</h1>

<h2>1.1: Any Target Architecture</h2>

<p>
masmx does not know a computer architecture when it begins to run. 
The developer begins the initial source file with a line like:
<pre>

	$include        "target.def"

</pre>
<p>
Initially masmx knows directives ($include is a directive) 
and some special names representing internal functions (like $, 
meaning "location counter").

<p>
Because file includes can be nested extensively, you don't need
to edit your existing source even to get the header include line in.
You can construct wrappers like:
<pre>

	$list	0
	$include	"target.def"
	$list	2
	$include	existing_application.msm

</pre>
<p>
And that arrangement allows useful lines like these two,
which set flags and specify macro text display depth, to be introduced:
<pre>

	$set_option	"abc"
	$plist		7


</pre>
<p>
You can alias the built-in directives and functions to suit your existing
code. You can also implement the directives of other assemblers as macros.

<p>
A definition file included at the head of the assembly defines: 
<ul>

	<pre></pre>assembly language syntax

	<pre></pre>the computer word size, up to 192 bits

	<pre></pre>the data byte size

	<pre></pre>the target data code, default ASCII
 
	<pre></pre>the address space

	<pre></pre>the address quantum

	<pre></pre>any address space segmentation or partitioning

	<pre></pre>register sets and names

	<pre></pre>the instruction set

	<pre></pre>any pseudo-instructions used to generate constants

	<pre></pre>integer encoding and floating point formats

</ul>
<h2>1.2: Any Syntax: Legacy Source Code Unchanged</h2>


<p>
masmx has a slender native syntax described in Section
4: The Core of masmx. There is no need to convert 
existing source code before masmx can assemble it, 
because the definitions in the include header files are used to 
explain the syntax of other assemblers to masmx.

<p>
Programmable syntax particles include
<ul>

	<pre></pre>the comment character

	<pre></pre>the quote character

	<pre></pre>the sub:string character

	<pre></pre>the line continue character if you want one

	<pre></pre>user-supplied renames for the masmx-supplied directives

	<pre></pre>user-supplied renames for the masmx-supplied functional macros

	<pre></pre>interpretation of legacy assembler macros

	<pre></pre>text string translation

	<pre></pre>integer notation

</ul>
<p>
Text string translation enables masmx to scan different operator styles.

<p>
masmx assembly does not require code changes. Source never needs to be
edited, until you want to change what it does.


<h3>1.2.1: Legacy Automatic Macros</h3>

<p>
The developer using masmx can implement function macros to replace
fixed functions of other assemblers. For example:

<p>
A legacy assembler may have a fixed macro <b>@</b>, meaning
"location counter of variables".

<p>
The developer using masmx can implement this function with these lines:
<pre>

@*	$func
	$return	$(1)
	$end

</pre>
<p>
To explain these lines in detail:
<ul>

	<pre></pre><b>@</b> is a label like any other label.
	It's the label of the macro.

	<pre></pre>there is an asterisk on <b>@*</b> to make it visible
	to the calling assembly

	<pre></pre><b>$func</b> is the directive at the head
	of a function macro

	<pre></pre>a function macro is a macro which returns a value
	at assembly time. Other kinds of macros generate code

	<pre></pre>the returned value is accessed in this case with the 	label <b>@</b>

	<pre></pre>functional values are tokens in expressions:
	<b>44/@+1*2++018</b>

	<pre></pre><b>$return</b> is a directive which returns
	the value to its right

	<pre></pre>the value in this case is the current state
	of a location counter

	<pre></pre>here, the returned value is location counter one.
	In the supplied definition 8051.def, <b>$(1)</b> counts
	the locations filled by variables. <b>$</b> is a masmx internal
	function name, meaning "location counter."

	<pre></pre><b>$end</b> ends any macro started with
	<b>$func</b> or <b>$proc</b>. 

	<pre></pre><b>$end</b> outside a macro ends the assembly.

	<pre></pre>the result size of a user-written function macro
	is 192 bits


</ul>

<p>
Here are a couple of assemblies which use function macro "@"
<pre>

MASMX/24592 1r1X
@.msm 5
CONT_CHAR=
LTERM=;
QDELIM='
STERM=.
*EOF*  :                        620:         $list   2
  :                        621: @*      $func
  :                        622:         $note   You Said @ so I think you mean the
  :                        623:         $note   location counter for variables
  :                        624:         $return $(1)
  :                        625:         $end
  :                        692:         $list   2   
  :                        693: $(1:1024)
  :                        2: 
  :                        3: first_buffer VAR        2048
Note: @.msm Line 4: You Said @ so I think you mean the
Note: @.msm Line 4: location counter for variables
00:0000 0C63          +4         +       @+99
*EOF*:$(00):0000:0002 :$(01):0400:0C00 
Object Code 58 Bytes: 0 Errors: 0 Undefined Labels

</pre>
<p>
Notice also the way you do integer constants in masmx:
<pre>

	+	value

</pre>
<p>
However you may need to generate little-endian.

<p>
masmx generates big-endian number values. Pseudo-instructions which
little-endian assemblers have for constant-generation (DW, DD etc)
are implemented as macros for masmx.

<p>
For example, 8051 developers are used to a pseudo-directive <b>DW</b>
from other assemblers.

<p>
That <b>DW</b> generates 16-bits little-endian. So we implement <b>DW</b>
here to do the same thing:
<pre>


MASMX/24592 1r1X
@.msm 5
CONT_CHAR=
LTERM=;
QDELIM='
STERM=.
*EOF*  :                        72:         $list   2
  :                        73: dw*     $proc
  :			   74: ?       $do dw(1), +  dw(1,?), dw(1,?)/*8:d  
  :                        75:         $note   You like to be in Little End Land?
  :                        76:         $note   Here you am!
  :                        77:         $end
  
  :                        624:         $list   2
  :                        625: @*      $func
  :                        626:         $note   You Said @ so I think you mean the
  :                        627:         $note   location counter for variables
  :                        628:         $return $(1)
  :                        629:         $end
  
  :                        696:         $list   2   
  :                        697: $(1:1024)
  :                        2: 
  :                        3: first_buffer VAR        2048

Note: @.msm Line 4: You Said @ so I think you mean the
Note: @.msm Line 4: location counter for variables
Note: @.msm Line 4: You like to be in Little End Land?
Note: @.msm Line 4: Here you am!
00:0000 630C          +4         dw      @+99
*EOF*:$(00):0000:0002 :$(01):0400:0C00 
Object Code 58 Bytes: 0 Errors: 0 Undefined Labels

</pre>
<p>
That is an example of a user written function ("@") used as
an token in an expression. Plus an example of a user-written
procedural macro, "DW".

<p>
A procedural macro generates code and runs from the
directive $PROC to the directive $END

<p>
A function macro returns a value to an expression and runs from
the directive $FUNC to the directive $END

<p>
The "DW" macro contains (apart from $note directives) these lines:
<pre>

dw*     $proc  
?       $do     dw(1),  +       dw(1, ?), dw(1, ?)/*8:d
        $end 

</pre>
<p>
To explain the <b>DW</b> macro
<ul>

	<b>dw</b> is a label like other labels. It's the label of the macro
<pre></pre>
	<b>dw*</b> has an asterisk to make it visible to the calling
	assembly
<pre></pre>
	<b>$proc</b> is the directive at the start of a
	code-producing macro
<pre></pre>
	the application writer may string <b>dw</b> values on a
	line, with a syntax:
<pre>

		dw	144, labelname, 15*90

</pre>
	therefore the the macro uses a <b>$do</b> directive, and
	uses a tag <b>?</b> on the <b>$do</b> to index into
	the actual arguments
<pre></pre>
	<b>?</b> is a label like any other. Its choice is arbitrary.
	<b>?</b> has no asterisk, so it only exists while the macro
	<b>dw</b> is subassembling.

<pre></pre>
	The label of a <b>$DO</b>, here <b>?</b>, is an incrementing tag.
	It starts from 1 and goes up.
<pre></pre>
	<b>dw(1)</b> is the number of comma-separated
	subfields in the first argumentof <b>dw</b>. It's the repeat
	count. Here its value is one for the one actual parameter
	<b>@+99</b>
<pre></pre>
	the repeat count after any <b>$do</b>, here <b>dw(1)</b>,
	is followed by
	a comma. The rest of the line is a line of assembly code which
	gets repeated. This line usually contains some parameterised
	values.
<pre></pre>
	In the <b>dw</b> macro, the inner line of assembly code is
<pre>

		+       dw(1, ?), dw(1, ?)/*8:d

</pre>
        here this line is assembled once only, for the one actual
	parameter <b>@+99</b>
<pre></pre>
	The parameter paraform 
<pre>
		dw(1, ?)
</pre>
	is field 1, subfield [?] of macro <b>dw</b>. It's referenced twice
	per actual parameter.
<pre></pre>
	The command code of <b>+</b> means a number constant.
	<b>-</b> or <b>^</b> (1s complement) also work as number
	constant commands
<pre></pre>
	Where masmx source has something like
<pre>

		+	expression, expression

</pre>

	or
<pre>
		+	expression, expression, expression:q

</pre>
	That means put values in equal-size fields of a word or multiword.
<pre></pre>
	Supplied definition <b>8051.def</b> has 8 bits for word size.
<pre></pre>
	This line
<pre>

		+	dw(1, ?), dw(1, ?)/*8:d

</pre>
	Ends <b>:d</b> for double, so 16-bits total.
<pre></pre>
	And has one comma, so two 8-bit fields.
<pre></pre>
	The expression on the left, <b>dw(1, ?)</b> places the actual
	parameter value in the left eight bits. Truncation makes that
	the LSB.
<pre></pre>
	The expression on the right, <b>dw(1, ?)/*8</b> shifts the actual
	parameter value eight bits right,  and places that in the right
	eight bits. The shift makes this the MSB of the value.
<pre></pre>
	<b>$end</b> directive ends the macro
</ul>


<h3>1.2.2: Number String Notations</h3>


<p>
Number string notation varies between assemblers. masmx can be 
set to understand number notations different from its own defaults.

<p>
Native masmx interprets number strings with leading zero as hex or
sometimes octal. Leading digit 1..9 means decimal.

<p>
Thus 1000 and 03e8 both mean one thousand.

<p>
With Assembly Flag <b>-c</b> 1000 and 0x3e8 both mean one thousand.

<p>
The definition "8051.def" sets the number syntax to Intel style
suffixed expressions like 03e8h and 001111101000B.

<p>
masmx's syntax-interpreting features are described in detail 
in Section 6.1: Establishing Your Syntax. 



<h3>1.2.3: A Complete Aside about Repeat Data</h3>


<p>
<b>$DO</b> directive can be used to generate structured name spaces.

<p>
In the 8051 <b>DW</b> example, there isn't a label on the inner line
<pre>

	+       dw(1, ?), dw(1, ?)/*8:d

</pre>
<p>
which is the part which finally generates something.

<p>
If there were a label on the generated line, the whole <b>$DO</b>
line would be something like:
<pre>
	
?	$do	dw(1),<b>label(?)</b>	  +	dw(1, ?), dw(1, ?)/*8:d

</pre>
<p>
with the label after the repeat count and comma.

<p>
The ascending value of repeat tag <b>?</b> is used to generate
new labels <b>label(1) label(2)...</b>

<p>
This way of making new label names can be also be used hierarchically
to construct complex data. See Section 7: Iterated Code and Structured Data


<h2>1.3: masmx is for Any Word Size</h2>


<p>
Integer and floating constants, and fields of instructions and other 
constructed things like descriptors, are computed to 192-bit precision.

<p>
The target computer word can be any size up to 192 bits.

<p>
Integers, floating items and instructions can be multiple words up to 192
bits total.


<p>
<h2>1.4: masmx is for Any Address Space</h2>

<p>
masmx can construct absolute arrays and instruction segments to fit
in address spaces up to 2*/192 bits.

<p>
Relocatable code for linkers and linking loaders
only gets 32-bit or 4-gigaquanta addressing per segment.

<p>
However the output from a masmx link may be in space up to 2*/192 bits.

<p>
Previously assembled absolute object code in address spaces up to
2*/192 bits may be incremented with new code which is either
relocatable or source.

<p>
A masmx link is an assembly which uses masmx linker features.
Text-encoded-binary <b>.txo</b> files and macro language to
organise and modify the binary code are included.
See section <b>9.2.2: masmx Linking in Principle</b>

<p>
Base-displacement addressing modes are supported for
accessing data constructed beyond the direct-address
space of instruction sets. Even for 32-bit PowerPC, 
that's a normal way of addressing static or .BSS

<p>
Many architectures rely entirely on the base-displacement principle
to address anything at all.

<p>
Data constructed at locations in 64-bit or 128-bit or 192-bit memory
or any other address space size up to 192 bits
can also be mapped on to base-displacement segments.

<p>
masmx can construct label structures and prepare code for
loading and accessing at astronomic addresses.

<p>
The giant-address ability can be used combined with the assembly-time
repeat compute abilities in masmx.

<p>
The memory space in the program may be larger than any fixed file systems.

<p>
However the distribution of loaded code may be sparse within
the large memory, so that the assembly output file does not take as much
space as the running program.

<p>
See Section 9: Output File Formats, Relocation and Linking,
Giant Address Spaces, Interfacing with GNU Tools, and Section 4.1.2.1:
Describing Address Spaces. Location Counter Controls.


<h2>1.5: masmx is for Any Floating Point Format</h2>


<h3>1.5.1: IEEE754 Formats</h3>


<p>
masmx evaluates floating numbers in a 192-bit format
with 23-bit exponent and 168-bit fractional mantissa, 
and supports transformations into the target format.

<p>
The default masmx floating number is the the 192-bit
value rounded to 96 bits with 23-bit midpointed exponent
and 72-bit mantissa.

<p>
The width and exponent-width of a floating item output in masmx default
format can be adjusted with the directives
<pre>

	$FLOATING_POINT

	$CHARACTERISTIC


</pre>
<p>
but the structure
<pre>

	mid-point-exponent/normalised-fractional-mantissa/1s-complement

</pre>
<p>
is only changed with macro language

<p>
This package contains macros for assembling 128-bit,  64- and 32-bit
IEEE754 floating constants.

<p>
Macros use the directive <b>$set</b> to cache floating numbers as label
values for manipulation

<p>
The masmx abstract format is:
<ul>

	a fraction-only 168-bit precision mantissa,
	normalising bit is represented, immediately
	to the right of the binary point
<pre></pre>
	a mid-pointed 23-bit exponent
<pre></pre>
	the entire item is 1s-complemented for negative polarity:
	sign bit = 1 indicates that all of the bits are inverted
<pre>

	__________________________________________________________________
	|s|190 exponent 168|167          mantissa                       0|
	|_|________________|_____________________________________________|

</pre>
</ul>
<p>
IEEE754 32-bit, 64-bit, and 128-bit floating formats have
<ul>

	an integral mantissa part one bit in size which is not
	represented. The encoded mantissa field starts with the
	first fractional bit. The normalising bit is the absent
	integral bit which has the imputed value 1.
<pre></pre>
	a biased exponent 8, 11 or 15 bits in size
<pre></pre>
	a sign bit which determines the polarity of the number.
	The remaining bits are not inverted with negative polarity.
<pre>

	_____________________________________
	|s|exponent|mantissa fractional part|
	|_|________|________________________|
	          ^
	         |1| <- the unrepresented normalising integral bit

</pre>
</ul>
<p>
For a given scale the IEEE754 biased exponent is 2 less than the
masmx abstract format mid-pointed exponent.

<p>
For the value 1.75 the masmx abstract format places the true fraction
of 1110000000... at the top of the mantissa field, at the
immediate right of the binary point, and sets the exponent at one
greater than the mid-point, indicating that the integral value is
obtained by hauling the mantissa one bit position upwards through
the binary point:
<pre>

	The masmx Abstract Format
	_____________________________________________________________
	|s| 100 0000 0000 0000 0000 0001 | 1110 0000 0000 0000 ......
	|_|______________________________|___________________________

</pre>
<p>
In the IEEE754 32-bit, 64-bit and 128-bit formats, 1.75 has a biased
exponent one less than the mid point:
<pre>

	The IEEE754 64-bit Format
	___________________________________________________________
	|s| 011 1111 1111 | 1100 0000 0000 0000 0000...............
	|_|_______________|________________________________________
	                ^
	               |1| <- the unrepresented normalising integral bit


</pre>
<p>
And these differences can be seen in the following interactive assembly.
The first generated value is the masmx default, the second ieee754:
<pre>

MASMX 7r2
0/-INPUT>>
        $list   0
        $word   32
        $include        "ieee754.def"
        $list   2
        +               1.75
        ieee754_64      1.75
        $end
  :                            41         $list   2
00:00000000 400001E00000000000000000
                              +42         +               1.75
00:00000003 3FFC000000000000  +43         ieee754_64      1.75
  :                            44         $end
:$(00):00000000:00000005 
-INPUT>>: object code 87 bytes: 0 errors: 0 undefined labels


</pre>
<h3>1.5.2 IEEE754, Note on Use of Macro Language</h3>

<p>
The macro language for generating IEEE754 floating values is shown here.

<p>
These macros can be a guide for implementing any other floating
format transformations:
<pre>

	$floating_point	192
	$characteristic	24

fieee754_32 $form 1, 8, 23
fieee754_64 $form 1, 11, 52
fieee754_128 $form 1, 15, 112

p       $proc
ieee754_32* $name 0

tag     $set	 p(1,1)
sign    $set    tag/*191
        
        $if     sign
tag     $set    ^tag        
        $endif

characteristic $set (((tag/*183)**128)++((tag/*168)**127))-2
mantissa $set   ((tag**(1*/168)-1)+(7*/141))/*144

	$nop	adjust any rounding outflow
	$nop	indicated by a 25th bit

	$if	mantissa**1*/24
mantissa $set	mantissa/*1
characteristic $set characteristic+1
	$endif

        $nop	bits 166..144 -> bits 22..0. Normalising Bit 167 truncated
        
        fieee754_32 sign, characteristic, mantissa 
        $end


p       $proc
ieee754_64* $name 0

tag     $set	p(1,1)
sign    $set    tag/*191
        
        $if     sign
tag     $set    ^tag        
        $endif

characteristic $set (((tag/*180)**1024)++((tag/*168)**1023))-2
mantissa $set   ((tag**(1*/168)-1)+(7*/112))/*115

	$nop	adjust any rounding outflow
	$nop	indicated by a 54th bit

	$if	mantissa**(1*/53)
mantissa $set	mantissa/*1
characteristic $set characteristic+1
	$endif

        $nop	bits 166..115 -> bits 51..0. Normalising Bit 167 truncated
        
        fieee754_64 sign, characteristic, mantissa 
        $end

p	$proc
ieee754_128* $name

tag	$set	p(1, 1)
sign	$set	tag/*191

	$do	sign,tag	$set	^tag

characteristic $set (((tag/*176)**16384)++((tag/*168**16383))-2
mantissa $set	((tag**(1*/168)-1)+(7*/52))/*55

	$nop	adjust any rounding outflow
	$nop	indicated by a 114th bit

	$if	mantissa**(1*/113)
mantissa $set	mantissa/*1
characteristic $set characteristic+1
	$endif

	$nop	bits 166..55 -> bits 111.0 Normalising bit 167 truncated

	fieee754_128	sign, characteristic, mantissa
	$end


</pre>

<p>
IEEE754 format floating numbers are supported on many
architectures as well as matching XDR layout.

<p>
The <b>$nop</b> directive has been used to comment the macro code.
This is because the macros may be included in many different
assemblies with different comment characters, <b># ; .</b>

<p>
<b>$floating_point</b> and <b>$characteristic</b> directives set the maximum range
and precision. The transient value is 192 bits in size

<p>
The directive <b>$set</b> caches the value of the floating argument
in the label <b>tag</b>

<p>
<b>tag</b> may contain a 1s-complement value. If it does,
it's inverted after <b>sign</b> is isolated and evaluated.
That's because IEEE754 formats only invert the sign bit for
negative polarity, not the whole number.

<p>
The labels <b>characteristic</b> and <b>mantissa</b> cache manipulated
fields from <b>tag</b>

<p>
<b>sign</b>, <b>characteristic</b> and <b>mantissa</b> are output under
control of the form-template <b>fieee754_32</b>, <b>fieee754_64</b>
or <b>fieee754_128</b>

<p>
These three form-templates are defined with the <b>$FORM</b> directive.

<p>
The <b>$FORM</b> directive drives instruction layouts and other small structures.
<pre>

fieee754_32	$form	1, 8, 23

</pre>
<p>
causes the "instruction" <b>fieee754_32</b> to construct its arguments in
this layout:
<pre>

	________________________________________________
	| x | xxxx xxxx | xxx xxxx xxxx xxxx xxxx xxxx |
	|___|___________|______________________________|
         31   30     23   22                         0

</pre>
<p>
the 64-bit layout:
<pre>

fieee754_64	$form	1, 11, 52

</pre>
<p>
causes the "instruction" <b>fieee754_64</b> to construct its arguments in
this layout:
<pre>

	____________________________________________________    _______
	| x | xxx xxxx xxxx | xxxx xxxx xxxx xxxx xxxx xxxx .... xxxx |
	|___|_______________|_______________________________    ______|
	 63   62         52   51                                     0


</pre>
<p>
and the 128-bit layout:
<pre>

fieee754_128	$form	1, 15, 112

</pre>
<p>
causes the "instruction" <b>fieee754_128</b> to construct its arguments in
this layout:
<pre>

	____________________________________________________    _______
	| x | xxx xxxx xxxx xxxx | xxxx xxxx xxxx xxxx xxxx .... xxxx |
	|___|____________________|__________________________    ______|
	 127  126            112   111                               0


</pre>
<p>
The labels tag, sign, characteristic and mantissa aren't promoted with
any trailing asterisk, so they only exist during the subassembly of
the macro.

<p>
All the macros shown are called "p". They don't have to be.

<p>
But the parameters are referenced by the macro name:

<p>
macro_name(x,y)

<p>
for example in the macros shown,  p(1,1)

<p>
Giving many macros the same $PROC or $FUNC label means that blocks of
macro language can be cut-and-pasted between different macros.

<p>
In this example the label "p" isn't available for calling. Only labels
with asterisk* at the end can be seen outside the macro they are in.

<p>
The trailing asterisk on ieee754_32* ieee754_64* and ieee754_128* make
those names visible as macros. They're the labels on the $name lines

<p>
An asterisk on the label of the $proc line would make that label visible:
<pre>

unique_macro_name*	$proc

</pre>
<p>
Then unique_macro_name must be unique. See Section 6.2.2.2: The $PROC 
Header

<p>
Macros with non-unique labels are called by the labels on the $NAME lines,
and these names are visible* and unique*.

<p>
The label on $PROC, $NAME or $FUNC is only visible for calling outside
the macro if the LABEL* has an asterisk after it.

<p>
There is a layout directive $FORM and code-generating macros
run from $PROC to $END. That's the essence of masmx.

<p>
Macros can all have the same label on the $PROC line to make them easy 
to write. Then they must have unique names on the $NAME line
to make them possible to call:
<pre>


$ masmx ieeef -ln
MASMX 7r2
3/ieeef.msm
*EOF*
  :                            1         $word   32
  :                            2:         $include "ieee754.def"
  :                            3 
00:00000000 3FE00000          +4         ieee754_32      1.75
00:00000001 BFE00000          +5         ieee754_32      -1.75
00:00000002 01B45BD15F9FB3FB  +6         ieee754_64      1.9e-300
00:00000004 3FEFFFFFFFFFFFFE  +7         ieee754_64      0.9999999999999997779553950749686919152736663818359375
  :                            8 
00:00000006 7FFFA000000000000000000000000000
                              +9 	ieee754_128	1.625
00:0000000A 4530893B3F9CA1B98E9D33873CAF6153
                              +10 	ieee754_128	1.8e400
*EOF*
:$(00):00000000:0000000E 
ieeef.msm: object code 163 bytes: 0 errors: 0 undefined labels


</pre>
<h1>2: masmx is hosted on</h1>


<h2>2.1:	Proprietary Unix Platforms</h2>


<h4>2.1.1:		Mac OS X / PowerPC G4</h4>

<h4>2.1.2:		Mac OS X / ix86</h4>

<h4>2.1.3:		Sun Sparc Solaris</h4>



<h2>2.2:	Linux Platforms</h2>

<h4>2.2.1:		UBUNTU Linux ix86</h4>
<h4>2.2.2:		DEBIAN Linux ix86</h4>


<h2>2.3:	Microsoft Platforms</h2>


<h4>2.3.1:		MS DOS</h4>

<h4>2.3.2:		MS Windows</h4>


<p>
This package includes executables and associated utilities for each.

<p>
In OS X, Solaris and Linux, you click Terminal and talk to the Unix shell.

In DOS or Windows you talk to the command line.




<h1>3: Getting Started</h1>

<h2>3.1: The Command Line for all Developer Platforms</h2>
<pre>

Prompt% masmx [-fLAGS] [inputfile[.msm]] [-FL] [outputfile[.txo]] [-FlAgS]

</pre>
<p>
The input file extension must be supplied if it is not .msm

<p>
The output file extension must be supplied if it is not .txo

<p>
For example
<pre>

PROMPT\>masmx in out -ulyke

</pre>
<p>
will read in.msm and write out.txo. The flags are case significant 
and -ulyke selects: 
<ul>
	-u&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp all labels must be resolved 
<pre></pre>	
	-l&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp List the main file and generated code 
<pre></pre>	
	-y&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp sort the label list
<pre></pre>
	-k&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp labels are case-significant
<pre></pre>
	-e&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp list the generated code word-space_word
<pre>
			736f2069 74206973       "so it is"
</pre>
		instead of streamed per source line
<pre>
			736f206974206973        "so it is"
</pre>
		(in this assembly the size of word is 32 bits)

</ul>
<p>
The banner of flag letters is optional, is anywhere on the
command line, may be present several times, and begins - (minus)
for all developer platforms:
<pre>

prompt% masmx -flAgs source -mOrE objfilename -pq

</pre>
<p>
The one-letter case-significant flags can be -sTuCk -TogethER -o -R -nOt

<p>
The filename arguments are positional.

<p>
The input filename is the first argument that doesn't start -minus.

<p>
The output filename is the second argument that doesn't start -minus.
	
<p>
The default extension for the source file name is .msm

<p>
The default extension for the output file name is .txo

<p>
These name extensions are applied where the filename contains no period.

<p>
If the second filename is not given, the output is temp.txo

<p>
If the first filename is not given, the assembler prompts for
interactive input. If a filename is at this point remembered, it
can be given as an include file:
<pre>

	$include	"file.name"
	$end

</pre>
<p>
The filename may be in quotes but need not be. When comment character
is the default period, it does not terminate the line if a nonspace
token <b>follows.it</b> immediately. This allows floating point expressions
and filenames:
<pre>

	$include	file.name

	+	1.625
	+	1.79*-200

. comment line

</pre>
<p>
$include default filename extension is for source files .msm

<p>
Therefore
<pre>

	$include	afile

</pre>
<p>
will read afile.msm

<p>
The filename must otherwise be given exactly and in full.

<p>
This interactive technique can be used, for example, to assemble with
temporarily changed list nesting depth controls:
<pre>

prompt% masmx -lpq
	$plist		5	. show deeply nested macro expansion
				. when option flags -pq are on
	$include	"file.name"
	$end

</pre>
<p>
A source file called temp.msm also results from this interactive method.

<p>
Minimal assemblies can be carried out without any input files:
<pre>

prompt% masmx -l
MASMX 7r2
0/-INPUT>>
        $word   32     
        $quantum 8
        +       10*/180
        +       1.75
        $end
  :                            1  $word 32
  :                            2  $quantum 8
00:00000000 00A000000000000000000000000000000000000000000000
                              +3  + 10*/180
00:00000018 400001E00000000000000000
                              +4  + 1.75
:$(00):00000000:00000024 
-INPUT>>: object code 119 bytes: 0 errors: 0 undefined labels

</pre>
<p>
The results shown here are an integer containing the value ten
shifted left 180 bits; and 1.75 in the masmx default floating
representation. Targets having other floating formats use
floating-constant pseudo-directives implemented as macros.

<p>
The summary output for locator zero shows that code is generated in 36
address locations. In this assembly those locations are 8-bit bytes.

<p>
The stuff about 119 bytes is the output file size, not the output code
size.

<p>
The next examples assemble an application called fastpass:
<pre>

Prompt% masmx fastpass.asm -u

</pre>
<p>
masmx reads fastpass.asm and writes temp.txo. 

<p>
Whatever the output name, fastpass is 8051 and the 
target machine wants Intel hex records, so you follow up:
<pre>

Prompt% imx temp.txo florida.hex

</pre>
<p>
or for example
<pre>

Prompt% masmx fastpass.asm today -u
Prompt% imx today.txo fastpass.hex

</pre>
<p>
imx utility does nothing clever with filename extensions. 
They are typed exactly and in full. There are no flags or 
options. The similar utility for Motorola S-records (32-bit address)
is mmx. See Section 9: Output File Formats, Relocation and Linking,
Giant Address Spaces, Interfacing with GNU Tools.

<p>
These steps are an assembly and a format conversion. 

<p>
The application called fastpass is assembled absolute. There is no link.
 
<p>
That's why <b>-u</b> is there. <b>-u</b> treats unresolved labels as 
an error. But you don't have to keep saying <b>-u</b> because 
the 8051 definition header says
<pre>

	$set_option     "u"

</pre>
<h2>3.2: Command Line Options</h2>
<p>
The full set of masmx command line options are
<pre>
	-a	allow automatic literals

		a literal is a storage constant which is
		generated in response to being referenced
		as an operand

		automatic literals are generated when an
		(operand) is entirely in parentheses. There may
		be a prefixed unary asterisk *(on the literal)

		unary operator +(operand) makes the operand
		an expression and not a literal. Therefore if
		-a flag is set and a non-literal expression starting
		(in parentheses) is needed, code a sign +(first)

		Default behaviour (not flag -a) only generates a
		literal when a literal pool tag is referenced outside
		the literal:
 
		literal_pool_tag(the_literal)

		-see section 5.2: Literals

	-b	linker option: collate all input files by segment

	-c      C language hex and octal Notation
		C Language \escape sequences in strings
		aligned strings zero padded. See also -z option

                standard masmx behaviour so interprets number
		expressions in source code that leading zero means
		hex and any other leading digit means decimal.

		If $OCTAL directive is issued leading zero means
		instead octal, until $HEX directive is issued.

		Thus by default

		1000 and 03e8 both mean one thousand

		However with -c flag the hex expression is 0x3e8

		See also -m flag which may be asserted as well

		-c flag enables C-Language \escape sequences in
		quoted strings

		-c flag pads aligned quoted strings with zero.
		Default behaviour is space fill. See also -z option

	-d	list addresses including segment or offset information

		of meaning when a breakpoint addresses are encoded
		after start_addresses in a location counter declaration:

		$(67:base_address:breakpoint)

		-see Section 4.1.2.1:	Location Counter Controls

		-see Section 9.1:	Text-Encoded Binary Format

		-see also -v flag

	-e      list generated code in one-word fields

		This makes the ouput readable when the target
		machine word size does not fit an exact number
		of hex or octal symbols

	-f	flag certain errors in the second assembly pass
		instead of in the first pass. This allows a listing
		to be generated

	-g	flag certain errors in the first assembly pass instead
		of in the second pass. This prevents unnecessary
		processing

	-h	stop after the first assembly pass

		-see also option -s


	-i      sign extended addressing

		The intra-segment part of addresses in masmx is
		by default unsigned.

		The intra-segment address is the part maintained
		in location counters, which can attain a maximum
		range of 4 gigaquanta without breakpointing.

		Larger structures up to 2 power 192
		(4 giga-tera-tera-tera-teraquanta) are constructed
		as multi-part or breakpointed sections.

		Therefore the inclusion of a location-counter or of the 
		address part of $EQUF value in a 192-bit expression:

		TUPLE	$EQUF	3072, R9, LEFT_HALF

		REFERENCE_POINT $SET	00003FFC000A0000+TUPLE

		results, without -i Flag, in the up-to-32-bit part
		getting added with leading-zero to the 192 bit part:


		192                                              0
		__________________________________________________
		|	          big base address               |
		|________________________________________________|
		|                 zero		|  intraseg addr |
		|_______________________________|________________|
					      32 31

		With -i Flag bit 31 of the 32-bit part is extended
		for the add:


		192                                              0
		__________________________________________________
		|	          big base address               |
		|________________________________________________|
		|                 signs		|+-intraseg addr |
		|_______________________________|________________|
					      32 31



	-j      has meaning when using masmx as a cumulative linker:

                When external labels are found but still relocatable,
                -j option causes references to them to remain
		outstanding, i.e. resolution of the name itself
		is requested again in subsequent links.

		Default behaviour replaces the label reference with
		a reference to offset+locator. The offset will later
		be summed with the new file segment base per this locator.

		-see section 8.25.2:	$include,$binary

		-see section 9: 	Output File Formats
					Relocation and Linking
    					Giant Address Spaces
					Interfacing with GNU Tools

	
	-k      labels are case-significant

	-l      list source and assembly when the $LIST setting is 
		higher than the current include nesting depth

	-m      Motorola Hex, Octal and Bit Notation

		-m flag is for	$hex
				@octal
				%bit-pattern

		Labels beginning $ and @ are then only
		recognised if they are in quotes "$xxx", except:

		$xxx @xxx names in the command field are recognised
		without quotes

		-m does not switch off other number notations
		guided by the $hex and $octal directives and the
		C-Syntax flag -c

                standard masmx behaviour so interprets number
		expressions in source code that leading zero means
		hex and any other leading digit means decimal.

		If $OCTAL directive is issued leading zero means
		instead octal, until $HEX directive is issued.

		Thus by default

		1000 and 03e8 both mean one thousand

		However with -m flag $3e8 also gives the value 1000.

		See also -c flag which may be asserted as well.

		If -m flag is asserted and not -c, then 03e8 and $3e8
		both mean a thousand.

		If -cm flags are asserted, 0x3e8 and $3e8 both mean 1000.

	-n	list relocation information when listing with option -l

	-o      force filenames to lowercase. This can avoid problems when
		large numbers of output files are checked using Unix tools.
		
	-p      List $PROC Text on Expansion when the $PLIST setting is
		higher than the current macro subassembly nesting depth

		-see Section 8.38: $PLIST Directive 

		-see Section 8.47.1:	Interaction of Run Options
					and List Directives

	        -also list macro text when listing labels

		-see option flags -xy

		-see Section 8.48: $SNAP directive 

	-q      List $FUNC Text on Expansion when the $PLIST setting is
		higher than the current macro subassembly nesting depth

		-see Section 8.38: $PLIST Directive 

		-see Section 8.47.1:	Interaction of Run Options
					and List Directives

	        -also list macro text when listing labels

		-see option flags -xy

		-see Section 8.48: $SNAP directive 

	-r	list $PROC or $FUNC text expansion during the first
		assembly pass when the $PLIST setting is
		higher than the current macro subassembly nesting depth

	        -also list macro text when listing labels

		-see option flags -xy

		-see Section 8.48: $SNAP directive 

	-s      Generate a source file with all text translations
		applied during the first assembly pass.

		Directly and indirectly included text is inlined.

		This output source file is called temp.msm

		This is the default behaviour when no
		input file is named on the command line.

		temp.msm is then read in the second assembly pass.

		-see Section 8.52: $TEXT translation directive

	-u      Treat unresolved labels as errors. 
		Otherwise information requesting linker
		resolution is placed in the output file.

		-see section 9: 	Output File Formats
					Relocation and Linking
    					Giant Address Spaces
					Interfacing with GNU Tools

	
	-v	of meaning when a breakpoint addresses are encoded
		after start_addresses in a location counter declaration:

		$(67:base_address:breakpoint)

		-v option causes the location counter breakpoint value
		to be written as a segment_index in the load-address
		clauses of the text-encoded binary output.

		Default behaviour is to compute load addresses
		from logical address + breakpoint address - base_address.

		(i.e. to apply absolute segment relocation
		at assembly time)

		-see Section 4.1.2.1:	Location Counter Controls

		-see section 9: 	Output File Formats
					Relocation and Linking
    					Giant Address Spaces
					Interfacing with GNU Tools
	
		-see also -d flag

	-w	silent assembly, unless there are diagnostics.
		Default behaviour is to list summary information	

	-x      List Labels at the end of the assembly.

		-see Section 8.48: $SNAP directive
		-see Section 8.28: $LIST directive
				   $list 0, masking names from list/export

	-y       Sort the label list.

		-see Section 8.48: $SNAP directive
		-see Section 8.28: $LIST directive
				   $list 0, masking names from list/export

	-z	Pad aligned quoted strings with zero.
		Default behaviour is to space fill.

		-c option also pads quoted strings with
		zero instead of space, but -zc combined
		pads quoted strings with space

		These four assemblies show the effects
		of -zc options in data word padding


		$ masmx a1 -ln
		MASMX 7r2
		3/a1.msm
*EOF*
  :                            1 	$word	32
  :                            2 	$quantum 8
00:00000000 61312020          +3 	"a1"
*EOF*
:$(00):00000000:00000004 
a1.msm: object code 54 bytes: 0 errors: 0 undefined labels

		$ masmx a1 -lnz
		MASMX 7r2
		3/a1.msm
		*EOF*
  :                            1 	$word	32
  :                            2 	$quantum 8
00:00000000 61310000          +3 	"a1"
*EOF*
:$(00):00000000:00000004 
a1.msm: object code 54 bytes: 0 errors: 0 undefined labels

		$ masmx a1 -lnc
		MASMX 7r2
		3/a1.msm
		*EOF*
  :                            1 	$word	32
  :                            2 	$quantum 8
00:00000000 61310000          +3 	"a1"
*EOF*
:$(00):00000000:00000004 
a1.msm: object code 54 bytes: 0 errors: 0 undefined labels

		$ masmx a1 -lncz
		MASMX 7r2
		3/a1.msm
		*EOF*
  :                            1 	$word	32
  :                            2 	$quantum 8
00:00000000 61312020          +3 	"a1"
*EOF*
:$(00):00000000:00000004 
a1.msm: object code 54 bytes: 0 errors: 0 undefined labels

	-E	accept new equation of a label which is already
		equated ($equ directive), with a warning diagnostic

		default behaviour retains the first and discards
		the new value with a warning diagnostic

		$set directive restates labels without restriction


	-F	floating point rounding guard pattern is 110
		instead of 111

	-G	floating point rounding guard pattern is 101
		instead of 111

		the mantissa is always generated longer than
		it is stored. The guard pattern bits are added
		to the most significant of the truncated bits
		and may carry into the stored mantissa

		This sketch represents the mantissa before rounding
		by means of the addition of guard bits. Of course the
		mantissa may outflow as a result of rounding. In that
		case the mantissa is shifted right one position to
		normalise again and the exponent is incremented

		The representation is of a positive magnitude mantissa
		with the value 1 at the normalising position

		A mantissa of value +-zero cannot be normalised
		

		 normalising value unless the mantissa value is zero
		 ___________________________________________________
		 |
		 |    mantissa for storage        truncated part
	_ _ _ _ _._______________________________________________
	 	|1xxxxxxxxxxxxxxxxxxxxxxxxxxxxxx|yyyyyyyyyyyyyyy|
	exponent|0000000000000000000000000000000|101000000000000|+
	_ _ _ _ |_______________________________|_______________|
						 | |
						 |_|____________
						 111
						 110
						 101

						 possible values of
						 the three rounding
						 guard bits


        -Q      execute a function name encountered in an
                expression even if it is in quotes

                this concerns user-written function macross
                constructed with

                        name*   $FUNC
                                .
                                .
                                $end

                or with

                        name    $FUNC
                        name1*  $NAME
                        na...*
                                .
                                .
                                $end


                default behaviour is to execute the function
                name if it is an expression token without
                quotes, but to return an identifying
                value if the the function name is in quotes

			procedure* $proc
				.
				$do	($t(procedure(1,5))=$func);
					**(procedure(1, 5)="lolly")	;
				$note	this is lolly
				.
		
				+	procedure(1, 5)

		the first mention usually detects whether the
		parameter token is function macro called lolly

		the second mention causes lolly to happen

		with option -Q the first mention in quotes
		also causes macro lolly to happen instead of
		just identifying it

	-Z	zero fill buffers declared with $RES directive
		(section 8.43)

		without -Z option no code is loaded in
		the $RES storage area

		$RES intervals in structures generated
		as literals are always zero-filled

	-+	option flag -+ includes masmx internal names
		in label table lists

		masmx	-x+y
			$end

		lists the directive and internal function labels
		and names with fixed values

		-see Section 8.28: $LIST directive
				   $list 0, masking names from list/export


</pre>


<h1>4: The Core of masmx</h1>

<h2>4.1: The Assembly Language Source Line</h2>

<h3>4.1.1: Label, Command, Operands</h3>

<p>
The outline of most assembly language lines is:
<pre>

[label]		[command]	[argument[, argument][, argument]	[argument]	[argument]]	[. Comment]

</pre>
<p>
Special lines called location counter controls describe the
program's address geometry:
<pre>

$(location_counter_id:controls)

</pre>
<p>
The fields of normal source lines are optional. There may be several
arguments, and command and argument fields may have subfields:
<pre>

[label] COMMAND,SubCommand    ARGUMENT1_1, ARGUMENT1_2     ARGUMENT2_1,...

</pre>
<p>
The subfields can contain substrings
<pre>

[label] COMMAND      arg1_1_1:arg1_1_2, arg_1_2_1:arg_1_2_2,...

</pre>
<p>
In the following line
<pre>

	add,carefully   this,probably to that,definitely:i:think

</pre>
<p>
Case-significant is not switched.

<p>
ADD is the command, and is subfield 1 of field 0

<p>
Subfield 0 and subfield 1 are the same, so ADD is 0,0 or 0,1.

<p>
CAREFULLY is subfield 2 of field 0.

<p>
THIS is subfield 1 of field 1
<p>
PROBABLY is subfield 2 of field 1

<p>
TO is subfield 1 of field 2

<p>
THAT is subfield 1 of field 3

<p>
DEFINITELY is substring 1 of subfield 2 of field 3 
<p>
I is substring 2 of subfield 2 of field 3 
<p>
THINK is substring 3 of subfield 2 of field 3

<p>
The substring separator show here is the default : colon. It can
be changed with the $STERM directive. The substring separator most
commonly in use is . period. Substring separator does not always
separate anything. It only does, if that's what macro language is
looking for, or in a complex text string, or a structured name space.

<p>
Otherwise substring separator can be a character in a label, as
<pre>

movem.L*	$name	OPCODE_MOVEM++WIDTH_L

</pre>
<p>
masmx is built around macros, and the fields, subfields and
substrings on a line are retrievable in macro expansion.

<p>
* and # flags on the front  of actual arguments can be retrieved with
the value of 1 if present, zero if absent, for example
<pre>

	move	field1, #target
	add     *field1, #value2

</pre>
<p>
The unary * and the unary # can be retrieved by the 
macros which implement "add" and "mov".

<p>
The meanings of these flags, and their encoding, are part of the target definition.

<p>
For example, * is often used to mean indirection, and # to mean immediate.


<h3>4.1.2 The Label Field</h3>

<p>
The label field starts in the first column of a source
image. It contains either
<pre>

	-white space-           
				>No Label

	-or-
	a word which looks like
$(0)

	-or like-
$(7:07800)                      >Location counter control

	
	-or a label-
A_Label                         >The tag of this location or
				a name given to a value
				or some other kind of tag

	
	-or an asterisk-
*                               >asterisk alone on the first
				column of any line in a macro
				means a label inherited from
				the macro call. This allows
				the label to be given a different
				meaning from the location at
				the point of macro call

</pre>
<p>
Most lines have the scheme
<pre>

[label]		[command]	[operand]

</pre>
<p>
and these "normal" lines are discussed further at section 4.2:
Lines of code Generally.


<h4>4.1.2.1: Describing Address Spaces: Location Counter Controls</h4>

<p>
Location counter controls are different from all other lines.

<p>
A line beginning with $ is telling masmx something 
about segments and addresses. In masmx segments are 
called location counters and there are 72 of them.

<p>
The 72 location counters may be breakpointed (restarted)
many times either to generate very large tables or to
build a complex load image.


<h4>4.1.2.1.1: Absolute Location Counters</h4>


<p>
The plainest use of location counter controls has the syntax
<pre>

$(counter_id:value)

</pre>
<p>
at the start of the assembly, and later
<pre>

$(counter_id)

</pre>
<p>
to switch between the program segments, for example, if location counter
zero has been chosen for code, and location counter one for data:
<pre>

$(0:code_start_address)

	some code

$(1:data_start_address)

	some data

$(0)

	some more code

$(1)

	some more data


</pre>
<p>
The switch $(0:0)
<pre>

$(0:0)

</pre>
<p>
means switch to location counter 0 and initialise it 
to absolute unrelocatable 0. That's the default at the
beginning of your assembly anyway.

<p>
You start the addressing for other parts of your program
<pre>

$(1:static_base_address)
$(2:strings_base_address/literal_pool_name)

</pre>
<p>
Then you switch between your locators as you need
<pre>

$(1)
structure1      structure_macro_name
buffer20        $res    20
$(0)
	load_address    r6, literal_pool_name("Long Text String":10)
	call            copy_routine

</pre>
<p>
You can give the location counters names:
<pre>

CODE    $equ    0
STATIC  $equ    1
$(CODE:0/STRING_LITERALS)
$(STATIC:32768)
$(STATIC)
buffer...
$(CODE)
Start   load... ,STRING_LITERALS("Text...
	call..
	store  ...,buffer...
$(STATIC)
another_variable..
$(CODE)
	load_address ..,another_varaiable

</pre>
<p>
The explanation of each possible field in a location counter control
is, for absolutely addressed segments:
<pre>

$(id:address:breakpoint,base_register/literal_pool_tag)

</pre>
<p>
or
<pre>

$(id:address:*breakpoint,base_register/literal_pool_tag)

</pre>
<p>
All fields except id (0..71) may be absent.

<p>
If addresses are absent
<pre>

$(id[,base_register][/literal_pool_tag])

</pre>
<p>
then addressing in this segment picks up where it last reached.

<p>
If the base register is specified, labels of locations in the
segment have a tuple base+displacement attribute.


<h4>4.1.2.1.1.1: The Breakpointed Location Counter: Hardware Segmentation</h4>


<p>
The breakpointed location counter may be used to describe the absolute
locations of hardware-relocated banks.

<p>
The simple absolute start address declaration has the syntax
<pre>

$(id:base_address)

</pre>
<p>
But the breakpointed value pointing to a hardware-relocated location
has the syntax
<pre>

$(id:logical_base_address:absolute_address)

</pre>
<p>
Load addresses are computed from breakpointed segment start plus offset
minus base.

<p>
But references are relative to the logical base only (the first address).
<pre>

$(5::SEGMENT1)
.
.
$(5::SEGMENT2)
.
.

	_________________________
	| SEGMENT1 Location 0	|
	|			|
	|			|
	|			|
	|_______________________|
	| SEGMENT2 Location 0	|
	|			|


</pre>
<p>
In this way a program in many absolute spaces may be constructed
as one load image.

<p>
The segments have to be hardware-based at run time before reference.

<p>
On simple hardware without MMU this effect is sometimes obtained
by selecting part of memory with I/O operations.

<p>
A program constructed in this way may include breakpointed parts from all
location counters. All the parts may be in one bank for loading. The
"absolute" addresses may, depending on load method, either be real target
absolute addresses or offsets in a load region selected at load time.

<p>
This example is for an architecture which has relocation bases
each corresponding to a fixed part of the program's address space, and
which allows applications to change parts of the address space while
running:
<pre>

$(0::SEGMENT1)
.
.
$(0::SEGMENT2)
.
.
$(5:5*4096:SEGMENT3)
.
.
$(4:16384:SEGMENT32)
.
$(8:32768:SEGMENT36)
.

base register 0: address space @ 0:	= absolute |SEGMENT1 |SEGMENT2|
base register 1: address space @ 4096:
base register 2: address space @ 8192:
base register 3: address space @ 12288:
base register 4: address space @ 16384:	= absolute |SEGMENT32|
base register 5: address space @ 20480:	= absolute |SEGMENT3 |
base register 6: address space @ 24576:
base register 7: address space @ 28672:
base register 8: address space @ 32768:	= absolute |SEGMENT36|
base register 9: address space @ 36864:

</pre>
<p>
In that example, the location counters have been mapped one-to-one
with the target base registers for easy reading. However, the range
of logical address space described by each location counter depends
only on the base address $(id:base_address...

<p>
Listings show the program-logical addresses. To see the absolute
addresses instead, use the <b>-d</b> flag as well as the <b>-l</b> flag


<h4>4.1.2.1.1.2: The Breakpointed Location Counter: -v Option</h4>

<p>
If <b>-v</b> option is applied, the treatment of breakpoint values is
different.

<p>
The SEGMENT value in $(id:start:SEGMENT) is not assumed to be an address
and is not added to the load addresses.

<p>
Instead, the value is prefixed before the load addresses in the
text-encoded binary output. See Section 9.1: Output File Formats

<p>
The breakpoint value may still be a hardware base address, but may instead
be another abstract, a page identifier or a segment index.

<p>
Listings show the program-logical addresses. To see the segment selectors
and offsets instead, use the <b>-d</b> flag as well as the <b>-lv</b> flags



<h4>4.1.2.1.1.3: Simple Location Counter without Breakpoint:
		 Base+Displacement in Flat Address Spaces</h4>


<p>
If the target runs with a large flat address space, or the segment is at
a high relative address in a large bank, and part of the segment is beyond
the immediate address scope of the instruction set, the developer may
cause a base register to be loaded with the a base address at run-time.

<p>
The locations in the segment are referenced as base+displacement
tuples where the displacement does not include the large load address.
But the large load address is included in the code load addresses:
<pre>

$(35:big_address_where_it_loads,r15)

</pre>
<p>
Then <b>big_address_where_it_loads</b> has to be placed in r15 at run-time.

<p>
The following assembled base-displacement example shows: 

<p>
Line 4 declares a segment which will be accessed 
using R15 as a cover or base register.

<p>
Lines 13..15 retrieve operands using R15 as a cover 
register.

<p>
It's the developer's responsibility actually to load R15 at runtime.
It's not necessary to mention R15 in the lines that reference data.
<pre>

MASMX 7r2
3/qplain.msm
LTERM=#
CONT_CHAR=|
STERM=.
  :                            1:         $include        "ppc_603.def"
  :                            2 
  :                            3 SEGMENT .equ    511*1024
  :                            4 $(48:SEGMENT,r15)
30:0007FC00 0000000000400000  +5 part1   +       2048*2048d
30:0007FC08 0000000000000064  +6 part2   +       100d
  :                            7 part3   $res    2048*2048-16
  :                            8 
30:0047FC00 0007FC10          +9 	+	.absolute(part3)
  :                            10 
  :                            11 $(0:3*65536)
00:00030000 640F0008          +12 start   oris    r15,, SEGMENT@ha     
00:00030004 39E0FC00          +13         addi    r15, SEGMENT@l 
00:00030008 806F0000          +14         lwz     r3, part1
00:0003000C 808F0008          +15         lwz     r4, part2
00:00030010 80AF0010          +16         lwz     r5, part3
00:00030014 4E800020          +17         blr
  :                            18         $end    start
:$(00):00030000:00030018 :$(30):0007FC00:0047FC04 
qplain.msm: object code 214 bytes: 0 errors: 0 undefined labels

</pre>
<h4>4.1.2.1.1.4: The Breakpointed Location Counter:
                 Base-Displacement in Translated Address Spaces</h4>

<p>
The following example has a base+displacement segment at a high
logical address which will be loaded at a different high absolute
address, i.e. a hardware relocation translate value is known at
assembly time.

<p>
The address SEGMENT must be loaded into R15 at runtime.

<p>
The physical address HARDWARE_LOADA is not visible to the code but is
used in the load strings.

<p>
It is known that hardware will translate addresses at SEGMENT to
HARDWARE_LOADA on reference.

<p>
Hardware relocation registers must be programmed to do that on load.

<p>
Multi-bank images for relocating hardware can be generated in this way.

<p>
The displacements used in operand reference do not reflect either
HARDWARE_LOADA or SEGMENT.

<p>
SEGMENT must be in R15 and the translation SEGMENT->HARDWARE_LOADA
must be in relocation registers or IO-implemented memory selectors.

<p>
The translation SEGMENT->HARDWARE_LOADA is turned on after load at
the address HARDWARE_LOADA.

<p>
The assembly is run with -D Flag to show absolute load addresses.
<pre>

MASMX 7r2
3/rplain.msm
LTERM=#
CONT_CHAR=|
STERM=.
  :                            1:         $include        "ppc_603.def"
  :                            2 
  :                            3 SEGMENT .equ    511*1024
  :                            4 HARDWARE_LOADA .equ	511*32768
  :                            5 
  :                            6 $(48:SEGMENT:HARDWARE_LOADA,r15)
30:00FF8000 0000000000400000  +7 part1   +       2048*2048d
30:00FF8008 0000000000000064  +8 part2   +       100d
  :                            9 part3   $res    2048*2048-16
  :                            10 
30:013F8000 0007FC10          +11 	+	.absolute(part3)
  :                            12 
  :                            13 $(0:3*65536)
00:00030000 640F0008          +14 start   oris    r15,, SEGMENT@ha     
00:00030004 39E0FC00          +15         addi    r15, SEGMENT@l 
00:00030008 806F0000          +16         lwz     r3, part1
00:0003000C 808F0008          +17         lwz     r4, part2
00:00030010 80AF0010          +18         lwz     r5, part3
00:00030014 4E800020          +19         blr
  :                            20         $end    start
:$(00):00030000:00030018 :$(30):0007FC00:0047FC04 
rplain.msm: object code 214 bytes: 0 errors: 0 undefined labels

</pre>
<h4>4.1.2.1.1.5: Void Segments</h4>


<p>
If the base address (VSEGMENT in the next example) is zero,
and the segment is not relocatable, and there is no breakpoint address,
and there is a base register:
<pre>

$(id:0,rX)

</pre>
<p>
then this is a Void Segment, and references resolve as displacements
within it, but code is not generated.

<p>
This addresses two cases, where 
<ul>
	The data is supplied by a calling
	routine which hands "this" routine
	a parameter address in a register
<pre></pre>
	The data is generated in a large
	array and based a part at a time 
	with a register.

</ul>
<p>
In both these cases, it is safe to place 
data-generating macros in the Void Segment. 
They will not generate data. This allows 
the same macros to be used for building an 
array and mapping part of it at different
moments with a Void Segment.
	
<p>
Macro "tree" in this example is called both in segment ARRAY
where it does generate data, and segment VSEGMENT, where it doesn't.

<p>
Both the void and the code-bearing segments are generated without
any breakpoint address here, just an address after the counter
selector: $(id:address
<pre>

MASMX 7r2
3/pusingv.msm
LTERM=#
CONT_CHAR=
STERM=.
*EOF*
  :                            1:         $include        "ppc1.def"
  :                            2         $set_option     "u"
  :                            3         $plist  8
  :                            4         
  :                            5 record* $proc        
  :                            6 *       $tree
  :                            7 h       +       record(1,1)
  :                            8 t       $res    record(1,1)
  :                            9         $root
  :                            10         .align  2
  :                            11         $end
  :                            12         
  :                            13 tree*   $proc
  :                            14 *       $tree
  :                            15 times   $do     3,dibber(times) record    tree(1,1)
  :                            16         $root
  :                            17         $end
  :                            18 
  :                            19 
  :                            20 ARRAY   $equ    262144*24
  :                            21 GRANULE $equ    22//4*4*2*3//8*8
  :                            22 
  :                            23 grains*       $proc
  :                            24       $do     index=2,        $list   0
  :                            25 $(55:ARRAY+index*GRANULE-GRANULE)
  :                            26 cluster(index)* $tree
  :                            27 times   $do     2,raddle(times)  tree 18
  :                            28         $root
  :                            29       $do     index=20000/GRANULE-1,  $list  1
  :                            30         $end
  :                            31 
37:00600000 00000012          +32 index $do     20000/GRANULE,  grains
37:00600018 00000012          +32 
37:00600030 00000012          +32 
37:00600048 00000012          +32 
37:00600060 00000012          +32 
37:00600078 00000012          +32 
37:00604D10 00000012          +32 
37:00604D28 00000012          +32 
37:00604D40 00000012          +32 
37:00604D58 00000012          +32 
37:00604D70 00000012          +32 
37:00604D88 00000012          +32 
  :                            33 
  :                            34 VSEGMENT $equ    0
  :                            35 
  :                            36 $(56:VSEGMENT,r12)
  :                            37 .this_segment $equ $(55)
38:00000000                   +38 times   $do     2,raddle(times) tree    18
38:00000018                   +38 
38:00000030                   +38 
38:00000048                   +38 
38:00000060                   +38 
38:00000078                   +38 
38:00000090                   +39 raddle2 tree    30
38:000000B4                   +39 
38:000000D8                   +39 
  :                            40 $(0:32768/.lit)
00:00008000 640C0060          +41         oris    r12,0,hi16(cluster(40).raddle(1))
00:00008004 618C15F0          +42         ori     r12,r12,lo16(cluster(40).raddle(1))
00:00008008 806C0018          +43         lwz     r3,raddle(1).dibber(2)
00:0000800C 808C0000          +44         lwz     r4,raddle(1).dibber(1)
00:00008010 80AC0078          +45         lwz     r5,raddle(2).dibber(3)
00:00008014 80CC0048          +46         lwz     r6,raddle(2)
00:00008018 80EC0090          +47         lwz     r7,raddle2
00:0000801C 616C0000          +48         mr      r11,r12
00:00008020 90EB0090          +49         stw     r7,raddle2(r11)
00:00008024 A0EB0078          +50         lhz 	r7,raddle(2).dibber(3)(r11)
00:00008028 8180802C          +51       lwz r12,.lit(cluster(20).raddle(2))
*EOF*
00:0000802c+00600AF8
:$(00):00008000:00008030 :$(37):00600000:00604DA0 :$(38):00000000:000000FC 
pusingv.msm: object code 18447 bytes: 0 errors: 0 undefined labels

</pre>
<h4>4.1.1.2.1.6: The Breakpointed Location Counter: Giant Address Spaces</h4>


<h4>4.1.1.2.1.6.1: Very Large Direct Addressed Segments</h4>

<p>
If breakpoint is prefixed with an asterisk, it is a
<b>*large_direct_base_address</b>
<pre>

$(id:address:*large_direct_base_address,base_register/literal_pool_tag)

</pre>
<p>
This *large_direct_address_base may be up to 192 bits wide, according
to the second value in the $AWIDTH declaration, for example:
<pre>

	$AWIDTH	32:128

</pre>
<p>
which can be seen in the example below:

<p>
An array spanning many times 4 gigaquanta may therefore be declared.
<pre>

	$word	32
	$quantum 8
	$byte	8
	$awidth	32:128

ARRAY		$equ	5*/96
ELEMENT_SIZE	$equ	1024*1024*1024
HOW_MANY	$equ	112000

element* $proc
*	+	subscript
	$res	ELEMENT_SIZE-4
	$end
	
newpart* $proc
$(45::*ARRAY+ELEMENT_SIZE*subscript-ELEMENT_SIZE)
	$do	subscript=4,		$list	0
part(subscript)*	element
	$do	subscript=HOW_MANY-3,	$list	1
	$end

subscript	$do	HOW_MANY,	newpart

2D:00000005000000000000000000000000:00000001      +23
2D:00000005000000000000000040000000:00000002      +23 
2D:00000005000000000000000080000000:00000003      +23 
2D:000000050000000000006D5F40000000:0001B57E      +23 
2D:000000050000000000006D5F80000000:0001B57F      +23 
2D:000000050000000000006D5FC0000000:0001B580      +23 
*EOF*
:$(2d):00000000:40000000 
Object Code 5264032 Bytes: 0 Errors: 0 Undefined Labels

</pre>
<p>
Some limitations may be encountered, and there are ways to go
beyond them.

<p>
Firstly, if you have terabillions of array elements instead of
just 112000, you could not put labels on all of them. The labels
"part(1)" thru "part(112000)" exist during the above assembly.

<p>
This is not really a restriction, because applications do not
address array elements through unique labels. They compute offsets
and add them to the table base address.

<p>
Secondly, if you generate load information for many billions of
locations in an array, you may not have a file system which can
hold the output files, unless the file system is implemented in system memory. This in turn would mean that the application is assembled
every time it's run, so it might in any case be more practical to
construct truly astronomic arrays at application run time.

<p>
masmx has a concept of a normal address space, where each location
counter addresses up to 4 gigaquanta, and a an increment of up to
192 bits which may be iteratively stepped.

<p>
The $awidth directive in the example shows an intra-segment address
space of 32 bits (4 gigabytes) and a maximum address space of 128 bits.
<pre>

	$awidth	32:128

</pre>
<p>
In the above example, location counter 45 starts at an address of
5*/96 (five times 65536 tera tera bytes) and is stepped 112000 times
by one gigabyte.

<p>
The extension value is not catenated but added, rightmost bit to
rightmost bit
<pre>
                                                   _______________
	running location counter:                  |_____________|
                                                          +
                   _______________________________________________
	step value:|_____________________________________________|

</pre>
<p>
The values which go in location labels and in load strings are the sum of
the location counter value at the point where label is declared,
plus the step value.

<p>
The address space is flat although it may be used to represent
a segmented space. Labels pointing into a giant space contain the
whole address.

<p>
See also option flag <b>-i</b>, sign extended addressing (Section 3.2: Command
Line Options).


<h4>4.1.2.1.1.6.2: Very Large Load Address Base-Displacement Examples</h4>



<h4>4.1.2.1.1.6.2.1: Giant Absolute Address Base-Displacement Example
With Static Base-Displacement Referencing</h4>

<p>
This example is described as static because the base-displacement
construct and the code-generating segment are assembled together.

<p>
Nevertheless the base register has to be loaded at runtime.

<p>
Whether ,register is given for base-displacement or not, giant
addressing is specified by a giant breakpoint flagged with *
<pre>

$(id:base:*giant_breakpoint,register[/literal_pool])

</pre>
<p>
Where ,register is also given then base-displacement label references
are generated.

<p>
giant_breakpoint is an address expression up to 192 bits wide.

<p>
displacements may only be 32 bits in size, but giant_breakpoint up to 192
bits wide may be set to new values billions of times.

<p>
Addresses progressing from base are added to giant_breakpoint
to give load addresses.

<pre>

MASMX 7r2
3/modest.msm
LTERM=#
CONT_CHAR=\
STERM=.
*EOF*
  :                            1:         $include        "ppc_64.def"
  :                            2 
  :                            3 SEGMENT $set    0x00FFFC0000000000
  :                            4 $(48::*SEGMENT,r15)
30:00FFFC0000000000:0000000000400000
                              +5 part1   +       2048*2048d
30:00FFFC0000000008:0000000000000064
                              +6 part2   +       100d
  :                            7 part3   $res    2048*2048-16
  :                            8 
  :                            9 $(0:3*65536)
00:00030000 4800000D          +10 start   bl      loaded      
00:00030004 00FFFC0000000000  +11         +       SEGMENT
00:0003000C 7DE802A6          +12 loaded  mfspr   r15, LR
00:00030010 E9EF0000          +13         ld      r15,,r15
00:00030014 E86F0000          +14         ld      r3, part1
00:00030018 E88F0008          +15         ld      r4, part2
00:0003001C E8AF0010          +16         ld      r5, part3
*EOF*
:$(00):00030000:00030020 :$(30):00000000:00400000 
modest.msm: object code 217 bytes: 0 errors: 0 undefined labels


</pre>
<h4>4.1.2.1.1.6.2.2.: Giant Absolute Address Data Example
with Dynamic Base-Displacement Referencing</h4>

<p>
This example is described as dynamic because the base-displacement
construct and the code-generating segment appear to be different segments.

<p>
The code is an array covering many times more address space than the
base-displacement construct, which can be mapped to different array
locations at different moments.

<p>
The base-displacement segment $(49) is called a void segment because
its declaration doesn't generate code. This is achieved by having a
base register but no address or relocation rule.

<p>
A giant array constructed as a stepped segment may be 
randomly accessed by basing different parts of the array 
at different moments for base-displacement addressing.

<p>
The use of a Void Segment to map  onto different parts of an array is
not confined to giant address models. See Section 4.1.2.1.1.5: Void
Segments
<pre>

MASMX 7r2
3/qbig.msm
LTERM=#
CONT_CHAR=\
STERM=.
*EOF*
  :                            1:         $include        "ppc_64.def"
  :                            2 
  :                            3 ARRAY   $equ    0x00FFFC0000000000
  :                            4 GRANULE $equ    2048*2048
  :                            5 
  :                            6 proces*	$proc
  :                            7 $(48::*ARRAY+GRANULE*x-GRANULE)
  :                            8         $do     x=3,    $list 0
  :                            9         $do     x=4094, $list 1
  :                            10 item(x)* +       x*2048*2048+ARRAY
  :                            11         $end
  :                            12 
30:00FFFC0000000000:00FFFC0000400000
                              +13 x	$do	4096,	proces
30:00FFFC0000400000:00FFFC0000800000
                              +13 
30:00FFFC03FF400000:00FFFC03FF800000
                              +13 
30:00FFFC03FF800000:00FFFC03FFC00000
                              +13 
30:00FFFC03FFC00000:00FFFC0400000000
                              +13 
  :                            14 
  :                            15 $(49::,r15)
  :                            16 h       $res    8
  :                            17 t       $res    2048*2048-8
  :                            18 
  :                            19 $(0:3*65536)
00:00030000 4800000D          +20 start   bl      loaded      
00:00030004 00FFFC017FC00000  +21         +       item(1536)
00:0003000C 7DE802A6          +22 loaded  mflr	  r15
00:00030010 E9EF0000          +23         ld	  r15,,r15
00:00030014 E86F0000          +24         ld      r3, h
00:00030018 E88F0008          +25         ld      r4, t
*EOF*
:$(00):00030000:0003001C :$(30):00000000:00000008 :$(31):00000000:00400000 
qbig.msm: object code 213163 bytes: 0 errors: 0 undefined labels

</pre>
<p>
With *giant-stepped segments, the size of the giant part of the address
is the second part of the $AWIDTH declaration, for example
<pre>

	$awidth 32:64

</pre>
<p>
The first or "ordinary" part of the $AWIDTH declaration may
not be more than 32 bits, and that sets the 4-gigaquanta limit of base in
<pre>

$(id:base:

</pre>
<p>
Base + current location counter cannot accumulate to more
than 4 gigaquanta without being stepped. The default of 
the giant part of $AWIDTH is 48 and the limit is 192.

<p>
See also Section 8.2: $AWIDTH directive
See also Section 9: Output File Formats, Relocation and Linking,
Giant Address Spaces, Interfacing with GNU Tools.

<h4>4.1.2.1.1.7: Literal Pool Tag</h4>


<p>
Literals may be generated in any sort of segment where code is
allowed. The only other sort of segment is a void segment, sometimes known
as a dsect. That's a base-displacement segment with no addresses
and no relocation rule.

<p>
Where a /literal_pool_tag appears in the location counter control
<pre>

$(id[:base][:breakpoint][,base_register]/literal_pool_tag)

</pre>
<p>
or
<pre>

$(id[:*relocation_alignment][,base_register]/literal_pool_tag)

</pre>
<p>
<b>/literal_pool_tag</b> gives a handle to the literal pool in the counter.

<p>
Literals are steered into a particular section or location counter by
referencing the section's <b>literal_pool_tag</b>(when_declaring_a_literal)

<p>
Where automatic literals are enabled with <b>-a</b> flag, untagged literals go
in the current (see 8.29: <b>$LIT</b> directive) default segment for literals.

<p>
Without <b>-a</b> flag, literals can only be generated via literal-pool-tag.

<p>
The literals are produced at the end of the section or section breakpoint.

<p>
Identical literals within a segment only happen once. All the references
get the same literal within one breakpointed part (that's within the whole
section if there isn't any breakpointing).

<p>
For example, in the definition header "8051.def":
<pre>

$(0:0/$literal)

</pre>
<p>
means start location counter zero at address zero, and 
gives the tag "$literal" to a literal pool at the end of 
the other code assembled in location counter zero. Tag 
"$literal" may then be referenced to assemble literals 
and return their address:
<pre>

	mov     dptr, #$literal("A Long String of Text")

</pre>
<p>
See also Section 5.2: Functions and Literals.
A forward slash signals the start of the literal pool
name. Therefore any expression which contains an operator 
<b>/ // /// */ /*</b> in the preceding expressions should be 
in parentheses. Or equated to a label in advance:
<pre>

OFFSET	$set	TOTAL_SIZE/GRANULE_LOGARITHM
$(.array::BASE+OFFSET/$literals_tag)


</pre>
<h4>4.1.2.1.2: Relocatable Location Counters</h4>
<pre>

$(id:*alignment[:initial_offset][,base_reg][/literal_pool_tag])

</pre>
<p>
id is the number 0..71 of the location counter

<p>
*alignment identifies relocatable code. It gets rounded to the
containing power of 2. *alignment is recognised by leading asterisk.

<p>
initial_offset is optional. It declares a hole or unlabelled buffer
at the front of the segment. initial_offset is usually absent = zero.

<p>
If base_reg is given, then references in the segment are base-displacement
but not relocatable. This rule also applies to references to literals in
the segment.

<p>
The code in the segment may be relocatable, but base-displacement
references are never relocatable.

<p>
If base_reg is not given, the text-encoded binary output has
relocation information against each reference to the segment.
This rule applies to references to literals in the segment.

<p>
Assembling with the <b>-nl</b> flags displays which references are tagged
with relocation information.

<p>
See Section 9:	Output File Formats, Relocation and Linking,
    		Giant Address Spaces, Interfacing with GNU Tools



<h2>4.2: Lines of Code Generally</h2>


<p>
Most lines of code have the scheme
<pre>

[label]		[command]	[operand]	[. comment]

</pre>
<h3>4.2.1: Labels</h3>


<p>
A label is a label because it starts in the first column of
a line. It may contain A..Z a..z 0..9 @!?_$ plus one more
value, the substring terminator which by default is : (colon),
but can be changed with the $STERM directive and is often . (period).

<p>
Substring terminator can be used just as a character in labels,
and can be the divider in a STRUCTURED.NAME.HIERARCHY.

<p>
Substring terminator is otherwise used as a macro parameter divider and
as a text string divider.

<p>
Labels may have a parenthesised part Label(5,4,3) which is
simply part of the label.

<p>
A label may have one or many subscripts.

<p>
These label(subscripts) may represent table locations at organised
address intervals (see 8.9: $DO directive and 7: Structured Data),
or the developer may assign the subscripts in a random way.

<p>
These examples show subscripted labels generated and then
referenced in an organised way and having an organised set
of values:
<pre>

index   $do     50,This_name(index)     +       6000-3*index     

</pre>
<p>
yields labels attached to integer constants
<pre>

This_name(1)    +       6000-3
This_name(2)    +       6000-3*2
This_name(3)    +       6000-3*3
		.
		.
This_name(50)   +       6000-3*50

.
.
.

ref     $do     50,     add     r30, This_name(ref)

</pre>
<p>
meaning
<pre>

		add     r30, This_name(1)
		add     r30, This_name(2)
		.
		.

</pre>
<p>
Subscripted labels and references 
to them don't have to be generated via loop control 
or parameter processing. You can directly code
<pre>

mylabel(1)
	load    default_parameter
mylabel(2)
	.
	.
	jump_not_finished       mylabel(2)

</pre>
<p>
Label subscripts don't have to be in ascending order or any order:
<pre>

MANY	$set	65536

index	$do	MANY,a_name(MANY+1-index)	+	99*index

</pre>
<p>
The subscript is an expression like any other and need not be written
as a normalised integer. On storage and reference, the assembler encodes
each expression in the subscript list as a strictly normalised integer.

<p>
For example, the first two repeats of the $DO above generate
<pre>

a_name(65536)	+	99*1
a_name(65535)	+	99*2

</pre>
<p>
and the last three generate
<pre>

a_name(3)	+	99*65534
a_name(2)	+	99*65535
a_name(1)	+	99*65536

</pre>
<p>
Reference to a subscripted label which is not there works functionally
as a count of labels the same plus one more subscript:
<pre>

MASMX 7r2
0/-INPUT>>

  :                            3 thing(4)
  :                            4 thing(5)
00:00000000 00000002          +5         +       thing()
  :                            6 
  :                            7 athing(3,9)
  :                            8 athing(3,7)
  :                            9 athing(3,5)
00:00000004 00000003          +10         +       athing(3)
  :                            11         $end
:$(00):00000000:00000008 
-INPUT>>: object code 63 bytes: 0 errors: 0 undefined labels

</pre>
<p>
It's selectable whether labels are case-significant, and
the decision taken about case applies to every name in the
assembly including names supplied by the assembler.

<p>
If <b>-k</b> flag is on the command line, all labels may only be referenced
case-significant. This includes internal labels of the assembler (directives
and internal functions), which are then lowercase only:
<pre>

	$proc
	.
	.
	$end

</pre>
<p>
The <b>-k</b> flag was may only be set at the command line.
<b>-k</b> is not actioned with the <b>$set_option</b> directive
<pre>

	$set_option	"k"

</pre>
<p>
There is likely be a policy or intention about case significance.

<p>
This line in a header file will safeguard a case-insignificant policy:
<pre>

	$do	$o('k'),	$exit	no, I'm not working with that

</pre>
<p>
This line in a header file will safeguard a case-significant policy:
<pre>

	$do	$o('k')=0,	$exit	no, I need case-significant

</pre>
<p>
The value of flag <b>-k</b> is always 0 or 1.

<p>
An expression whose most-final-operator is "=" will always generate
1 for equals or zero for unequal.

<p>
Therefore that $do will happen either once or not at all.

<p>
Labels may be TRAILED_WITH_ASTERISKS***

<p>
which makes them more global than the macro level 
in which they appear, one level more global per 
asterisk. If there's one more asterisk than macro 
depth, the label is catalogued externally for loaders 
and linkers to use.

<p>
See also Section 8.28: <b>$list 0, Masking Labels from List and Export</b>

<p>
Labels can be both declared and referenced within quotes

<p>
"heresalabel!" jump "wheresalabel?"

<p>
and if so the characters in the label can be anything, 
but it's still only case-significant if that's opted.

<p>
"heresalabel!" is the same label as heresalabel!
"wheresalabel?" is the same label as wheresalabel?

<p>
Within macro expansion, labels and references to them 
can be generated from parameter values, if the labels
are generated or referenced "in quotes":
<pre>

p	$proc
yello*	$name
	$if	$t("p(1,1)_tag")=0	. does it exist yet?
"p(1,1)_tag"*
	.
	.

</pre>
<p>
Default quote character is " and can be changed with $QUOTE directive.

<p>
One use of quotes is when it's desired to generate some 
labels beginning with $ symbol. Section 4.1.2.1: Describing Address Spaces: Location Counter Controls, shows that $ may not be in column 1 when $ is
the first character of a label.

<p>
But quote may be in column 1, and $ in column 2:
<pre>

"$special_label"

</pre>
<p>
The quotes are not part of the label.

<p>
masmx uses labels starting $ -all the labels supplied by masmx do.

<p>
This is so that developers don't accidentally try to define the same
labels again.

<p>
Because using masmx involves defining a machine as well as writing
applications, administrators might want to assign labels regarded as
system labels starting with $, for example
<pre>

"$vector"*      $func
		$return $vector(1,1)*8+$vectorBase
		$end

</pre>
<p>
Then application developers can reference this function name
<pre>

	load_address    r16, $vector(LEVEL_3_INTERRUPT)

</pre>
<p>
and can assign intuitively similar labels like "vector", which, if
they don't also start with $, will not clash with any labels which begin
with $ in order to mark them as machine or system labels.


<h3>4.2.2 The Command Field</h3>


<p>
The command field (the first field which is preceded by any
whitespace) can contain a directive, a constant, the name
of a $PROC macro, or the name of a $FORM template.
<pre>

[label] COMMAND [arguments]

</pre>
<h4>4.2.2.1 Directives</h4>


<p>
The directives are listed in Section 8: Directives. They
may all be aliased to other names using the $EQU directive,
and frequently are, for example
<pre>

.equ    $equ,"$directive"       "$equ"
.macro  $equ,"$directive"       "$proc"
.macend $equ,"$directive"       "$end"

</pre>
<p>
These aliases are examples from a PowerPC definition 
header file.

<p>
Quotes are used in these expressions because <b>-m</b> (Motorola) flag
may be on. The quotes force the "$xxxxxx" tokens to be seen as
labels and not as hex strings.

<p>
Also, a small number of directives, <b>$word</b>, <b>$byte</b> and others,
work functionally outside the command field if they are not in quotes
<pre>

byte	$equ	$byte		   . $byte returns the actual byte size
setbyte	$equ,"$directive"  "$byte" . setbyte is the same directive as $byte
 
</pre>
<p>
Note however quotes in the command field produce a text string constant

<p>
The command field is never viewed as an expression. So $equ in the
command position will always be viewed as the name of some sort of
command, and directive $EQU will be recognised.

<p>
These lines make .equ .macro and .macend to be labels of directives also.


<h4>4.2.2.2 Data Constants</h4>


<p>
Data constants may be integers, microstructures of bit fields, 
floating point items or text strings.


<h4>4.2.2.2.1 Integer Items</h4>


<p>
Integer items in masmx native syntax have a command 
code which is a unary sign + - ^  The third of these, 
^ is "not" or 1s complement. See Sections 4.2.3.2.: 
Expressions, and 4.2.3.2.1: Operators for an 
explanation of the operators
 <b>= ^= > < -- ++ /* */ ** + - * / // /// *+ *-</b>


<p>
When unary sign <b>+ - ^</b> occupies the command field, the
integer or floating item value may be shunted up to the 
unary sign or tabbed over to the argument field
<pre>

	+       99
	+99
	-	3.7

</pre>
<p>
The following assembly shows at lines 38..49 that
integer items may have trailing length overrides. Their meanings are
<ul>
:s or s = 1 * word size 
<pre></pre>
:d or d = 2 * word size
<pre></pre>
:l or L = 2 * word size
<pre></pre>
:t or T = 3 * word size
<pre></pre>
:q or Q = 4 * word size
<pre></pre>
:p or p = 5 * word size
<pre></pre>
:h or h = 6 * word size
<pre></pre>
:o or o = 8 * word size

</ul>
<p>
These size-tags may be upper or lower case.

<p>
If the last token in the expression is a label instead of a number string
(as line 45 of the next assembly sample), then any length override must
be preceded by : (colon), like

	+       expression:D
	
<p>
It is always allowed to use a colon before the length override.

<p>
When the number constant is floating point, any length override follows
the fraction, not the exponent
<pre>

	+	1.6384d*+4
	+	expression:q*-downscale
	+	1.000000006768:pe+1200000

</pre>
<p>
Integers are by default scanned as hex with leading zero and as decimal with any other leading digit.

<p>
1000 and 03e8 both mean one thousand

<p>
An example is on lines 30..32 of the assembly listed below.

<p>
If $OCTAL directive is issued leading zero means octal, until
$HEX directive is issued.

<p>
masmx has many variations on number string notation:
<ul>
	C language integer syntax
<pre></pre>

	Motorola hex/bit syntax
<pre></pre>

	Intel-style notation suffixes
<pre></pre>

	$OCTAL/$HEX switch

</ul>
<p>
These are discussed under Section 4.1.3.2: Expressions.


<p>
The default and starting point is:
<ul>
	leading 1..9 is decimal
<pre></pre>

	leading 0 is hex
<pre></pre>

	leading \ is bit pattern
<pre></pre>

	character values bounded by 'apostrophes' produce
	their absolute value in an +'expression'
</ul>
<pre>

MASMX 7r2
3/ctest.msm
*EOF*
  :                            1         $word   16
00:0000 00010000              +2         +       4096*16
00:0002 00100000              +3         +       4096*256
00:0004 01000000              +4         +       4096*4096
  :                            5 
  :                            6 likely  $equ    15        
  :                            7 what    $equ    3
  :                            8 how     $equ    -256
  :                            9 
00:0006 FFF0                  +10         ^       likely
00:0007 FFF3                  +11         +       ^likely++what
00:0008 FF03                  +12         +       ^likely**how++what
  :                            13 
00:0009 0060                  +14         +       100-4
00:000A 0005                  +15         +       100/20
00:000B 0005                  +16         +       99//20
00:000C 0004                  +17         +       80//20
00:000D 0005                  +18         +       81//20
00:000E 0013                  +19         +       99///20
00:000F 004162636465666768696A6B6C6D6E6F
                              +20         +       'abcdefghijklmno'-(32*/(('o'-'a')*8))
00:0017 FFFF0000              +21         -       4096*16
00:0019 FFF00000              +22         -       4096*256
00:001B FF000000              +23         -       4096*4096
00:001D FFA0                  +24         -       100-4
00:001E FFFB                  +25         -       100/20
00:001F FFFB                  +26         -       99//20
00:0020 FFED                  +27         -       99///20
00:0021 0001                  +28         +       2>1
00:0022 0000                  +29         +       1>2
00:0023 00380000              +30         +       0700000/*1
00:0025 700000000000000000000000000000000000000000000000
                              +31         +       0700000*/168
00:0031 380000000000000000000000000000000000000000000000
                              +32         +      (0700000*/168)/*1
00:003D 700000000000000000000000000000000000000000000000
                              +33         +       7*/188
00:0049 0001                  +34         +       1<(7*/188)
00:004A 0000                  +35         +       1>(7*/188)
  :                            36 
00:004B 0063                  +37         +       99
00:004C 00000063              +38         +       99d
00:004E 000000000063          +39         +       99t
00:0051 0000000000000063      +40         +       99q
00:0055 00000000000000000063  +41         +       99p
00:005A 000000000000000000000063
                              +42         +       99h
00:0060 00000000000000000000000000000063
                              +43         +       99o
00:0068 FF88                  +44         +  (-8)*likely
00:0069 FFFFFFFFFFFFFFFFFFFFFFFFFFFFFF88
                              +45         +  (-8)*likely:o
00:0071 000F4240              +46         +       1000000
00:0073 01000000              +47         +      01000000
00:0075 000F4240              +48         +       1000000:l
00:0077 4240                  +49         +       1000000:s
  :                            50 
*EOF*
:$(00):0000:0078 
ctest.msm: object code 550 bytes: 0 errors: 0 undefined labels


</pre>
<p>
Integer line items are in canonical byte order, and the only way to
change that is by implementing pseudo-directives (often implemented
with names like DW and DD) as macros.

<p>
All expressions used to generate integer line items are 
evaluated to 192 bits of precision. Then in the absence
of a length override, an integer item is output in
the number of words (of size set by $WORD) required to represent it.

<p>
In addition to labels, there is one number string
situation where : must be used before a length suffix. 
That situation is in cases like 0123:D, which is different 
in meaning from 0123D. This only concerns hex and the :D
symbol specifically. Developers may prefer
always to use colon in this position. There is also the :L
or L suffix, identical in meaning to :D



<h4>4.2.2.2.2 Split Integers</h4>


<p>
A split integer item is a small list of equal size fields. The default
size of the total is one word. The suffixes :d etc can change the size.

<p>
The source syntax of split integers has commas between the fields:
<pre>


MASMX 7r2
3/commas.msm
*EOF*
  :                            1         $word   48
00:000000000000 666677778888  +2         +       06666, 07777, 08888
00:000000000001 0A0B0C0D0E0F  +3         +       10, 11, 12, 13, 14, 15
00:000000000002 FFF00AFFF00B  +4         +       -1, +10, -1, +11
00:000000000003 123456789ABC  +5         +       1,2,3,4,5,6,7,8,9,10,11,12
  :                            6 left    $equ    0aaaaaaaaaaaaaaaaaaaaa
  :                            7 centre  $equ    0bbbbbbbbbbbbbbbbbbbbb
  :                            8 right   $equ    0ccccccccccccccccccccc
  :                            9 
00:000000000004 AAAACCCCBBBB  +10         +       left, right, centre
00:000000000005 AAAAAAAACCCCCCCCBBBBBBBB
                              +11         +       left, right, centre:d   
00:000000000007 AAAAAAAAAAAAAAAACCCCCCCCCCCCCCCCBBBBBBBBBBBBBBBB
                              +12         +       left, right, centre:q   
*EOF*
:$(00):000000000000:00000000000B 
commas.msm: object code 200 bytes: 0 errors: 0 undefined labels

</pre>
<p>
If the number of fields does not divide into the total size,
zero-filled slack bits are generated at the top.



<h4>4.2.2.2.3: $FORM Items</h4>


<p>
$FORM declares a bit structure from one word to 192 bits in size.
The command field when using a form is the label of the $FORM:
<pre>

MASMX 7r2
3/form.msm
*EOF*
  :                            1         $word   16
  :                            2 descriptor $form 1, 1, 14, 2, 3, 3, 24
  :                            3 
00:0000 8180A4040064          +4         descriptor 1,,384, 2, 4, 4, 262144+100
00:0003 00C8F6040063          +5         descriptor  ,,200, 3, 6, 6, 262144+99
*EOF*
:$(00):0000:0006 
form.msm: object code 55 bytes: 0 errors: 0 undefined labels

</pre>
<p>
$FORM is masmx's building block for instructions:
<pre>

jump_form	$form	6, 26

jump*		$proc
		jump_form	JUMP_CODE, jump(1, 1)
		$end

</pre>

<h4>4.2.2.2.4 Floating Point Items</h4>

<p>
A number item, integer or floating, is recognised by command which is
unary symbol + - ^
<pre>

	+	99	. integer
	-	1.3276	. floating item

</pre>
<p>
Floating numbers contain a digit string with decimal point 
or the decimal scale operator, *+ *- or both
<pre>

	+	1.75
	+	175*-2

	+	298.5e1262611

</pre>
<p>
The scale punctuation e+ e- is also recognised after a fraction string

<p>
Floating numbers can be cached as label values and manipulated bitwise
into the floating format of the target architecture
<pre>

	floating_value	$set	16384.0e+1000000

</pre>
<p>
masmx internal floating precision has a 168-bit simple fraction
and a 23-bit midpointed characteristic equivalent in range to decimal
exponents [+|-]1262611

<p>
Negative polarity has all 192 bits in ones complement
<pre>

	
	__________________________________________________________________
	|s|190 exponent 168|167          mantissa                       0|
	|_|________________|_____________________________________________|



</pre>
<p>
masmx default floating numbers are the 192-bit number rounded to 96 bits,
with the characteristic still 23 bits midpointed, and the fraction 72 bits
<pre>


	95	      72   71					       0
	________________________________________________	_________
	|s|characteristic|	fraction-only mantissa			|
	|_|______________|______________________________	________|


</pre>
<p>
Numbers in the default 96-bit format are shown here

<pre>

MASMX 7r2
3/fs32.msm
*EOF*
  :                            1 	$word	32
  :                            2 
00:00000000 400001C00000000000000000
                              +3         +       1.5
00:00000003 BFFFFE3FFFFFFFFFFFFFFFFF
                              +4         -       1.5
00:00000006 72B049CD0D73CF08E04D576E
                              +5         + 1.5*+1000000
00:00000009 0D4FB9B3C73F219697B1274F
                              +6         + 1.5*-1000000
*EOF*
:$(00):00000000:0000000C 
fs32.msm: object code 145 bytes: 0 errors: 0 undefined labels

</pre>
<p>
The directive $FLOATING POINT changes the default 96-bit total size of the
stored floating-point constant.

<p>
The $CHARACTERISTIC directive sets the characteristic size for a given
number size.
<pre>

	$characteristic,number_size	characteristic_width

</pre>
<p>
Without number_size, characteristic_width is for the current default
floating number size

<p>
characteristic_width is the characteristic field + sign, or
everything except the mantissa. So for example a target which supports
the 80-bit coprocessor format with 15-bit exponent might have
<pre>

	$floating_point	80
	$characteristic	16

</pre>
<p>
<b>$characteristic 8</b> means one sign bit and seven exponent bits:
<pre>

MASMX/24592 1r1X
FP32.msm 5
*EOF*  :                        1:         $word   32
  :                        2:         $floating_point 32
  :                        3:         $characteristic 8
  :                        4:         $characteristic,64 16
  :                        5:         $characteristic,128 20
  :                        6: 
00:00000000 41C00000      +7         +       1.5
00:00000001 4001C00000000000+8         +       1.5d
00:00000003 40001C00000000000000000000000000
			 +9         +       1.5q
*EOF*:$(00):00000000:00000007 
Object Code 107 Bytes: 0 Errors: 0 Undefined Labels

</pre>
<p>
The structure
<pre>

	mid-pointed-exponent/normalised-fractional-mantissa/1s-complement

</pre>
<p>
can be escaped with macro language

<p>
Macros supplied in this package generate IEEE754 floating constants. 

<p>
See Section 1.5: Any Floating Point Format.

<p>
This example generates
<pre>

	1.375e+1200000

</pre>
<p>
according to different syntaxes. A size override h for hexaword
follows the fraction in each number, so they are all 192 bits
<pre>


$ masmx -ln
MASMX 7r2
0/-INPUT>>
        $word   32
        +       1.375h*+1200000
        +       1.375he+1200000
        +       1375h*+1199997
floatup $set	137.5he1199998
floataway $set	1.375he1200000
floatalong $set 1.375h*+1200000
        +       floatup
        +       floataway
        +       floatalong
        $end
  :                            1         $word   32
00:00000000 7CD38B90563FA97362D8D4F8DAAE3CB167FAE1BBCD7D99BB
                              +2         +       1.375h*+1200000
00:00000006 7CD38B90563FA97362D8D4F8DAAE3CB167FAE1BBCD7D99BB
                              +3         +       1.375he+1200000
00:0000000C 7CD38B90563FA97362D8D4F8DAAE3CB167FAE1BBCD7D99BB
                              +4         +       1375h*+1199997
  :                            5 floatup $set 137.5he1199998
  :                            6 floataway $set 1.375he1200000
  :                            7 floatalong $set 1.375h*+1200000
00:00000012 7CD38B90563FA97362D8D4F8DAAE3CB167FAE1BBCD7D99BB
                              +8         +       floatup
00:00000018 7CD38B90563FA97362D8D4F8DAAE3CB167FAE1BBCD7D99BB
                              +9         +       floataway
00:0000001E 7CD38B90563FA97362D8D4F8DAAE3CB167FAE1BBCD7D99BB
                              +10         +       floatalong
  :                            11         $end
:$(00):00000000:00000024 
-INPUT>>: object code 339 bytes: 0 errors: 0 undefined labels


</pre>

<h4>4.2.2.2.5: The Decimal Scale Operator *+ *-</h4>

<p>
The decimal scale operator not only adds scale to a fraction string, but may also
join two integer expressions to construct a floating number, with the mantissa taken
from the left and the exponent from the right. Any length override is typed after the
fraction and before the *+ *- operator
<pre>

$ masmx -ln floating
MASMX 7r2
3/floating.msm
  :                            1 
  :                            2 	$word	48		. the word size of the target
  :                            3 				. processor architecture
  :                            4 
  :                            5 	$floating_point 96	. the default size of a floating constant
  :                            6 				. = 2 words
  :                            7 
  :                            8 	$characteristic		24	. the characteristic field width
  :                            9 					. for a 2-word floating number
  :                            10 					. 24 bits is the maximum characteristic
  :                            11 
  :                            12 	$characteristic,48	12	. the characteristic field width
  :                            13 					. for a 1-word floating number
  :                            14 
  :                            15 one     $equ    1
  :                            16 
00:000000000000 3FFFFDCCCCCCCCCCCCCCCCCD
                              +17 	+	1*-1		. floating recognised from operator
  :                            18 				. current default floating size
  :                            19 
00:000000000002 3FDCCCCCCCCD  +20 	+	1s*-one		. floating recognised from operator
  :                            21 				. single-word override
  :                            22 
  :                            23 
00:000000000003 3FFFFDCCCCCCCCCCCCCCCCCD
                              +24 	+	0.1		. floating recognised from fraction string
00:000000000005 3FDCCCCCCCCD  +25 	+	0.1s		. floating recognised from fraction string
  :                            26 				. single word override, 12-bit characteristic
  :                            27 
00:000000000006 3FFFFDCCCCCCCCCCCCCCCCCD
                              +28 	+	1.0e-1		. fraction string followed by e+ e- punctuation
  :                            29 
00:000000000008 3FFFFDCCCCCCCCCCCCCCCCCD
                              +30 	+	one*-one	. floating recognised from operator
  :                            31 				. mantissa / exponent expressions
  :                            32 				. contain any integer tokens
  :                            33 
00:00000000000A 3FDCCCCCCCCD  +34 	+	1s*-1		. expression sizes and rounds at
  :                            35 				. one-word override
  :                            36 
  :                            37 
00:00000000000B 3FFFFDCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCD
                              +38         +	1q*-one		. four-word override
  :                            39 
00:00000000000F 3FDCCCCCCCCD  +40 	+	1.0s*-one  	. exponent string can be any integer tokens
  :                            41 
00:000000000010 401800000000404A00000000407C8000000040AFA0000000
                              +42 	+	1s*+0, 1s*+1, 1s*+2, 1s*+3q	. four words,
  :                            43 						. four floating numbers
  :                            44 
  :                            45 tagged	$equ	163.84e+2
00:000000000014 40000F800000000000000000
                              +46 	+	tagged
  :                            47 
  :                            48 	$end
:$(00):000000000000:000000000016 
floating.msm: object code 336 bytes: 0 errors: 0 undefined labels


</pre>

<p>
The scale operator <b>*+ *-</b> is actioned after arithmetic operators <b>/ // /// * + -</b>
and before boolean and shift operators <b>** */- */ /* ++ --</b>

<h4>4.2.2.2.6 Text Strings</h4>


<p>
Text strings are a row of bytes composed from
<pre>
	"text in quotes ";	. text in quotes

	:;			. the substring character default :

	number_expression	. generating one byte per expression

</pre>
<p>
These line-continued parts produce
<pre>

	"text_in quotes":number_expression

</pre>
<p>
These lines
<pre>

	"string of text":10:;
	"another line of text ":;
	"and more of that line"

</pre>
<p>
could be keyed as
<pre>

	"string of text":10:"another line of text and more of that line"

</pre>
<p>
The byte size, the quote symbol and the substring symbol are all
symbols which can be selected at a different value from
their defaults of 8, " and : with the use of directives
$BYTE $QUOTE $STERM

<p>
Data code generated may be changed from ASCII to a sequence
compiled and switched using the $DATA_CODE directive.

<p>
Text string contents are read from source code in ASCII.

<p>
See also 3.2 Command Line Options <b>-zc</b> for space or zero pad

<p>
Text string constants are described further in 
<ul>

Section 8.5: $BYTE Directive
<pre></pre>
Section 8.42: $QUOTE Directive 
<pre></pre>
Section 8.49: $STERM Directive
<pre></pre>
Section 8.8: $DATA_CODE Directive
<pre></pre>
Section 8.1: $ASCII Directive

</ul>

<p>
Text strings generate enough words (size set by $WORD) to 
contain a byte (size set by $BYTE) per symbol in the string.

<p>
Each character between "quotes" is a symbol and an expression
after the substring mark is a symbol, as
<pre>

	"characters":10

</pre>
or
<pre>

	$sterm	'.'
LF	$equ	10

	"characters".LF
 
</pre>
<p>
If there are whole bytes unfilled in the last word of the string,
they are space-filled (zero-filled with <b>-c</b> flag <b>XOR -z</b> flag).

<p>
If there are bits unfilled  after the last whole byte position
in the last word in the string, they are zero filled.

<p>
See also Section 10: Byte-Addressing Machines with 32- and 64-bit
Bus, Managing Alignments

<h4>4.2.2.3: Macro Calls: Instructions and Structures</h4>

<p>
Most code lines have macro calls in the command position.
That's how instructions are in masmx.

<p>
Words like "add" and "mov" are not known to masmx until
they are the names of macros or macro entry points:
<pre>

p       $proc
add*    $name   6
mov*    $name   7
	instruction_form  $n, p(1,1), p(1,2)
	$end

</pre>
<p>
Then the lines in assembly language files are macro calls like these:
<pre>

	add     This, That
	mov     That, There


</pre>
<h3>4.2.3: The Operand Field</h3>


<h4>4.2.3.1: Fields, Subfields and Substrings</h4>

<p>
In the scheme
<pre>

[label] command  subfield,subfield:substring field field 

</pre>
<p>
A field has at least one subfield. A subfield has
at least one substring. If a field has more than one
subfield they're separated with comma. If a subfield
has more than one substring they're separated with
substring symbol, which you can change with $STERM directive.

<p>
Substring symbol is shown as its default colon above,
and shown as period in this example:
<pre>

[label] command  subfield,subfield.substring field field 

</pre>
<p>
Each subfield or substring contains an expression or
a text string in quotes or a literal.


<h4>4.2.3.2 Expressions</h4>


<p>
Expressions are labels or numbers computed together by
operators. Labels may represent 
<ul>
	addresses of storage locations
<pre></pre>
	
	values given names with $EQU or $SET

	the current iteration count of a $DO loop
<pre></pre>
	
	functions internally supplied from the assembler, 
	such as location counter values
<pre></pre>
	
	macrofunctions written by the developer, 
	which assemble when referenced and return 
	a value to which can be used in the expression

</ul>
<h4>4.2.3.2.1 Operators</h4>
	
<p>
This is the hierarchy of operators.
	
<p>
The operators first on the list are examined first and actioned 
last and are the at top of the hierarchy.

<p>
The operators last on the list are examined last and actioned
first and are at the bottom of the hierarchy.
<pre>


	=               equal, returns 1 if left expression equals
			right, otherwise returns 0

	^=              unequal, returns 1 if left expression is 
			unequal to right, otherwise returns 0

	>               more than, returns 1 if left expression > right
			otherwise returns 0

	<               less than, returns 1 if left expression < right                 
			otherwise returns 0

	--              xor

	++              or

	/*              shift right

	*/              shift left

	*/-		shift left negative count = shift right algebraic

	**              and

	*+ *-		decimal scale

	+ -             add, subtract: equal precedence left to right

	/ // /// *      divide, covered quotient, remainder, multiply:
			equal precedence left to right

	______________________________________________________________

	Unary +-^       plus, minus, ones-complement

	()              parentheses.


</pre>

<p>
Decimal scale operator <b>*+ *-</b> is described in
<b>4.2.2.2.4 Floating Point Items</b>,
and <b>4.2.2.2.5: The Decimal Scale Operator</b>


<h4>4.2.3.2.1.1: Operators Used on Relocatable Tokens</h4>

<p>
Not all operators may be used on relocatable arguments.

<p>
These notes apply only to relocatable tokens in expressions.

<p>
Operations other than these are not allowed on relocatable tokens.

<p>
Relocation information in the text encoded binary is supplemented
according to the following operations.

<p>
+ and - may be used without limit on mixed relocatable and unrelocatable
arguments. Relocation information is appended for addition once per + of
a relocatable argument, and for subtraction once per -

<p>
AND ** instructs the linker that truncation is expected and range is
not to be checked after relocation.

<p>
Only the token left of ** may be relocatable, not the AND mask.

<p>
/* SHIFT RIGHT and */- SHIFT RIGHT ALGEBRAIC cause the entire unrelocated
value to be placed in output unshifted, with instructions to the linker
to shift after relocation.

<p>
Only the token left of the shift operator may be relocatable, not the
shift count

<p>
At assembly time, shift right algebraic */- is chosen instead of shift
left */ if the left shift count is <b>factually</b> negative.

<p>
The shift count is factually negative in
<pre>

	NUMBER*/-16
	NUMBER*/(-16)

</pre>
<p>
The shift count is not factually negative in
<pre>

	NUMBER*/-(-16)

</pre>
<p>
The linker is instructed that the value for shifting after relocation
is to be treated as signed for range-checking if the left shift count
is <b>apparently</b> negative.

<p>
The shift count is apparently negative if minus follows shift-left
immediately, as */-

<p>
The shift count is apparently negative in
<pre>

	NUMBER*/-16

</pre>
<p>
The shift count is apparently negative in
<pre>

	NUMBER*/-0

</pre>
<p>
and then linker range-checking is for signed although no shift takes place.

<p>
The shift count is not apparently negative in
<pre>

	NUMBER*/(-16)

SLEIGHT	$equ	-16
	NUMBER*/SLEIGHT

</pre>
<p>
In both cases the shift count is ACTUALLY NEGATIVE but not APPARENTLY
NEGATIVE, so shift right would take place; unrelocated NUMBER would
be forwarded entire and unshifted to the linker with instructions to
shift right 16 bits after relocation; range-check as unsigned.


<h4>4.2.3.2.2 Tokens in Expressions</h4>


<h4>4.2.3.2.2.1 Number Strings</h4>


<p>
masmx's default interpretation of number strings is that
leading 0 is hex and leading 1..9 is decimal. \1010101 is
bit-pattern binary: 
<pre>


MASMX/24592 1r1X
luri.msm 5
*EOF*  :                        1:         $word   32
00:00000000 000F4240      +2         +       1000000
00:00000001 01000000      +3         +       01000000
00:00000002 000000AA      +4         +       \10101010
*EOF*:$(00):00000000:00000003 
Object Code 75 Bytes: 0 Errors: 0 Undefined Labels



</pre>
<p>
If the directive
<pre>

	$octal

</pre>
<p>
is issued leading zero is octal and displays are octal, until
<pre>

	$hex

</pre>
<p>
is issued again.

	
<p>
$SUFFIX directive is for code written for Intel style assemblers        
<pre>
	
	$suffix 1

</pre>
<p>
causes suffix letters D Q O H B to mean decimal, octal, hex  
bit-pattern. The default is decimal, or hex for leading zero
<pre>

	$suffix 2

</pre>
<p>
is the same except the default is always decimal. For examples
see Section 8.51: $SUFFIX directive.


<p>
Option flags <b>-cm</b> mean C Language syntax and Motorola syntax.

<p>
If Option <b>-c</b> is set then 00001243 is octal and 0x00ABC is hex.

<p>
If Option <b>-m</b> is set then $012a is hex and %101000 is bit-pattern
binary.

<p>
Expression tokens of ASCII bytes between apostrophes produce their
absolute value in the current character set and size (by default 8-bit
ASCII, see 8.8 $DATA_CODE directive and 8.5 $BYTE directive):
<pre>

MASMX 7r2
3/immediat.msm
*EOF*
  :                            1         $word   32
00:00000000 0000006168657245  +2         +       'ahere'-32
*EOF*
:$(00):00000000:00000002 
immediat.msm: object code 62 bytes: 0 errors: 0 undefined labels



</pre>
<h4>4.2.3.2.2.2 Label References</h4>


<p>
Labels of any type (storage location line labels, equates, function
macro names, $DO loop tags) may be referenced in expressions
<pre>

	+       this*that+the_other

</pre>
<p>
And they mostly return their values. Some labels work in a 
functional way and return something computed.

<p>
Labels may be bounded with quotes in most places that expressions
appear in masmx, but if $QUOTE has been changed to ' apostrophe,
labels bounded with that will not be recognised in expressions,
but instead the ASCII characters between apostrophes will be read
as their data value in the current character set and size, by default
8-bit ASCII, see 8.8 $DATA_CODE directive and 8.5 $BYTE directive.


<h4>4.2.3.2.2.3 Macro Parameters</h4>


<p>
Macro actual arguments are accessed by using the label of 
the macro in a functional way
<pre>

p       $proc
add*    $name   1
	iform   p(0, 1), p(1, 1), p(1, 2)
	$end



</pre>
<p>
The hierarchy of arguments on the macro call line is
<pre>

    OP[, f0_subfield2]  f1_subfield1[, ...f1_subfieldn] [f2_subfield1[,...

</pre>
<p>
<b>OP</b> is the command name or directive or instruction name. It
is the first word after any whitespace. It is both subfield zero and
subfield one of the first field, <i>macro_name</i><b>(0, 0)</b> and
<i>macro_name</i><b>(0, 1)</b>, or if the macro has a much-used
non-unique name, for example <b>P</b>, then <b>OP</b> may be referenced
with <b>p(0, 0)</b> or with <b>p(0, 1)</b>.

<p>
After the command field, which is number zero, the whole fields are
numbered 1.. and their subfields [x],1..

<p>
So the word <b>f2_subfield1</b> is referenced
<i>macro_name</i><b>(2, 1)</b>

<p>
Fields are separated by spaces. Subfields in a field are 
separated by a comma and spaces can follow the comma.
There can also be substrings in subfields, separated by the 
substring character, default :

<p>
The referencing rules are, if for example the $PROC name is P,
(it may be any name), 
<pre>

p       $proc

</pre>
<ul>

	p or p() returns a count of fields in the
	actual arguments
<pre></pre>

	p(expression) returns a count of subfields in 
	field number "expression" of the actual
	arguments
<pre></pre>

	p(expression1, expression2) returns the value 
	of subfield "expression2" of field "expression1"
	of the actual arguments
<pre></pre>

	p(expression1, expression2:) returns a count of 
	substrings in subfield "expression2" of field
	"expression1" of the actual arguments
<pre></pre>

	p(expression1, expression2:expression3) returns the 
	value of substring "expression3" of subfield
	"expression2" of field "expression1" of the actual
	arguments
<pre></pre>

	p(expression1, *expression2) returns 1 if subfield 
	"expression2" of field "expression1" has the prefix * 
	otherwise 0
<pre></pre>
     
	p(expression1, #expression2) returns 1 if subfield 
	"expression2" of field "expression1" has the prefix # 
	otherwise 0
<pre></pre>

	p(expression1, expression2:*expression3) returns 1 
	if substring "expression3" of subfield "expression2"
	of field "expression1" has the prefix * otherwise 0
<pre></pre>
     
	p(expression1, expression2:#expression3) returns 1 
	if substring "expression3" of subfield "expression2"
	of field "expression1" has the prefix # otherwise 0
          
 
</ul>
<p>
p(0, 1) and p(0, 0) are both like the internal function $n
and return the value of the $NAME used to invoke the $PROC
for example
<pre>

p       $proc
add*    $name   20
subtract* $name  21
	.
	.
	$end

</pre>
<p>
The value p(0, 1) is 20 if the proc was called as "add". 

<p>
p(0, 0) returns a value 192 bits wide. $n returns a value 32 bits wide.

<p>
p(0, 2) returns a subcommand from the command field,
for example:
<pre>

L       $EQU    2
	.
	.
	move,L  etc,etc

</pre>
<p>
p(0, 2) will return the value of L, which is 2.

<p>
When a nested macro is called, actual parameters plus any new tokens
are re-ordered for the nested macro:
<pre>

	first_macro	left, right, centre	off_centre

____________________________________________________________________
first_macro receives this parameter stream:

	first_macro	left, right, centre	off_centre
____________________________________________________________________

p		$proc
first_macro*	$name
		.
	second_macro	justify	p(2, 1)-7	p(1, 1), p(1, 3), p(1, 2)
		.
		$end

____________________________________________________________________
second_macro receives this parameter stream:

	second_macro	justify	off_centre-7	left,centre,right
____________________________________________________________________

p		$proc
second_macro*	$name
		.
		.
		$end

</pre>
<p>
Macro language plus parameters can be displayed step-by step if the
value <b>$plist</b> is greater than current macro nesting depth, plus the
option flags <b>-p</b> (display <b>$proc</b> macros) <b>-q</b> (display
<b>$func</b> macros).

<p>
Listing and <b>-pq</b> displays are on the second assembly pass.

<p>
If problems encountered are so great than the second assembly pass is
not reached <b>-r</b> flag displays macros on the first assembly pass.

<p>
See 8.38: <b>$plist</b> Directive, 3.2: Command Line Options,
11.4: Tracing Macro Expansion.


<h4>4.2.3.2.2.4 Assembler-supplied functions</h4>


<h4>4.2.3.2.2.4.1: $ -this location counter</h4>


<p>
The expression $ returns the value of the current location counter. 
For example the sequence
<pre>

$(7:256)
	$res    4
bampot  $equ    $+1

</pre>
<p>
will have the result that the label bampot has the value 261

<p>
In giant segments, the giant value is obtained by adding the
giant base to $, or by calling the $A function, see Section 4.2.3.2.2.4.3
<pre>

$ masmx -ln
MASMX 7r2
0/-INPUT>>
	$word	32

ASTRONOMIC	$set	07FFFF8000380000000040000
	    
$(43:1024:*ASTRONOMIC)
	
	$res	512
here
tube	$equ	$+ASTRONOMIC+1

	+	tube
	+	here

	$end
  :                            1  $word 32
  :                            2 
  :                            3 ASTRONOMIC $set 07FFFF8000380000000040000
  :                            4      
  :                            5 $(43:1024:*ASTRONOMIC)
  :                            6  
  :                            7  $res 512
  :                            8 here
Note: -INPUT>> Line 9: GIANT SPACE: $ returns intrasegment part of counter only
Note: -INPUT>> Line 9: for absolute current location use $A
  :                            9 tube $equ $+ASTRONOMIC+1
  :                            10 
2B:000000040600:7FFFF8000380000000040601
                              +11  + tube
2B:000000040603:7FFFF8000380000000040600
                              +12  + here
  :                            13 
  :                            14  $end
:$(2B):00000400:00000606 
-INPUT>>: object code 113 bytes: 0 errors: 0 undefined labels

</pre>
<p>
The value of "tube" is ASTRONOMIC+1537, equal to 07FFFF8000380000000040601
hexadecimal.

<p>
$ alone at the point where "tube" is declared only has the net value 1536.

<p>
"here" is not an equate but a location, and has the value ASTRONOMIC+1536,
equal to 07FFFF8000380000000040600 hexadecimal

<p>
Note, <b>$WORD</b> directive sets the address quantum to <b>$WORD</b> size.

<p>
If the target machine address quantum is an 8-bit byte,
<b>$WORD</b> must be followed with the <b>$QUANTUM</b> directive
<pre>

	$word		32
	$quantum	8

</pre>


<h4>4.2.3.2.2.4.2: $(..) -a location counter</h4>


<p>
The expression $(..) returns the value of the location 
counter identified in the brackets. For example the sequence
<pre>

text    $equ    0
var     $equ    1
$(var:4096)
	$res    4
$(text:256)
CONSTANT        +       $(1)+3

</pre>
<p>
causes the data word at location CONSTANT to contain 
the value 4103


<h4>4.2.3.2.2.4.3: $a -absolute address</h4>

<p>
<b>$a</b> is the absolute address relative to the program space.
In base-displacement sections <b>$a</b> adds the base if that is known
from an absolute location counter, and in relocatable sections <b>$a</b>
instructs the link step to add the relocation.
<pre>

	$(15:*8, r9)
	here	+	$a(here)

</pre>
<p>
In this example the segment is relocatable (it has an *alignment word),
and the effect of <b>$a</b> is that relocation information is attached
to the generated constant.

<p>
<b>$a</b> is functional whether the target address is both relocatable and
base+displacement as already shown; where the target address is relocatable:
<pre>


	$(4:*4)
	there

		+	$a(there)

</pre>
<p>
and where the target address has a known absolute base
<pre>

	$(4:QUITE_LARGE_START_ADDRESS, r9)

		$res	intervening_displacement

	name

		+	$a(name)

</pre>
<p>
In this configuration, <b>name</b> has the base+diplacement value 
<pre>

	intervening_displacement, r9

</pre>
<p>
and <b>$a(name)</b> has the absolute value
<pre>

	QUITE_LARGE_ADDRESS+intervening_displacement

</pre>
<p>
<b>$a</b> has no function for addresses in void segments, where the base
register value is runtime dynamic

<p>
A breakpoint value in the locator declaration can indicate a hardware
translation or index known in advance for addresses which are already
absolute in linked program terms
<pre>

	$(17:ADDRESS_IN_PROGRAM:ADDRESS_IN_HARDWARE)

</pre>
<p>
<b>$a</b> retrieves ADDRESS_IN_PROGRAM and not ADDRESS_IN_HARDWARE.
A separate function <b>$bank_index</b> retrieves that


<p>
<b>$a</b> function is also used in segments which are giant at
assembly time.
<pre>

	$($14::*00FFC800003F0000, r19)
	basev	+	$a:d	; double length:d

</pre>
<p>
Giant means address spaces larger than four gigaquanta.

<p>
The <b>$a</b> function works for relocatable segments which are for later
link-inclusion in giant spaces. But the constant must be large enough
to contain the linked address:
<pre>

	$(15:*8, r9)
	here	+	$a(here):d	; double length:d

</pre>
<p>
If the constant overflows, the link step fails with an error message.


<h4>4.2.3.2.2.4.4: $b -base address of current section
                   or -base address of current segment</h4>

<p>
<b>$b</b> in an absolute section retrieves the initial start address
of the section
<pre>

$(2:02000)

	$include	source1
	$include	source2

$(2:05000)

constant +		$b

</pre>
<p>
The value stored in location <b>constant</b> is <b>02000</b>

<p>
<b>$B</b> function in a relocatable section retrieves the link root of the
input segment within the link collection
<pre>

%masmx

$(2:*8)

	.
	.

constant +		$b

	$store		rel_file
	$end

%masmx

	$include	linkmacro.def

$(2:02000)
buffer	$res		03000
	$include,$binary rel_file.txo

</pre>
<p>
The value in location <b>constant</b> is <b>05000</b>.

<p>
<b>$b</b> does not concern the breakpoint address retrieved
with <b>$bank_index</b>


<h4>4.2.3.2.2.4.5: $bank_index -absolute or virtual memory space identity</h4>

<p>
For targets with hardware relocation, $bank_index retrieves the absolute
or virtual load pointer named in the breakpoint field of the location
counter switch statement
<pre>

	$(locator_number:relative_base_address:BREAKPOINT_VALUE)

</pre>
<p>
This value is naturally known if it has been named, but <b>$bank_index</b>
allows portable macro code to retrieve it

<p>
If assembly flag -v is not set, this breakpoint value is the absolute load
address of the section assembling. A section defined by locator number
may be breakpointed many times in one or many assemblies, making many
absolute banks. The value is an absolute word or byte address, and is
added to program-relative addresses to construct load string addresses

<p>
If assembly flag -v is set, this value is an abstraction like a handler
or descriptor index, and the binary output appends it to load string
addresses without interpreting it. A section defined by location counter
may breakpointed many times, constructing many banks at virtual (i.e.
assembly-time-independent) addresses

<p>

<b>$bank_index</b> retrieves the current section breakpoint whether
virtual or absolute

<p>
There are no parameters. Only the current breakpoint value of the
current section can be retrieved in this way.

<p>
An application of <b>$bank_index</b> is the export of long
absolute or virtual names
<pre>

	public_name*	$equ	$bank_index*/address_size++$


</pre>
<h4>4.2.3.2.2.4.6: $n -value of instruction $NAME, macro entry tag</h4>

<p>
When exported from a macro,
$n is a token for the low-order 32 bits of the macro $name value.
The whole 192-bit value is macro_name(0, 0)

<p>
$n may be used both 
<pre>

	inside $PROC..$END (instruction or structure macro) 
	
</pre>
<p>
and 
<pre>

	inside $FUNC..$END (value-generating macro).

</pre>
<p>
$n references the call name of the macro, which must be the label 
of a $NAME directive within the macro declaration.

<p>
For example where
<pre>

	$word   48
"$instruction" $form 8, 40
	.
	.
p       $proc
load*   $name   1
store*  $name   2
add*    $name   3
subtract* $name  4

	$instruction   $n, p(1,1)

	$end

</pre>
<p>
the call line
<pre>

	add     8193

</pre>
<p>
generates, shown as hex,
<pre>

	030000002001

</pre>
<p>
because the macro was called with the name add, 
which is worth 3, 3 is in the upper eight bits 
of the output instruction, and the 
operand address in the lower 40.

<p>
$n can also be retrieved as parameter p(0, 1) or p(0, 0)

<p>
parameter [macro_name](0, 0) is the same as [macro_name](0,1) because
subfield 0 is the same as subfield 1 for all parameter fields.

<p>
The result width of [macro_name](0, 0) and of all parameters is 192 bits.

<p>
The result width of $n is 32 bits.

<p>
Function macros written with $FUNC can also access $n or
[macro_name](0, 0) or [macro_name](0,1)

<p>
This user-written function uses its $n value to compute
an address relative to the trailing edge of 
either a two- or a three-byte relative-jump instruction:
<pre>

"$REL"  $func
"$REL2"* $name   2
"$REL3"* $name   3
target  $set    $REL(1,1)-($+$n)
	$if     target<-128)
	$flag   You may only jump from instr. trailing edge - 128
	$endif
	$if     target>127
	$flag   You may only jump from instr. trailing edge + 127
	$endif
	$return target
	$end

</pre>
<p>
Here are $PROC instruction macros which call 
$REL function.

<p>
"cjne" wants an 8-bit relative displacement from its own 
trailing edge, which is three bytes later than the location 
counter. $REL3 is called

<p>
"jc" and "jnc" want an 8-bit relative displacement from 
their trailing edge, which is two bytes later than the 
location counter. $REL2 is called.
<pre>


i$cjne_a        $form   8,8,8
i$cjne_r        $form   5,3,8,8
i$cjne_indirect $form   7,1,8,8

"$jumpcc"	$form 8, 8

p	$proc
cjne*	$name

        $if     ($t(p(1,1))=REGISTERS$)**(p(1,1)=A)
          $if   p(1,#2)
            i$cjne_a            0b4, p(1,2), $REL3(p(1,3))
          $else
            i$cjne_a            0b5, p(1,2), $REL3(p(1,3))
          $endif
        $elseif $t(p(1,1))=POINTER$
          $if   p(1,#2)
            i$cjne_indirect     05bh, p(1,1), p(1,2), $REL3(p(1,3))
          $else
            $flag Second Operand Must Be Immediate
          $endif
        $elseif $t(p(1,1))=RREGISTERS$
          $if  p(1,#2)
            i$cjne_r            017, p(1,1), p(1,2), $REL3(p(1,3))
          $else
            $flag Second Operand Must Be Immediate
          $endif
        $else
          $flag First Operand Must be A/Rn/@Rn
        $endif
        $end

p       $proc
jc*     $name   JC_CODE
jnc*    $name   JNC_CODE
	$jumpcc $n, $REL2(p(1,1))
	$end

</pre>
<p>
$n may also be accessed as parameter (0, 1) of the macro name.
In function $REL, $n could instead be retrieved as $rel(0, 1)
$rel(0,0) can be referenced with the same result, because subfield
0 is the same as subfield 1.


<h4>4.2.3.2.2.4.7: $net(..) -the unrelocated value of an expression</h4>

<p>
If an expression attempts algebra on a relocatable address,
very few operations are allowed. See 4.2.3.2.2.1: Operators Used
on Relocatable Tokens.

<p>
There may be reasons why algebra is needed on the unrelocated part of a 
relocatable address. For example, field range checks should be carried
out at assembly time on both absolute and relocatable code.

<p>
Relocatable code is also checked later at link, but it should be checked
that no part of the unrelocated value has outflowed.

<p>
Range checking at link is geometrically driven from within the linker.
But at assembly time only macro language can carry out checks.

<p>
It is also desirable that the same macro language is used for both
absolute and relocatable code generation.

<p>
No comparison operators are allowed on a relocatable address. The sequence
<pre>

p	$proc
jump*	$name	
target	$set	p(1, 1)

	$do	target>16777261,	$flag	you can't jump there

</pre>
<p>
would always error where p(1, 1) is relocatable, because comparison
operator > is not allowed on a relocatable.

<p>
The following is allowed
<pre>

	$do	$net(target)>16777261,	$flag	you can't jump there

</pre>
<p>
Labels which are not present are treated as external and therefore
relocatable.

<p>
Shift right /* algebraic shift right */- AND ** are always allowed on
relocatable values, to allow relocation of split and shifted fields.

<p>
Addition and subtraction are always allowed on relocatable fields.

<p>
See Sections 9.2: masmx Linking in Principle, 9.2.3: Demonstration Links
(PowerPC).

<p>
Information is encoded in the relocatable
binary output which causes the whole value to be relocated before
any shifts or truncations.  See Sections 9.2: masmx
Linking in Principle, 9.2.3: Demonstration Links (PowerPC).

<p>
When using $NET for address range checks in instruction macros,
or carrying out a range comparison any other way,
the address parameter should be cached in a label first.
In this example that label is called "target":
<pre>

p	$proc

jump*	$name	JUMP_OPCODE
jump_maybe* $name JIF_OPCODE

target	$set	p(1, 1)

	$do	$net(target)>(1*/ADDRESS_FIELD_SIZE)-1,	;
	$flag	jump address out of range

	jump_form	p(0, 0), target
	$end


</pre>
<p>
It may be inefficient to fetch the parameter tagged p(1, 1) more
than once, especially if the actual parameter calls function macros.


<h4>4.2.3.2.2.4.8: $o(.) -is this option set?</h4>


<p>
An expression whose value is 'A'..'Z' or 'a'..'z' is allowed in the
parentheses, and 1 is returned if the equivalent flag is on, for example:
<pre>

	$do	$o('k'),	$note flag -k is set

	$if	$o(65)=0
	$flag	flag -A should be set
	$endif 

</pre>
<p>
The flag is set by any of <b>-abcdefghijklmnopqrsuvwxyzEFGQZ+</b> anywhere 
on the command line, or with the <b>$SET_OPTIONS</b> directive.


<h4>4.2.3.2.2.4.9: $r -region

<h5>4.2.3.2.2.4.9.1: $r</h5>

<p>
Returns the identity, not the value, of the current 
location counter 0..71. 


<h5>4.2.3.2.2.4.9.2: $r(..)</h5>

<p>
returns the identity of named address expression's location counter


<p>
There should be a label in parentheses and "$R(label)" 
will return be the identity 0..71, of the location 
counter under which the label is generated.
				  
				  
<h4>4.2.3.2.2.4.10: $rel(..) -is this a relocatable location counter?</h4>


<p>
An expression identifying a location counter 0..71 is in the parentheses,
and $REL(x) tells you if it's a relocatable segment. No parentheses,
and $REL tells you if the current segment is relocatable. The
result isn't always 0 or 1. It's the load alignment factor of
the segment which is 0 for absolute and 1 or something higher
for relocatable.

<p>
This function can be cascaded with the previous one to
detect whether a label is relocatable
<pre>

	$if     $rel($r(label))
	.
	.


</pre>
<h4>4.2.3.2.2.4.11: $t(..) -what type of label</h4>


<p>
The return value from the $t(..) function is a type 
associated with a label. The type will either be 
assigned by the assembler or by the developer.

<p>
In this example, the developer has designated a type value, 
128, to mean registers. The imaginary architecture
here does not place registers in the memory address 
space, and the register tags must be detected in 
order to generate the correct instruction variant.

<p>
The contents of the parentheses must resolve to a label, 
typically an actual parameter to a macro.

<p>
There may be unary + - * # on the front of the argument. This is
not predictable for macro language examining actual parameters.

<p>
$t function steps over one unary symbol + - * # if present before
examining the label.

<p>
A macro parameter is examined here to decide 
whether it is the tag of a register or some other kind 
of address before the correct variant of the instruction 
can be chosen:
<pre>

"$instruction" $form    6, 6, 36
"$register_instruction" $form 6, 6, 6, 30
"$REGISTERS" $equ       128
R0      $equ,$registers 0
R1      $equ,$registers 1
	.
	.
R63     $equ,$registers 63


p       $proc
store*  $name   12
	$if     $t(p(1,2))=$REGISTERS
	$register_instruction $n+32, p(1, 1), p(1, 2), 0
	$else
	$instruction    $n, p(1,1), p(1,2)
	$endif
	$end

</pre>


<h4>4.2.3.2.2.4.11.1: Label Type Undefined</h4>

<p>
Labels which have not been defined before the start
of the second assembly pass may be tested for type, 
which will be 0. Any other reference to an undefined
label during the second assembly pass generates an
external reference, or if <b>-u</b> flag is set, an error.


<h4>4.2.3.2.2.4.11.2: Label Type Location</h4>

<p>
A label has the type of a storage address if it
has been encountered on column 1 of a source line, and
is not the label of a $EQU, $SET, $EQUF, $PROC, 
$FUNC, a $NAME in a $PROC or $FUNC, or the counter tag 
of a $DO, or the tag of a $LIT directive. 
	
<p>
The type and value of address labels cannot be changed.
However the same label name can be used independently
in different subassemblies (macro depths).
	
<p>
An address label has an associated location counter and 
is either absolute or relocatable.


<h4>4.2.3.2.2.4.11.3: Label Type $EQU</h4>

<p>
The label of a $EQU line has an absolute or a relocatable 
value according to the the argument to which it's equated.

<p>
$EQU labels are not intended to be equated more than once
per subassembly. A warning is output if they are.

<p>
Any label name may be defined independently in different
subassemblies.


<h4>4.2.3.2.2.4.11.4: Label Type $SET</h4>

<p>
The label of a $SET line has an absolute or a relocatable 
value according to the argument to which it's set.

<p>
$SET labels are intended to be reassigned at will.
$SET is actioned on both assembly passes.

<p>
Any label name may be defined independently in different
subassemblies.

<p>
The label of a $DO, which accumulates in value as
a relative-1 counter, has a type of $SET.
	

<h4>4.2.3.2.2.4.11.5: Label Type $EQUF</h4>

<p>
$EQUF equates a label to a list of values and the label has
the type $EQUF. This enables macro processing to assign to
subassemblies a transparent number of subparameters.

<p>
When parameter reference is resolved, the preassembled values
in the $EQUF label are individually accessed, thus
<pre>

load    $proc
	lwz     load(1, 1), load(1, 2)(load(1, 3))
	$end

</pre>
<p>
table_reference $equf   lookup, r31
<pre>

	load    r3, table_reference

</pre>
<p>
resolves to
<pre>

	lwz r3,lookup(r31)

</pre>
<p>
If the $EQUF name is a component of an expression, 
it's its first value, "lookup" in this example, which is
considered a principal value and is returned.
<pre>

MASMX 7r2
3/lodation.msm
LTERM=#
CONT_CHAR=
STERM=.
*EOF*
  :                            1:         $include "ppc1.def"
  :                            2 load*   $proc
  :                            3      lwz   load(1,1),load(1, 2)(load(1,3))
  :                            4         $end
  :                            5 
  :                            6 lookup  $equ    101
  :                            7 table_reference $equf   lookup, r31
  :                            8 
00:00000000 807F0065          +9         load    r3, table_reference
  :                            10 
*EOF*
:$(00):00000000:00000004 
lodation.msm: object code 54 bytes: 0 errors: 0 undefined labels

</pre>


<p>
Any of the values in the $EQUF may be retrieved with label\X

<p>
In that assembly. table_reference\1 would retrieve the value
"lookup", equal to 101.

<p>
table_reference\2 would be the tag value identifying r31

<p>
Any $EQUF attributes retrieved via \selector are net of relocation.

<p>
Any \selection outside the set which has been declared (here 1 and 2)
gives a result of 0.



<h4>4.2.3.2.2.4.11.6: Label Type $DIRECTIVE</h4>


<p>
The labels of directives available when the assembler begins 
to execute have the type $DIRECTIVE. The developer may also
alias those directives by giving equates the type of 
$DIRECTIVE, thus
<pre>

MACRO   $equ,$directive $proc
MACEND  $equ,$directive $end


</pre>
<h4>4.2.3.2.2.4.11.7: Label Type $FUNCTION</h4>    


<p>
The internal functions available when the assembler begins
to execute have the type $FUNCTION. The developer may also
alias those functions by giving equates the subtype of $FUNCTION,
thus
<pre>

	$cont_char	'|'
. semicolon is no longer the line continue

	$lterm		';'
; period is no longer the comment character

	$sterm		'.'
; period can now be used within a label

.       $equ,$function  "$"   ; $ is now also named .


</pre>
<p>
This only equates "." to location counter function "$" if "$"
is in quotes as shown. This retrieves the functional identity
of "$" for "."

<p>
"." now means the location counter function.

<p>
Without the quotes $ is evaluated functionally and "." receives
the current location value. That would render "." an unusable function

<h4>4.2.3.2.2.4.11.8: Label Type $PROC</h4>


<p>
The label on column 1 of the $PROC card is the name of the
macro. Its meaning is all the images from $PROC to $END, and
it has the label type of $PROC.

<p>
If a $PROC name is encountered on the command field of a
line, the macro is expanded, if the label is made visible*
outside the $PROC with a trailing asterisk.

<p>
If the name of the macro currently being expanded
is encountered when evaluating an operand expression, 
then a parameter reference is resolved:
<pre>

this_macro*      $proc
	jump    this_macro(1, 4)
	$end

	this_macro 1, 2, 3, away

</pre>
<p>
has the effect "jump away"

<p>
this_macro* has to be unique to the subassembly calling it.
$PROC labels often aren't unique, and aren't exported with
the trailing asterisk* Then the macro must contain an exported
$NAME which has a asterisked_label*

<p>
<b>$PROC</b> macros also have a unique numeric identity attached
to their name, if their name is unique*

<p>
That identity is returned if the <b>$PROC</b> name is referenced
functionally
<pre>

$ masmx -ln
MASMX 7r2
0/-INPUT>>

	$word	16

var*    $proc   $(1)
*       $res    var(1,1)
        $end

	.
	.

align*	$proc
	$if	($t(align(1,1))=$proc)**(align(1,1)=var)
granule	$set	align(1, 2)
	var	granule-($(1)**granule-1)
	$else
granule	$set	align(1, 1)
	$do	granule-($**granule-1),	-	1
	$endif
	$end

$(1:1024)	.	variables
$(0:256)	.	invariables
	
	$do	5,      -	4

firstly	var	21
	align	var, 8
secondly var	4

	align	8
	+	99
	+	firstly
	+	secondly


	$end

  :                            1 
  :                            2  $word 16
  :                            3 
  :                            4 var*    $proc   $(1)
  :                            5 *       $res    var(1,1)
  :                            6         $end
  :                            7 
  :                            8  .
  :                            9  .
  :                            10 
  :                            11 align* $proc
  :                            12  $if ($t(align(1,1))=$proc)**(align(1,1)=var)
  :                            13 granule $set align(1, 2)
  :                            14  var granule-($(1)**granule-1)
  :                            15  $else
  :                            16 granule $set align(1, 1)
  :                            17  $do granule-($**granule-1), - 1
  :                            18  $endif
  :                            19  $end
  :                            20 
  :                            21 $(1:1024) .	variables
  :                            22 $(0:256) .	invariables
  :                            23  
00:0100 FFFC                  +24  $do 5,      - 4
00:0101 FFFC                  +24 
00:0102 FFFC                  +24 
00:0103 FFFC                  +24 
00:0104 FFFC                  +24 
  :                            25 
  :                            26 firstly var 21
  :                            27  align var, 8
  :                            28 secondly var 4
  :                            29 
00:0105 FFFF                  +30  align 8
00:0106 FFFF                  +30 
00:0107 FFFF                  +30 
00:0108 0063                  +31  + 99
00:0109 0400                  +32  + firstly
00:010A 0418                  +33  + secondly
  :                            34 
  :                            35 
  :                            36  $end
:$(00):0100:010B :$(01):0400:041C 
-INPUT>>: object code 113 bytes: 0 errors: 0 undefined labels


</pre>

<h4>4.2.3.2.2.4.11.9: Label Type $NAME</h4>


<p>
$NAME is used within macro text $PROC..$END or $FUNC..$END
to give alternative call names associated with a call value
to the macro. $NAME labels return a type of $NAME.

<p>
Macro labels do not need to be unique, so long as they have
unique $NAME entry points.
	
<p>
Therefore it's possible to have similar or identical cryptic
labels for all $PROC declarations. For example:
<pre>

instruction_form $form 8, 8, 16

p       $proc
grabit* $name   1
dropit* $name   2
	instruction_form   $n, p(1, 1), p(1, 2)
	$end

</pre>
<p>
If the developer has called many procedural macros P, then
P is not used as a call name, but the $NAME names are:
<pre>

	grabit  r12, input_port
	dropit  r12, output_port

</pre>
<p>
Whatever macro you're writing, if it's called "p",
its argument paraforms are then p(1,1) p(1,2) etc, 
which makes it easy to write the macros. $NAME then 
makes it easier to call the macros.

<p>
If the macro is instead called "pqrpqr" then its parameters are
referenced by macro code within pqrpqr as pqrpqr(1, 1), pqrpqr(1, 2) etc.

<p>
Whether you want to call a macro by its $PROC label or a $NAME label,
that label must be exported by having a trailing asterisk* Any label
so exported from a $PROC must be unique to the next subassembly level
upwards.


<h4>4.2.3.2.2.4.11.10: Label Type $FUNC</h4>


<p>
Developer-written function labels return a type of $FUNC.
Developer-written functions are all functions which are 
not internal to masmx, including functions in header files 
supplied with this package. They are macros which return
values which may be referenced in expressions.

<p>
A $FUNC type label is the label on column 1 of a $FUNC 
line. This is a user written value-generating macro and 
its meaning is the expression on the first $RETURN line 
actioned in the macro text $FUNC..$END

<p>
$FUNC macros are expanded when encountered during evaluation
of an operand expression, for example
<pre>

@*      $func
	$return $(1)
	$end

length_of_variables     $set    @-START_OF_VARIABLES
	
</pre>
<p>
This example is from the mapping of external RAM in a
microcontroller system. The developer uses location counter $(1)
to map external RAM and wishes $(1) to be known as @. 
	
<p>
@ returns the next available address in variable space.


<h4>4.2.3.2.2.4.11.11: Label Type $FORM</h4>


<p>
A label declared as $FORM returns the type $FORM and
describes the layout of an instruction or similar
bit-structure.

<p>
When a $FORM label is encountered in the command position
the corresponding storage structure is generated inline.
<pre>

powerpc_load_store_instruction  $form   6, 5, 5, 16

p       $proc
lwz*    $name   LWZ
stw*    $name   STW
lbz*    $name   LBZ
stb*    $name   STB
	.
	.
	powerpc_load_store_instruction $n,p(1, 1),.index\p(1, 2),p(1, 2)
	$end



</pre>
<h4>4.2.3.2.2.4.11.12: Label Types Assigned by the Developer</h4>


<p>
Label type values 128..255 are available to the developer
who may designate them to associate special attributes with
certain names. For example, a definition file for M68K might
contain
<pre>

data_register   $equ    128
address_register $equ   129
pointer_register $equ   130
special_register $equ   131

d0      $equ,data_register      0
d1      $equ,data_register      1
	.
	.
d7      $equ,data_register      7

a0      $equ,address_register   0
a1      $equ,address_register   1
	.
	.
a7      $equ,address_register   7
	.
	.
a0@     $equ,pointer_register   0
a1@     $equ,pointer_register   1
	.
	.
a7@     $equ,pointer_register   7
	.
	.
ssp     $equ,special_register   $0407
usp     $equ,special_register   $0007
cr      $equ,special_register   1

</pre>
<p>
Because the 68K target (and nearly all CISC targets)
use the same mnemonics, ADD, MOVE etc, for functional
groups of instructions which have different opcodes
depending on the class of operands (memory, various
register classes), names may be typed and the type
may be retrieved with $T(..)
<pre>

p       $proc
move.b* $name   MOV_B
move.w* $name   MOV_W
move.l* $name   MOV_L
	$if     $t(p(1,1))=data_register     
	.
	.

</pre>
<h4>4.2.3.2.2.5: Function Macros</h4>

<p>
Operand expressions may include user function macros, described in
section 5.1

<h4>4.2.3.3: Literals</h4>

<p>
An operand may be a literal, described in section 5.2


<h1>5: Functions and Literals</h1>                        


<h2>5.1: User-written Functions</h2>


<h3>5.1.1: A Function Is</h3>


<p>
Functions are not code subroutines (as they are in C-Language).

<p>
masmx functions are macros which return values at assembly time.

<p>
User written functions return a computed value for use in an expression.

<p>
Functions mostly contain directives, because they don't
generate code: 
<pre>

simplog*	$func
		$do	simplog(1,1)=64,	$return	6
		$do	simplog(1,1)=8,		$return	3
		$flag	bucket can only be 8 bytes or 64 bytes
		$return	0
		$end

...
		shift_left	r6, simplog(BUCKET_SIZE)


</pre>
<h3>5.1.2: Directives for Constructing Functions</h3>


<h4>5.1.2.1: $FUNC -head of function</h4>
<pre>


function_name  $FUNC
	.
	.

</pre>
<p>
There must be a label when the command is $FUNC.
$FUNC can have an argument
<pre>

fname*  $FUNC	*
	.
	.

</pre>
<p>
* is the only argument $FUNC can have. It means
"second pass only", or don't expand this macro on
the first assembly pass. The use of this is
explained in Section 8.22: $FUNC directive.


<p>
Second-pass-only functions are used to generate a data item
once only by reference.

<p>
They prevent the situation where the data is not generated on the
second pass because its label was generated on the first pass:
<pre>


f*      $func
	$if     $t(f(1,1))=0  . Non-existent?
"f(1,1)"** generate f(1,1)    . generate label and data
	$endif
	$return f(1,1)        . return label value
	$end
	.
	.
	call    f(ROUTINE)

</pre>
<p>
One way of solving this problem is a literal,
which doesn't get duplicated and doesn't have
a label. But the functional result of a literal
is the address of a constant, and you may want
your function to do something more complicated
than that.

<p>
Another way of solving the problem is to stop
"f" from expanding on the first pass:
<pre>

f*      $func	*
	$if     $t(f(1,1))=0  . Non-existent?
"f(1,1)"** generate f(1,1)    . Generate Label and Data
	$endif
	$return f(1,1)        . return label value
	$end
	.
	.
	call    f(ROUTINE)

</pre>
<p>
The * asterisk argument on the $FUNC directive makes the function
a second-pass-only function



<h4>5.1.2.2: $NAME -entry point and invocation tag</h4>

<p>
It's easier to code functions (like $PROCs) if
they all have the same name. But it's easier to
call them if they have unique names as well:
<pre>

f       $func	*
Distant_Routine* $NAME
	$if     $t(f(1,1))=0  . Non-existent?
"f(1,1)"** generate f(1,1)    . Generate Label and Data
	$endif
	$return f(1,1)        . return label value
	$end
	.
	.
	call    Distant_Routine(ROUTINE)

</pre>
<p>
$NAME can have an argument value in the $FUNC context
exactly as in the $PROC context:
<pre>

f       $func	*
Distant_Routine* $NAME '0'
Distant_Destiny* $NAME '1'
	$if     $t("f(1,1):f(0,1)")=0  . Non-existent?
"f(1,1):f(0,1)"** generate f(1,1, $N)
			      . Generate Label and Data
	$endif
	$return "f(1,1):f(0,1)". return label value
	$end
	.
	.
	call    Distant_Routine(ROUTINE)
	goto    Distant_Destiny(AFAR)

</pre>
<p>
"f(0, 1)" and $N both mean the argument value of $NAME.
Labels or anything else in quotes inside a macro body can be
constructed to include macro parameters.


<h4>5.1.2.3: $RETURN -value of result</h4>

<p>
The argument of $RETURN is an expression.
192 bits of it are returned:
<pre>

	$return expression

</pre>
<p>
$RETURN also leaves the containing macro, and this is true of $PROC
macros as well as $FUNC macros, although $PROC macros do not have
a result value.


<h4>5.1.2.4: $END -foot of function</h4>


<p>
$END is the last command on any subassembly.
A $FUNC is a subassembly (a macro):
<pre>

f       $func
	.
	.
	$return something
	$end


</pre>

<h3>5.1.3: Code Generated During Function Evaluation</h3>

<p>
Code can't be generated inline to the current
location counter during a $FUNC. That's treated
as an error.

<p>
Here function macro "f" calls a macro "generate" to build a 
data item out of line (In locator 42), and  
attach the label to it, and then
return to whatever the old location counter
was:
<pre>

f*      $func	*
	$if     $t(f(1,1))=0  . Non-existent?
"f(1,1)"** generate f(1,1)    . Generate Label and Data
	$endif
	$return f(1,1)        . return label value
	$end
	.
	.
p       $proc   $(42)        
generate* $name
*       +       address_of_resolver_routine
	"p(1, 1)"
	$end
	.
	.
	call    f(ROUTINE)

</pre>

<h2>5.2: Literals</h2>


<h3>5.2.1: A Literal Is</h3>

<p>
Literals are a kind of function. A constant is generated by reference,
and the result of that is the address of the constant.
<pre>

	Load    r24, .literal_pool_name(0FFFC0000)

</pre>
<p>
R24 gets loaded with a word containing 0FFFC0000. That word is generated
at the end  of the segment that "literal_pool_name" was declared in.


<h3>5.2.2: The Literal Pools</h3>


<p>
Each of the 72 location counters may have one literal pool.

<p>
Within one literal pool, identical literals are not duplicated. All
references get the same one.

<p>
If a location counter is breakpointed (many segments declared
with the same location counter), each part gets a literal table,
and identical literals may occur in each part, but not more than
once in each part.

<p>
Location counters which are breakpointed more than 64 times are only
allowed literals in the first 64 parts. Literal pools are not appropriate
for each element of a giant array.


<h3>5.2.3: Literal Pool Tags</h3>


<p>
Literal Pool Tags are labels of literal pools, and referencing them
acts functionally to generate a literal and return its address

<p>
Each literal pool may have any number of tags.

<p>
Literal Pool Tags may be generated: 
<ul>

	on the location counter control line:

</ul>
<pre>
$(5:DATA_SEGMENT/literal_pool_5)
</pre>
<ul>
	as the label of a $LIT directive:

</ul>
<pre>
lits7  $LIT    7
</pre>

<h3>5.2.4: The $LIT Directive</h3>


<p>
$LIT may have a label and may have an argument.
If $LIT has an argument it must be the identity
of a location counter 0..71.

<p>
If $LIT has no argument its effective argument
is the identity of the current location counter.

<p>
$LIT always sets the default location counter
for literals to the value in its argument or
to the current location counter.

<p>
The default location counter for literals is
only used by automatic literals (literals which
are generated without referencing a literal
pool tag).

<p>
If $LIT has a label, the label becomes a literal
tag for the literal pool.



<h3>5.2.5: Automatic Literals</h3>


<p>
Automatic literals are literals which are generated
in the current default literal pool without referencing 
a literal pool tag.

<p>
The default literal pool is at the segment-end of the default
location counter for literals.

<p>
Option <b>-a</b> must be on to allow automatic literals.

<p>
Automatic literals are generated if any field in certain
kinds of source lines is entirely in parentheses.

<p>
Mostly these source lines are instructions, where the command
is a macro which generates code under the control of a $FORM:
<pre>

	Load    r24, (0FFFC0000)

</pre>
<p>
The fields generated to fill the $FORM are tested for automatic literal
syntax when <b>-a</b> flag is on.

<p>
In that example, 0FFFC0000 is generated at the end of the assembly or
location counter breakpoint. The address of the literal goes in the
load instruction.

<p>
masmx also generates automatic literals where an integer line item has all
its expression part in parentheses and separate from the operative unary:
<pre>

	+       (1.75)  . 
	+       (BIG), (ADDRESSES) .


</pre>
<p>
Literals are rarely used on PowerPC, because two instructions are mostly
used to place immediate 16-bit values in each half of a register. However
these examples are about what masmx can do for any target.

<p>
In the following assembly, automatic literals are allowed from line 8.

<p>
Line 9 says automatic literals will be generated in location counter 8.

<p>
The assembly has <b>-d</b> flag set to display the real load
address of the locator 0 segment. 

<p>
Line 12 causes a literal to be generated at address 08180,
which is after the 384-byte buffer at line 3.

<p>
Line 13 causes another literal right after that at 08184.

<p>
The operands in lines 15 and 16 aren't literals.
They're straightforward address expressions.

<p>
Line 19 causes two literals to be generated.

<p>
The right-hand half of line 20 references a literal, but it's the same
literal as the right-hand half of line 19, so it's not generated again.

<p>
The left-hand half of line 21 references a literal, but it's the same
one as the left-hand half of line 1, so it's not generated again.

<p>
Line 22 references two literals, but they're the literals generated for
line 19, so they're not generated again.

<p>
There are no literals on lines 23, 26, 27.

<p>
Line 28 references the literal that was generated at line 12.

<p>
Line 29 generates a literal in location counter 5.

<p>
Line 31 generates three literals and references the third one at address
08198 which references the second one at address 08194 which references the
first one at address 08190.

<p>
Lines 32 and 33 both access the same literal. They load its address, not
the first word of its value.

<p>
Line 34 generates a string literal at the end of the instruction segment
And loads the address of the literal (not the first word of the literal)
via base-displacement reference. This literal is not automatic. Its
location is steered by the literal tag ".00"

<p>
The destination register field in the macro li is the five bits
immediately above the lower 16 bits. The base register used building
the address is the five bits below the six-bit opcode.

<p>
Line 35 generates and loads an address literal at the end of the
instruction segment. This is via literal tag ".00" and not an automatic
literal. The literal is at a high address and referenced via
base-displacement.

<p>
There is no literal on line 36. The operand is referenced by
base-displacement.

<p>
There is no literal on line 37. The immediate operand is built via
base-displacement.
<pre>


MASMX 7r2
3/ll6abs.msm
LTERM=#
CONT_CHAR=
STERM=.
*EOF*
  :                            1:         $include        "ppc3.def"
  :                            2 $(8:0x08000)
  :                            3         $res    384
  :                            4 $(15:524288)
  :                            5 rife    $res    512
  :                            6 somewhere_big
  :                            7 $(5:0x05000/.05)
  :                            8 $(0::0x0144000,r2/.00)
  :                            9         $set_option "a"
  :                            10         $lit    8
  :                            11 rro     $form   16, 16   
  :                            12         
00:00144000 80608180          +13         lwz     r3, (.(15)+262144)
00:00144004 90608184          +14         stw     r3, (.(15)+262145)
  :                            15 
00:00144008 80800600          +16         lwz     r4, +(1536)
00:0014400C 90800801          +17         stw     r4, +(2049)
00:00144010 48000024          +18         b       along
  :                            19 
00:00144014 000081880000818C  +20 __x     +       (.(15)+262142), (.(15)+262141)d       
00:0014401C 000C01FE0000818C  +21 __y            +(.(15)+262142), (.(15)+262141)d       
00:00144024 00008188000C01FD  +22         +       (.(15)+262142), +(.(15)+262141)d       
00:0014402C 8188818C          +23         rro     (.(15)+262142), (.(15)+262141)d
00:00144030 01FE01FD          +24         rro     +(.(15)+262142), +(.(15)+262141)d
  :                            25 
00:00144034 48000028          +26 along   b       down
00:00144038 000C0200          +27         +       +(.(15)+262144)
00:0014403C 000C0200          +28         +(.(15)+262144)
00:00144040 80A08180          +29         lwz    r5, (.(15)+262144)
00:00144044 80C05000          +30         lwz    r6, .05(.(15)+524289)
00:00144048 80E08198          +31         lwz    r7, (((rife)))
00:0014404C 6006819C          +32         ori     r6,, ("String")
00:00144050 6007819C          +33         ori     r7,, ("String")
00:00144054 64480068          +34       li      r8, .00("more_string")
00:00144058 81220074          +35       lwz     r9, .00(somewhere_big)
00:0014405C EB020014          +36 down    ld      r24, __x
00:00144060 6459001C          +37       li      r25, __y
00:00144064 4E800020          +38         blr
*EOF*
00:00144068+6D6F72655F737472696E6720
00:00144074+00080200
05:00005000+00100201
08:00008180+000C0200
08:00008184+000C0201
08:00008188+000C01FE
08:0000818c+000C01FD
08:00008190+00080000
08:00008194+00008190
08:00008198+00008194
08:0000819c+537472696E672020
:$(00):00000000:00000078 :$(05):00005000:00005004 :$(08):00008000:000081A4 :$(0F):00080000:00080200 
ll6abs.msm: object code 537 bytes: 0 errors: 0 undefined labels


</pre>
<p>
If -A is selected to allow automatic literals, code and macro language
should not include expressions that begin with left-parenthesis,
if the expression is not meant as a literal.

<p>
A unary plus in front of the opening parenthesis will suppress the
accidental generation of a literal:
<pre>

p       $proc
b*      $name   18
bl*     $name   18++1*/6
	$if     .net(p(1,1))**3
	$flag   You can't jump there
	$endif
	i$1     p(0, 1), +(p(1, 1)-.)+p(0, 1)/*6
	$end

</pre>
<p>
Automatic literals are not available unless switched on with <b>-a</b> option.

<p>
There may be a preceding unary *(before_the_literal)

<p>
This is an example of a target which has an indirection
flag in the instruction notated with * on the operand
<pre>

	lr	r3, *(VERY_BIG_ADDRESS)

</pre>
<p>
A literal containing VERY_BIG_ADDRESS is generated

<p>
Macro language places the address of the literal in the instruction

<p>
Macro language interrogates for unary * and sets its present or
absent value in the indirection bit of the instruction.

<p>
The value stored at location VERY_BIG_ADDRESS is loaded into r3
when the instruction is executed.

<p>
Unary symbols other than * left of the first parenthesis cause the parentheses to be part of an expression and no literal is generated:
<pre>

	la	a0, +(ANOTHER_BIG_ADDRESS)

</pre>
<p>
+(ANOTHER_BIG_ADDRESS) is an expression, not a literal. An attempt is made
to place ANOTHER_BIG_ADDRESS in the address field of the instruction.

<p>
It's possible to generate nested literals, but this may not be intended.
The nested literal is only generated if it both begins and ends with
parenthesis. The opening parenthesis may have a flag * token in front:
<pre>

$ masmx constanz -ln
MASMX 7r2
3/constanz.msm
  :                            1 	$word		32
  :                            2 constanza $form		1, 31
  :                            3 
  :                            4 	$set_option	"a"
  :                            5 	$lit		5
  :                            6 	$plist		5
  :                            7 
  :                            8 instanza*	$proc
  :                            9 	constanza	instanza(1, *1), instanza(1, 1)
  :                            10 	 $end
  :                            11 
  :                            12 $(5:050000)
05:00050000 80050003          +13  	instanza	*(instanza *(instanza *(99)))
  :                            14 	$end
05:00050003+80050002
05:00050002+80050001
05:00050001+00000063
:$(05):00050000:00050004 
constanz.msm: object code 95 bytes: 0 errors: 0 undefined labels

</pre>
<p>
This is next example does not generate a nested literal. It is an
expression within a literal:
<pre>

$ masmx -ln
MASMX 7r2
0/-INPUT>>
	$word	32
	$set_option	"a"

	+	((99)+2)
	$end
  :                            1  $word       32
  :                            2  $set_option "a"
  :                            3 
00:00000000 00000001          +4  + ((99)+2)
  :                            5  $end
00:00000001+00000065
:$(00):00000000:00000002 
-INPUT>>: object code 77 bytes: 0 errors: 0 undefined labels


</pre>
<h1>6: Describing the Target Architecture in Text</h1> 

<p>
If you're not using a ready made header file, you need
to construct one. Either way, the first line in the
main file of your assembly is something like
<pre>

	$include        "target.def"

</pre>
<p>
Once you've done that, you've established
<ul>
	How your source code talks to masmx (syntax)
<pre></pre>

	What your target machine looks like (architecture)

</ul>
<p>
Perhaps <b>target.def</b> allows <b>$include</b> to be called
<b>include</b>, because the existing code calls <b>include</b>
<pre>
	include device.def
	include uart.def
	include maths.inc

</pre>

<h2>6.1: Establishing your Syntax</h2>

<p>
All directives are explained in full in alphabetical order
in Section 8: Directives

<p>
When masmx starts running,
<ul>
	semicolon is line continuation
<pre></pre>

	period is line termination (comment)
<pre></pre>

	period does not terminate the line
	if it is followed immediately with a nonspace
	token, as
        <pre>

		$include	file.name
		+		1.8	. floating value

        </pre>
	Any other comment character terminates the
	line unconditionally:
        <pre>

		$lterm		'#'

		+		1.75	#floating value

	</pre>
	No symbol inside single or double quotes terminates the line
<pre></pre>

	text string delimiter is "
<pre></pre>

	substring delimiter is colon
<pre></pre>

	leading zero on a number is hex
<pre></pre>
	numbers beginning 1..9 are decimal
<pre></pre>
	numbers beginning \ are bit-pattern binary

</ul>
<p>
If you don't want semicolon to mean line continuation
that's the first thing you change. If you don't want
line continuations at all
<pre>

	$CONT_CHAR       0

</pre>
<p>
Continuation character is not recognised if if is followed immediately
by a nonspace token
<pre>

$ masmx -ln
MASMX 7r2
0/-INPUT>>
	$cont_char       '\'
CONT_CHAR=\
	$word		32
	+		\10101010\	bit pattern 0xAA and line continue
			*/16\		shift left 16 and line continue
			++3     	. OR 3
	$end
  :                            1  $cont_char '\'
  :                            2  $word  32
00:00000000 00AA0003          +3  +  \10101010*/16++3  . OR 3
  :                            4  $end
:$(00):00000000:00000001 
-INPUT>>: object code 54 bytes: 0 errors: 0 undefined labels

</pre>
<p>
If you want comment to be semicolon
<pre>

	$LTERM  ';'

</pre>
<p>
If you want text strings to be bounded by apostrophe
<pre>

	$QUOTE  027

</pre>
<p>
or maybe
<pre>

	$QUOTE  ''''

</pre>
<p>
However macro language does not recognise parameterised label
references inside single quotes-see Section 8.42: $QUOTE directive.

<p>
If you want substring delimiter to be period
<pre>

	$STERM  '.'

</pre>
<p>
If you want inputs with leading zero to be octal and
displays to be octal
<pre>

	$OCTAL

</pre>
<p>
If you change your mind
<pre>

	$HEX

</pre>
<p>
If you have number strings in your code with trailing 
flags like 123q or 0abaH 
<pre>

	$SUFFIX 2

</pre>
<p>
If you want leading 0... to be octal and leading 0x... to be hex
<pre>

	$SET_OPTION     "c"

</pre>
If you want leading $... to be hex
<pre>

	$SET_OPTION     "m"

</pre>
If you want both
<pre>

	$SET_OPTION     "mc"

</pre>
<p>
If you've done that and you still want to access masmx-supplied
functions like location counter "$" and identity of location
counter "$r" without using quotes, you alias masmx 
function names (It's assumed here you've changed $STERM to period):
<pre>

.           $equ,"$function"    "$"
.locator_id $equ,"$function"    "$r"
.class      $equ,"$function"    "$t"

</pre>
<p>
This equates
<pre>

	.		to location counter function		"$"

	.locator_id	to function yielding id of
			current counter of reference	    	"$r"

	.class		to function yielding label type		"$t"


</pre>
<p>
if "$" "$r" "$t" are in quotes as shown. This retrieves the functional
identities of
<pre>

	"$"		for	. 

	"$r" 		for	.locator_id

	"$t"		for	.class


</pre>
<p>
Without the quotes $ $r $t return their functional value instead
of their identity.

<p>
The quotes are necessary to give "$" "$r" "$t" the new names
. .locator_id .class

<p>
Directives beginning with $ when Motorola Hex (option <b>-m</b>) is
asserted are still recognised in the command field, but not
in the subcommand or argument fields. If your code has many
directives with other names, you may alias masmx directives:
<pre>

.equ    $equ,"$directive"       "$equ"
.if     .equ,"$directive"       "$if"
.elseif .equ,"$directive"       "$elseif"
.else   .equ,"$directive"       "$else"
.endif  .equ,"$directive"       "$endif"
.macro  .equ,"$directive"       "$proc"
.macend .equ,"$directive"       "$end"

</pre>
<p>
If your code has directives with no masmx equivalent, you write
the required directives as macros.
<pre>

.org*   .macro
$(0:.org(1,1))
	.macend

.align* .macro
granule $set   1*/.align(1,1)
	$res    (.+granule-1**-granule)-.
	.macend

.globl*	.macro
".globl(1,1)"**	$blank
	.macend

</pre>

<p>
If your code contains operators that aren't
<pre>

= ^= > < -- ++ /* */ ** + - /// // / * *+ *- ^ ()

</pre>
<p>
you need to translate some text on input
<pre>

	$text   /!=/^=/
	$text	\<=\-1<\
	$text	/>=/+1>/
	$text   \%\///\
	$text   /|/++/
	$text   \<<\*/\
	$text   \>>\/*/
	$text   /&/**/
	$text   /^/--/
	$text   /~/^/

</pre>
<p>
or perhaps
<pre>

	$text   / EQ /=/
	$text   / NE /^=/
	$text   \ LT \<\
	$text   / GT />/
	$text	\ LE \-1<\
	$text	/ GE /+1>/
	$text   \ MOD \///\
	$text   / OR /++/
	$text   \ SHL \*/\
	$text   \ SHR \/*\
	$text   \ ASHR \*/-\
	$text   / AND /**/
	$text   / XOR /--/
	$text   / NOT /^/

</pre>
<p>
All $TEXT directive lines must be together in your header.
masmx will only search one sequence of $TEXT in the label
table, for efficiency.

<h2>6.2: Describing the Target Architecture</h2>


<p>
The directives which are central to masmx are described here
in related groups and described in alphabetical order in
Section 8: Directives.

<p>
All directives appear in the instruction field of the assembly 
language line.



<h3>6.2.1: $WORD, $BYTE, $QUANTUM, $AWIDTH</h3>

	       
<p>
It's nowhere assumed that your machine has a word size like
8, 16, 32 or 64, or that its address quantum is an 8-bit byte.

<p>
These four directives describe the basics of the machine
to masmx.
<pre>


	$WORD   bits_in_computer_word

</pre>
<p>
$WORD defines the smallest amount of code that can be generated 
from one source line. See also $QUANTUM. One guide to selecting 
word is the size of the smallest instruction in the instruction
set. If the machine has single-octet instructions $WORD must be
8. 32 is suitable for PowerPC, 16 for m68k or ColdFire.
<pre>

	$BYTE   bits_per_character

</pre>
<p>
$BYTE defaults to 8. It can be set to anything and character 
strings are packed accordingly.
<pre>

	$QUANTUM  bits_in_addressable_location

</pre>
<p>
$QUANTUM is the same as $WORD for very few computer 
architectures. Nevertheless $WORD automatically sets 
$QUANTUM and $AWIDTH. For PowerPC and Alpha:
<pre>

	$WORD      32
	$QUANTUM   8

</pre>
<p>
are suitable settings.
<pre>

	$AWIDTH         bits_in_address

</pre>
<p>
$AWIDTH describes how many bits are used to express 
a load address in the the assembly output file. 8-bit 
microprocessors and microcontrollers have a word size 
of 8 but usually an address width of 16, so it is 
necessary to override the default address width set 
by $WORD:
<pre>

	$WORD           8
	$AWIDTH         16

</pre>
<p>
$AWIDTH has a second part for the giant part of
address space, for example:
<pre>

	$awidth         32:64

</pre>
<p>
This allows the 32-bit location counters to be stepped
through astronomic space when constructing giant code
and data. One instruction stream or array scalar may only
be constructed to a size of 4 gigaquanta, but an array
of either may be constructed up to 2 power 192 in size

<p>
See also section 9:	Output File Formats, Relocation and Linking,
			Giant Address Spaces, Interfacing with GNU Tools


<h3>6.2.2: $FORM, $PROC, $NAME, $END</h3>


<p>
These four directives are the building blocks of machine
instructions and architectural descriptors.

<h4>6.2.2.1: The $FORM Template</h4>
<pre>

label   $FORM   bit_field_width, ...,bit_field_width

</pre>
<p>
$FORM describes a microstructure, especially an instruction 
layout, of any size up to 192 bits. For example, load/store
instructions for PowerPC have the layout
<pre>

"$load_store_instruction" $form   6, 5, 5, 16    


</pre>
<h4>6.2.2.2: The $PROC Header</h4>
<pre>      

label   $PROC

</pre>
<p>
$PROC begins an inline macro which may be used in the command field
(a $FUNC is a value-generating macro used in expressions).

<p>
The label on a $PROC or a $FUNC can only be used as a macro
call if it has an asterisk* to make it visible outside the macro.

<p>
In the following example, "p" is not visible outside the macro,
and could be used as the header label of other macros without problems.

<p>
Because "p" is not visible outside the macro, the macro can only be
called with the names "lwz" and "stw"

<p>
The label of a $PROC is used functionally to 
reference actual arguments, for example 
<pre>

p       $proc
	.
lwz*	$name	OPCODE_LWZ
stw*	$name	OPCODE_STW
	.
	$instruction_form   p(0, 1), p(1, 1) .index\p(1, 2), p(1, 2)
	$end

</pre>
<p>
p(0, 1) references the command on the call line,
p(1, 1) the first argument subfield. See Section 
4.2.3.2.2.3: Macro Parameters


<h4>6.2.2.3: The $NAME Entry Point</h4>
 <pre> 

label*   $NAME   value

</pre>
<p>
$NAME lines are entry points in $PROCs and $FUNCs.

<p>
$NAME assigns a value to the call name which can be
referenced as any of p(0, 1) or p(0, 0) or $N.

<p>
The label* on a $NAME directive can only be used to call the
macro if it is made visible outside the macro by being promoted
with an asterisk*

<p>
One $PROC macro may generate several instructions
with similar layout. Such a macro has several
$NAME entry points.

<h4>6.2.2.4: The $END Macro Footer</h4>

<p>
$END ends a subassembly (the macro or the main assembly).


<h4>6.2.2.5: Minimal Instruction Macro Example</h4>

<p>
$FORM, $PROC and $NAME and $END describe an imaginary computer
architecture to the assembler:
<pre>

standard_format $FORM   8, 16

instruction     $PROC

load*           $NAME   0
store*          $NAME   1
add*            $NAME   2
subtract*       $NAME   3

		standard_format     $N, instruction(1, 1)

		$END

</pre>
<p>
The label on a $PROC, a $FUNC or a $NAME can only be used as a macro
call if it has an asterisk* to make it visible outside the macro.

<p>
"instruction" is not visible outside the macro, and can be used as the
header label of other macros.

<p>
These lines of code
<pre>

	load    4094
	add     4097
	subtract 100
	store   2047

</pre>
<p>
will generate
<pre>

	000ffe
	021001
	030064
	0107ff

</pre>


<h4>6.2.2.6: The Two-pass $PROC</h4>


label   $PROC	*

<p>
If the first argument on a $PROC line is * then the $PROC is two-pass
in the second pass of the main assembly.

<p>
This allows forward references to local labels within the $PROC.

<p>
Labels defined in a $PROC are dropped when the $END image is encountered, unless they  are flagged*** for visibility to one or more higher assembly 
levels.

<p>
Labels should only be promoted if other parts of the assembly need them,
but they may be forward-referenced within the macro.

<p>
The forward reference need not be resolved on the first assembly pass.

<p>
On the second pass, a preliminary pass within the macro expansion is
necessary for any labels which are forward-referenced and not global.



<h4>6.2.2.7 The Out of Line $PROC</h4>


<p>
A location counter with the strict syntax $(expression) can be coded
as the first or second argument on a $PROC directive
<pre>

p	$proc	* $(4)
enter*	$name
	.
	.
	$end

aside*	$proc	$(6)
	.
	.
	$end

</pre>
<p>
The $(expression) part may be the second argument when the two-pass
asterisk * flag is the first argument.


<h4>6.2.2.8: Nested Macro Descriptions</h4>

<p>
Macros are mostly defined one at a time.  They can call each other to
a large nesting depth:
<pre>

p*	$proc
	+	$l
	q
	$end

q*	$proc
	+	$l
	r
	$end

r*	$proc
	+	$l
	$end

</pre>
<p>
A command "p" also causes "q" and "r" to assemble.

<p>
Macro descriptions may also be written in a nested way:
<pre>

one*	$proc
two*	$proc
three*	$proc
	$end
	three
	$end
	two
	$end

</pre>
<p>
This is rarely necessary but may be an advantage.

<p>
"one" causes "two" to exist and to be called, and the call "two"
causes "three" to exist and to be called.

<p>
"one" exists during the whole of the main assembly. "two" exists when
"one" is subassembling. "three" exists when "two" is subassembling.

<p>
The macros "p" "q" and "r" are now described in a nested way, which
makes "q" and "r" invisible most of the time:
<pre>

p*      $proc
        +       $l
q*      $proc
        +       $l
r*      $proc
        +       $l
        $end
        r
        $end
        q
        $end

</pre>
<p>
So command "p" causes "q" to exist and to be called, and that causes
"r" to exist and to be called.

<p>
The names of inner macros are not visible to the main assembly. 

<p>
It's possible to declare one macro within another in order to
repeat-call the inner macro at the point where it's declared
($DO only repeats one line, but that line can be a macro call):
<pre>

macro1*	$proc

	.
	.

p	$proc
copyright* $name
	load	start+A_LOT-index
	store	start+A_LOT-index+1
	$end

index	$do	A_LOT,	copyright

	.
	.

	$end


</pre>

<h2>6.3: Ready Made Target Descriptions</h2>

<h3>6.3.1: 8051</h3>

<p>
8051.def header include file in this package has been
used with masmx to build mission-critical software for 
a number of prestige clients.


<h3>6.3.2: PowerPC</h3> 

<p>
The ppc_603.def file in this delivery has been successfully used
to generate a stable, running RT kernel.

<p>
ppc_603.def may be steered to produce absolute or relocatable code.
The equivalent header file for linking relocatables is map_ppc.def
(see Section 9: Output File Formats, Relocation and Linking,
Giant Address Spaces, Interfacing with GNU Tools)

<p>
Definitions ppc_64.def and ppc64map.def support the development of
giant address assembly and linking technique See Section 9.2: Linking.

<p>
For support developing assembly and link definitions, contact
<b>masmx@gmx.ch</b>


<h3>6.3.3: Fragment Samples - ColdFire/68000, MIPS, ARM</h3>

<p>
Legacy code can be assembled unchanged.

<p>
In these fragment examples, masmx assembles code in some very individual
syntaxes which were developed independently for different targets.

<p>
Keeping pace with architectural extensions is a matter of adding more
macro language. This can be done anywhere that the target architecture
is understood.

<p>
Fragments of definition for ColdFire/68K, MIPS, and ARM are shown here.

<p>
If you want a whole definition header for these or any machines and
do not wish to build it from this manual, contact masmx@gmx.ch


<h4>6.3.3.1: ColdFire and 68000</h4>

<p>
This assembly switches on listing at a few places in a kernel assembly
for ColdFire.

<p>
Illustrated is that
<ul>

	tokens like -(a7) and w*4 can be labels.
<pre></pre>
	Macro language must declare and sometimes reference
	labels like that in quotes as
<pre>

"-(a7)"		$equ,"$a_reg_@-" 	7
"w*4"		$equ,$special_reg	0*/2++2

</pre>
	Macro language must sometimes puts quotes on parameter
	references to labels like that, as "p(1, 1)".

<pre></pre>
	This prevents -(a7) from meaning minus (a7),
	L*8 from meaning eight times L etc.

<pre></pre>
	When macro parameter reference in an instruction is in
	quotes, it is forced to real parameter value meaning with a
	unary sign, as +"p(1, 1)". Otherwise the characters "p(1, 1)"
	would go into the instruction instead of the actual parameter.

<pre></pre>
	Application source code just uses the register tokens and
	doesn't need to put any quotes on them
<pre>

		move.w	(displacement, a0, d3.l*8), -(a4)

</pre>
	The following simple code sample shows the principle for
	sending a list of comma-separated things in parentheses
	all as one parameter to a nested macro. A function
	macro can retrieve the subparameters from inside the parentheses
	<pre>

MASMX 7r2
3/prango32.msm
*EOF*
  :                            1 	$word	32
  :                            2 
  :                            3 p*	$proc
  :                            4 	q	p(1, 1)
  :                            5 	$end
  :                            6 
  :                            7 q*	$proc
  :                            8 	+	fourth(q(1, 1)), second(q(1, 1)), third(q(1, 1)), first(q(1, 1))
  :                            9 	$end
  :                            10 
  :                            11 f	$func
  :                            12 first*	$name	1
  :                            13 second*	$name	2
  :                            14 third*	$name	3
  :                            15 fourth*	$name	4
  :                            16 	$return	f($n, 1)
  :                            17 	$end
  :                            18 
00:00000000 04020301          +19 	p	(1, 2, 3, 4)
  :                            20 
  :                            21 
*EOF*
:$(00):00000000:00000001 
prango32.msm: object code 54 bytes: 0 errors: 0 undefined labels

	</pre>
	If anything could be prepended to the parentheses
	like <b>displacement(a0, d3.l*8)</b>, it is better to send
	that complex parameter to the nested function macro as the
	first <b>SUBSTRING</b> of itself, for example <b>p(1, 1:1)</b>

<pre></pre>
	Text joined before( is field 0 to the more nested macro,
	otherwise the first field inside () is field 0.

<pre></pre>
	Text joined )after is a further field.

<pre></pre>
	Therefore the substituted parameter for paraform p(1, 1:1)
	and actual parameter
<pre>

	(displacement, a0, d3.l*8)

</pre>
	forms one field, field 0, with three subfields

<pre>

	displacement, a0, d3.l*8

</pre>
	If the actual parameter had been

<pre>

	displacement(a0, d3.l*8 more, more)and, more

</pre>
	fields 0 1 2 3 would be presented to the more-nested macro as

<pre>

	displacement a0,d3.l*8 more,more and,more

</pre>
	where many instructions have the same name, labels
	have a class or type. This enables macro language to
	pick the correct instruction code for the operand types
	and sizes, for example, register/storage

</ul>
<pre>

MASMX 7r2
3/coldfire.msm
CONT_CHAR=|
LTERM=;
STERM=.
*EOF*
  :                            1:       $include        "coldfire.def"
  :                            10 	$list	2
  :                            11 
  :                            12 	$set_option	"c"
  :                            13 
  :                            14 "$d_reg" 	$equ	128
  :                            15 "$a_reg" 	$equ	129
  :                            16 "$a_reg_@"	$equ	130
  :                            17 "$a_reg_@+" 	$equ	131
  :                            18 "$a_reg_@-"	$equ	132
  :                            19 "$special_reg"	$equ	133
  :                            20 
  :                            21 d0	$equ,"$d_reg"	0
  :                            22 d1	$equ,"$d_reg"	1
  :                            23 d2	$equ,"$d_reg"	2
  :                            24 
  :                            62         $list   2
  :                            63 
  :                            64 "-(a6)"	$equ,"$a_reg_@-"	6
  :                            65 "-(a7)"	$equ,"$a_reg_@-"	7
  :                            66 
  :                            67 "(a0)+"	$equ,"$a_reg_@+"	0
  :                            68 "(a1)+"	$equ,"$a_reg_@+"	1
  :                            69 "(a2)+"	$equ,"$a_reg_@+"	2
  :                            70 
  :                            122         $list   2
  :                            123 
  :                            124 "l*2"	$equ,"$special_reg"	1*/2++1
  :                            125 "l*4"	$equ,"$special_reg"	1*/2++2
  :                            126 "l*8"	$equ,"$special_reg"	1*/2++3
  :                            127 
  :                            128 "$i_rr"	$form	4, 3, 3, 3, 3
  :                            129 "$i_rm"	$form	4, 3, 3, 3, 3, 16
  :                            130 "$i_rl"	$form	4, 3, 3, 3, 3, 32
  :                            131 "$i_rx"	$form	4, 3, 3, 3, 3, 4, 3, 1, 8
  :                            132 
  :                            133 "$b_cs"	$form	8, 8
  :                            134 "$b_cl"	$form	8, 8, 16
  :                            135 
  :                            136 f	$func
  :                            137 ;
  :                            138 ;	when no displacement is coded outside the parentheses
  :                            139 ;
  :                            140 "$inside"*	$name
  :                            141 	$return	f(0)
  :                            142 
  :                            143 "$displacement8"*	$name
  :                            144 	$do	f(0, 1)<-128,	$flag	displacement too low
  :                            145 	$do	f(0, 1)>127,	$flag	displacement too high
  :                            146 "$displacement"*	$name
  :                            147 	$return	f(0, 1)
  :                            148 
  :                            149 "$base_a"*	$name
  :                            150 	$do	$t(f(0, 2))^=$a_reg,	$flag base register not a0..a7
  :                            151 	$do	$t(f(0, 2))^=$a_reg,	$trace f(0, 2)
  :                            152 	$return	f(0, 2)
  :                            153 
  :                            154 "$idx_c"*	$name
  :                            155 	$return	f(0, 3:)	; how many substrings are after (disp, a0,.
  :                            156 
  :                            157 "$idx_d"*	$name		; d-register
  :                            158 	$do	$t(f(0, 3:1))=$a_reg,		$return	8++f(0, 3:1)
  :                            159 	$do	$t(f(0, 3:1))^=$d_reg,		$flag	index not d0..d7
  :                            160 	$return	f(0, 3:1)
  :                            161 
  :                            162 "$idx_w"*	$name		; width++scale
  :                            163 	$do	f(0, 3:)=1,	$return	"l*1"
  :                            164 	$do	$t("f(0, 3:2)")^=$special_reg,	$flag	scale not in scale
  :                            165 	$return	"f(0, 3:2)"
  :                            166 
  :                            167 	$end
  :                            168 
  :                            169 f	$func
  :                            170 ;
  :                            171 ;	when there is a displacement and then parentheses
  :                            172 ;
  :                            173 "$icount"*	$name
  :                            174 	$return	f(1)
  :                            175 
  :                            176 "$itype"*	$name
  :                            177 	$return	$t("f(1, 1)")
  :                            178 
  :                            179 "$ibase"*	$name
  :                            180 	$return	f(1, 1)
  :                            181 
  :                            182 	$end
  :                            183 
  :                            241         $list   2
  :                            242 
  :                            243 p	$proc
  :                            244 adda*	$name	7*/4++13
  :                            245 suba*	$name	7*/4++9
  :                            246 cmpa*	$name	7*/4++11
  :                            247 
  :                            248 	$if		$t(p(1, 2))=$a_reg
  :                            249 
  :                            250 "$type"	  $set		$t("p(1, 1)")
  :                            251 
  :                            252 	  $if		$type**128	; register direct or indirect[+-]
  :                            253 
  :                            254 	    $i_rr	p(0, 0), p(1, 2), p(0, 0)/*4, $type, +"p(1, 1)"
  :                            255 
  :                            256 	  $elseif	$itype\p(1, 1)=$a_reg	; displacement_outside(a_)
  :                            257 
  :                            259 	    $i_rm	p(0, 0), p(1, 2), p(0, 0)/*4, 5, $ibase\p(1, 1),|
			p(1, 1)
  :                            260 
  :                            261 	  $elseif	$inside\p(1, 1:1)=2	; (displacement_inside, a_)
  :                            262 
  :                            264 	    $i_rm	p(0, 0), p(1, 2), p(0, 0)/*4, 5,	|
			$base_a\p(1, 1:1), $displacement\p(1, 1:1)
  :                            265 
  :                            266 	  $elseif	$inside\p(1, 1:1)=3	; (displacement, a_, d_[.])
  :                            267 
  :                            270 	    $i_rx	p(0, 0), p(1, 2), p(0, 0)/*4, 6,	|
			$base_a\p(1, 1:1), $idx_d\p(1, 1:1),	|
			$idx_w\p(1, 1:1), 0, $displacement8\p(1, 1:1)
  :                            271 
  :                            272 	  $elseif	p(1, #1)		; immediate
  :                            273 	    $i_rl	p(0, 0), p(1, 2), p(0, 0)/*4, 7, 4, p(1, 1)
  :                            274 
  :                            275 	  $else
  :                            276 	    $i_rl	p(0, 0), p(1, 2), p(0, 0)/*4, 7, 1, p(1, 1)
  :                            277 	  $endif
  :                            278 	$else
  :                            279 	  $flag	receiving operand must be a0..a7
  :                            280 	$endif
  :                            281 	$end
  :                            282 
  :                            462         $list   2
  :                            463 
  :                            464 ; coldfire doesn't have so many movem variations as 68k
  :                            465 
  :                            466 p	$proc
  :                            467 
  :                            468 movem.w*	$name	0x0122
  :                            469 movem.l*	$name	0x0123
  :                            470 movem*		$name	movem.l
  :                            471 
  :                            472 	$if	$t("p(1, 1)")="$a_reg_@"
  :                            473 	$movem_i	p(0, 0)++16, 2, p(1, 1), right2left(p(1, 2))
  :                            474 
  :                            475 	$elseif	$t("p(1, 2)")="$a_reg_@"
  :                            476 	$movem_i	p(0, 0), 2, p(1,2), right2left(p(1, 1))
  :                            477 
  :                            478 	$elseif	$itype\p(1,1)=$a_reg
  :                            480 	$movem_im	p(0, 0)++16, 5, $ibase\p(1, 1),|
			right2left(p(1, 2)), p(1, 1)
  :                            481 
  :                            482 	$elseif	$itype\p(1,2)=$a_reg
  :                            484 	$movem_im	p(0, 0), 5, $ibase\p(1, 2),|
			right2left(p(1, 1)), p(1, 2)
  :                            485 
  :                            486 	$elseif	$inside\p(1, 1:1)=2
  :                            489 	$movem_im	p(0, 0)++16, 5, $base_a\p(1, 1:1),|
			right2left(p(1, 2)),|
			$displacement\p(1, 1)
  :                            490 
  :                            491 	$elseif	$inside\p(1, 2:1)=2
  :                            494 	$movem_im	p(0, 0), 5, $base_a\p(1, 2:1),|
			right2left(p(1, 1)),|
			$displacement\p(1, 2)
  :                            495  
  :                            496 	$else
  :                            497 
  :                            498 	$flag	movem variant not in ColdFire set
  :                            499 
  :                            500 	$endif
  :                            501 	$end
  :                            502 
  :                            503 ; removal of movem-predecrement means only one bitmask direction is needed
  :                            504 
  :                            505 f	$func
  :                            506 right2left*	$name
  :                            507 mask	$set	0
  :                            508 	$sterm	'/'
  :                            509 x	$do	f(1, 1:),mask	$set	mask++range_up(f(1, 1:x))
  :                            510 	$sterm	'.'
  :                            511 	$return	mask
  :                            512 	$end
  :                            513 
  :                            514 f	$func
  :                            515 range_up*	$name
  :                            516 mask	$set	0
  :                            517 	$sterm	'-'
  :                            518 	$if	f(1,1:)=1
  :                            519 	$if	$t(f(1, 1:1))=$d_reg
  :                            520 mask	$set	1*/f(1, 1:1)
  :                            521 	$elseif	$t(f(1, 1:1))=$a_reg
  :                            522 mask	$set	256*/f(1, 1:1)
  :                            523 	$else
  :                            524 	$flag	tag not data register or address register
  :                            525 	$endif
  :                            526 	$elseif	f(1,1:)=2
  :                            529 	$if	  ($t(f(1, 1:1))=$d_reg)|
		**($t(f(1, 1:2))=$d_reg)|
		**(f(1, 1:2)>f(1, 1:1))
  :                            530 
  :                            531 mask	$set	((1*/f(1, 1:1))-1)--((2*/f(1, 1:2))-1)
  :                            532 
  :                            535 	$elseif	  ($t(f(1, 1:1))=$a_reg)|
		**($t(f(1, 1:2))=$a_reg)|
		**(f(1, 1:2)>f(1, 1:1))
  :                            536 
  :                            537 mask	$set	((256*/f(1, 1:1))-1)--((512*/f(1, 1:2))-1)
  :                            538 
  :                            539 	$elseif	($t(f(1, 1:1))=$d_reg)**($t(f(1, 1:2))=$a_reg)
  :                            540 
  :                            541 mask	$set	((1*/f(1, 1:1))-1)--((512*/f(1, 1:2))-1)
  :                            542 	$else
  :                            543 	$flag	bad range
  :                            544 	$endif
  :                            545 	$else
  :                            546 	$flag	too many ranges in range
  :                            547 	$endif
  :                            548 	$sterm	'/'
  :                            549 	$return	mask
  :                            550 	$end
  :                            551 
Note: coldfire.def Line 553: end of header include
  :                            2 
  :                            3 __LINK_POINTER	$equ,"$a_reg"	6
  :                            4 __TCB_LOCATION	$equ		0
  :                            5 
  :                            6 
  :                            7 CPUS		$set	1
  :                            8 PRIORITIES	$set	8
  :                            9 IDLE_STACK	$set	64
  :                            10 
Note: coldfire.msm Line 12: listing off
Note: coldfire.msm Line 13: after all, the kernel structures aren't interesting
  :                            114 	$list	1
  :                            115 
00:00000400 2F08              +116 	move	a0, -(a7)
00:00000402 6100008C          +117 	bsr	p_tcb
00:00000406 48E87FFF0010      +118 	movem	d0-a6, (tcb.genregs, a0)
00:0000040C 2248              +119 	move	a0, a1
00:0000040E 205F              +120 	move	(a7)+, a0
00:00000410 23480030          +121 	move	a0, tcb.a_reg_0(a1)
00:00000414 234F004C          +122 	move	a7, tcb.a_reg_7(a1)
  :                            123 
00:00000418 20290004          +124 	move	tcb.h.priority(a1), d0
  :                            125 
00:0000041C 6B50              +126 	bmi	qaside	$8_bits
00:0000041E 0C8000000007      +127 	cmpi	#PRIORITIES-1, d0
00:00000424 6E48              +128 	bgt	qaside	$8_bits
  :                            129 
Note: coldfire.msm Line 131: listing off
Note: coldfire.msm Line 132: after all, the context switch isn't interesting
  :                            158 	$list	1
  :                            159 
00:00000466 4CE9FFFF0010      +160 	movem	tcb.genregs(a1), d0-a7
00:0000046C 4E73              +161 	rte
  :                            162 
  :                            163 
  :                            164 
(+03)20
00:0000046E 4AB900000124      +165 qaside	tst	qaside_h
00:00000474 670C              +166 	beq	first	$8_bits
(+03)20
00:00000476 207900000128      +167 	move	qaside_t, a0
00:0000047C 21490000          +168 	move	a1, tcb.h.next(a0)
00:00000480 6006              +169 	bra	last	$8_bits
(+03)20
00:00000482 23C900000124      +170 first	move	a1, qaside_h 	
(+03)20
00:00000488 23C900000128      +171 last	move	a1, qaside_t
00:0000048E 60B0              +172 	bra	pick
  :                            173 
  :                            174 
  :                            175 	$if	__LINK_POINTER
  :                            176 
  :                            178 	$do	$t(__LINK_POINTER)^=$a_reg,	|
	$flag	__LINK_POINTER should be a6 or similar
  :                            179 
  :                            180 ;	this is callable from c and returns pointer to tcb
  :                            181 ;	it requires that applications do not use stack frame
  :                            182 ;	link register (often a6) for anything except linking stack frames
  :                            183 
  :                            184 ;	it does not matter if functions do not use stack
  :                            185 ;	frames at all. It matters that nothing but LINK and UNLK
  :                            186 ;	instructions should change the link register
  :                            187 
00:00000490 2F00              +188 p_tcb*	move	d0, -(a7)
  :                            189 
00:00000492 204E              +190 	move	__LINK_POINTER, a0
00:00000494 6002              +191 	bra	again?	$8_bits
00:00000496 2040              +192 again!	move	d0, a0
00:00000498 2018              +193 again?	move	(a0)+, d0
00:0000049A 66FA              +194 	bne	again!
  :                            195 
00:0000049C 201F              +196 	move	(a7)+, d0
00:0000049E 4E75              +197 	rts
  :                            198 
  :                            199 
  :                            200 	$elseif	__TCB_LOCATION
  :                            201 
  :                            202 ;	this is callable from c and returns pointer to tcb
  :                            203 ;	if compilers can be directed to spare an address register,
  :                            204 ;	possibly a5 or a4, then __TCB_LOCATION can be that register
  :                            205 ;	and the encoding at the head of the assembly would be as
  :                            206 ;
  :                            207 ;	__LINK_POINTER	$equ		0
  :                            208 ;	__TCB_LOCATION	$equ,$a_reg	a5
  :                            209 ;
  :                            210 ;	otherwise __TCB_LOCATION may be a longword in RAM
  :                            211 ;	linked in location counter 3 (static data), but not if
  :                            212 ;	more than one core is running in the execution space
  :                            213 
  :                            214 	$if	$t(__TCB_LOCATION)=$a_reg
  :                            215 	$note	tcb pointer is an address register
  :                            216 	$else
  :                            217 	$note	tcb pointer is not at address register
  :                            218 	$endif
  :                            219 
  :                            220 p_tcb*	move	__TCB_LOCATION, a0
  :                            221 	rts
  :                            222 
  :                            223 	$else
  :                            224 
  :                            225 	$flag	you must have __LINK_POINTER or __TCB_LOCATION
  :                            226 
  :                            227 	$endif
*EOF*
:$(00):00000400:000004A0 :$(03):00000000:0000012C :$(43):00000000:00000058 
coldfire.msm: object code 1441 bytes: 0 errors: 1 undefined labels

</pre>

<p>
The same macro language can assemble 68000 source which has
tokens <b>[] a4@ a0@+ a7@-</b>
<pre>

MASMX 7r2
3/coldfir@.msm
CONT_CHAR=|
LTERM=;
STERM=.
*EOF*
  :                            1: 	$include	"coldfire.def"
  :                            2 
  :                            3 __LINK_POINTER	$equ,"$a_reg"	6
  :                            4 __TCB_LOCATION	$equ		0
  :                            5 
  :                            6 
  :                            7 CPUS		$set	1
  :                            8 PRIORITIES	$set	8
  :                            9 IDLE_STACK	$set	64
  :                            10 
  :                            11 
Note: coldfir@.msm Line 15: listing off
Note: coldfir@.msm Line 16: after all, the kernel structures aren't interesting
  :                            116 	$list	1
  :                            117 
00:00000400 2F08              +118 	move	a0, a7@-
00:00000402 6100008C          +119 	bsr	p_tcb
00:00000406 48E87FFF0010      +120 	movem	d0-a6, [tcb.genregs, a0]
00:0000040C 2248              +121 	move	a0, a1
00:0000040E 205F              +122 	move	a7@+, a0
00:00000410 23480030          +123 	move	a0, [tcb.a_reg_0, a1]
00:00000414 234F004C          +124 	move	a7, [tcb.a_reg_7, a1]
  :                            125 
00:00000418 20290004          +126 	move	[tcb.h.priority, a1], d0
  :                            127 
00:0000041C 6B50              +128 	bmi	qaside	$8_bits
00:0000041E 0C8000000007      +129 	cmpi	#PRIORITIES-1, d0
00:00000424 6E48              +130 	bgt	qaside	$8_bits
  :                            131 
  :                            132 
Note: coldfir@.msm Line 135: listing off
Note: coldfir@.msm Line 136: after all, the context switch isn't interesting
  :                            162 	$list	1
  :                            163 
00:00000466 4CE9FFFF0010      +164 	movem	[tcb.genregs, a1], d0-a7
00:0000046C 4E73              +165 	rte
  :                            166 
  :                            167 
  :                            168 
(+03)20
00:0000046E 4AB900000124      +169 qaside	tst	qaside_h
00:00000474 670C              +170 	beq	first	$8_bits
(+03)20
00:00000476 207900000128      +171 	move	qaside_t, a0
00:0000047C 21490000          +172 	move	a1, [tcb.h.next, a0]
00:00000480 6006              +173 	bra	last	$8_bits
(+03)20
00:00000482 23C900000124      +174 first	move	a1, qaside_h 	
(+03)20
00:00000488 23C900000128      +175 last	move	a1, qaside_t
00:0000048E 60B0              +176 	bra	pick
  :                            177 
  :                            178 
  :                            179 	$if	__LINK_POINTER
  :                            180 
  :                            182 	$do	$t(__LINK_POINTER)^=$a_reg,	|
	$flag	__LINK_POINTER should be a6 or similar
  :                            183 
  :                            184 ;	this is callable from c and returns pointer to tcb
  :                            185 ;	it requires that applications do not use stack frame
  :                            186 ;	link register (often a6) for anything else
  :                            187 
  :                            188 ;	it does not matter if functions do not use stack
  :                            189 ;	frames at all. It matters that nothing but LINK and UNLK
  :                            190 ;	instructions should change the link register
  :                            191 
00:00000490 2F00              +192 p_tcb*	move	d0, a7@-
  :                            193 
00:00000492 204E              +194 	move	__LINK_POINTER, a0
00:00000494 6002              +195 	bra	again?	$8_bits
00:00000496 2040              +196 again!	move	d0, a0
00:00000498 2018              +197 again?	move	a0@+, d0
00:0000049A 66FA              +198 	bne	again!
  :                            199 
00:0000049C 201F              +200 	move	a7@+, d0
00:0000049E 4E75              +201 	rts
  :                            202 
  :                            203 
  :                            204 	$elseif	__TCB_LOCATION
  :                            205 
  :                            206 ;	this is callable from c and returns pointer to tcb
  :                            207 ;	if compilers can be directed to spare an address register,
  :                            208 ;	possibly a5 or a4, then __TCB_LOCATION can be that register
  :                            209 ;	and the encoding at the head of the assembly would be as
  :                            210 ;
  :                            211 ;	__LINK_POINTER	$equ		0
  :                            212 ;	__TCB_LOCATION	$equ,$a_reg	a5
  :                            213 ;
  :                            214 ;	otherwise __TCB_LOCATION may be a longword in RAM
  :                            215 ;	linked in location counter 3 (static data), but not if
  :                            216 ;	more than one core is running in the execution space
  :                            217 
  :                            218 	$if	$t(__TCB_LOCATION)=$a_reg
  :                            219 	$note	tcb pointer is an address register
  :                            220 	$else
  :                            221 	$note	tcb pointer is not at address register
  :                            222 	$endif
  :                            223 
  :                            224 p_tcb*	move	__TCB_LOCATION, a0
  :                            225 	rts
  :                            226 
  :                            227 	$else
  :                            228 
  :                            229 	$flag	you must have __LINK_POINTER or __TCB_LOCATION
  :                            230 
  :                            231 	$endif
*EOF*
:$(00):00000400:000004A0 :$(03):00000000:0000012C :$(43):00000000:00000058 
coldfir@.msm: object code 1441 bytes: 0 errors: 1 undefined labels

</pre>

<h4>6.3.3.2: MIPS</h4>


<p>
The syntax taken as reference for MIPS appears like gcc compiler output
and has no special problems.

<p>
The 32 registers have 64 names.

<p>
Therefore the sample definition "mips.def" does not text-translate
the base-displacement syntax
<pre>

	LDW	displacement(base_register)
	STB	displacement(base_register)

</pre>
<p>
to masmx plain syntax
<pre>

	STW	displacement, base_register
	LDB	displacement, base_register

</pre>
<p>
because of the 64 translation tuples that would require.
Instead the function method gets the base register id
out of the parentheses.

<p>
Definition "mips.def" switches on option flag <b>-c</b>

<p>
<b>-c</b> Flag enables  C-Language style \escape sequences
in quote strings, and hex expressions beginning 0x..

<p>
MIPS architecture is the model taken for the discussion on alignment
at section 10: Byte-Addressing Machines with 32 and 64 Bit Bus, Managing
the Alignments.

<p>
The right-shift handling of absolute jump addresses to aligned target
locations is shown here.

<p>
MIPS also has relative branches. These are discussed comprehensively
in the Section 9: Linking, which takes PowerPC for a model.

<p>
MIPS is shown here as big-endian. Alignment issues with canonical
and reverse byte order are discussed at Section 10.
<pre>

MASMX 7r2
3/prelude.msm
CONT_CHAR=|
LTERM=#
STERM=.
  :                            1:       $include        "mips.def"
  :                            46               $list   2
  :                            47 
  :                            48 "$27" $equ,$register          27
  :                            49 "$28" $equ,$register          28
  :                            50 "$29" $equ,$register          29
  :                            51 "$30" $equ,$register          30
  :                            52 "$31" $equ,$register          31
  :                            53 
  :                            56               $list   2
  :                            57 
  :                            58 "$at" $equ,$register          $1
  :                            59 "$v0" $equ,$register          $2
  :                            60 "$v1" $equ,$register          $3
  :                            61 
  :                            62 "$a0" $equ,$register          $4
  :                            63 
  :                            101              $list   2
  :                            102 
  :                            103 "$irri"              $form   6, 5, 5, 16
  :                            104 
  :                            186              $list   2
  :                            187 
  :                            188 p            $proc
  :                            189 sw*          $name   43
  :                            190 sb*          $name   40
  :                            191 lw*          $name   35
  :                            192 lb*          $name   32
  :                            193 
  :                            194              $irri   p(0, 0), $index\p(1, 2), p(1, 1), p(1, 2)
  :                            195              $end
  :                            196 
  :                            197 "$index"*    $func
  :                            198 tag          $set    $index(1, 1)
  :                            199 type         $set    $t($index(1, 1))
  :                            200 
  :                            202              $do     type^=$register,       |
                        $note   index register tag is untyped
  :                            204              $do     tag>31,                |
                        $flag   index register tag value too high
  :                            206              $do     tag<0,                 |
                        $flag   index register tag value too low
  :                            207 
  :                            208              $return tag
  :                            209              $end
  :                            210 
  :                            211 
  :                            212 p            $proc
  :                            213 j*           $name   2
  :                            214 jal*         $name   3
  :                            215 
  :                            216 target               $set    p(1, 1)
  :                            218              $do     ($net(target)**3)^=0,  |
                        $flag   you can't jump there
  :                            219 
  :                            220              $ij     p(0, 0), target/*2
  :                            221              $end
  :                            222 
  :                            2 $(__data:0x3000)
  :                            3 $(__text:0x1000)
  :                            4 
  :                            5        .data
03:00003000 2247727565737365220A6175730A5361616E656E4C616E64
                              +6        .asciiz """Gruesse""\naus\nSaanenLand\"Pays\777\666d\'enHaut\r\n"
03:00003018 2250617973FFB66427656E486175740D0A00
                              +6 
03:0000302A 4A756C6907080C0B0900
                              +7        .asciiz "Juli\a\b\f\v\t"
Note: prelude.msm Line 8: exactly 3 octal symbols expected here
03:00003034 626973313453657074656D6265720A6C736F206B6F6D6D74
                              +8        .asciiz "bis\61\064September\x0also kommt\xc"
Note: prelude.msm Line 8: exactly 2 hexadecimal symbols expected here
03:0000304C 0C00              +8 
  :                            9 
03:0000304E 596568756469      +10       .ascii  "Yehudi"
03:00003054 20                +11       .byte   32
03:00003055 4D656E7568696E    +12       .ascii  "Menuhin"
03:0000305C 0A                +13       .byte   10
03:0000305D 466F7220657665720A+14       .ascii  "For ever\n"
  :                            15 
03:00003066 456D696C696100    +16         .asciiz "Emilia", "Kopatchinskaja"
03:0000306D 4B6F7061746368696E736B616A6100
                              +16 
03:0000307C 4C65696600        +17         .asciiz "Leif", "Ove", "Andsnes"
03:00003081 4F766500          +17 
03:00003085 416E64736E657300  +17 
03:0000308D 536F6C00          +18         .asciiz "Sol", "Gabetta"
03:00003091 4761626574746100  +18 
03:00003099 43687269737469616E00
                              +19         .asciiz "Christian", "Tetzlaff"
03:000030A3 5465747A6C61666600+19 
03:000030AC 5665726F6E69636100+20         .asciiz "Veronica", "Eberle"
03:000030B5 456265726C6500    +20 
  :                            21 
  :                            22       .align  1
03:000030BC 01F4              +23       .half   500
  :                            24 
  :                            25       .align  2
03:000030C0 00000063          +26       .word   99, 100, 101
03:000030C4 00000064          +26 
03:000030C8 00000065          +26 
  :                            27 
  :                            28       .text
  :                            29 
  :                            30 usefully      $equ    0x18C
  :                            31 upward        $equ    65536
  :                            32 
01:00001000 8D250040          +33       lw      $5, 64($9)
01:00001004 0085001A          +34       div     $4, $5
01:00001008 0C000063          +35       jal     usefully
01:0000100C 08004000          +36       j       upward
  :                            37 
  :                            38       $end
:$(01):00001000:00001010 :$(03):00003000:000030CC 
prelude.msm: object code 581 bytes: 0 errors: 0 undefined labels

</pre>

<h4>6.3.3.3: ARM</h4>

<p>
This discussion is for 32-bit ARM. Thumb has a different header.

<p>
ARM has 32 names for each of its principal arithmetic and logic
instructions. All these instructions are definable in one macro,
and the macro has 512 names. This is only a problem for whoever
keys the macro file in. Here are one-and-a-half of the sixteen
arithmetic instructions:
<pre>


p	$proc

andeq*	$name	0*/6++0*/1++0
andeqs*	$name	0*/6++0*/1++1	
andne*	$name	1*/6++0*/1++0
andnes*	$name	1*/6++0*/1++1	

andcs*	$name	2*/6++0*/1++0
andcss*	$name	2*/6++0*/1++1	
andcc*	$name	3*/6++0*/1++0
andccs*	$name	3*/6++0*/1++1	

andmi*	$name	4*/6++0*/1++0
andmis*	$name	4*/6++0*/1++1	
andpl*	$name	5*/6++0*/1++0
andpls*	$name	5*/6++0*/1++1	

andvs*	$name	6*/6++0*/1++0
andvss*	$name	6*/6++0*/1++1	
andvc*	$name	7*/6++0*/1++0
andvcs*	$name	7*/6++0*/1++1

	.
	.
	.	


addeq*	$name	0*/6++4*/1++0
addeqs*	$name	0*/6++4*/1++1	
addne*	$name	1*/6++4*/1++0
addnes*	$name	1*/6++4*/1++1	

addcs*	$name	2*/6++4*/1++0
addcss*	$name	2*/6++4*/1++1	
addcc*	$name	3*/6++4*/1++0
addccs*	$name	3*/6++4*/1++1	

addmi*	$name	4*/6++4*/1++0
addmis*	$name	4*/6++4*/1++1	
addpl*	$name	5*/6++4*/1++0
addpls*	$name	5*/6++4*/1++1	

addvs*	$name	6*/6++4*/1++0
addvss*	$name	6*/6++4*/1++1	
addvc*	$name	7*/6++4*/1++0
addvcs*	$name	7*/6++4*/1++1	

addhi*	$name	8*/6++4*/1++0
addhis*	$name	8*/6++4*/1++1	
addls*	$name	9*/6++4*/1++0
addlss*	$name	9*/6++4*/1++1	

addge*	$name	10*/6++4*/1++0
addges*	$name	10*/6++4*/1++1	
addlt*	$name	11*/6++4*/1++0
addlts*	$name	11*/6++4*/1++1	

addgt*	$name	12*/6++4*/1++0
addgts*	$name	12*/6++4*/1++1	
addle*	$name	13*/6++4*/1++0
addles*	$name	13*/6++4*/1++1	

add*	$name	14*/6++4*/1++0
adds*	$name	14*/6++4*/1++1	
addnv*	$name	15*/6++4*/1++0
addnvs*	$name	15*/6++4*/1++1	

	.
	.
	.



	$if	p(1, #3)
	$i1	p(0, 0)/*6, 1,p(0, 0),p(1, 1),p(1, 2),$rotisse(p(1, 3))
	$else
	$i1	p(0, 0)/*6, 0, p(0, 0), p(1, 1), p(1, 2), p(1, 3)
	$endif

	$end

</pre>
<p>
Symbols {} contain the register list for multiple loads and stores.
masmx translates {} to function surrounds
<pre>

	$brace(		)

</pre>
<p>
Load-store instructions are traditionally spelled with operands
[in, square, brackets]. masmx can pass enclosures like that to
function macros, where [] may be used instead of ()

<p>
The 8-bit immediate with 4-bit positioning-exponent is encoded with
the function $rotisse, made visible in the following assembly.

<p>
Because there is no automatic truncation at 32 bits (masmx evaluates
numbers at 192-bit precision), function macro $rotisse uses AND-mask
FFFFFFFF hexadecimal in places.

<p>
Modern developer environments will probable use flag <b>-c</b> for C-Language
style numbers 0x..

<p>
Here masmx-native 0FFFFFFFF for hex, \111010010000 for bit-pattern
have been used.
<pre>


MASMX 7r2
3/arm32.msm
CONT_CHAR=|
LTERM=;
*EOF*
  :                            1:       $include        "arm32.def"
  :                            6        $list   2
  :                            7 
  :                            8         $text   /{/$brace(/
  :                            9         $text   /}/)/
  :                            10 
  :                            208      $list   2
  :                            209 
  :                            210 "$rotisse"*  $func
  :                            211 !    $set    $rotisse(1, 1)
  :                            212      $do     !<256,  $return !
  :                            213      $do     !>1*/32-1,      $flag   cannot rotate inside 32 bits
  :                            214 
  :                            216      $do     $t(ROTATE_RIGHT_INTO_VIEW)=0,|
ROTATE_RIGHT_INTO_VIEW  $set    1
  :                            217 
  :                            218      $if     ROTATE_RIGHT_INTO_VIEW
  :                            219 
  :                            222 ?    $do     15,                            |
        $do     !/*(2*?)++((!*/32)/*(2*?))**0FFFFFFFF<256,      |
                $return (16-?)*/8++!/*(2*?)++((!*/32)/*(2*?))**0FFFFFFFF
  :                            223 
  :                            224      $else   ;       ROTATE LEFT INTO VIEW instead
  :                            225 
  :                            228 ?    $do     15,                            |
        $do     (!*/(2*?))**0FFFFFFFF++((!*/(2*?))/*32)<256,    |
                $return ?*/8++(!*/(2*?))**0FFFFFFFF++((!*/(2*?)/*32)
  :                            229 
  :                            230      $endif
  :                            231 
  :                            232      $flag   immediate not in available set
  :                            233      $return !
  :                            234 
  :                            235      $end
  :                            236 
  :                            337      $list   2
  :                            338 
  :                            339 "$mls"       $form   9, 1, 1, 1, 4, 16
  :                            340 
  :                            341 p    $proc
  :                            342 
  :                            343 stmfd*       $name   \111010010000
  :                            344 ldmfd*       $name   \111010001001
  :                            345 
  :                            346      $mls    p(0, 0)/*3, , $t(p(1, 1))=!,p(0, 0), p(1, 1), p(1, 2)
  :                            347 
  :                            348      $end
  :                            349 
  :                            350 
  :                            351 "$brace"* $func
  :                            352 v       $set    0
  :                            353 t       $do     $brace(1),v     $set    v++$range_up($brace(1,t))
  :                            354         $return v
  :                            355         $end
  :                            356 
  :                            357 f    $func
  :                            358 "$range_up"* $name
  :                            359 mask $set    0
  :                            360      $sterm  '-'
  :                            361      $if     f(1,1:)=1
  :                            362      $if     $t(f(1, 1:1))=$reg
  :                            363 mask $set    1*/f(1, 1:1)
  :                            364      $else
  :                            365      $flag   mask tag not simple register
  :                            366      $endif
  :                            367      $elseif f(1,1:)=2
  :                            370      $if       ($t(f(1, 1:1))=$reg)|
                **($t(f(1, 1:2))=$reg)|
                **(f(1, 1:2)>f(1, 1:1))
  :                            371 
  :                            372 mask $set    (1*/f(1, 1:1)-1)--(2*/f(1, 1:2)-1)
  :                            373 
  :                            374      $else
  :                            375      $flag   bad range
  :                            376      $endif
  :                            377      $else
  :                            378      $flag   too many ranges in range
  :                            379      $endif
  :                            380      $sterm  '.'
  :                            381      $return mask
  :                            382      $end
  :                            383 
Note: arm32.def Line 385: end of header include
  :                            2 
  :                            3        $plist  7
  :                            4 
00:00000000 E92E01F0          +5        stmfd   r14!, {r4-r8}
  :                            6 
00:00000004 E79D8064          +7        ldr     r8, [r13, #100]
00:00000008 E7268040          +8        str     r8, [r6, #-64]!
  :                            9 
00:0000000C E61C4078          +10       ldr     r4, [r12], #-120
00:00000010 E6874FFC          +11       str     r4, [r7], #4092
  :                            12 
00:00000014 E5335049          +13       ldr     r5, [r3, -r9, lsl#4]!
  :                            14 
00:00000018 38967008          +15       adds    r6, r7, r8
00:0000001C 0E889F41          +16       addcc   r8, r9, #260
00:00000020 38998007          +17       adds    r9, r8, r7
00:00000024 0E878F81          +18       addcc   r7, r8, #516
00:00000028 38967008          +19       adds    r6, r7, r8
00:0000002C 0E89AE41          +20       addcc   r9, r10, #1040
  :                            21 
00:00000030 E8BE01F0          +22       ldmfd   r14!, {r4-r8}
*EOF*
:$(00):00000000:00000034 
arm32.msm: object code 162 bytes: 0 errors: 0 undefined labels

</pre>  

<h1>7: Iterated Code and Structured Data</h1>


<h2>7.1: $DO</h2>
<pre>


	$DO	count,repeated_source_line

</pre>
<p>
This example discusses a 32-bit computer, and an integer-to-ASCII
conversion routine which uses a 10,000 word table to translate an integer
to eight ascii digits in five instructions, plus a store instruction. 

<p>
The table has to contain 10,000 4-byte elements:
<pre>

	"0000"
	"0001"
	.
	.
	.
	"9999"

</pre>
<p>
Instead of coding all that stuff by hand, you code (the nested $DO shown
is all one line, using ; continuation)
<pre>

	$WORD   32

values_table
thousa	$do             10,;
hundre	$do             10,;
ten	$do             10,;
unit	$do             10,	;
	+               '0'+thousa-1, '0'+hundre-1, '0'+ten-1, '0'+unit-1


	load    reg1, integer
	doubleshiftright        reg1, 32
	divide  reg1, 10000, IMMEDIATE
	load    reg1, values_table, Indexreg1
	load    reg2, values_table, Indexreg2
	doublestore reg1, eightbytefield

</pre>
<p>
This is the same table with different line-continues:
<pre>

values_table
Thousands $do 10,Hundreds $do 10,tens $do 10,units $do 10, ;      
	'0'+Thousands-1, ;
	'0'+Hundreds-1,  ;
	'0'+Tens-1,      ;
	'0'+units-1

</pre>
<p>
A label (Thousands, Hundreds etc) on the $DO 
line is a relative-1 counter tag.


<h2>7.2 Subscripted Labels</h2>

<p>
Labels may be generated with subscripts on the end.

<p>
Macro language can produce the subscripted new labels, and so
can developers manually.

<p>
In the following example:

<p>
Line 3 references a label which does not exist

<p>
Line 4 is a count of labels one(x) with one subscript.

<p>
Line 5 is a count of labels one(8,x) with two subscripts.

<p>
Line 6 references a subscripted label which does
exist, "one(1)", and gets its value, the address 00000F.

<p>
There is no label "one(2)". Therefore line 7 counts all the labels
"one(2,x)", and there are none. The resulting value is 0.

<p>
There is no label "one(3)". Therefore line 8 counts all the labels
"one(3,x)", and there are none. The resulting value is 0.

<p>
Line 9 gets a count of all the one(x) labels with one subscript, as line 4. 

<p>
Line 11 would change the number of one(x) labels to 3 if flag <b>-k</b> were
set, and line 7 would then get the value 00000F as line 6.

<p>
Line 16 references a label which does not exist.

<p>
Assembly is with <b>-u</b> option to highlight whether any labels are
undefined.

<p>
Only two labels are marked as undefined: unsubscripted <b>one</b> at line 3,
and  <b>two</b> at line 16.
<pre>

MASMX 7r2
3/simple.msm
*EOF*
  :                            1         $res    4
  :                            2 one(9)  $res    4
undefined name in simple.msm on Line 3: ONE
00:000008 000000              +3        +       one
00:000009 000002              +4         +       one()
00:00000A 000004              +5        +       one(8)
00:00000B 00000F              +6         +       one(1)
00:00000C 000000              +7         +       one(2)
00:00000D 000000              +8         +       one(3)
00:00000E 000002              +9         +       one()
  :                            10 one(1)
  :                            11       $do     $o('k'),one(2)
  :                            12 one(8,1)
  :                            13 one(8,2)
  :                            14 one(8,3)
  :                            15 one(8,4)
undefined name in simple.msm on Line 16: TWO
00:00000F 000000              +16         +       two(7)
*EOF*
:$(00):000000:000010 
simple.msm: object code 135 bytes: 0 errors: 2 undefined labels


</pre>
<p>
It's possible to have several subscripts and to generate
the subscripts from $DO tags:
<pre>

MASMX 7r2
3/similar.msm
*EOF*
  :                            1 $(0:64)
  :                            2 label(1)
  :                            3 times   $do     8,label(1,times)       $res    1
  :                            4 times $do 5,label(2,1,times) $res 1
  :                            5 label(1,1,1)
00:00004D 000040              +6         +       label(1,1)
00:00004E 000042              +7         +       label(1,3)
00:00004F 000044              +8         +       label(1,5)
00:000050 000040              +9         +       label(1)
00:000051 000045              +10         +       label(1,6)
00:000052 000000              +11         +       label(2)
00:000053 000005              +12         +       label(2,1)
00:000054 000048              +13         +       label(2,1,1)
00:000055 000000              +14         +       label(99)
00:000056 000001              +15         +       label()
  :                            16 
*EOF*
:$(00):000040:000057 
similar.msm: object code 107 bytes: 0 errors: 0 undefined labels

</pre>

<p>
It's possible to reference subscripted labels functionally and
retrieve a count of how many there are. Line 15 of the example above
is a request for a count of any "label(" with one subscript.

<p>
Where labels have two subscripts, "label(1)" means a count of how many
begin "Label(1,", and so on, unless label(1) specifically exists.

<p>
However "label" exists in examples with one, two  and three subscripts in
this example, and that's unwise because, although the assembler's resulting
behaviour is determinate, user confusion could be promoted.

<p>
Line 6 gets the value of label(1,1) because that exists on line 3.
However this known value masks the functional ability to count
the number of labels like the label(1,1,1) on line 5.

<p>
Line 9 gets the value of label(1), because that exists on line 2.
The functional ability to count the number of labels generated
on line 3 is masked.

<p>
All of "label(2.." are label(2,x,y) with three subscripts.
Therefore line 12 is a count of label(2,1,x) and line 13 is
the value of label(2,1,1)

<p>
Line 11 resolves to zero because there is no label(2), and the
number of label(2,x) is none.

<p>
Line 14 resolves to zero because there is no label(99), and the
number of label(99,x) is none.

<p>
Line 15 counts the one label in label(x) with one subscript.



<h3>7.2.1: Subscripted Labels alongside Base-Register-in-Parenthesis</h3>

<p>
These syntax examples shows a subscripted label followed by a base
register tag in parentheses, and then a subscripted label without
any base register:
<pre>

index	$do	240,name_of(index)	+	GENERATOR_FORMULA(index)

...

	lwz     r3, name_of(99)(r2)
	lwz	r4, name_of(1)

</pre>
<p>
The example shows PowerPC code, but the action for safe
assembler interpretation is general in principle.

<p>
The first of the two load instructions does not present a problem.
The last parenthesed token on the line (r2) is interpreted as a
base-register tag, and that is intended.

<p>
The label name_of(99) is also evaluated as intended.

<p>
On the second load instruction, (1) could be evaluated as a
base-register tag, and that is not intended. name_of(1) is a label.

<p>
Interpretation is made definitive by interpreting only typed values
like r1 or r2 as a base register in macro language, if subscripted
labels are in use.

<p>
The supplied definition "ppc_603.def", for example, takes the default
action that a simple integer expression in parentheses is accepted as
a base-register tag.

<p>
This is the correct default for assembly code generated by gcc.

<p>
Subscripted labels will never be generated from c code, and gcc for
PowerPC encodes into assembler with plain numbers for base registers
for the load/store instructions.

<p>
The code fragment above is knowingly written for masmx and for masmx
data structuring, and is a different matter from gcc compilation.
The supplied definition "ppc_603.def", can be switched in advance to
require tagged base register names like r1 and r3:
<pre>

__registers_by_name	$set		1
			$include	"ppc_603.def"


</pre>
<h2>7.3: Structured Data and Structured Code Name Spaces</h2>


<h3>7.3.1: simple structures $TREE..$ROOT</h3>


<p>
It's possible to generate and to reference subscripted
labels in an automatic way. 

<p>
In the following example, the input side of
a device driver scans four serial channels as quickly
as possible. 30 bytes of code are generated to sample
each channel in turn. 

<p>
Here also, the $TREE and $ROOT directives are used to 
build a structured label space for each channel's
registers. $TREE and $ROOT can be used within or 
outwith a macro.

<p>
The components of the structure are referenced by
stringing together the components of their labels
with the $STERM character, which for 8051 is . (period)

<p>
A small part of the label table is shown at the end of the assembly
<pre>

MASMX 7r2
3/uart.msm
CONT_CHAR=
LTERM=;
QDELIM='
STERM=.
*EOF*
  :                            1:         $include   "8051_7r2.def"
  :                            2 
  :                            3 LSR_RDR EQU     0       ; Data In Receive FIFO
  :                            4 
  :                            5 serial*  $proc     
  :                            6         $res    (($+15)**-16)-$
  :                            7 *       $tree          
  :                            8 rhr
  :                            9 thr     $res    1
  :                            10 ier     $res    1
  :                            11 isr     $res    1
  :                            12 lcr     $res    1
  :                            13 mcr     $res    1
  :                            14 lsr     $res    1
  :                            15 msr     $res    1
  :                            16 spr     $res    1
  :                            17         $root
  :                            18         $end
  :                            19 
  :                            20 '$bit'*       $func
  :                            21       $if     $bit(1,1:1)<128
  :                            22       $return (($bit(1,1:1)**31)*/3)++$bit(1,1:2)
  :                            23       $else
  :                            24       $return $bit(1,1:1)++$bit(1,1:2)
  :                            25       $end
  :                            26 
  :                            27 generate* $proc *
  :                            28 Sample:
  :                            29         jb      $bit(FULL.device),leave ; Is there any buffer space?
  :                            30         mov     dptr,#uart(device).lsr  ; Is there data on COM1 input FIFO?
  :                            31         movx    a,@dptr
  :                            32         jnb     $bit(acc.LSR_RDR), Leave; No more so Next UART
  :                            33         mov     dptr,#uart(device).rhr  ; Yes
  :                            34         movx    a,@dptr                 ; Read
  :                            35         mov     dptr,#buffer(device)    ; Find Place in Circular Input Buffer
  :                            36         mov     dpl,write_cursor(device); By Means of the Running Cursor
  :                            37         movx    @dptr,a                 ; Write the Data to XRAM
  :                            38         inc     write_cursor(device)    ; Advance the Input Cursor
  :                            39         mov     a,read_cursor(device)   ; If write starts to equal read
  :                            40         cjne    a,write_cursor(device),Sample ; Is there any more? 
  :                            41         setB    $bit(FULL.device)       ; Stop reading from FIFO to XRAM
  :                            42 leave:       
  :                            43         $end
  :                            44 
  :                            45 
  :                            46 DEVICES equ     128
  :                            47 DATA    equ     1024
  :                            48 TOTAL   equ     4
  :                            49 RTVARS  equ     64
  :                            50 Full    equ     32
  :                            51 
  :                            52 $(3:RTVARS)
  :                            53 device  $do     TOTAL,write_cursor(device)      $res    1
  :                            54 device  $do     TOTAL,read_cursor(device)       $res    1
  :                            55 $(2:DEVICES)
  :                            56 device  $do     TOTAL,uart(device)              serial
  :                            57 $(1:DATA)
  :                            58 device  $do     TOTAL,buffer(device)            VAR    256
  :                            59 
  :                            60 
  :                            61 $(0:64)
00:0040 20011B                +62 device        $do     TOTAL,  generate
00:0043 900085                +62 
00:0046 E0                    +62 
00:0047 30E014                +62 
00:004A 900080                +62 
00:004D E0                    +62 
00:004E 900400                +62 
00:0051 854082                +62 
00:0054 F0                    +62 
00:0055 0540                  +62 
00:0057 E544                  +62 
00:0059 B540E4                +62 
00:005C D201                  +62 
00:005E 20021B                +62 
00:0061 900095                +62 
00:0064 E0                    +62 
00:0065 30E014                +62 
00:0068 900090                +62 
00:006B E0                    +62 
00:006C 900500                +62 
00:006F 854182                +62 
00:0072 F0                    +62 
00:0073 0541                  +62 
00:0075 E545                  +62 
00:0077 B541E4                +62 
00:007A D202                  +62 
00:007C 20031B                +62 
00:007F 9000A5                +62 
00:0082 E0                    +62 
00:0083 30E014                +62 
00:0086 9000A0                +62 
00:0089 E0                    +62 
00:008A 900600                +62 
00:008D 854282                +62 
00:0090 F0                    +62 
00:0091 0542                  +62 
00:0093 E546                  +62 
00:0095 B542E4                +62 
00:0098 D203                  +62 
00:009A 20041B                +62 
00:009D 9000B5                +62 
00:00A0 E0                    +62 
00:00A1 30E014                +62 
00:00A4 9000B0                +62 
00:00A7 E0                    +62 
00:00A8 900700                +62 
00:00AB 854382                +62 
00:00AE F0                    +62 
00:00AF 0543                  +62 
00:00B1 E547                  +62 
00:00B3 B543E4                +62 
00:00B6 D204                  +62 
  :                            63 
*EOF*

....

UART(2):SPR=$02:0097
UART(3)=$02:00A0
UART(3):RHR=$02:00A0
UART(3):THR=$02:00A0
UART(3):IER=$02:00A1
UART(3):ISR=$02:00A2
UART(3):LCR=$02:00A3
UART(3):MCR=$02:00A4
UART(3):LSR=$02:00A5
UART(3):MSR=$02:00A6
UART(3):SPR=$02:00A7
UART(4)=$02:00B0
UART(4):RHR=$02:00B0
UART(4):THR=$02:00B0
UART(4):IER=$02:00B1
UART(4):ISR=$02:00B2
UART(4):LCR=$02:00B3
UART(4):MCR=$02:00B4
UART(4):LSR=$02:00B5
UART(4):MSR=$02:00B6
UART(4):SPR=$02:00B7
VAR=:P1:(1)0:07
WRITE_CURSOR(1)=$03:40
WRITE_CURSOR(2)=$03:41
WRITE_CURSOR(3)=$03:42
WRITE_CURSOR(4)=$03:43
XCH=:N1:P:0:0C
XCHD=:P1:0:1C
XRL=:N1:P:0:06
8051_7r2.def=1<0005
uart.msm=0<0003
:$(00):0000:00B8 :$(01):0400:0800 :$(02):0080:00B8 :$(03):0040:0048 
uart.msm: object code 381 bytes: 0 errors: 0 undefined labels

</pre>

<p>
$TREE..$ROOT structures may be nested to depth 8.
More complex examples can be found in Section
8.54: $TREE Directive.


<h3>7.3.2: branched structures $BRANCH..$ROOT</h3>


<p>
Structures declared with $BRANCH instead of $TREE start from
the same storage address. Values may freely be declared. The later
declared values load last:
<pre>

MASMX 7r2
3/ast.msm
*EOF*
  :                            1        $word   32
  :                            2 
  :                            3 $(4:040000)
  :                            4 
  :                            5 ast1   $branch
  :                            6 axil   $res    1
  :                            7 twig   $res    1
  :                            8 x      $do     12,leaf(x)      $res    1
04:0004000E 11111111          +9        +       011111111
  :                            10       $root
  :                            11 
  :                            12 ast2  $branch
  :                            13 x     $do     6,blossom(x)    $res    1
04:00040006 22222222          +14       +       022222222
  :                            15       $root
*EOF*

......

AST1=$04:00040000
AST1:AXIL=$04:00040000
AST1:TWIG=$04:00040001
AST1:LEAF(1)=$04:00040002
AST1:LEAF(2)=$04:00040003
AST1:LEAF(3)=$04:00040004
AST1:LEAF(4)=$04:00040005
AST1:LEAF(5)=$04:00040006
AST1:LEAF(6)=$04:00040007
AST1:LEAF(7)=$04:00040008
AST1:LEAF(8)=$04:00040009
AST1:LEAF(9)=$04:0004000A
AST1:LEAF(10)=$04:0004000B
AST1:LEAF(11)=$04:0004000C
AST1:LEAF(12)=$04:0004000D
AST2=$04:00040000
AST2:BLOSSOM(1)=$04:00040000
AST2:BLOSSOM(2)=$04:00040001
AST2:BLOSSOM(3)=$04:00040002
AST2:BLOSSOM(4)=$04:00040003
AST2:BLOSSOM(5)=$04:00040004
AST2:BLOSSOM(6)=$04:00040005
X=00000006
ast.msm=0<00000003
:$(04):00040000:0004000F 
ast.msm: object code 76 bytes: 0 errors: 0 undefined labels


</pre>
<p>
Pointer-based structures may be branched in the same way:
<pre>

MASMX 7r2
3/transport.msm
*EOF*
  :                            1        $word   16
  :                            2        $quantum        8
  :                            3        $awidth 32
  :                            4 
  :                            5 p      $proc
  :                            6 udp_datagram* $name
  :                            7 sourcep        +       p(1,1)
  :                            8 destp   +       p(1,2)
  :                            9 length  +       p(1,3)
  :                            10 checksum +      p(1,4)
  :                            11 data
  :                            12       $end
  :                            13 
  :                            14 p     $proc
  :                            15 tcp_segment*  $name
  :                            16 sourcep       +       p(1,1)
  :                            17 destp +       p(1,2)
  :                            18 sequence +    0:d
  :                            19 ack   +       0:d
  :                            20 hl_code       +       0
  :                            21 window        +       0
  :                            22 checksum +    0
  :                            23 urgent        +       0
  :                            24 data
  :                            25       $end
  :                            26 
  :                            27 pointer_register $equ 15
  :                            28 
  :                            29 $(67:,pointer_register)
  :                            30 
  :                            31 user_datagram $branch
43:00000000                   +32               udp_datagram
43:00000002                   +32 
43:00000004                   +32 
43:00000006                   +32 
  :                            33               $root
  :                            34 
  :                            35 tcp_part      $branch
43:00000000                   +36               tcp_segment
43:00000002                   +36 
43:00000004                   +36 
43:00000008                   +36 
43:0000000C                   +36 
43:0000000E                   +36 
43:00000010                   +36 
43:00000012                   +36 
  :                            37               $root
  :                            38 
  :                            39 
*EOF*

...

POINTER_REGISTER=000F
TCP_PART=00000000,0000000F
TCP_PART:SOURCEP=00000000,0000000F
TCP_PART:DESTP=00000002,0000000F
TCP_PART:SEQUENCE=00000004,0000000F
TCP_PART:ACK=00000008,0000000F
TCP_PART:HL_CODE=0000000C,0000000F
TCP_PART:WINDOW=0000000E,0000000F
TCP_PART:CHECKSUM=00000010,0000000F
TCP_PART:URGENT=00000012,0000000F
TCP_PART:DATA=00000014,0000000F
TCP_SEGMENT=:N1:P:0:0000
UDP_DATAGRAM=:N1:P:0:0000
USER_DATAGRAM=00000000,0000000F
USER_DATAGRAM:SOURCEP=00000000,0000000F
USER_DATAGRAM:DESTP=00000002,0000000F
USER_DATAGRAM:LENGTH=00000004,0000000F
USER_DATAGRAM:CHECKSUM=00000006,0000000F
USER_DATAGRAM:DATA=00000008,0000000F
transport.msm=0<00000003
:$(43):00000000:00000014 
transport.msm: object code 32 bytes: 0 errors: 0 undefined labels


</pre>
<h3>7.3.3: Complex Structures</h3>


<p>
Simple and branch structures can be combined hierarchically.
<pre>

Simple Structure			Branch of a Branched Structure
________________			______________________________

name	$TREE				name	$BRANCH
	.					.
	.					.
	.					.
	$ROOT					$ROOT

</pre>
<p>
In this example stem(*):left and stem(*):right are pictures of the same
storage:
<pre>

MASMX 7r2
3/complex.msm
*EOF*
  :                            1        $word   32
  :                            2 
  :                            3 p      $proc
  :                            4 one*   $name
  :                            5 *      $tree
  :                            6 left   two1
  :                            7 index  $do     6,spray(index)  two2
  :                            8        $root
  :                            9        $end
  :                            10 
  :                            11 p     $proc
  :                            12 two1* $name
  :                            13 *     $branch
  :                            14 index $do     4,bud(index)    three1
  :                            15         $root
  :                            16 right $branch
  :                            17 cusp  three2
  :                            18       $root
  :                            19       $end
  :                            20 
  :                            21 two2* $proc
  :                            22 *     $tree
  :                            23 index $do     12,tendril(index)       +      24-index
  :                            24       $root
  :                            25       $end
  :                            26 
  :                            27 three1*       $proc
  :                            28 *     $tree
  :                            29 index $do     4,shoot(index)  +       100
  :                            30       $root
  :                            31       $end
  :                            32 
  :                            33 three2*       $proc
  :                            34 *     $tree
  :                            35 index $do     8,blossom(index)        -      100
  :                            36       $root
  :                            37       $end
  :                            38 
  :                            39 $(2:02000)
02:00002000 00000064          +40 index $do     3,stem(index)   one
02:00002001 00000064          +40 
02:00002002 00000064          +40 

........

02:00002106 0000000D          +40 
02:00002107 0000000C          +40 
  :                            41 $(3:03000)
03:00003000 00000003          +42       +       stem()
  :                            43 first_high_index $set stem()
03:00003001 00000003          +44       +       first_high_index
03:00003002 000020B0          +45       +       stem(first_high_index)
03:00003003 00000004          +46       +       stem(first_high_index):left:bud()
  :                            47 second_high_index $set stem(first_high_index):left:bud()
03:00003004 00000004          +48       +       second_high_index
03:00003005 000020BC          +49       +       stem(first_high_index):left:bud(second_high_index)
  :                            50 
03:00003006 00000004          +52       +       stem(first_high_index):left:bud(second_high_index):;
                shoot()
  :                            53 
  :                            56 third_high_index $set ;
                stem(first_high_index):left:bud(second_high_index):;
                shoot()
  :                            57 
03:00003007 00000004          +58       +       third_high_index
  :                            59 
03:00003008 000020BF          +61       +       stem(first_high_index):left:bud(second_high_index):;
                shoot(third_high_index)
  :                            62 
03:00003009 00000006          +63       +       stem(first_high_index):spray()
  :                            64 second_high_index $set stem(first_high_index):spray()
03:0000300A 00000006          +65       +       second_high_index
03:0000300B 000020FC          +66       +       stem(first_high_index):spray(second_high_index)
  :                            67 
03:0000300C 0000000C          +68       +       stem(first_high_index):spray(second_high_index):tendril()
  :                            69 
  :                            71 third_high_index $set ;
                stem(first_high_index):spray(second_high_index):tendril()
  :                            72 
03:0000300D 0000000C          +73       +       third_high_index
03:0000300E 00002107          +75       +       ;
 stem(first_high_index):spray(second_high_index):tendril(third_high_index)
  :                            76 
03:0000300F 00000006          +77       +       stem(first_high_index):spray()
  :                            78 second_high_index $set stem(first_high_index):spray()
03:00003010 00000006          +79       +       second_high_index
  :                            80 
03:00003011 000020FC          +81       +       stem(first_high_index):spray(second_high_index)
03:00003012 0000000C          +82       +       stem(first_high_index):spray(second_high_index):tendril()
  :                            83 
  :                            85 third_high_index $set ;
                stem(first_high_index):spray(second_high_index):tendril()
  :                            86 
03:00003013 0000000C          +87       +       third_high_index
  :                            88 
03:00003014 00002107          +89  + stem(first_high_index):spray(second_high_index):tendril(third_high_index)
  :                            90 
03:00003015 00000008          +91       +       stem(first_high_index):right:cusp:blossom()
  :                            92 second_high_index $set stem(first_high_index):right:cusp:blossom()
03:00003016 00000008          +93       +       second_high_index
03:00003017 000020B7          +94       + stem(first_high_index):right:cusp:blossom(second_high_index)
*EOF*

.....

FIRST_HIGH_INDEX=00000003
INDEX=00000003
ONE=:N1:P:0:00000000
SECOND_HIGH_INDEX=00000008
STEM(1)=$02:00002000
STEM(1):LEFT=$02:00002000
STEM(1):LEFT:BUD(1)=$02:00002000
STEM(1):LEFT:BUD(1):SHOOT(1)=$02:00002000
STEM(1):LEFT:BUD(1):SHOOT(2)=$02:00002001
STEM(1):LEFT:BUD(1):SHOOT(3)=$02:00002002
STEM(1):LEFT:BUD(1):SHOOT(4)=$02:00002003
STEM(1):LEFT:BUD(2)=$02:00002004
STEM(1):LEFT:BUD(2):SHOOT(1)=$02:00002004
STEM(1):LEFT:BUD(2):SHOOT(2)=$02:00002005
STEM(1):LEFT:BUD(2):SHOOT(3)=$02:00002006
STEM(1):LEFT:BUD(2):SHOOT(4)=$02:00002007
STEM(1):LEFT:BUD(3)=$02:00002008
STEM(1):LEFT:BUD(3):SHOOT(1)=$02:00002008
STEM(1):LEFT:BUD(3):SHOOT(2)=$02:00002009
STEM(1):LEFT:BUD(3):SHOOT(3)=$02:0000200A
STEM(1):LEFT:BUD(3):SHOOT(4)=$02:0000200B
STEM(1):LEFT:BUD(4)=$02:0000200C
STEM(1):LEFT:BUD(4):SHOOT(1)=$02:0000200C
STEM(1):LEFT:BUD(4):SHOOT(2)=$02:0000200D
STEM(1):LEFT:BUD(4):SHOOT(3)=$02:0000200E
STEM(1):LEFT:BUD(4):SHOOT(4)=$02:0000200F
STEM(1):RIGHT=$02:00002000
STEM(1):RIGHT:CUSP=$02:00002000
STEM(1):RIGHT:CUSP:BLOSSOM(1)=$02:00002000
STEM(1):RIGHT:CUSP:BLOSSOM(2)=$02:00002001
STEM(1):RIGHT:CUSP:BLOSSOM(3)=$02:00002002
STEM(1):RIGHT:CUSP:BLOSSOM(4)=$02:00002003
STEM(1):RIGHT:CUSP:BLOSSOM(5)=$02:00002004
STEM(1):RIGHT:CUSP:BLOSSOM(6)=$02:00002005
STEM(1):RIGHT:CUSP:BLOSSOM(7)=$02:00002006
STEM(1):RIGHT:CUSP:BLOSSOM(8)=$02:00002007
STEM(1):SPRAY(1)=$02:00002010
STEM(1):SPRAY(1):TENDRIL(1)=$02:00002010
STEM(1):SPRAY(1):TENDRIL(2)=$02:00002011
STEM(1):SPRAY(1):TENDRIL(3)=$02:00002012
STEM(1):SPRAY(1):TENDRIL(4)=$02:00002013
STEM(1):SPRAY(1):TENDRIL(5)=$02:00002014
STEM(1):SPRAY(1):TENDRIL(6)=$02:00002015
STEM(1):SPRAY(1):TENDRIL(7)=$02:00002016
STEM(1):SPRAY(1):TENDRIL(8)=$02:00002017
STEM(1):SPRAY(1):TENDRIL(9)=$02:00002018
STEM(1):SPRAY(1):TENDRIL(10)=$02:00002019
STEM(1):SPRAY(1):TENDRIL(11)=$02:0000201A
STEM(1):SPRAY(1):TENDRIL(12)=$02:0000201B
STEM(1):SPRAY(2)=$02:0000201C
STEM(1):SPRAY(2):TENDRIL(1)=$02:0000201C
STEM(1):SPRAY(2):TENDRIL(2)=$02:0000201D
STEM(1):SPRAY(2):TENDRIL(3)=$02:0000201E
STEM(1):SPRAY(2):TENDRIL(4)=$02:0000201F
STEM(1):SPRAY(2):TENDRIL(5)=$02:00002020
STEM(1):SPRAY(2):TENDRIL(6)=$02:00002021
STEM(1):SPRAY(2):TENDRIL(7)=$02:00002022
STEM(1):SPRAY(2):TENDRIL(8)=$02:00002023
STEM(1):SPRAY(2):TENDRIL(9)=$02:00002024
STEM(1):SPRAY(2):TENDRIL(10)=$02:00002025
STEM(1):SPRAY(2):TENDRIL(11)=$02:00002026
STEM(1):SPRAY(2):TENDRIL(12)=$02:00002027
STEM(1):SPRAY(3)=$02:00002028
STEM(1):SPRAY(3):TENDRIL(1)=$02:00002028
STEM(1):SPRAY(3):TENDRIL(2)=$02:00002029
STEM(1):SPRAY(3):TENDRIL(3)=$02:0000202A
STEM(1):SPRAY(3):TENDRIL(4)=$02:0000202B
STEM(1):SPRAY(3):TENDRIL(5)=$02:0000202C
STEM(1):SPRAY(3):TENDRIL(6)=$02:0000202D
STEM(1):SPRAY(3):TENDRIL(7)=$02:0000202E
STEM(1):SPRAY(3):TENDRIL(8)=$02:0000202F
STEM(1):SPRAY(3):TENDRIL(9)=$02:00002030
STEM(1):SPRAY(3):TENDRIL(10)=$02:00002031
STEM(1):SPRAY(3):TENDRIL(11)=$02:00002032
STEM(1):SPRAY(3):TENDRIL(12)=$02:00002033
STEM(1):SPRAY(4)=$02:00002034
STEM(1):SPRAY(4):TENDRIL(1)=$02:00002034
STEM(1):SPRAY(4):TENDRIL(2)=$02:00002035
STEM(1):SPRAY(4):TENDRIL(3)=$02:00002036
STEM(1):SPRAY(4):TENDRIL(4)=$02:00002037
STEM(1):SPRAY(4):TENDRIL(5)=$02:00002038
STEM(1):SPRAY(4):TENDRIL(6)=$02:00002039
STEM(1):SPRAY(4):TENDRIL(7)=$02:0000203A
STEM(1):SPRAY(4):TENDRIL(8)=$02:0000203B
STEM(1):SPRAY(4):TENDRIL(9)=$02:0000203C
STEM(1):SPRAY(4):TENDRIL(10)=$02:0000203D
STEM(1):SPRAY(4):TENDRIL(11)=$02:0000203E
STEM(1):SPRAY(4):TENDRIL(12)=$02:0000203F
STEM(1):SPRAY(5)=$02:00002040
STEM(1):SPRAY(5):TENDRIL(1)=$02:00002040
STEM(1):SPRAY(5):TENDRIL(2)=$02:00002041
STEM(1):SPRAY(5):TENDRIL(3)=$02:00002042
STEM(1):SPRAY(5):TENDRIL(4)=$02:00002043
STEM(1):SPRAY(5):TENDRIL(5)=$02:00002044
STEM(1):SPRAY(5):TENDRIL(6)=$02:00002045
STEM(1):SPRAY(5):TENDRIL(7)=$02:00002046
STEM(1):SPRAY(5):TENDRIL(8)=$02:00002047
STEM(1):SPRAY(5):TENDRIL(9)=$02:00002048
STEM(1):SPRAY(5):TENDRIL(10)=$02:00002049
STEM(1):SPRAY(5):TENDRIL(11)=$02:0000204A
STEM(1):SPRAY(5):TENDRIL(12)=$02:0000204B
STEM(1):SPRAY(6)=$02:0000204C
STEM(1):SPRAY(6):TENDRIL(1)=$02:0000204C
STEM(1):SPRAY(6):TENDRIL(2)=$02:0000204D
STEM(1):SPRAY(6):TENDRIL(3)=$02:0000204E
STEM(1):SPRAY(6):TENDRIL(4)=$02:0000204F
STEM(1):SPRAY(6):TENDRIL(5)=$02:00002050
STEM(1):SPRAY(6):TENDRIL(6)=$02:00002051
STEM(1):SPRAY(6):TENDRIL(7)=$02:00002052
STEM(1):SPRAY(6):TENDRIL(8)=$02:00002053
STEM(1):SPRAY(6):TENDRIL(9)=$02:00002054
STEM(1):SPRAY(6):TENDRIL(10)=$02:00002055
STEM(1):SPRAY(6):TENDRIL(11)=$02:00002056
STEM(1):SPRAY(6):TENDRIL(12)=$02:00002057
STEM(2)=$02:00002058
STEM(2):LEFT=$02:00002058
STEM(2):LEFT:BUD(1)=$02:00002058
STEM(2):LEFT:BUD(1):SHOOT(1)=$02:00002058
STEM(2):LEFT:BUD(1):SHOOT(2)=$02:00002059
STEM(2):LEFT:BUD(1):SHOOT(3)=$02:0000205A
STEM(2):LEFT:BUD(1):SHOOT(4)=$02:0000205B
STEM(2):LEFT:BUD(2)=$02:0000205C
STEM(2):LEFT:BUD(2):SHOOT(1)=$02:0000205C
STEM(2):LEFT:BUD(2):SHOOT(2)=$02:0000205D
STEM(2):LEFT:BUD(2):SHOOT(3)=$02:0000205E
STEM(2):LEFT:BUD(2):SHOOT(4)=$02:0000205F
STEM(2):LEFT:BUD(3)=$02:00002060
STEM(2):LEFT:BUD(3):SHOOT(1)=$02:00002060
STEM(2):LEFT:BUD(3):SHOOT(2)=$02:00002061
STEM(2):LEFT:BUD(3):SHOOT(3)=$02:00002062
STEM(2):LEFT:BUD(3):SHOOT(4)=$02:00002063
STEM(2):LEFT:BUD(4)=$02:00002064
STEM(2):LEFT:BUD(4):SHOOT(1)=$02:00002064
STEM(2):LEFT:BUD(4):SHOOT(2)=$02:00002065
STEM(2):LEFT:BUD(4):SHOOT(3)=$02:00002066
STEM(2):LEFT:BUD(4):SHOOT(4)=$02:00002067
STEM(2):RIGHT=$02:00002058
STEM(2):RIGHT:CUSP=$02:00002058
STEM(2):RIGHT:CUSP:BLOSSOM(1)=$02:00002058
STEM(2):RIGHT:CUSP:BLOSSOM(2)=$02:00002059
STEM(2):RIGHT:CUSP:BLOSSOM(3)=$02:0000205A
STEM(2):RIGHT:CUSP:BLOSSOM(4)=$02:0000205B
STEM(2):RIGHT:CUSP:BLOSSOM(5)=$02:0000205C
STEM(2):RIGHT:CUSP:BLOSSOM(6)=$02:0000205D
STEM(2):RIGHT:CUSP:BLOSSOM(7)=$02:0000205E
STEM(2):RIGHT:CUSP:BLOSSOM(8)=$02:0000205F
STEM(2):SPRAY(1)=$02:00002068
STEM(2):SPRAY(1):TENDRIL(1)=$02:00002068
STEM(2):SPRAY(1):TENDRIL(2)=$02:00002069
STEM(2):SPRAY(1):TENDRIL(3)=$02:0000206A
STEM(2):SPRAY(1):TENDRIL(4)=$02:0000206B
STEM(2):SPRAY(1):TENDRIL(5)=$02:0000206C
STEM(2):SPRAY(1):TENDRIL(6)=$02:0000206D
STEM(2):SPRAY(1):TENDRIL(7)=$02:0000206E
STEM(2):SPRAY(1):TENDRIL(8)=$02:0000206F
STEM(2):SPRAY(1):TENDRIL(9)=$02:00002070
STEM(2):SPRAY(1):TENDRIL(10)=$02:00002071
STEM(2):SPRAY(1):TENDRIL(11)=$02:00002072
STEM(2):SPRAY(1):TENDRIL(12)=$02:00002073
STEM(2):SPRAY(2)=$02:00002074
STEM(2):SPRAY(2):TENDRIL(1)=$02:00002074
STEM(2):SPRAY(2):TENDRIL(2)=$02:00002075
STEM(2):SPRAY(2):TENDRIL(3)=$02:00002076
STEM(2):SPRAY(2):TENDRIL(4)=$02:00002077
STEM(2):SPRAY(2):TENDRIL(5)=$02:00002078
STEM(2):SPRAY(2):TENDRIL(6)=$02:00002079
STEM(2):SPRAY(2):TENDRIL(7)=$02:0000207A
STEM(2):SPRAY(2):TENDRIL(8)=$02:0000207B
STEM(2):SPRAY(2):TENDRIL(9)=$02:0000207C
STEM(2):SPRAY(2):TENDRIL(10)=$02:0000207D
STEM(2):SPRAY(2):TENDRIL(11)=$02:0000207E
STEM(2):SPRAY(2):TENDRIL(12)=$02:0000207F
STEM(2):SPRAY(3)=$02:00002080
STEM(2):SPRAY(3):TENDRIL(1)=$02:00002080
STEM(2):SPRAY(3):TENDRIL(2)=$02:00002081
STEM(2):SPRAY(3):TENDRIL(3)=$02:00002082
STEM(2):SPRAY(3):TENDRIL(4)=$02:00002083
STEM(2):SPRAY(3):TENDRIL(5)=$02:00002084
STEM(2):SPRAY(3):TENDRIL(6)=$02:00002085
STEM(2):SPRAY(3):TENDRIL(7)=$02:00002086
STEM(2):SPRAY(3):TENDRIL(8)=$02:00002087
STEM(2):SPRAY(3):TENDRIL(9)=$02:00002088
STEM(2):SPRAY(3):TENDRIL(10)=$02:00002089
STEM(2):SPRAY(3):TENDRIL(11)=$02:0000208A
STEM(2):SPRAY(3):TENDRIL(12)=$02:0000208B
STEM(2):SPRAY(4)=$02:0000208C
STEM(2):SPRAY(4):TENDRIL(1)=$02:0000208C
STEM(2):SPRAY(4):TENDRIL(2)=$02:0000208D
STEM(2):SPRAY(4):TENDRIL(3)=$02:0000208E
STEM(2):SPRAY(4):TENDRIL(4)=$02:0000208F
STEM(2):SPRAY(4):TENDRIL(5)=$02:00002090
STEM(2):SPRAY(4):TENDRIL(6)=$02:00002091
STEM(2):SPRAY(4):TENDRIL(7)=$02:00002092
STEM(2):SPRAY(4):TENDRIL(8)=$02:00002093
STEM(2):SPRAY(4):TENDRIL(9)=$02:00002094
STEM(2):SPRAY(4):TENDRIL(10)=$02:00002095
STEM(2):SPRAY(4):TENDRIL(11)=$02:00002096
STEM(2):SPRAY(4):TENDRIL(12)=$02:00002097
STEM(2):SPRAY(5)=$02:00002098
STEM(2):SPRAY(5):TENDRIL(1)=$02:00002098
STEM(2):SPRAY(5):TENDRIL(2)=$02:00002099
STEM(2):SPRAY(5):TENDRIL(3)=$02:0000209A
STEM(2):SPRAY(5):TENDRIL(4)=$02:0000209B
STEM(2):SPRAY(5):TENDRIL(5)=$02:0000209C
STEM(2):SPRAY(5):TENDRIL(6)=$02:0000209D
STEM(2):SPRAY(5):TENDRIL(7)=$02:0000209E
STEM(2):SPRAY(5):TENDRIL(8)=$02:0000209F
STEM(2):SPRAY(5):TENDRIL(9)=$02:000020A0
STEM(2):SPRAY(5):TENDRIL(10)=$02:000020A1
STEM(2):SPRAY(5):TENDRIL(11)=$02:000020A2
STEM(2):SPRAY(5):TENDRIL(12)=$02:000020A3
STEM(2):SPRAY(6)=$02:000020A4
STEM(2):SPRAY(6):TENDRIL(1)=$02:000020A4
STEM(2):SPRAY(6):TENDRIL(2)=$02:000020A5
STEM(2):SPRAY(6):TENDRIL(3)=$02:000020A6
STEM(2):SPRAY(6):TENDRIL(4)=$02:000020A7
STEM(2):SPRAY(6):TENDRIL(5)=$02:000020A8
STEM(2):SPRAY(6):TENDRIL(6)=$02:000020A9
STEM(2):SPRAY(6):TENDRIL(7)=$02:000020AA
STEM(2):SPRAY(6):TENDRIL(8)=$02:000020AB
STEM(2):SPRAY(6):TENDRIL(9)=$02:000020AC
STEM(2):SPRAY(6):TENDRIL(10)=$02:000020AD
STEM(2):SPRAY(6):TENDRIL(11)=$02:000020AE
STEM(2):SPRAY(6):TENDRIL(12)=$02:000020AF
STEM(3)=$02:000020B0
STEM(3):LEFT=$02:000020B0
STEM(3):LEFT:BUD(1)=$02:000020B0
STEM(3):LEFT:BUD(1):SHOOT(1)=$02:000020B0
STEM(3):LEFT:BUD(1):SHOOT(2)=$02:000020B1
STEM(3):LEFT:BUD(1):SHOOT(3)=$02:000020B2
STEM(3):LEFT:BUD(1):SHOOT(4)=$02:000020B3
STEM(3):LEFT:BUD(2)=$02:000020B4
STEM(3):LEFT:BUD(2):SHOOT(1)=$02:000020B4
STEM(3):LEFT:BUD(2):SHOOT(2)=$02:000020B5
STEM(3):LEFT:BUD(2):SHOOT(3)=$02:000020B6
STEM(3):LEFT:BUD(2):SHOOT(4)=$02:000020B7
STEM(3):LEFT:BUD(3)=$02:000020B8
STEM(3):LEFT:BUD(3):SHOOT(1)=$02:000020B8
STEM(3):LEFT:BUD(3):SHOOT(2)=$02:000020B9
STEM(3):LEFT:BUD(3):SHOOT(3)=$02:000020BA
STEM(3):LEFT:BUD(3):SHOOT(4)=$02:000020BB
STEM(3):LEFT:BUD(4)=$02:000020BC
STEM(3):LEFT:BUD(4):SHOOT(1)=$02:000020BC
STEM(3):LEFT:BUD(4):SHOOT(2)=$02:000020BD
STEM(3):LEFT:BUD(4):SHOOT(3)=$02:000020BE
STEM(3):LEFT:BUD(4):SHOOT(4)=$02:000020BF
STEM(3):RIGHT=$02:000020B0
STEM(3):RIGHT:CUSP=$02:000020B0
STEM(3):RIGHT:CUSP:BLOSSOM(1)=$02:000020B0
STEM(3):RIGHT:CUSP:BLOSSOM(2)=$02:000020B1
STEM(3):RIGHT:CUSP:BLOSSOM(3)=$02:000020B2
STEM(3):RIGHT:CUSP:BLOSSOM(4)=$02:000020B3
STEM(3):RIGHT:CUSP:BLOSSOM(5)=$02:000020B4
STEM(3):RIGHT:CUSP:BLOSSOM(6)=$02:000020B5
STEM(3):RIGHT:CUSP:BLOSSOM(7)=$02:000020B6
STEM(3):RIGHT:CUSP:BLOSSOM(8)=$02:000020B7
STEM(3):SPRAY(1)=$02:000020C0
STEM(3):SPRAY(1):TENDRIL(1)=$02:000020C0
STEM(3):SPRAY(1):TENDRIL(2)=$02:000020C1
STEM(3):SPRAY(1):TENDRIL(3)=$02:000020C2
STEM(3):SPRAY(1):TENDRIL(4)=$02:000020C3
STEM(3):SPRAY(1):TENDRIL(5)=$02:000020C4
STEM(3):SPRAY(1):TENDRIL(6)=$02:000020C5
STEM(3):SPRAY(1):TENDRIL(7)=$02:000020C6
STEM(3):SPRAY(1):TENDRIL(8)=$02:000020C7
STEM(3):SPRAY(1):TENDRIL(9)=$02:000020C8
STEM(3):SPRAY(1):TENDRIL(10)=$02:000020C9
STEM(3):SPRAY(1):TENDRIL(11)=$02:000020CA
STEM(3):SPRAY(1):TENDRIL(12)=$02:000020CB
STEM(3):SPRAY(2)=$02:000020CC
STEM(3):SPRAY(2):TENDRIL(1)=$02:000020CC
STEM(3):SPRAY(2):TENDRIL(2)=$02:000020CD
STEM(3):SPRAY(2):TENDRIL(3)=$02:000020CE
STEM(3):SPRAY(2):TENDRIL(4)=$02:000020CF
STEM(3):SPRAY(2):TENDRIL(5)=$02:000020D0
STEM(3):SPRAY(2):TENDRIL(6)=$02:000020D1
STEM(3):SPRAY(2):TENDRIL(7)=$02:000020D2
STEM(3):SPRAY(2):TENDRIL(8)=$02:000020D3
STEM(3):SPRAY(2):TENDRIL(9)=$02:000020D4
STEM(3):SPRAY(2):TENDRIL(10)=$02:000020D5
STEM(3):SPRAY(2):TENDRIL(11)=$02:000020D6
STEM(3):SPRAY(2):TENDRIL(12)=$02:000020D7
STEM(3):SPRAY(3)=$02:000020D8
STEM(3):SPRAY(3):TENDRIL(1)=$02:000020D8
STEM(3):SPRAY(3):TENDRIL(2)=$02:000020D9
STEM(3):SPRAY(3):TENDRIL(3)=$02:000020DA
STEM(3):SPRAY(3):TENDRIL(4)=$02:000020DB
STEM(3):SPRAY(3):TENDRIL(5)=$02:000020DC
STEM(3):SPRAY(3):TENDRIL(6)=$02:000020DD
STEM(3):SPRAY(3):TENDRIL(7)=$02:000020DE
STEM(3):SPRAY(3):TENDRIL(8)=$02:000020DF
STEM(3):SPRAY(3):TENDRIL(9)=$02:000020E0
STEM(3):SPRAY(3):TENDRIL(10)=$02:000020E1
STEM(3):SPRAY(3):TENDRIL(11)=$02:000020E2
STEM(3):SPRAY(3):TENDRIL(12)=$02:000020E3
STEM(3):SPRAY(4)=$02:000020E4
STEM(3):SPRAY(4):TENDRIL(1)=$02:000020E4
STEM(3):SPRAY(4):TENDRIL(2)=$02:000020E5
STEM(3):SPRAY(4):TENDRIL(3)=$02:000020E6
STEM(3):SPRAY(4):TENDRIL(4)=$02:000020E7
STEM(3):SPRAY(4):TENDRIL(5)=$02:000020E8
STEM(3):SPRAY(4):TENDRIL(6)=$02:000020E9
STEM(3):SPRAY(4):TENDRIL(7)=$02:000020EA
STEM(3):SPRAY(4):TENDRIL(8)=$02:000020EB
STEM(3):SPRAY(4):TENDRIL(9)=$02:000020EC
STEM(3):SPRAY(4):TENDRIL(10)=$02:000020ED
STEM(3):SPRAY(4):TENDRIL(11)=$02:000020EE
STEM(3):SPRAY(4):TENDRIL(12)=$02:000020EF
STEM(3):SPRAY(5)=$02:000020F0
STEM(3):SPRAY(5):TENDRIL(1)=$02:000020F0
STEM(3):SPRAY(5):TENDRIL(2)=$02:000020F1
STEM(3):SPRAY(5):TENDRIL(3)=$02:000020F2
STEM(3):SPRAY(5):TENDRIL(4)=$02:000020F3
STEM(3):SPRAY(5):TENDRIL(5)=$02:000020F4
STEM(3):SPRAY(5):TENDRIL(6)=$02:000020F5
STEM(3):SPRAY(5):TENDRIL(7)=$02:000020F6
STEM(3):SPRAY(5):TENDRIL(8)=$02:000020F7
STEM(3):SPRAY(5):TENDRIL(9)=$02:000020F8
STEM(3):SPRAY(5):TENDRIL(10)=$02:000020F9
STEM(3):SPRAY(5):TENDRIL(11)=$02:000020FA
STEM(3):SPRAY(5):TENDRIL(12)=$02:000020FB
STEM(3):SPRAY(6)=$02:000020FC
STEM(3):SPRAY(6):TENDRIL(1)=$02:000020FC
STEM(3):SPRAY(6):TENDRIL(2)=$02:000020FD
STEM(3):SPRAY(6):TENDRIL(3)=$02:000020FE
STEM(3):SPRAY(6):TENDRIL(4)=$02:000020FF
STEM(3):SPRAY(6):TENDRIL(5)=$02:00002100
STEM(3):SPRAY(6):TENDRIL(6)=$02:00002101
STEM(3):SPRAY(6):TENDRIL(7)=$02:00002102
STEM(3):SPRAY(6):TENDRIL(8)=$02:00002103
STEM(3):SPRAY(6):TENDRIL(9)=$02:00002104
STEM(3):SPRAY(6):TENDRIL(10)=$02:00002105
STEM(3):SPRAY(6):TENDRIL(11)=$02:00002106
STEM(3):SPRAY(6):TENDRIL(12)=$02:00002107
THIRD_HIGH_INDEX=0000000C
THREE1=:P1:0:00000003
THREE2=:P1:0:00000004
TWO1=:N1:P:0:00000000
TWO2=:P1:0:00000002
complex.msm=0<00000003
:$(02):00002000:00002108 :$(03):00003000:00003018 
complex.msm: object code 2976 bytes: 0 errors: 0 undefined labels

</pre>

<h1>8:    The Directives:</h1>                                         

<h2>8.1:  $ASCII             Set Character Set to ASCII</h2>


<p>
$ASCII sets the generated character code for text constants bound by
the quote symbol to ASCII. $DATA_CODE defines and/or selects an alternate 
generated character code for text constants.

<p>
Input is always in ASCII. The initial selection for encoding is $ASCII.



<h2>8.2:  $AWIDTH            Output File Load Address Width</h2>


<p>
$AWIDTH governs the width of addresses placed in the output file
for inclusion in load string formats. If it is a different value from
$WORD it must be submitted to the assembly later than $WORD. For
example, a suitable $WORD value for 8-bit microcontrollers is 8, but
a suitable $AWIDTH is 16:
<pre>

	$WORD   8       . 8-bit microcontroller
	$AWIDTH 16      . Load Strings have a 16-bit address

</pre>
<p>
A suitable $WORD for M68K is 16, but a suitable $AWIDTH is 32
<pre>

	$WORD   16      ; Standard Size Generated Data Item is 16 bits
	$AWIDTH 32      ; Load Strings have a 32-bit address 
	
</pre>
<p>
If giant address spaces are used, then the giant part of the address
is stated after the primary part.
<pre>

	$AWIDTH 32:64

</pre>
<p>
The maximum size of the first or "net" part is 32 bits.

<p>
The maximum size of the second or giant-stepped part is 192 bits.

<p>
See Section 4.1.2.1: Describing the Address Space: Location Counter Controls.

<p>
See Section 9: Output File Formats, Relocation and Linking,
Giant Address Spaces, Interfacing with GNU Tools.


<h2>8.3:  $BLANK		Set the Globality of a Future Label</h2>


<p>
$BLANK sets the globality of a label which is not yet declared,
for example
<pre>

entry_point*	$blank	0
	.
	.
entry_point
	la	r1, #initial_stack
	.
	.

</pre>

<h2>8.4:  $BRANCH		Structure Overlay</h2>


<p>
$BRANCH is the start of a structure overlay. The following assembly
with part of its label listing shows an  example of overlaid
storage definition
<pre>

MASMX 7r2
3/welblech.msm
*EOF*
  :                            1 p      $proc
  :                            2 yooz*  $name
  :                            3 *      $tree
  :                            4 yo*    $branch
  :                            5        +       7
  :                            6        +       8
  :                            7        +       9
  :                            8        $root
  :                            9 ho*    $branch
  :                            10       +       12
  :                            11       $root
  :                            12       $root
  :                            13       $end
  :                            14 
  :                            15 $(6:06000)
  :                            16 well $tree
  :                            17 switch $res 1
  :                            18 blech $branch
06:006001 000001              +19 up + 1
06:006002 000007              +20 halfway yooz
06:006003 000008              +20 
06:006004 000009              +20 
06:006002 00000C              +20 
06:006005 000063              +21 down  +       99
  :                            22  $root
  :                            23 
  :                            24 fest  $branch
06:006001 000002              +25 left  +       2
06:006002 000007              +26 centre        yooz
06:006003 000008              +26 
06:006004 000009              +26 
06:006002 00000C              +26 
06:006005 000064              +27 right +       100
  :                            28       $root
  :                            29       $root
  :                            30 
06:006006 006002              +31       +       well:blech:halfway:ho
06:006007 006002              +32       +       well:fest:centre:yo
06:006008 006005              +33       +       well:blech:down
06:006009 006001              +34       +       well:fest:left
*EOF*
.
.
.
WELL=$06:006000
WELL:SWITCH=$06:006000
WELL:BLECH=$06:006001
WELL:BLECH:UP=$06:006001
WELL:BLECH:HALFWAY=$06:006002
WELL:BLECH:HALFWAY:YO=$06:006002
WELL:BLECH:HALFWAY:HO=$06:006002
WELL:BLECH:DOWN=$06:006005
WELL:FEST=$06:006001
WELL:FEST:LEFT=$06:006001
WELL:FEST:CENTRE=$06:006002
WELL:FEST:CENTRE:YO=$06:006002
WELL:FEST:CENTRE:HO=$06:006002
WELL:FEST:RIGHT=$06:006005
YOOZ=:N1:P:0:000000
welblech.msm=0<000003
:$(06):006000:00600A 
welblech.msm: object code 215 bytes: 0 errors: 0 undefined labels


</pre>

<h2>8.5:  $BYTE              Set the Width of a Data Character</h2>


<p>
$BYTE is defaulted to 8, and is only likely to be anything different
if the target machine's address quantum is other than a byte, for
example a word of 30 or 48 or 60 bits. See Section 8.41: $QUANTUM,
Section 10: Byte-Addressing Machines with 32 and 64 Bit Bus: Managing 
Alignments	

<p>
$BYTE also applies with +'symbols' bounded by single quote in number
expressions. ASCII is read in source code, but the +'expression' token
has a value in the current character set and size.

<p>
See also 8.8: $DATA_CODE directive.

<p>
Here is an example of an assembly for a 48-bit architecture generating
string constants first of 8-bit then 6-bit bytes.
<pre>

MASMX/-240 1r1X
big48.msm 5
*EOF*  :                        1:         $word   48
  :                        2:         $quantum 48
00:00000000 496E697469616C20537472696E6773206F6620382D626974
			 +3         "Initial Strings of 8-bit data"
00:00000004 206461746120  +3 
  :                        4:         $byte   6
00:00000005 B21D25C80CF4CA9BA7CC0BE6034A67A34B39030863AE5900
			 +5         "Later Strings of Tightly Packed Data"
00:00000009 921D21000000  +5 
*EOF*:$(00):0000000A 
Object Code 150 Bytes: 0 Errors: 0 Undefined Labels

</pre>
<p>
Where the width of $BYTE is less than 7 and the character code is still
ASCII, the character values are compressed by discarding bit 5 and
placing 6-bits right justified in the target field. Truncation then
takes place if the target field is less than 6 bits.
<pre>

	________________________________________________________________|
	|   0   |   d   |discard|   d   |   d   |   d   |   d   |   d   |
Input   |_______|_______|_______|_______|_______|_______|_______|_______|
		    |               |       |       |       |       |   |
		    |_______        |       |       |       |       |   |
			____|_______|_______|_______|_______|_______|___|
			|   d   |   d   |   d   |   d   |   d   |   d   |
Receiving Field         |_______|_______|_______|_______|_______|_______|
									|

</pre>
<p>
The $DATA_CODE directive may be used to organise a completely different
data code translation.

<p>
There are special considerations where $WORD size is not an exact 
multiple of the $BYTE size. Here is an example of 7-bit character
data generated for a 30-bit architecture.
<pre>

$ ../masmx qzuli -ln
MASMX 7r2
3/qzuli.msm
*EOF*
  :                            1         $set_option "e"
  :                            2         $word   30
  :                            3         $octal
  :                            4         $byte   7
000:0000000000  3757677375 7677375767 7375767737 5767737576 7737576773 7576773757
                              +5         "???????????????????????????????"
Note: qzuli.msm Line 5: trailing zero bits in last data word of string
000:0000000006  6773757677 3750040200
                              +5 
000:0000000010  3757677375 7677375767 7375767737 5767737576 7737576773 7576773757
                              +6         "??????????????????????????":127:127:127:127
000:0000000016  7777777777     +6 
*EOF*
:$(0):0000000000:0000000017 
qzuli.msm: object code 162 bytes: 0 errors: 0 undefined labels

</pre>

<p>
<b>$octal</b> directive shows the 30-bit words and adresses in octal.

<p>
In line 4, the assembler added three 7-bit space characters to fill the
last data word, but still needed to add two trailing zero bits.

<p>
The first 30 characters had exactly filled seven data words, but the last
character left 23 bits.

<p>
Space fill in the last word is added without comment. <b>-c</b> or
<b>-z</b> flag causes zero fill instead of space.
<b>-zc</b> flags combined fill with space

<p>
Slack bits remaining after the last character position are zeroed
and a message is output

<p>
The constant in line 5 exactly fills 210 bits or seven data words.

<p>
Setting $WORD automatically sets $QUANTUM.

<p>
Best known architectures have an address quantum of 8 and a word
size 16 or 32. For these, quantum must be set to 8 after word size.

<p>
This 30-bit architecture has a 30-bit quantum. So only 15 locations
have been filled.

<p>
The <b>-e</b> flag causes a space to be printed between each word of generated
code. This makes readable when the word size does not fit an exact number of
hex or octal symbols

<p>
Another case of a text string being placed in a field not a multiple
of $BYTE can arise where the target field is in a $FORM:
<pre>

$ masmx ldes -ln
MASMX 7r2
3/ldes.msm
*EOF*
  :                            1         $word   32
  :                            2         $quantum 8
  :                            3         $byte   8
  :                            4 label_descriptor $form  8, 8, 16, 4, 60   
  :                            5 
00:00000000 0700FFF63404C4142454C310
                              +6      label_descriptor 7,0,-10,3,"@LABEL1"
*EOF*
:$(00):00000000:0000000C 
ldes.msm: object code 70 bytes: 0 errors: 0 undefined labels

</pre>
<p>
In this example the characters @LABEL1 have been placed 
in the first 56 bits of their 60-bit field, and four zero 
bits appended.

<p>
Quoted character fields in a $FORM structure are zero-padded
in any untyped columns. The columns can be typed as space to force
space, as "@VOL2&nbsp;&nbsp;" distinct from "@VOL1" here
<pre>
$ masmx ldes2 -ln
MASMX 7r2
3/ldes2.msm
*EOF*
  :                            1         $word   32
  :                            2         $quantum 8
  :                            3         $byte   8
  :                            4 label_descriptor $form  8, 8, 16, 4, 60   
  :                            5 
00:00000000 0700FFF6340564F4C3100000
                              +6 	label_descriptor 7,0,-10,3,"@VOL1"
00:0000000C 0707000A740564F4C3220200
                              +7 	label_descriptor 7,7, 0a,7,"@VOL2  "
*EOF*
:$(00):00000000:00000018 
ldes2.msm: object code 95 bytes: 0 errors: 0 undefined labels

</pre>
<p>
A quoted string in a macro macro expansion may contain parameter
references:
<pre>

MASMX/-240 1r1X
bdw.msm 5
*EOF*  :                        1: bdw     $form   24,12,6,6,48
  :                        2: p       $proc   5
  :                        3: bd      $name        
  :                        4:         $byte   6
  :                        5:         bdw     p(1, 1), 0, 0, p(1, 2), "p(1, 1)"
  :                        6:         $byte   8
  :                        7:         $end
  :                        8: 
00:00000000 0000000000038A1BAB440000+9         bd      bank1, 3
00:00000004 0000000000078A1BAB450411+10         bd      bank1001, 7
*EOF*:$(00):00000008 
Object Code 127 Bytes: 0 Errors: 2 Undefined Labels

</pre>
<p>
The right half of the first structure contains the text
"bank1   " compressed to 6-bit characters.

<p>
The right half of the second structure contains the text "bank1001"
compressed to 6-bit characters (bit 5 of each ASCII symbol is dropped):
<pre>

	    62     61     6e     6b     31     20     20     20
	100010 100001 101110 101011 010001 000000 000000 000000

	    62     61     6e     6b     31     30     30     31
	100010 100001 101110 101011 010001 010000 010000 010001

</pre>
<p>
The macro references "bank1 and "bank1001" as well as capturing the
names as text. External references have been marked 
in the output file. Those are the two undefined labels.


<h2>8.6:  $CHARACTERISTIC    Set Floating Point Characteristic Size</h2>

<p>
$CHARACTERISTIC sets the size or sizes of the characteristic part
(sign + exponent) of floating point items. If the $CHARACTERISTIC
directive has a subcommand, for example:
<pre>

	$characteristic,64      SIZE 
	
</pre>
<p>
then size is the characteristic size of a 64-bit floating point item.

<p>
Without the subcommand, SIZE is the characteristic size of a
default-size floating point item. 

<p>
A default-size floating point item is 96 bits unless $FLOATING_POINT directive has changed it.

<p>
The default 96-bit floating point item has the default characteristic
size 24 bits, and the mid-pointed exponent is 23 bits:
<pre>


	_______________________________________________________________
	|s|94 exponent 72|71          mantissa                       0|
	|_|______________|____________________________________________|


</pre>
<p>
In the following example, a default sized floating point 
item is 32 bits, set by the $FLOATING_POINT directive, 
but there may also be 64-bit and 80-bit floating constants 
generated, which each require a different width of characteristic 
from the default of 8.

<p>
The largest characteristic size possible is 24 bits. The largest
floating point item size possible is 192 bits.
<pre>


$ masmx -ln dfp16
MASMX 7r2
3/dfp16.msm
*EOF*
  :                            1         $word   16
  :                            2         $quantum 8
  :                            3         $awidth 32
  :                            4         $floating_point 32
  :                            5         $characteristic 8
  :                            6         $characteristic,64 12
  :                            7         $characteristic,80 16
  :                            8 $(2:*8:256)        
02:00000100 41C00000          +9 one     +1.5
02:00000104 401E000000000000  +10 two     +1.75:q
02:0000010C 4001C000000000000000
                              +11 three   +15.0e-1:p
02:00000116 B837FFFF          +12 four    -100.0
02:0000011A 47C80000          +13 	+100.0
02:0000011E 438CC2DC14A740E08BDA
                              +14 five    +33*+20000:p
*EOF*
:$(02):00000000:00000128 
dfp16.msm: object code 145 bytes: 0 errors: 0 undefined labels

</pre>
<p>
Here, 64-bit floating point items (quadwords where $WORD 
is 16) are given  a 12-bit characteristic, and 80-bit 
floating point items (pentawords) have a 16-bit characteristic. 

<p>
The default floating model has a mid-pointed exponent 
occupying all the $CHARACTERISTIC width except the high-order 
sign bit, the mantissa is normalised fraction-only with no 
integral part either represented or imputed, and negative 
representation is the ones complement of the entire item.

<p>
This is not IEEE 754 encoding. IEEE 754, or any 
other encoding different from masmx default, is generated 
with macros which use the <b>$set</b> directive to capture
and manipulate a number argument.

<p>
Macro language does reversed byte order if needed. 

<p>
Code written for other assemblers has constant-generating
pseudo-directives (for example, .float).

<p>
Macros implement these directives for masmx.

<p>
Floating point values are calculated to 192 bits precision, and
the default output is 96 bits:
<pre>

$ masmx -ln gflo
MASMX 7r2
3/gflo.msm
*EOF*
00:000000 BFFFFE3FFFFFFFFFFFFFFFFF
                              +1         -1.5
00:000004 72B04D80286861658C3056A5
                              +2         +15*+1000000
00:000008 0D4FBCE0B90EE9FC3D9D7123
                              +3         +15*-1000000
*EOF*
:$(00):000000:00000C 
gflo.msm: object code 112 bytes: 0 errors: 0 undefined labels


</pre>
<p>
24 is the maximum characteristic width, and the default for floating-point
items three or more words in size. The default for a single floating-point
word is 8 bits and for a double 12:
<pre>

MASMX/-240 1r1X
hflo.msm 5
*EOF*  :                        1:         $word   32
  :                        2:         $quantum 8
  :                        3:         $awidth 32
  :                        4:         $floating_point 32
00:00000000 41C00000      +5         1.5
00:00000004 401C000000000000+6         1.5d
00:0000000C 400001C00000000000000000+7         1.5t
00:00000018 400001C0000000000000000000000000
			 +8         1.5q
00:00000028 400001C000000000000000000000000000000000
			 +9         1.5p
00:0000003C 400001C00000000000000000000000000000000000000000
			 +10         1.5h
00:00000054 400001C00000000000000000000000000000000000000000
			 +11         1.5o
*EOF*:$(00):0000006C 
Object Code 246 Bytes: 0 Errors: 0 Undefined Labels

</pre>
<p>
The request to generate an octaword item only resulted in
a hexaword, because 192 bits is the limit of masmx.
Octawords may be generated when $WORD is 24 or less.

<p>
Floating point items are not auto-sized like integers.

<p>
Floating point items are the default $FLOATING_POINT size, 
or the size selected with the trailing letter: 
<pre>

	S for single (one word)
	D or L for double 
	T for triple
	Q for quadword
	P for pentaword
	H for hexaword
	O for octaword

</pre>
<p>
These trailing letters may be upper or lower case and may have a
colon before them:
<pre>

	67.5:t

</pre>
<p>
Because only decimal digits, signs, a period and a characteristic
operator (*+ *- e e+ e- E E+ E-) may appear in an input string
for floating point, and neither hex nor labels may appear there, 
it is safe to use the trailing D without a colon for a two-word 
floating point item:
<pre>

	1.75*+200d

</pre>
<p>
The period is optional, but if it is absent, only the *+ or *-
operator (and not the E E+ E-) will inform the assembler that
the item is floating point.

<p>
To generate floating values using every type of expression token,
see 4.2.2.2.5: The Decimal Scale Operator
<b>*+ *-</b>


<h2>8.7:  $CONT_CHAR          Change Line Continuation Character</h2>

<p>
Default $CONT_CHAR is semicolon. The line is catenated with the
first noncomment non-white-space non-continuation character
on the next line:
<pre>

MASMX/-240 1r1X
leggy.msm 5
*EOF*00:00000000 00055555      +10         +       262144;
       	       					  ++65536;
	     					  ++16384;      
						   ++4096;
					  	   ++1024;
					   	    ++256;
					    	     ++64;
		  				     ++16;
						      ++4;
		   				      ++1
		 
*EOF*:$(00):00000001 
Object Code 25 Bytes: 0 Errors: 0 Undefined Labels


</pre>
<p>
To use semicolon for comment or for anything else,
continuation must be changed first.

<p>
Then semicolon is immediately available for reassignment
as comment character (and then period is immediately available for
reassignment as substring terminator).
<pre>

	$cont_char      0
	$lterm          ';'

</pre>
<p>
Setting continuation to zero means there is no line continuation.

<p>
If another character is wanted for line continuation,
then the $CONT_CHAR argument is not zero, but the value
of the required character. All of these are tilde ~
<pre>

	$cont_char       '~'
	$cont_char       07e
	$cont_char       126

</pre>
<p>
To get space into a continued line, the space must be before the
continuation character, because leading whitespace on the next line
is skipped:
<pre>

	$cont_char	'\'

	command		field1	\
			field2	\
			field3

</pre>

<p>
Line continue character does not act if a nonspace token follows
it immediately:
<pre>

$ masmx -ln
MASMX 7r2
0/-INPUT>>
	$cont_char       '\'
CONT_CHAR=\
	$word		32
	+		\10101010\	bit pattern 0xAA and line continue
			*/16\		shift left 16 and line continue
			++3     	. OR 3
	$end
  :                            1  $cont_char '\'
  :                            2  $word  32
00:00000000 00AA0003          +3  +  \10101010*/16++3  . OR 3
  :                            4  $end
:$(00):00000000:00000001 
-INPUT>>: object code 54 bytes: 0 errors: 0 undefined labels

</pre>


<h2>8.8:  $DATA_CODE             Set Alternative Character Set</h2>

<p>
$DATA_CODE is used to declare an alternate data code for quoted
text strings and to select it.

<p>
masmx reads ASCII input, but $DATA_CODE directive lets "text strings"
and +'number constants' be generated in another target data code.

<p>
The initial alternate data code is the same as ASCII, but $DATA_CODE
can change all or part of it. For example:
<pre>

MASMX/-240 1r1X
code.msm 5
*EOF*  :                        1:         $word   32
  :                        2:         $quantum  8
  :                        3:         $byte   8
  :                        4:         $awidth 32
00:00000000 41424320      +5         "ABC"
  :                        6:         $data_code  'A':0c1, 0c2, 0c3, 0c4, 0c5, 0c6, 0c7, 0c8, 0c9
  :                        7:         $data_code  32:64
00:00000004 C1C2C3C4C5C64040+8         "ABCDEF"
  :                        9:         $ascii
00:0000000C 4142434445462020+10         "ABCDEF"
  :                        11:         $data_code
00:00000014 C1C2C340      +12         "ABC"
*EOF*:$(00):00000018 
Object Code 73 Bytes: 0 Errors: 0 Undefined Labels

</pre>
<p>
Here the $DATA_CODE directive has been used to generate alternative 
values for the first nine letters of the alphabet, and for the 
space character.

<p>
$DATA_CODE also switches to the alternative data code as it constructs it.

<p>
$ASCII switches back to ASCII text generation,
but leaves the alternate code available.

<p>
$DATA_CODE without any operands switches to the previously constructed data
code again. Both assembly passes begin in ASCII character mode.


<h2>8.9: $DO                Generate Repeated Code</h2>     

$DO repeats code.

<p>
The arguments are the repeat count, a comma, and the line of code
to be repeated:
<pre>

MASMX 7r2
3/do1.msm
*EOF*
00:000000 000021              +1         $do      5, +   33
00:000001 000021              +1 
00:000002 000021              +1 
00:000003 000021              +1 
00:000004 000021              +1 
*EOF*
:$(00):000000:000005 
do1.msm: object code 72 bytes: 0 errors: 0 undefined labels

</pre>

<p>
$DO may be nested and the label on the $DO line represents a relative-1
ascending counter:
<pre>


        $word	32

hunthou	$do	10,;
hundred $do     10,;
ten     $do     10,;
unit    $do     10, + hunthou+'0'-1, hundred+'0'-1, ten+'0'-1, unit+'0'-1


MASMX 7r2
3/dotable.msm
*EOF*
  :                            1         $word	32
  :                            2 
00:00000000 30303030          +6 hunthou	$do	10,;
hundred $do     10,;
ten     $do     10,;
unit    $do     10, + hunthou+'0'-1, hundred+'0'-1, ten+'0'-1, unit+'0'-1
00:00000001 30303031          +6 
00:00000002 30303032          +6 
00:00000003 30303033          +6 
00:00000004 30303034          +6 
00:00000005 30303035          +6 
.
.
.
00:0000270B 39393935          +6 
00:0000270C 39393936          +6 
00:0000270D 39393937          +6 
00:0000270E 39393938          +6 
00:0000270F 39393939          +6 
*EOF*
:$(00):00000000:00002710 
dotable.msm: object code 90045 bytes: 0 errors: 0 undefined labels

</pre>
<p>
The counter argument to $DO is evaluated to a precision of 192 bits.
32 bits of the expression's final value are used as a count.
	
Therefore the expression
<pre>

	$DO     label>07FF0000000000000000000

</pre>
<p>
Is evaluated correctly. The value of the expression
<pre>

		label>07FF0000000000000000000

</pre>
is either one for "greater" or zero for "not greater". 
<p>
A repeat count expression sometimes has possible values
only of zero or one, as:
<pre>

	x=y

	x^=y
	
	$o('x')

</pre>
<p>
Then  $DO has the effect of a decision. The code line argument is
assembled once or not.

<p>
When the count argument of $DO is zero, the code line argument
is not assembled.

<p>
A label on a $DO has an incrementing value starting from 1:
<pre>

MASMX 7r2
0/-INPUT>>
count_up        $do     5,      +       6-count_up
        $end
00:000000 000005              +1 count_up $do 5, + 6-count_up
00:000001 000004              +1 
00:000002 000003              +1 
00:000003 000002              +1 
00:000004 000001              +1 
  :                            2  $end
:$(00):000000:000005 
-INPUT>>: object code 72 bytes: 0 errors: 0 undefined labels

</pre>
<p>
$DO can only iterate one line of code, but that line can be a macro call.


<h2>8.10: $ELSE              Conditional Assembly</h2>
      

<p>
Part of conditional assembly
<pre>

	$if     expression1
	.
	.
	$elseif expression2
	.
	.
	$else
	.
	.
	$endif

</pre>
<h2>8.11: $ELSEIF            Conditional Assembly</h2>                

<p>
Part of conditional assembly
<pre>

	$if     expression1
	.
	.
	$elseif expression2
	.
	.
	$else
	.
	.
	$endif


</pre>

<h2>8.12: $END               End of Macro or Assembly</h2>          

<p>
This image is required at the end of all subassemblies (macros)
<pre>

name_of* $proc
	.
	.
	$end

tag_of*	$func
	.
	.
	$end

</pre>
<p>
If $END is encountered in the main assembly, its effect is end of
assembly. In the main assembly a program transfer address may be supplied
as an argument to $END
<pre>

	$end    program_transfer_address

</pre>
<p>
$END in an include file doesn't stop the assembly, so $END can be
used in an include file to give a transfer address.



<h2>8.13: $ENDIF             Conditional Assembly</h2>              

<p>
Part of conditional assembly
<pre>

	$if     expression1
	.
	.
	$elseif expression2
	.
	.
	$else
	.
	.
	$endif



</pre>
<h2>8.14: $EQU               Assign Value to Label</h2>


<p>
$EQU assigns a value to a label for the duration of the 
assembly or subassembly (macro). 

<p>
The label may be assigned any value which can be expressed
in 192 bits.
<pre>

label   $equ    10*44*/180

</pre>
<p>
If a label is equated again, a warning note is output
and the label is given the new value.

<p>
A label is equated on the second assembly pass if it does not yet exist.

<p>
If the label is equated for the first time on the second assembly pass
(see Functions which Generate Code and Second Pass Only Functions,
Section 8.22.1), then only its first equate is actioned.

<p>
Labels mostly cannot be changed in type between location, $EQU, $SET etc,
although $SET labels may be $SET again to new values. See Section 8.46:
$SET Directive.

<p>
$EQU may have a subfunction which assigns a TYPE to the label.
Two types supplied within the assembler, $DIRECTIVE and $FUNCTION,
may be used for aliasing:
<pre>

.macro  $equ,$directive $proc
.endm   $equ,$directive $end

.       $equ,"$function" "$"

</pre>
<p>
$FUNCTION means assembler supplied functions, like the location
counter, not user-written $FUNC..$END macro functions.

<p>
To make . functionally the same as $ location counter, "$" is in
quotes. Otherwise $ returns its functional value, the current location.

<p>
The developer may use a range of type values 128..191 to type,
for example, register sets:
<pre>

data_register   $equ    128
address_register $equ   129

d0      $equ,data_register      0
d1      $equ,data_register      1
	.
	.
d7      $equ,data_register      7

a0      $equ,address_register   0
a7      $equ,address_register   7
	.
	.
a7      $equ,address_register   7

</pre>
<p>
This allows the actual parameters of instruction macros to have a type.
The type of a tag can be retrieved with the $T internal function:
<pre>

p       $proc
move.w  $name
	$if     $t(p(1,1))=address_register
	.
	.

</pre>
<p>
This is useful in dialects where many instructions have the same
name but the encodings change for different operand types.



<h2>8.15: $EQUF              Assign List of Values to Label</h2>

<p>
$EQUF equates a label to a list of values.

<p>
Macro expansion can then retrieve each value individually as a
separate argument. 

<p>
Each value corresponds to a subfield in the FIELD, SUBFIELD
paradigm.

<p>
$EQUF typically equates a base-displacement tuple plus possibly
further attributes like indirection or field-size:
<pre>

aName   $equf   buffer, r9, halfaword
	.
	.
	addto   r6, aName

</pre>
<p>
has the effect
<pre>

	addto   r6, buffer, r9, halfaword

</pre>
<p>
Arithmetic is possible on the first or principal $EQUF value:
<pre>

	addto   r6, aName+5

</pre>
<p>
has the effect
<pre>

	addto   r6, buffer+5, r9, halfwaword

</pre>
<p>
The $EQUF name must be on the left of any +- expression or the
other attributes aren't retrieved.

<p>
That is,
<pre>

	addto   r6, aName+5

</pre>
<p>
works as
<pre>

	addto   r6, buffer+5, r9, halfwaword

</pre>
<p>
but
<pre>

	addto   r6, 5+aName

<p>
only works as

	addto   r6, 5+buffer


</pre>
<p>
In "addto r6,aName+5", the addto macro receives for its
arguments:
<pre>

	addto(1, 1)     is      r6
	addto(1, 2)     is      buffer+5
	addto(1, 3)     is      r9
	addto(1, 4)     is      halfaword

</pre>
<p>
Each binary token in the $EQUF may have a retrievable 
unary * flag, as subfields always can

<p>
Where
<pre>

aName   $equf   buffer, *r9, halfaword
	.
	.
	addto   r4, aName

</pre>
<p>
Then
<pre>

	addto(1, *3)    is      1

</pre>
<p>
*R9 is only the second subfield of aName, but R4 is a subfield before
aName. addto can see four subfields.

<p>
Where r9 is supplied, not *r9, the value of "addto(1, *3)" is zero.
Either way, the value of "addto(1, 3)" is r9.

<p>
It's possible to override the trailing attributes. Where:
<pre>

aName   $equf   buffer, r9, halfaword
	.
	.
	addto   r6, aName,,all_of_aword

</pre>
<p>
The effect is
<pre>

	addto   r6, buffer, r9, all_of_aword

</pre>
<p>
And the effect of
<pre>

	addto   r6, aName+20, r7

</pre>
<p>
is
<pre>

	addto   r6, buffer+20, r7, halfaword

</pre>
<p>
Only one subfield in a field of actual arguments can be a 
$EQUF label. Developers wanting to use $EQUF for each of
two operands in a two-address instruction set 
would need to notate each operand as a separate field:
<pre>

left    $equf   input_buffer, a0, d0.w, 4, L        
right   $equf   output_buffer, a1@+,,, L
	.
	.
	eor.l   left right

NOT:::  eor.l   left, right     

</pre>
<p>
In the following assembly, a procedural macro "p" 
retrieves some integer tokens from the $EQUF laBEL and 
uses them to generate integer constants. A flag * can 
be set and retrieved for each subfield. * has a value 
of 1 when it is present.
<pre>

MASMX 7r2
3/equf.msm
*EOF*
  :                            1         $word   32
  :                            2 p*      $proc
  :                            3         +       p(1, 1):S
  :                            4         +       p(1, 2):s
  :                            5         +       p(1, 3)s
  :                            6         +       p(1, 4)s
  :                            7         +       p(1, *1)s
  :                            8         +       p(1, *4)s
  :                            9         $end
  :                            10 
  :                            11 laBEL   $equf   5, 4, 3, *2
00:00000000 00000005          +12         p       laBEL
00:00000001 00000004          +12 
00:00000002 00000003          +12 
00:00000003 80000002          +12 
00:00000004 00000000          +12 
00:00000005 00000001          +12 
*EOF*
:$(00):00000000:00000006 
equf.msm: object code 99 bytes: 0 errors: 0 undefined labels

</pre>
<p>
laBEL is the only argument on the 
"p laBEL" line, and it delivers subfields 1,1 1,2 1,3
and 1,4 (the first four subfields of field 1) to the macro.

<p>
Where a $EQUF label is the second subfield in the field:
<pre>

	mnemonic   register_tag,EQUF_LABEL

</pre>
<p>
then EQUF_LABEL supplies parameters 1,2 1,3 1,4 ...  

<p>
If there are two actual arguments before EQUF_LABEL, the argument
subfields supplied by EQUF_LABEL are 1,3 1,4 1,5...
<pre>

	mnemonic        register_tag, another_register_tag, EQUF_LABEL

</pre>
<p>
Macro language calls its formal arguments <b>p(argument numbers)</b>
if the macro is called <b>p</b>. The macro can be called anything
and can have extra names each attached to a latent parameter value
<p>
The following assembly is for a 32-bit RISC architecture.

<p>
The load/add/store macro generates instructions with a register left-side
operand and a storage right-side operand.

<p>
The left-side operand is a register tag in the range 0..15.

<p>
This register tag is one formal argument on the instruction call line,
and is the first subfield <b>p(1,1)</b> of the one argument field.

<p>
There are 1..3 more formal arguments, and they all describe the
storage operand.

<p>
Macro language calls these last three formal arguments 
<b>p(1,2) p(1,3) p(1,4)</b>. The formal arguments get translated
to the actual arguments

<p>
<b>p(1, 2)</b> is the operand address.

<p>
<b>p(1, 3)</b> is an optional index register tag.

<p>
<b>p(1, 4)</b> is an optional tag describing the size and bit-position of
the operand.

<p>
The RISC architecture has an address quantum of 32 bits.

<p>
Some of its instructions can access fields within 32-bit words using 
a selector encoded in the second quartet of the instruction layout.

<p>
$EQUF names INPUT1 INPUT2 OUTPUT hold an address and maybe an index register and a field designator:
<pre>

MASMX 7r2
3/equf32.msm
*EOF*
  :                            1         $word   32
  :                            2 "$instru" $form        4, 4, 4, 4, 16
  :                            3 
  :                            4 b1      $equ    4
  :                            5 b2      $equ    5
  :                            6 b3      $equ    6
  :                            7 b4      $equ    7
  :                            8 
  :                            9 immediate $equ  1
  :                            10 h1      $equ    2
  :                            11 h2      $equ    3
  :                            12 
  :                            13 r0      $equ    0
  :                            14 r1      $equ    1
  :                            15 r5      $equ    5
  :                            16 r6      $equ    6
  :                            17 r15     $equ    15
  :                            18 
  :                            19 p       $proc
  :                            20 load*   $name   1
  :                            21 add*    $name   2
  :                            22 store*  $name   3
  :                            23         $instru       $n, p(0,2)++p(1,4), p(1, 1), p(1,3), p(1,2)
  :                            24         $end
  :                            25 
  :                            26 code    $equ    1
  :                            27 static  $equ    2
  :                            28 $(static:16384)
  :                            29 buffer  $res    1024
  :                            30 $(code:256)
  :                            31 
  :                            32 INPUT1  $equf   buffer+512, r5, b1
  :                            33 INPUT2  $equf   buffer
  :                            34 OUTPUT  $equf   buffer, r1, h2
  :                            35 
01:00000100 14F54200          +36         load    r15, input1
01:00000101 20F04000          +37         add     r15, input2
01:00000102 33F14000          +38         store   r15, output
  :                            39 
01:00000103 16654200          +40         load    r6, INPUT1,,b3
01:00000104 33654000          +41         store   r6, OUTPUT,r5
01:00000105 33614063          +42         store   r6, OUTPUT+99
*EOF*
:$(01):00000100:00000106 :$(02):00004000:00004400 
equf32.msm: object code 131 bytes: 0 errors: 0 undefined labels

</pre>
<p>
See also base-displacement segments (Sections 4.1.2.1:
Describing Address Spaces: Location Counter Controls).

<p>
With flag <b>-i</b>, sign extended addressing, subfields of a <b>$EQUF</b>
may not be *flagged
<pre>
MASMX 7r2
3/see2it.msm
*EOF*
  :                            1 		$word	16
  :                            2 
  :                            3 r9		$equ	9
  :                            4 r7		$equ	7
  :                            5 
  :                            6 		$set_option	"i"
  :                            7 
  :                            8 
  :                            9 WRITABLE	$equ	1
  :                            10 WRITE_PROTECTED	$equ	-WRITABLE
  :                            11 STACK_FRAME 	$equ	64
  :                            12 
  :                            13 
  :                            14 frame		$equ	-STACK_FRAME
  :                            15 eprom		$equ	0F000
  :                            16 
Error: see2it.msm Line 17: sign extended address may not be *flagged
  :                            17 parameter1	$equf	*frame, r9, WRITABLE
  :                            18 parameter2	$equf	eprom, r7, WRITE_PROTECTED
  :                            19 
  :                            20 . If the flag is retrieved it is the sign bit of the address
  :                            21 
  :                            22 macro*		$proc
  :                            23 		+	macro(1, *1)
  :                            24 		+	macro(1,  2)
  :                            25 		+	macro(1, *3)
  :                            26 		+	macro(1,  3)
  :                            27 		+	macro(1,  1)q
  :                            28 		$end
  :                            29 
00:0000 0001                  +30 		macro	parameter1
00:0001 0009                  +30 
00:0002 0000                  +30 
00:0003 0001                  +30 
00:0004 FFFFFFFFFFFFFFC0      +30 
  :                            31 
00:0008 0000                  +32 		macro	parameter2
00:0009 0007                  +32 
00:000A 0001                  +32 
00:000B FFFF                  +32 
00:000C 000000000000F000      +32 
  :                            33 
*EOF*
:$(00):0000:0010 
see2it.msm: object code 103 bytes: 1 errors: 0 undefined labels
</pre>
<p>
If <b>-i</b> is set and the *flag is retrieved, it is the sign bit
of the address.

<p>
$EQUF is mainly for parameter lists for macros.

<p>
The field values may also be retrieved without a macro.

<p>
The  $EQUF label is referenced directly plus a backslash and a number,
label\?
<pre>

zylabel	$equf	buffer+2047, r15, left_hand_half_extended

</pre>
<p>
zylabel\1 returns the address buffer+2047

<p>
zylabel\2 returns the value represented by tag r15

<p>
zylabel\3 returns the encoding assigned the name "left_hand_half_extended"

<p>
Any values retrieved in this way are net of any relocation attribute.

<p>
The values retrieved are sign-extended to 192 bits.


<p>
The large number of attributes possible in a $EQUF label (six) is aimed
at high-level language development requiring complex attribute information.


<h2>8.16: $EXIT              Stop the Assembly with a Message</h2>

<p>
$EXIT outputs the argument text and exits the assembly, for example:
<pre>

case_required $proc
	$if     $o(k)=0
	$exit   Option -k Required
	$end

</pre>
<p>
The developer needed <b>-k</b> flag (case significant labels) to be set on the
command line.


<h2>8.17: $FLAG              Diagnostic, Mark Assembly in Error</h2>


<p>
Display a message and mark the assembly in error. $FLAG
is actioned on the second pass. Example:
<pre>

	$if     address>64*1024*1024*1024*1024
	$flag   That was a mistake
	$endif

</pre>
<p>
File and line number are listed with the message.


<h2>8.18: $FLAGF             First Pass Diagnostic, Mark in Error</h2>


<p>
Display a message and mark the assembly in error. $FLAGF
is actioned on the first pass and the second pass is not
begun. Example:
<pre>

	$if     length>64*1024*1024*1024*1024
	$flagf  That's never going to work
	$endif

</pre>
<p>
File and line number are listed with the message.


<h2>8.19: $FLOATING_POINT    Default Size of Floating Point Item</h2> 


<p>
$FLOATING_POINT sets the default size of floating point items.

<p>
The default is initially 96 bits:
<pre>

	_______________________________________________________________
	|s|94 exponent 72|71          mantissa                       0|
	|_|______________|____________________________________________|


</pre>
<p>
Floating point numbers are generated automatically when a number
item (command code + - ^) has a decimal point or a scale operator
*+ or *-
<pre>

	+	1.9
	-	20*+1200000
	+	1.37*-800000

</pre>
<p>
Automatic floating-point numbers have an all-fractional mantissa with no
integral part whether hidden or represented.

<p>
Exponent is midpointed.

<p>
Negative polarity is represented by the entire item in 1-s complement.

<p>
Sign-bit indicates that all bits are inverted.

<p>
This is not IEEE 754 format. That is supported with macros.
See Section 1.5: Any floating-point format.

<p>
Word size is 32 bits in the following assembly.

<p>
Octaword at 32 bits generates 192 bits the same as hexaword. Numbers
aren't larger than 192 bits.

<p>
Exponent syntax e E e+ E+ e- E- is only detected if a
decimal point has been encountered in a digit string
<pre>

MASMX/-240 1r1X
hflo.msm 5
*EOF*  :                        1:         $word   32
  :                        2:         $quantum 8
  :                        3:         $awidth 32
  :                        4:         $floating_point 32
00:00000000 41C00000      +5         +1.5
00:00000004 401C000000000000+6         +1.5d
00:0000000C 400001C00000000000000000+7         +0.15*+1t
00:00000018 400001C0000000000000000000000000
			 +8         +15*-1q
00:00000028 400001C000000000000000000000000000000000
			 +9         +1.5p
00:0000003C BFFFFE3FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
			 +10         -1.5h
00:00000054 400001C00000000000000000000000000000000000000000
			 +11         +1.5o
*EOF*:$(00):00000000:0000006C 
Object Code 275 Bytes: 0 Errors: 0 Undefined Labels

</pre>
<p>
$FLOATING_POINT sets both the default size of a floating number constant,
and also the default range and layout of $set and $equ values which have
floating number arguments
<pre>

	__________________________________________________________________
	|s|190 exponent 168|167          mantissa                       0|
	|_|________________|_____________________________________________|



</pre>
<h2>8.20: $FORM             Map Layout of Bit Structure or Instruction</h2>


<p>
$FORM declares layouts of bitfields into which instruction 
codes and operand addresses and tags can be assembled.

<p>
$FORM can also be used for structures which are not instructions.

<p>
An example of a $FORM is the template of load and store 
instructions in PowerPC:
<pre>

i$type_load_store $form 6, 5, 5, 16

</pre>
<p>
The label of the $FORM is the command name in the code-generating
line of the instruction macro:
<pre>

p       $proc
lwz     $name   32
stw     $name   36
lhz     $name   40
	.
	.
	i$type_load_store $n, p(1, 1), index$\p(1, 2), p(1, 2)
	$end

index$  $func
	$return index$(1, 1)
	$end

</pre>
<p>
The code fragment:
<pre>

ADDRESS $equ    4094        
	lwz     r6, ADDRESS(R31) 
	
</pre>
<p>
is structured per $FORM i$type_load_store to fields of
six, five, five, and sixteen bits containing 32.6.31.4094, or
0x80df0ffe:
<pre>

MASMX/-240 1r1X
q.msm 5
LTERM=#
CONT_CHAR=
STERM=.
*EOF*  :                        2: ADDRESS $equ    4094
00:00000000 80DF0FFE      +3         lwz     r6, ADDRESS(R31)
*EOF*:$(00):00000000:00000004 
Object Code 58 Bytes: 0 Errors: 0 Undefined Labels

</pre>
<p>
A function \macro to haul up a base register value from parentheses allows
source code written with the syntax <b>address(Register)</b> to assemble.

<p>
masmx macro language for one-address computers can be written with
the base register as third subfield
<pre>

	lwz	r6, ADDRESS, r31

</pre>
<p>
And the code-generating line can then be
<pre>

	i$type_load_store $n, p(1, 1), p(1, 3), p(1, 2)

</pre>
<p>
The supplied definition "ppc_603.def" processes either syntax.


<h2>8.21: $FUNC              Macro to Produce Operand Value</h2>      
<pre>

fname   $func
	.
ename*   $name   ; entry point $NAME doesn't have to be used
ename2*  $name   ; unless label on $FUNC is not unique or not visible*
ename3*  $name   ; or multiple $NAME values ar needed 
	.
	.
	$return ...
	$end

</pre>
<p>
Is a macro which returns a value which may be used in
expressions. An example is in the definition "8051.def"

<p>
The XRAM (variables) location counter is referenced as @.

<p>
@ is given the functional meaning location counter one. That
is where the variables are assembled.
<pre>

@*      $func
	$return $(1)
	$end

</pre>
<p>
A function can be used to extract parenthesised qualifiers on an
operand subfield. If the contents of parentheses are intricate,
having comma or space separators they can only be given to the
function macro as a SUBSTRING
<pre>

	add.l   offset(a0, d0.w), d1

p       $proc
add.l*  $name   ADD.L
	.
	.
subparams $set  howmany\p(1,1:1)
a_reg   $set    sub_param1\p(1,1:1)
index_reg $set  sub_param2\p(1,1:1)
index_lwb $set  sub_param3\p(1,1:1)
	.
	.
	$if     subparams>1
	instruction_form_x p(1, 2), a_reg, index_reg, index_lwb, p(1, 1) 
	$elseif
	.
	.
	$end


m68k_A_REG	$equ	128
m68k_D_REG	$equ	129
m68k_W_TAG	$equ	130


a0	$equ,m68k_A_REG		0
	.
	.
d0	$equ,m68k_D_REG		0
	.
	.
w	$equ,m68k_W_TAG		1

f       $func
howmany* $name
	$return f(1)
sub_param1* $name
	$do     $t(f(1, 1))^=m68k_A_REG, $note Should be Address Register
	$return f(1, 1)
sub_param2* $name 
	$do     $t(f(1, 2:1))^=m68k_D_REG, $note Should be Data Register
	$return f(1, 2)
sub_param3* $name
	$do     $t(f(1, 2:2))^=m68k_W_TAG, $note Should be Width Tag
	$return f(1, 3)
	$end

</pre>
<p>
The complex parenthesised text was sent to the function macro
as a substring, but the function macro then sees fields or subfields.
See also Section 6.3.3.1: ColdFire and 68000.

<p>
A function can be used to carry out range or type checks: 
<pre>

f       $func
rel2*    $name   2
rel3*    $name   3
v       $set    f(1,1)-$-$n
	$if     v<-128
	$flag   can only jump back -128 from instruction trailing edge
	$endif
	$if     v>127
	$flag   can only jump forward 127 from instruction trailing edge
	$endif
	$return v
	$end

</pre>
<p>
This function returns an 8-bit displacement relative to the 
trailing edge of an instruction which may be either two or 
three bytes long.

<p>
This is an 8051 $PROC or procedural macro
which calls entry rel2 of this $FUNC or functional macro
<pre>

p       $proc
jc*      $name   040
jnc*     $name   050
jz*      $name   060
jnz*     $name   070
sjmp*    $name   080        
	i$mova_direct $n, rel2(p(1,1))
	$end

</pre>
<p>
In the following 8051 assembly, two jump instructions which
both use the rel2 function entry cannot be generated without error
because they are too far from their target:
<pre>


MASMX 7r2
3/relj.msm
CONT_CHAR=
LTERM=;
QDELIM='
STERM=.
*EOF*
  :                            1:         $include        "8051_7r2.def"
Error: relj.msm Line 2: You may only jump -128..+127 from $+2
Error: relj.msm Line 2: can only forward 127 from instruction trailing edge
00:0000 8080                  +2 down    sjmp    up
  :                            3 
  :                            4 that_lot* $proc    
  :                            5         $do     index=2,        $list   0
  :                            6         +       5
  :                            7         $do     index=125,      $list   1
  :                            8        $end
00:0002 05                    +9 index   $do    128,    that_lot
00:007F 05                    +9 
00:0080 05                    +9 
00:0081 05                    +9 
  :                            10 
Error: relj.msm Line 11: You may only jump -128..+127 from $+2
Error: relj.msm Line 11: can only jump back -128 from instruction trailing edge
00:0082 407C                  +11 up      jc      down
*EOF*
:$(00):0000:0084 :$(01):0400:0400 
relj.msm: object code 443 bytes: 4 errors: 0 undefined labels


</pre>
<p>
Here a similar fragment assembles because the
distance between the jump instructions and their targets is smaller:
<pre>


MASMX 7r2
3/relja.msm
CONT_CHAR=
LTERM=;
QDELIM='
STERM=.
*EOF*
  :                            1:         $include        "8051_7r2.def"
  :                            2 
00:0000 807C                  +3 down    sjmp    up
00:0002 05                    +4         $do     124,        +  5
00:0003 05                    +4 

................

00:007B 05                    +4 
00:007C 05                    +4 
00:007D 05                    +4 
00:007E 4080                  +5 up      jc      down
*EOF*
:$(00):0000:0080 :$(01):0400:0400 
relja.msm: object code 431 bytes: 0 errors: 0 undefined labels


</pre>
<h3>8.21.1 Functions which Generate Code and Second Pass Only Functions</h3>

<p>
$FUNC macros primarily generate values which on $RETURN from
macro expansion are used in expressions. Functions are not
allowed to generate code inline to the current location counter.

<p>
Functions may incidentally generate code in out-of-line 
location counters before returning a value. Their
functional value may be the address of an item which they
have generated.

<p>
This function generates address constant and its
functional value is the address of the constant.

<p>
The indirect jump instruction assembled under locator 0
accesses the constant assembled under locator 2:
<pre>

v*      $func
$(2)
constant +      v(1, 1)
$(0)
	$return constant
	$end
	.
	.
	ijump    v(external_routine)

</pre>
<p>
Macro language can accidentally call this function multiple times for one
actual parameter, although that's avoidable.

<p>
A macro may need to range check an operand.

<p>
Macro language does not know if an actual parameter contains a function
call, but should ideally be written to scan each actual parameter only once, by setting a local label to it if multiple references are needed.

<p>
The safe way of generating code out-of-line in a function is where the
function which creates a global label for its data item, and tests if
it exists already:
<pre>

v*       $func
	$if	$t("constant_v(1,1)")=0
$(2)
"constant_v(1,1)"** +      v(1, 1)
$(0)
	$return "constant_v(1,1)"
	$end

</pre>
<p>
and this still won't work, because the label is generated on the
first pass, and so the data is not generated on the second pass.

<p>
The function macro can be set to expand only on the second pass with
a flag argument of * on the $FUNC line. Then it works:
<pre>

v*       $func	*
	$if	$t("constant_v(1,1)")=0
$(2)
"constant_v(1,1)"** +      v(1, 1)
$(0)
	$return "constant_v(1,1)"
	$end

</pre>
<p>
Functions like this should not generate code in a segment which
has literals in it.

<p>
If a simple pointer constant is required, literals are a better way
of getting it, either with a tagged literal pool:
<pre>

$(2:BASE_ADDRESS_2/LiteralPoolNameInLocator2)
$(0:BASE_ADDRESS_0)
	.
	.
	ijump    LiteralPoolNameInLocator2(external_routine)

</pre>
<p>
or by having automatic literals:
<pre>

	$set_option("a")        . allow automatic literals
	$lit    2               . put them in locator 2
	.
	.
	ijump   (external_routine)


</pre>
<p>
However a function may be needed to produce some table more complex than
a list of pointers.

<p>
The vector entries might be encoded items and not completely
plain pointers, so macro processing becomes necesssary.

<p>
Here is an assembly where a function calls for the address of an entry point vector.

<p>
If the vector does not exist it is generated.

<p>
The vector in turn pointer is an encoded one-word structure,
and not a simple pointer.

<p>
The macro which generates the vector pointer calls for the
generation of a descriptor for a target segment if
that does not exist.

<p>
The descriptor imports the address of the target segment and
and also contains a text label for it.

<p>
Vectors and descriptors are not one to one. The segments have
multiple entries.
<pre>

MASMX 7r2
3/v.msm
*EOF*
  :                            1         $word   32
  :                            2 i       $form   8, 24
  :                            3 descriptor $form  32, 32, 64
  :                            4 
  :                            5 p       $proc
  :                            6 call*   $name   10
  :                            7         i       $n, p(1, 1)
  :                            8         $end
  :                            9 
  :                            10       $plist  7
  :                            11 
  :                            12 v*      $func *
  :                            13         $if     $t(v(1,1))=0
  :                            14 "v(1,1)"** vector v(1, 1)
  :                            15         $endif
  :                            16         $return v(1,1)
  :                            17         $end
  :                            18 
  :                            19 vector* $proc   $(2)
  :                            20         $if     $t(vector(1,1:1))=0
  :                            21 "vector(1,1:1)"*** segment vector(1,1:1)
  :                            22         $endif
  :                            23 *       +       vector(1,1:1)*/4++vector(1,1:2)
  :                            24         $end
  :                            25 
  :                            26 segment* $proc   $(62)
  :                            27 *       descriptor +"load$:segment(1,1)", 0, "segment(1,1)"
  :                            28         $end
  :                            29 
  :                            30 $(2:020000)
  :                            31 $(62:03e0000)
  :                            32 $(0:64)
  :                            33 
3E:003E0000 00000000000000006C65667420202020
                              +34         call    v(left:1)
02:00020000 03E00001          +34 
00:00000040 0A020000          +34 
3E:003E0004 00000000000000007269676874202020
                              +35         call    v(right:1)
02:00020001 03E00041          +35 
00:00000041 0A020001          +35 
00:00000042 0A020000          +36         call    v(left:1)
02:00020002 03E00002          +37         call    v(left:2)
00:00000043 0A020002          +37 
3E:003E0008 000000000000000063656E7472652020
                              +38         call    v(centre:7)
02:00020003 03E00087          +38 
00:00000044 0A020003          +38 
  :                            39 
*EOF*

.......

LEFT:1=$02:00020000
LEFT=$3e:003E0000
LOAD$:LEFT
RIGHT:1=$02:00020001
RIGHT=$3e:003E0004
LOAD$:RIGHT
LEFT:2=$02:00020002
CENTRE:7=$02:00020003
CENTRE=$3e:003E0008
LOAD$:CENTRE
:$(00):00000040:00000045 :$(02):00020000:00020004 :$(3E):003E0000:003E000C 
v.msm: object code 518 bytes: 0 errors: 3 undefined labels

</pre>
<p>
Four vector table entries and three segment descriptors have been
generated for five jump instructions. The output file
contains import requests for unresolved labels values "load$:left",
"load$:right", and "load$:centre" to be added the first word of
each descriptor.


<h2>8.22: $HEX               Set Binary Notation to Hex</h2>

<p>
Default binary notation is hex.

<p>
A number string beginning ascii zero is in current binary notation. 

<p>
Therefore 1000 and 03e8 both mean one thousand, unless the opposite
directive
<pre>

	$OCTAL

</pre>
<p>
has been issued. Then 03e8 means three and 01750 means one thousand,
but 1000 still means one thousand.

<p>
the $HEX directive
<pre>

	$HEX

</pre>
<p>
gets hex back.

<p>
Each assembly pass begins in hex mode.

<p>
When hex is on, display is also in hex

<p>
When octal is on, display is also in octal

<p>
$SUFFIX directive (see section 8.50: $SUFFIX Directive) changes
the interpretation of number strings. 

<p>
The <b>-c</b> flag changes number syntax to C language for hex and octal.

<p>
The <b>-m</b> option turns on Motorola $hex syntax and %bit_pattern.



<h2>8.23: $IF                Conditional Assembly</h2>

Part of conditional assembly
<pre>

	$if     expression1
	.
	.
	$elseif expression2
	.
	.
	$else
	.
	.
	$endif




</pre>
<h2>8.24:	$INCLUDE	Include a Source File or a Binary File</h2>		

<h3>8.24.1:	$INCLUDE	Read a Nested Source File</h3>           


<p>
Read and assemble a nested source file. Nesting can recurse
to a depth of 16. 
<pre>

	$include        "target.def"

</pre>
<p>
The default filename extension is .msm

<p>
Therefore
<pre>

	$include	application

</pre>
<p>
reads application.msm

<p>
The following are defaults until definition files change them:

<p>
semicolon is a line continuation character

<p>
The substring separator is colon

<p>
The quote character is "

<p>
The comment character is initially period, but comment character period
is never actioned if it is immediately followed by a nonspace token:
<pre>

	$include	file2.src	
	+		1.5	. floating number	

</pre>
<p>
If an include definition has changed the quote character,
subsequent includes names cannot be bound with "" but may
be bound with the new quote character.

<p>
Special symbols like comment and line continue are not actioned
within quotes
<pre>

	$include	"rough looking;; file. name. "


</pre>

<h3>8.25.2: $INCLUDE,$BINARY	Read a Text Encoded Binary File</h3>

<p>
Linking Directive
<pre>

	$include,$binary	file	$(n, n, n,...

</pre>
<p>
Reads a text encoded binary and submits each text line in it to
the developer-supplied link macro $MAP

<p>
The optional second argument selects and orders the segments to be taken
from the file.

<p>
Without the second argument, all sections are taken from the file and if
they are relocatable, default behaviour collects the segments
exactly in order of appearance.

<p>
Option flag <b>-b</b> causes instead all the relocatable segments of all
the binary files included to be collated by section.

<p>
A cumulative link (where the inputs are relocatable and so are the
outputs) always has the effect of gathering by section.

<p>
Absolute address in the included binaries have the effect
of giving an absolute start addresses to the link.

<p>
An absolute location counter switch before the binary includes
gives an absolute start address to the link:
<pre>

$(0:65536)
	$include,$binary	rel_file1
	$include,$binary	rel_file2

</pre>
<p>
A relocatable location counter switch before the binary includes
causes relocatable segments to be gathered by section and output as
new relocatable segments:
<pre>

$(0:*4)
	$include,$binary	rel_file_A
	$include,$binary	rel_file_B

</pre>
<p>
Specific handling can be applied to each segment of each input file.
See Sections 9.2.2 masmx Linking in Principle, 9.2.3: Demonstration
Links (PowerPC).
The link macro definition including $MAP macro must be already included.

<p>
The default file name extension is txo, as
<pre>

	$include,$binary	"rel_file.txo"

</pre>
<p>
The binary includes must be Text Encoded Binary format. See Section 9:
Output File Formats, Relocation and Linking,
Giant Address Spaces, Interfacing with GNU Tools



<h3>8.24.3: $INCLUDE,$VOID		Bind to an Independent Text Encoded Binary</h3>

<p>
Linking Directive. The default filename extension is .txo
<pre>

	$include,$void	kernel
	$include,$void	absolute_library_bank

</pre>
<p>
include addresses from a text encoded binary file, but do not include
code from it:

<p>
See also Section 9: Output File Formats, Relocation and Linking,
Giant Address Spaces, Interfacing with GNU Tools


<h2>8.25: $INFO       Linking Directive used within $MAP macro</h2>
<h3>8.25.1: $INFO, $OFFSET     Replace Information at the Relocation Stack Top</h3>

<p>
Update relocation information from relocatable input to relocatable
output.

<p>
Applied to the offset value in the tuple at the relocation stack top.

<p>
$offset is the equivalent of addend value in ELF environment.
<pre>

	$info,$offset	expression

</pre>
<p>
Subsequently the $LOAD directive will rewrite the relocation clause to
Text Encoded Binary output from the adjusted relocation tuple on the
internal relocation stack.

<p>
Not all relocation tuples include an offset value, only those which
indicate manipulation (shift/truncate) of the value after relocation.

<p>
In the absence of offset+shift information, the offset is obtained from the code.

<p>
See Section 9: Output File Formats, Relocation and Linking,
Giant Address Spaces, Interfacing with GNU Tools

<p>
New offset carries an adjusted value forward in cumulative links.

<p>
Macro language must take this action where three circumstances combine:
<pre>

	There is a right-shift to be carried out on the offset
	(and therefore there is an extracted offset in the
	relocation clause)

	A segment base address used in the field value
	has moved as a result of relocation

	The output is relocatable

</pre>
<p>
When there is no extracted offset in the relocation tuple, the necessary
adjustment is made by macro language on the code and the relocation tuple
need not be adjusted.

<p>
When the ouput is absolute, no relocation tuple is stacked.

<h3>8.25.2: $INFO, $RANGE_CHECK
   and   $INFO, $RANGE_CHECK1: Request Linker Automatic Range Checking</h3>
<pre>

	$info,$range_check	value

</pre>
<p>
requests the linker section of masmx to range check value for the
current field size described at the relocation stack top.

<p>
masmx linker section derives the allowable range geometrically according
to the known field size and signed/unsigned attribute at the relocation
stack top.

<p>
Version $RANGE_CHECK of range check is used where the $MAP macro
maintains a 192-bit offset during the successive accumulation of
relocation clauses for one field.

<p>
The check errors if the final value applied does not fit the field.
See Sections 9.2.3.7-8, 10: Linking in Giant Space.

<p>
$RANGE_CHECK1 requests more stringent behaviour than $RANGE_CHECK:
where more than one relocation clause applies to one field of code

<pre>

	$info,$range_check1	value

</pre>
$RANGE_CHECK1  also requests masmx linker to range check value for the
field at the relocation stack top. In contrast to RANGE_CHECK, each
addition of a successive relocation tuple (where they are more than one)
to the target field must stay in range.

<p>
If a rightward shift after relocation is requested, intermediate results
must fit a 48-bit offset maintained in the relocation stack. The final result must fit the target field.

<p>
Otherwise each add/subtract must fit the target field.

<p>
See Linker Examples in Section 9.2.3.



<h2>8.26: $LINEWIDTH      Text Encoded Binary Line Length</h2>

<p>
Set the guideline maximum line length for the Text Encoded Binary
outupt. The default is 60 columns.
<pre>

	$LINEWIDTH      expression


</pre>
<h2>8.27: $LIST              Set Inclusion Nest Level for Listing</h2>

<p>
<i><b>$list 0, masking names from list/export</b></i>

<p>
$LIST is initially set to 1, which means the primary assembly
input file is listed but include files are not listed.

<p>
When $LIST is cleared
<pre>

	$list   0

</pre>
<p>
Nothing will be listed. When <b>$LIST</b> is set to more than 1, then 
with option <b>-l</b>, included source is listed to an include nesting
depth of the <b>$LIST</b> value.

<p>
Labels are not catalogued for listing or export when <b>$LIST</b> is 0.

<p>
This allows developers to list the labels in applications without
listing all the names in a complex target machine definition:
<pre>

	$list		0
	$include	ppc_603.def
	$list

</pre>
<p>
However labels which are not catalogued for listing are also not
exported.

<p>
In this example
<b>yasimi</b> is listed  and exported and <b>yadont</b> is not.
<b>yasimi</b> and <b>yadont</b> are both available in this assembly
<pre>

$ cat yasimi.msm
	$word		32
	$quantum	8

$(4:1024)
yasimi*	+	yadont
	$list	0
yadont*	+	yasimi

	

$ masmx -lnxy yasimi yasimi
MASMX 7r2
3/yasimi.msm
*EOF*
  :                            1 	$word		32
  :                            2 	$quantum	8
  :                            3 
  :                            4 $(4:1024)
04:00000400 00000404          +5 yasimi*	+	yadont
*EOF*
YASIMI+=$04:00000400
yasimi.msm=0<00000003
:$(04):00000400:00000408 
yasimi.msm: object code 84 bytes: 0 errors: 0 undefined labels

$ cat yasimi.txo

$04:00000400
00000404 00000400
+YASIMI:$04:00000400
:$04*00000000:00000400:00000408


</pre>

<p>
Here is an extract from a cumulative link source. The
names in reloca.txo must be passed on. But here it is not wished or
needed to list the text encoded binary code from reloca.txo
<pre>

	$list		0
	$include	ppc_map.def
	$list		-1
	$include, $binary reloca
	$list		2
	$include, $binary my_reloc
	$store		newreloc

</pre>
<p>
The names in reloca.txo are catalogued and exported because -1
is not zero. In fact the default <b>$LIST</b> value of 1 would have the
same effect here, because <b>$LIST 1</b> does not list any files
which are included in other files.

<p>
Whenever source is listed, so is any code generated from each 
source line. The following assembled example generates 7500 
labels which have the values name(1)..name(7500) and generates
7500 constants with the value of each label.

<p>
Listing is turned off before name(3) and turned on again
before name(7497)
<pre>


3/names.msm
*EOF*
  :                            1 
  :                            2 this*  $proc
  :                            3         $do     times=3,   $list 0
  :                            4         $do     times=7497, $list 1
  :                            5 name(times)*        +       name(times)
  :                            6         $end
  :                            7 
00:000000 000000              +8 times  $do     7500,   this
00:000001 000001              +8 
00:001D48 001D48              +8 
00:001D49 001D49              +8 
00:001D4A 001D4A              +8 
00:001D4B 001D4B              +8 
*EOF*
:$(00):000000:001D4C 
names.msm: object code 52537 bytes: 0 errors: 0 undefined labels


</pre>
<h2>8.28: $LIT               Set Default Location Counter for Literals</h2>
<pre>

[label] $lit    expression

</pre>
<p>
Identifies the location counter 0..71 in which automatic literals
are generated.

<p>
Automatic literals are by default in counter 0.

<p>
If $LIT has no argument, automatic literals are in
the current location counter.

<p>
If there is a label on a $LIT line, the label is a literal pool tag.

<p>
See Section 4.1.2.1: Describing Address Spaces: Location Counter Controls,
Section 4.2.3.2.2.4.11: Label Types, and 
Section 5: Functions and Literals.

<p>
Automatic literals are literals not triggered by a literal pool
tag (see section 5.2: Literals), but by a leading parenthesis 
on expressions encountered at some syntactical points, chiefly
instruction operands.

<p>
Automatic literals may be generated if option flag <b>-a</b> is on.

<p>
Developers not wishing leading parenthesis on an operand to 
trigger literal generation can let option <b>-a</b> default.

<p>
By default option <b>-a</b> is off, and automatic literals are not
generated.

<p>
Developers who want automatic literals can include option -<b>a</b>
in a target definition include file:
<pre>

	$set_option     "a"

</pre>
<p>
The places where automatic literals may be generated are:
<ul>
	
	If parenthesis is the first symbol of an actual parameter to
	a $form, for example an operand to an instruction:
<pre>

		load    r11, (from_very_high_address)

</pre>
	If parenthesis is the first symbol in an expression in
	a number constant, for example
<pre>

		+       (0ffffff0000000000)
		+       (1*/90), 10:d


</pre>
</ul>
<p>
Line 3 in the following assembly allows automatic literals.

<p>
Lines 5..12 define a minimal instruction set and register set.

<p>
Line 14 defines an address too large to place in the 16-bit
operand address field of the instructions.

<p>
Line 16 initialises location counter 7 to absolute 07000 hex.

<p>
Line 17 switches to location counter 0 and initialises it at 64.

<p>
Line 19 specifies that automatic literals are generated at the
end of locator 7.

<p>
Line 21 loads the address of the literal 00fffc0000000000 into
R11. The assembler first generates the literal 00fffc0000000000
at the address 07000, then places 07000 in the operand field
of the LOAD instruction.

<p>
Line 22 loads the 64-bit value 00fffc0000000000 into R11 from
the address 07000 which had been loaded into R11.

<p>
Line 24 is 64-bit integer value 00fffc0000000000 generated
inline.

<p>
Line 25 is the same as line 24. The parentheses do not make a 
literal, because the leading parenthesis is not the first symbol 
in the expression. The unary plus is.

<p>
In line 26, + signals an integer item, but the expression
when it is encountered begins with a parenthesis. The integer
literal 00fffc0000000000 is found at 00007000 and the item
generated inline is 00007000. The literal is not new, It was
generated at line 21.

<p>
In line 27, the comma between the expressions causes two 16-bit
values to be placed in one 32-bit item. The first of the two
expressions is the literal (00fffc0000000000) which is the literal
at 07000. 07000 is placed in the left half of the word. The
right half is 15 or 000F.

<p>
Line 28 is another pair of 16-bit values. The first is not a
literal because +(0xffee), begins with plus not parenthesis. 
The second is a literal (0xffee) generated at 7008. The
inline result is 0ffee7008.
<pre>


MASMX 7r2
3/lit.msm
*EOF*
  :                            1         $word   32
  :                            2         $quantum 8
  :                            3         $set_option     "a"
  :                            4 
  :                            5 instruction     $form   8, 4, 4, 16
  :                            6 
  :                            7 r11     $equ    11
  :                            8 
  :                            9 p       $proc
  :                            10 load*   $name   99
  :                            11         instruction     $n, p(1,1), p(1,3), p(1, 2)
  :                            12         $end
  :                            13 
  :                            14 with_a_very_high_address $equ   00fffc0000000000
  :                            15 
  :                            16 $(7:07000)
  :                            17 $(0:64)
  :                            18 
  :                            19         $lit    7
  :                            20 
00:00000040 63B07000          +21         load    r11, (with_a_very_high_address)
00:00000044 63BB0000          +22         load    r11,,r11
  :                            23 
00:00000048 00FFFC0000000000  +24         +       00fffc0000000000
00:00000050 00FFFC0000000000  +25         +(00fffc0000000000)
00:00000058 00007000          +26         +       (00fffc0000000000)
00:0000005C 7000000F          +27         +       (00fffc0000000000), 15
00:00000060 FFEE7008          +28         +       +(0ffee), (0ffee)
  :                            29 
*EOF*
07:00007000+00FFFC0000000000
07:00007008+0000FFEE
:$(00):00000040:00000064 :$(07):00007000:0000700C 
lit.msm: object code 196 bytes: 0 errors: 0 undefined labels


</pre>
<h2>8.29: $LOAD		Output Text Encoded Binary</h2>

<p>
Linking Directive
<pre>

	$load,$bits	expression

</pre>
<p>
is used in the developer-supplied $MAP macro to write updated code
to the new Text Encoded Binary output file.

<p>
The subcommand is the code size in bits of the written superword.

<p>
$LOAD is the counterpart of $SET,$BINARY which caches Text Encoded
Binary Input in a label and automatically sets label $BITS to the
size of the superword which has been read:
<pre>

data_label	$set,$binary	superword_parameter

		.
		.

		$load,$bits	data_label

</pre>
<p>
The subcommand does not have to be the automatic label $BITS, but
the same size superword must be written as read.


<h2>8.30: $LTERM             Change Comment Sentinel</h2>
     

<p>
The default $LTERM is period.

<p>
This declaration:
<pre>      
	
	$lterm  03b

</pre>
<p>
or this:
<pre>

	$lterm  ';'

</pre>
<p>
will change the comment sentinel to semicolon. $LTERM can be changed
to any ASCII graphic symbol which is not required for something else.
<pre>

	$lterm  '#'

</pre>
<p>
is the same as
<pre>

	$lterm  023

</pre>
<p>
If # is used as the comment sentinel, it cannot 
also be used as a flag value on the front of 
operand expressions (see Section 4.2.3.2.2.3: 
Macro Parameters.


<h2>8.31: $NAME              Declare Macro Entry Point</h2>         

$NAME is a species of equate.
<pre>

tag     $name   value

</pre>
<p>
When declared within the body of of a procedural macro $PROC
or a functional macro $FUNC, $NAME is used to equate a mnemonic
to an opcode or an input parameter. The purpose of this is to
allow many similar instructions or functions to be declared
in one macro. Then the name must be exported from the macro

tag*	$name	value

<p>
This example from a PowerPC definition shows
the mnemonic in the command field of a line acting as an
entry point to the procedural macro or $PROC, p. 

<p>
The value assigned to the call mnemonic by $NAME
is retrieved during macro expansion as parameter p(0, 1).
This yields the operation code required by the developer.

<p>
32 bits of the value of p(0, 1) may be retrieved via the 
internal function $N in masmx, but $N is not used in the 
PowerPC file because Motorola Hex Notation may be switched on.

<p>
In this example the instruction layout i$4 is filled first with 
a 6-bit opcode p(0, 1). That's followed by a 5-bit register
tag p(1, 1) and a 16-bit storage operand address p(1, 2). 

<p>
A base register may be parenthesised on the trailing end of the 
storage operand  
<pre>

	stw     r2, address(R15)

</pre>
<p>
And that has to be encoded in five bits before the address.

<p>
For efficiency the definition "ppc_603.def" also accepts the plain masmx
syntax for one-address computers and by default adusts source on read:
<pre>

	stw	r2, address, r15

</pre>
<p>
The definition shown instead assigns the parenthesed part of the actual
parameter to a function .f with the function call <b>.f\p(1, 2)</b>
<pre>


i$4     $form   6, 5, 5, 16

.f*     $func
	$return .f(1, 1)
	$end

p       $proc

lwz*     $name   32
lwzu*    $name   33
lbz*     $name   34
lbzu*    $name   35
stw*     $name   36
stwu*    $name   37
stb*     $name   38
stbu*    $name   39
lhz*     $name   40
lhzu*    $name   41
lha*     $name   42
lhau*    $name   43
sth*     $name   44
sthu*    $name   45
lmw*     $name   46
stmw*    $name   47
lfs*     $name   48
lfsu*    $name   49
lfd*     $name   50
lfdu*    $name   51
stfs*    $name   52
stfsu*   $name   53
stfd*    $name   54
stfdu*   $name   55
	
	i$4     p(0, 1), p(1, 1), .f\p(1, 2), p(1, 2)
	$end

</pre>
<p>
An assembly using this definition:
<pre>


MASMX/24592 1r1X
name.msm 5
LTERM=#
CONT_CHAR=
STERM=.
*EOF*  :                        2: 
  :                        3: from    .equ    $ee84
  :                        4: to      .equ    0xc008
  :                        5: 
00:00000000 80C0EE84      +6         lwz     r6, from
00:00000004 98CEC008      +7         stb     r6, to(r14)
00:00000008 4E800020      +8         blr
*EOF*:$(00):00000000:0000000C 
Object Code 76 Bytes: 0 Errors: 0 Undefined Labels

</pre>
<p>
The name LWZ has been recognised and 32 has been placed in the
upper 6 bits of the instruction on line 6. The name STB has been
recognised and 38 has been placed in the upper 6 bits of the
instruction on line 7.


<h2>8.32: $NOP               Do Nothing [+ comment]</h2>
                  
<p>
$NOP directive can introduce a comment without using the comment character
<pre>

	$nop	comment-text

</pre>
<p>
Header files included in assemblies of differing syntax can use $NOP directive
instead of $LTERM character to allow code to be commented.
<p>
$LTERM (comment character) may have a different value (for example # ; .)
in each of many assemblies.
<p>
$NOP may also annul any unused directives in legacy code, for example:
<pre>

preset  equ,$directive     $nop


</pre>
<h2>8.33: $NOTE              Informative Diagnostic, Not Error</h2>   

<p>
$NOTE causes a message to be displayed without causing the 
assembly to fail.

<p>
The push/pop macro nn the definition "8051.def" alerts the
developer to a risky practice with a $NOTE message:
<pre>

p       $proc
push    $name   0c0        
pop     $name   0d0
	$if     p(1,#1)++($t(p(1,1))=POINTER$)++($t(p(1,1))=REGISTERS$)
	  $flag PUSH/POP Direct Addressed IRAM Location or SFR Only
	$else
	  $if $t(p(1,1))=RREGISTERS$
	    $note Caution: RRegister bank might not be at address 0..7
	  $endif
	  i$mova_direct   $n, p(1,1)
	$endif
	$end

</pre>
<p>
There is also a $FLAG in the macro which marks the assembly in error
if the operand is illegal.

<p>
$NOTE displays on the second assembly pass.


<h2>8.34: $NOTEF             First Pass Informative Diagnostic</h2>

<p>
$NOTEF is similar to $NOTE, except it displays on the first
assembly pass.


<h2>8.35: $OCTAL             Set Binary Notation to Octal</h2>         


<p>
$OCTAL causes input number strings with leading zero to be
interpreted as octal and listings to be octal. 
<pre>

	$OCTAL

</pre>
<p>
The default rule is hexadecimal. Assembly always starts in hexadecimal.

<p>
See also 8.22: $HEX directive

<p>
See also Section 6.1: Establishing Your Syntax,
Section 8.51: The <b>$SUFFIX</b> Directive, Section 4.2.3.2.2.1: 
Number Strings (C-Language Octal/Hex Notataion, Motorola 
Hex and Bit-List Notation), and Section 3.1: Command
Line (option flags <b>-mc</b>).


<h2>8.36: $PATH      	     Alter Include Path</h2>

<p>
<b>$path</b> sets a text value to which is prefixed to the
filename arguments of <b>$include</b> directive.

<p>
This encourages related files to be functionally grouped in directories
where a wrapper file may include its functional relations from its own
directory, without naming that directory. So
<pre>

	$path		../math_libs
	$include	math_libs
	$path		../network/ipv4
	$include	netservice.def
	$path		../electromechanical/stepper_type5
	$include	stepper5
	$path
	$include	application7

</pre>
<p>
Then directory <b>../math_libs</b> may contain
<pre>

	ieee754_scan_in.msm	ieee754_format_out.msm
	ieee754_calculate.msm	math_libs.msm

</pre>
<p>
And source file <b>../math_libs/math_libs.msm</b> may contain
<pre>

	$include	ieee754_scan_in
	$include	ieee754_format_out
	$include	ieee754_calculate

</pre>
<p>
Directory <b>../network</b> may contain
<pre>

	../ipv4/	../ipv6/

</pre>
<p>
Directory <b>../network/ipv4</b> may contain
<pre>

	socket.def	netservice.def	rpc.def		xdr.def

</pre>
<p>
Source file <b>../network/ipv4/netservice.def</b> may contain
<pre>

	$include	socket.def
	$include	rpc.def
	$include	xdr.def

</pre>
<p>
Finally the directive <b>$path</b> without an argument cancels
the path prefix, and the next includes are relative to the current
directory.

<p>
Note that Microsoft operating systems recognise the path separator <b>/</b>
as well as <b>\</b> when open calls are made from <b>masmx</b>.

<p>
Therefore there is no need to change any <b>$include</b> or <b>$path</b>
arguments when moving between Unix / Linux developer platforms and Microsoft machines. Just always use <b>/</b>

<h2>8.37: $PLIST             Set Depth for Listing Macro Expansion</h2>


<p>
$PLIST sets the subassembly recursion level to which macro text will
be listed. The default is 0, which means no macro expansions are 
listed.
<pre>

	$plist  3

</pre>
<p>
causes source to be listed to two nested levels of subassembly or
macro expansion, but only if option flag <b>-p</b> or <b>-q</b> is asserted. 

<p>
If <b>-p</b> is off, no <b>$PROC</b> text listed. 
<p>
If <b>-q</b> is off, no <b>$FUNC</b> text listed.

<p>
If <b>-r</b> is on, <b>$PROC</b> and <b>$FUNC</b> text is listed
on the first assembly pass if $PLIST is high enough.
This for problems in macro language which
do not allow the second pass to be reached. Otherwise nothing is
ever listed until the second assembly pass.

<p>
Generated code is listed according to the <b>$LIST</b> level
and <b>-l</b> option, not the <b>$PLIST</b> level and <b>-pq</b> options.


<h2>8.38: $PROC              Declare Procedural Macro</h2>
   

<p>
The head of a procedural macro. $PROC must have a label, but the
label need not be unique. If the label on the $PROC image is not
unique it may not be promoted*, the macro body must contain $NAME entry
points which have unique labels and which are made visible*.

<p>
A $PROC line must be matched with a $END line:
<pre>

aname   $proc
entry*  $name   value        
	.
	.
	$end

</pre>
<p>
When a promoted* label of $PROC or $NAME is in the instruction 
field of a source line, the macro is subassembled.

<p>
This assembly is made more visible futher down. The ljmp/lcall macro
and the nop/ret/reti macro are exposed.
<pre>

MASMX 7r2
3/forjoy.msm
CONT_CHAR=
LTERM=;
QDELIM='
STERM=.
*EOF*
  :                            1:         $include        "8051_7r2.def"
  :                            2 
00:0000 0203EB                +3         ljmp    for.joy
  :                            4         $res    1000
  :                            5 
00:03EB 1203EF                +6 for.joy lcall    for.more
00:03EE 32                    +7          reti
  :                            8 
  :                            9 for.more 
00:03EF 00                    +10         nop
00:03F0 22                    +11         ret
*EOF*
:$(00):0000:03F1 :$(01):0400:0400 
forjoy.msm: object code 81 bytes: 0 errors: 0 undefined labels



</pre>
<p>
One macro defines LJMP and LCALL instructions. The other
defines RET, RETI and NOP instructions.

<p>
Macros don't need unique $PROC names unless they are invoked
by their $PROC names. Both macros in this sample are called 
P. They can only be called by their $NAME entry points, and then
only because the * asterisks make the names* visible.

<p>
Line 165 directs the assembler to start listing lines
from the included 8051 definition header file.

<p>
Line 166 is the structure template for long jump instructions.

<p>
Line 168, not shown, directs the assembler to stop listing 
the include file.

<p>
Line 414 directs the assembler to start listing the include file.

<p>
Line 415 starts declaring a procedural macro called P

<p>
Line 416 declares that if this macro is called by the name
LCALL, it has an nominal value of 18. This value may be retrieved
via the parameter reference p(0,1) or p(0, 0) or the masmx internal
function $N.

<p>
Line 417 declares that if this macro is called by the name
LJMP, it has a nominal value of 2, and 2 will be returned
for p(0, 1) or p(0, 0) or $N.

<p>
Line 418 will generate a 24-bit structure with the nominal call
value $N in the first 8 bits whenever the macro is expanded.

<p>
The second field of the i$long_jump form is given the value of the
first actual argument subfield. That is macro name plus numbers: p(1, 1)

<p>
Line 419 ends the macro.

<p>
Line 421 is not listed because it directed the assembler
to stop listing.

<p>
Line 522 directs the assembler to list the include file.

<p>
Line 523 declares another procedural macro called P

<p>
Line 524 says that if P is called by the name NOP, $n is 0.

<p>
Line 525 says that if P is called by the name RET, $n is 34.

<p>
Line 526 says that if P is called by the name RETI, $n is 50.

<p>
Line 527 generates one data word with the value $n.
The data word is 8 bits in size.

<p>
Line 528 ends of the macro.

<p>
Line 530 is not listed. It directed the assembler to stop
listing the include file.

<p>
The line numbers step down because they are line numbers
of the main file, not an include file.

<p>
Line 3 is an LJMP (long jump, direct address) to location
for.joy.

<p>
Line 4 is a buffer of 1000*address quantum, = 1000 bytes.

<p>
Line 6 is for.joy which is 1000+3 bytes beyond the start
of the assembly. for.joy calls for.more

<p>
Line 9 is for.more
<p>
Line 10 is a 8051 hardware NOP instruction (not a $NOP directive).
<p>
Line 11 is a RET (return) instruction.

<p>
Line 7 is a RETI (interrupt return instruction).
<pre>


MASMX/24592 1r1X
forjoy.msm 5
CONT_CHAR=
LTERM=;
QDELIM='
STERM=.
*EOF*  :                        165:         $list   2
  :                        166: i$long_jump     $form   8,16
  :                        167:         
  :                        414:         $list   2
  :                        415: p       $proc
  :                        416: lcall*  $name   012
  :                        417: ljmp*   $name   002
  :                        418:         i$long_jump     $n, p(1,1)
  :                        419:         $end
  :                        420:         
  :                        522:         $list   2
  :                        523: p       $proc
  :                        524: nop*    $name   0        
  :                        525: ret*    $name   022
  :                        526: reti*   $name   032
  :                        527:         +       $n
  :                        528:         $end
  :                        529:         
  :                        2: 
00:0000 0203EB        +3         ljmp    for.joy
  :                        4:         $res    1000
  :                        5: 
00:03EB 1203EF        +6 for.joy lcall    for.more
00:03EE 32            +7          reti
  :                        8: 
  :                        9: for.more 
00:03EF 00            +10         nop
00:03F0 22            +11         ret
*EOF*:$(00):0000:03F1 :$(01):0400:0400 
Object Code 89 Bytes: 0 Errors: 0 Undefined Labels


</pre>
<p>
A new layer or frame of the label table is constructed in
subassembly, and removed at the end of subassembly. Labels
declared in the macro expansion are not visible to more 
inclusive assembly layers except by design. Labels are 
unique in their subassembly layer (macro depth). 

<p>
Where more than one assembly layer has declared a label with
the same name, references to the label resolve to the declaration
in the most deeply nested macro.

<p>
The subassembly can access all the labels that currently exist.

<p>
To make a label more permanent than the macro expansion 
which declares it, asterisk(s) are suffixed to the label, 
one for each subassembly layer to which the label is promoted:
<pre>

mymacro*   $proc
	.
	.
"label1:p(1,1)"*
"labelx:p(1,1)"**
labely  .
	.
	$end

Start_of_Assembly
	.
	.
	mymacro   athing
	.
	.

</pre>
<p>
In the above example, "label1:athing" is visible to the whole
assembly, because it has one asterisk. 

<p>
Actual parameters can be included in labels names in quotes.

<p>
"labelx:athing" is visible to the whole assembly and to links. 
It has one more asterisk than the macro depth.

<p>
"labely" isn't visible outside the macro expansion.


<p>
If a $PROC macro has forward references to local labels, the macro must
be scanned twice on the second assembly pass. These $PROCs are called
two-pass $PROCs. They are marked by an asterisk argument of asterisk *
on the $PROC line:
<pre>


PUSHACC* $proc	*
	PUSH    ACC
	MOV     stackcheck,SP
	JB      stackcheck.7, StackOk
	JMP     ColdBoot
StackOk:
	$end

</pre>
<p>
The label StackOK is not exported from the macro expansion. Therefore
it stopped existing when the macro exited on the first assembly pass.
So the macro needs a preliminary pass on the second main assembly pass.

<p>
A $PROC line can have a location counter argument in syntax $(n)
as first argument or second argument after the 2-pass flag:
<pre>

p	$proc	$(20)
nomen*	$name
	.
	.
	$end

macby*	$proc	* $(50)
	.
	.
	$end

</pre>
<p>
Then code generated in the proc is in the named segment, and
location counter at the time of calling is switched back after.

<p>
If any line in a $PROC contains a label of * asterisk alone,
the label on the $PROC call line is reassigned as if it
appeared where the asterisk is.

<p>
In this assembly, "buffer1" and "buffer2" are declared in 
location counter 1. There is no break between the instructions
generated in location counter 0.
<pre>


MASMX/24592 1r1X
var.msm 5
CONT_CHAR=
LTERM=;
QDELIM='
STERM=.
*EOF*  :                        125:         $list   2
  :                        126: var*    $proc   $(1)
  :                        127: *       $res    var(1,1)
  :                        128:         $end
  :                        677:         $list   2
  :                        678: $(1:1024)
  :                        679: $(0:0)
00:0000 020006        +2         jmp     here
00:0003 020009        +3         jmp     there
  :                        4: buffer1 var     1024
  :                        5: buffer2 var     512
00:0006 900400        +6 here    mov     dptr, #buffer1
00:0009 900800        +7 there   mov     dptr, #buffer2
  :                        8: 
*EOF*:$(00):0000:000C :$(01):0400:0A00 
Object Code 92 Bytes: 0 Errors: 0 Undefined Labels


</pre>

<h2>8.39: $PUSHREL	Acquire a Relocation Tuple from a Superword</h2>

<p>
Linking directive
<pre>

parameter_label		$pushrel	relocation_clause

</pre>
<p>
used in the $MAP macro. $PUSHREL scans a relocation clause in Text
Encoded Binary input and tables the relocation attributes in the label
of the $PUSHREL line.

<p>
Therefore $PUSHREL must have a label.

<p>
$PUSHREL gives this label the type $EQUF. Macro Language can now use
it as a list containing three or five values.

<p>
The address value, subfield 1 of the $EQUF, is the relocation
base to be applied.

<p>
These attributes can be retrieved:
<pre>

parameter_label\1 	is the relocation value to be added to the
			superword data (i. e. to the code)

parameter_label\2	the number of bits in the target field to
			which the relocation value is added

parameter_label\3	is the left shift scale at which the relocation
			value is added to the superword data

_______________________________________________________________________
Parts \4 and \5 present if the target field is split or right-shifted
_______________________________________________________________________

parameter_label\4	is the addend value if it needed to be encoded
			separately in Text Encoded Binary.

			This offset value is normally in the superword
			data, but if assembly macro language shifted
			a relocatable value right: 

			part \4 contains the unrelocated and unshifted
			value;

			and part \5 contains the right shift count:

parameter_label\5	right shift count encoded as a negative integer:
 			to be applied to the separately delivered
			offset in part \4 after it has been relocated


</pre>
<p>
When the absolute address space is 32 bits or less, the relocation
value is the address part of the $pushrel label. This is the same
as part \1 of the pushrel label, except for sign extension.

<p>
The expression
<pre>

	parameter_label\1

</pre>
<p>
would be sign-extended from bit 31, so it is better to extract the
principal $EQUF value address-fashion:
<pre>

value	$set	parameter_label

</pre>
<p>
And that yields 32 bits unsigned, or signed if Flag -I is set.

<p>
When the absolute address space is between 33 and 192 bits, the
large relocation value is retrieved with a second $PUSHREL and
not from the label holding the parameter list:
<pre>

value	$pushrel,$long_absolute		relocation_clause

</pre>
<p>
A $MAP link macro consists of an outer loop which submits superwords
from the line of Text Encoded Binary to an inner macro, and of an inner
macro which caches the code part of the superword, and submits each
relocation tuple attached to it to another macro where the relocation
is applied to the code: 
<pre>

p	$proc
"$map"*	$name

p	$proc
superword* $name
clauses	$set	p(1,1:)	. The relocation clauses in TXO are substrings
			. The last substring is the code

data	$set,$binary	p(1,1:clauses)	. cache the code = last substring


clause	$do	clauses-1,	relocate	p(1,1:clause)

	load,$bits	data	. $bits is automatic from $set,$binary
				. write the code

	$end	. of SUPERWORD

p	$proc
relocate* $name

rel_params $pushrel	p(1, 1)

value	$set	rel_params\1

bits    $set    rel_params\2
scale   $set    rel_params\3
offset  $set    rel_params\4
descant $set    label1\5

limit   $set    1*/bits
mask    $set    limit-1
unmask  $set    ^(mask*/scale)

	$do	ENVIRONMENT=64,;
value	$PUSHREL,$LONG_ABSOLUTE	p(1, 1)

	$if	descant<0
field	$set	value+offset
	$info,$range_check1	field
	$info,$offset		field
field	$set	field*/descant
	$else
field	$set	value+(($data/*scale)**mask)
	$info,$range_check1	field
	$endif

"$data"* $set	((field**mask)*/scale)++($data**unmask)

.  label data* must be promoted in order to be the label "data" known
.  to the calling macro and not a new "data" only known in this macro

	$end	. of RELOCATE

index	$do	p(),	superword	p(index, 1)
	$end	. of $MAP

</pre>
<p>
If a relocation clause does not go absolute at $PUSHREL, $PUSHREL also tables a relocation tuple internally.

<p>
This relocation tuple may need adjusting with $INFO directive, because
a new in-segment displacement may have been summed.

<p>
$LOAD outputs all relocation tuples not absolutely resolved as new
relocation clauses in the output Text Encoded Binary.

<p>
Output code generation, of which $LOAD is an example, forwards
unresolved relocation tuples. All internally stacked  relocation
tuples have been actioned and are removed.

<p>
See Section 9: Output File Formats, Relocation and Linking,
Giant Address Spaces, Interfacing with GNU Tools


<h2>8.40: $QUANTUM           Select Bit Size of Addressed Object</h2>

<p>
$QUANTUM must be set to 8 for target machines which address bytes.

<p>
$WORD directive sets $QUANTUM to the value of $WORD. If the address
quantum is not the word size, $QUANTUM must follow $WORD:
<pre>

	$word   32
	$quantum 8


</pre>
<h2>8.41: $QUOTE            Select Character for Bounding Text Strings</h2>


<p>
Sets the quote character
<pre>

	$quote	''''

</pre>
<p>
Default is " character.

<p>
When the quote character is encountered in the instruction field,
or in a field of a  $FORM, it bounds a text string:
<pre>

	"Text Constant"
	.
	.
descriptor $form        16, 48
	descriptor      VALUE, "Label"


</pre>
<p>
If quote character appears in column 1, or in an expression, it bounds a
label. This allows labels beginning $ to be declared.
<pre>

MASMX/24592 1r1X
dollar1.msm 5
*EOF*  :                        1:         $word           16
  :                        2: $(6:06000)
  :                        3: "$handle"
  :                        4:         $res    10
06:600A 000A          +5         +       $-$handle
  :                        6: 
*EOF*:$(06):6000:600B 
Object Code 38 Bytes: 0 Errors: 0 Undefined Labels


</pre>
<p>
When -M Flag (Motorola Hex) is on, labels beginning $
can still be understood in expressions if they have quotes
around them:
<pre>

MASMX/24592 1r1X
dollar.msm 5
CONT_CHAR=
LTERM=;
STERM=.
*EOF*  :                        1:         $word           16
  :                        2:         $cont_char       0       . No Continuation
  :                        3:         $lterm          ';'     . comment is ;
  :                        4:         $sterm          '.'     ; sub.string is .
  :                        5:         $set_option     "m"     ; Motorola Hex
  :                        6: $(6:06000)                      ; Locator 6, base 24K
  :                        7: "$handle"                       ;
  :                        8:         $res    10              ; Buffer 10 Words
  :                        9: .locator $equ,"$function" "$"   ; Alias Location Counter
06:600A 0010          +10         +       .locator-"$handle"+$6
  :                        11: 
*EOF*:$(06):6000:600B 
Object Code 38 Bytes: 0 Errors: 0 Undefined Labels

</pre>
<p>
The "legal" character set for labels is       
<pre>

		$ 
		A..Z 
		a..z 
		0..9 
		@ 
		! 
		? 
		_ (underscore)

</pre>
<p>
and the currect $STERM which is default colon but often
set to period.

<p>
Labels bounded with $QUOTE may contain characters which are not 
otherwise included in labels: 

<pre>

$ masmx -l
MASMX 7r2
0/-INPUT>>
	$word	32
	$quantum 8
$(5:050000)
index   $do	9,	+	100-index
"unconventional \ rough { label"
	$res	12
	+	"unconventional \ rough { label"
	$end
  :                            1  $word 32
  :                            2  $quantum 8
  :                            3 $(5:050000)
05:00050000 00000063          +4 index $do 9, + 100-index
05:00050004 00000062          +4 
05:00050008 00000061          +4 
05:0005000C 00000060          +4 
05:00050010 0000005F          +4 
05:00050014 0000005E          +4 
05:00050018 0000005D          +4 
05:0005001C 0000005C          +4 
05:00050020 0000005B          +4 
  :                            5 "unconventional \ rough { label"
  :                            6  $res 12
05:00050030 00050024          +7  + "unconventional \ rough { label"
  :                            8  $end
:$(05):00050000:00050034 
-INPUT>>: object code 148 bytes: 0 errors: 0 undefined labels

</pre>
<p>
It's also possible to declare a label which begins with a decimal
digit, but it couldn't be referenced without $QUOTE:
<pre>

MASMX/24592 1r1X
nuri.msm 5
*EOF*  :                        1: $(4:0480)
  :                        2: 123OLeary
04:000480 000481        +3         +       "123OLeary"+1       
*EOF*:$(04):000480:000481 
Object Code 48 Bytes: 0 Errors: 0 Undefined Labels

</pre>
<p>
If quote character is changed to apostrophe, it cannot be used to bound
labels in expressions. Apostrophe has a fixed meaning in expressions.
The expression gets the bit-pattern value of the contained characters
in the current size and character code, by default 8-bit ASCII.

<p>
In this assembly an unconventional label is declared sucessfully but
can not be referenced:
<pre>

$ masmx vr -lx
MASMX 7r2
3/vr.msm
QDELIM='
  :                            1  	$quote	''''
  :                            2 
  :                            3 	$word 32
  :                            4 	$quantum 8
  :                            5 $(5:050000)
05:00050000 00000063          +6 index	$do	9,	+	100-index
05:00050004 00000062          +6 
05:00050008 00000061          +6 
05:0005000C 00000060          +6 
05:00050010 0000005F          +6 
05:00050014 0000005E          +6 
05:00050018 0000005D          +6 
05:0005001C 0000005C          +6 
05:00050020 0000005B          +6 
  :                            7 'unconventional \ rough { label'
  :                            8 	$res 12
05:00050030 656E74696F6E616C205C20726F756768207B206C6162656C
                              +9 	+	'unconventional \ rough { label'
  :                            10 	$end

  :

  :

vr.msm=0<00000003
INDEX=00000009
UNCONVENTIONAL \ ROUGH { LABEL=$05:00050024
:$(05):00050000:00050048 
vr.msm: object code 188 bytes: 0 errors: 0 undefined labels


</pre>
<h3>8.41.1: Quoted Strings and Labels within Macro Expansions</h3>


<p>
When labels are in quotes in a macro, the quotes can
contain argument paraforms which are replaced with
actual parameters.


<p>
An expression token in quotes is expected to be a label.
<pre>


MASMX 7r2
3/quo.msm
*EOF*
  :                            1 p*       $proc
  :                            2 "name:p(1,1)"
  :                            3         +       "name:p(1,1)"+0c0000
  :                            4         $snap    2
  :                            5         $end
  :                            6 $(0:64)
00:000040 0C0040              +7         p       yes
NAME:YES=$00:000040
*EOF*
:$(00):000040:000041 
quo.msm: object code 44 bytes: 0 errors: 0 undefined labels

</pre>
<p>
If the value of $QUOTE is apostrophe, a 'label' in 
column 1 can be constructed and defined, catenating 
parameters with other symbols; 

<p>
however 'characters between apostrophes' in an 
expression have  their own immediate value without 
substitution, +'label'=0000006c6162656c. 

<p>
Therefore when $QUOTE is an apostrophe or 0x27, 
labels may only be included in expressions without 
surrounding $QUOTE. Consequently, labels in the 
actual arguments may be referenced, but not catenated 
with new symbols to construct new labels for reference:
<pre>

MASMX 7r2
3/quo1.msm
QDELIM='
*EOF*
  :                            1         $quote  027
  :                            2 p*      $proc
  :                            3 'name:p(1,1)'
  :                            4         +       'name:p(1,1)'+0c0000
  :                            5         +       name:no+0a0000
  :                            6         $snap    2
  :                            7         $end
  :                            8 $(0:64)
00:000040 00006E616D65466E6F  +9         p       no
00:000043 0A0040              +9 
NAME:NO=$00:000040
*EOF*
:$(00):000040:000044 
quo1.msm: object code 63 bytes: 0 errors: 0 undefined labels


</pre>
<p>
The quote character in the command or instruction position always 
means a text string, and within a macro, parameter substition
takes place. 
<pre>

MASMX 7r2
3/quo3.msm
*EOF*
  :                            1 p*      $proc
  :                            2 "name:p(1,1)"
  :                            3         "name:p(1,1)"
  :                            4         $snap    2
  :                            5         $end
  :                            6 $(0:64)
00:000040 6E616D653A5365655F446174613F20
                              +7         p       See_Data?
NAME:SEE_DATA?=$00:000040
*EOF*
:$(00):000040:000045 
quo3.msm: object code 68 bytes: 0 errors: 0 undefined labels


</pre>
<p>
A field of a $FORM all in quotes also means a string, and in a 
macro expansion, parameter substitution takes place:
<pre>

MASMX 7r2
3/quo4.msm
*EOF*
  :                            1 f       $form   16, 104
  :                            2 p*      $proc
  :                            3 "name:p(1,1)"
  :                            4         f       -6, "!p(1,1)!"
  :                            5         $snap    2
  :                            6         $end
  :                            7 $(0:64)
00:000040 FFFA215365655F446174613F212020
                              +8         p       See_Data?
NAME:SEE_DATA?=$00:000040
*EOF*
:$(00):000040:000045 
quo4.msm: object code 68 bytes: 0 errors: 0 undefined labels


</pre>
<p>
If the "!p(1,1)!" is meant to be a label and not the string of its
character values, adding a unary sign will change the string to
an expression and the label will be searched:
<pre>

	f	-6, +"!p(,1 1)!"

</pre>
<h2>8.42: $RES               Declare a Storage Buffer</h2>             

<p>
$RES declares a buffer, i.e. it advances the current location
counter.

<p>
By default no code is loaded in $RES storage

<p>
<b>-Z</b> option causes the buffer to be zero-filled instead

<p>
$RES intervals in $PROC structures generated as literals
are always zero-filled


<pre>

$(1:1024)
buffer_name     $res    100
buffer_2        $res    40

</pre>
<p>
has the effect that "buffer_name" has a value of 1024,
and represents a location 0400 in counter 1.

<p>
"buffer_2" has a value of 1124 and represents location 0464 in counter 1. 

<p>
If address quantum is less than word size, it's sometimes necessary
to align after $RES.
<pre>

MASMX 7r2
3/linitup.msm
*EOF*
  :                            1         $word   32
  :                            2         $quantum 8
  :                            3 
  :                            4 line_up* $proc
  :                            5 granule $set    line_up(1,1)    
  :                            6         $res    ($+granule-1**-granule)-$
  :                            7         $end
  :                            8 
  :                            9 $(12:0780000)
  :                            10 first_buffer    $res    17
  :                            11         line_up 4
  :                            12 second_buffer   $res    19
  :                            13         line_up 4
  :                            14 end_buffers
0C:00780028 00780000          +15         +       first_buffer
0C:0078002C 00780014          +16         +       second_buffer
0C:00780030 00780028          +17         +       end_buffers
*EOF*
:$(0C):00780000:00780034 
linitup.msm: object code 72 bytes: 0 errors: 0 undefined labels

</pre>

<h2>8.43: $RETURN            Return a Value from $FUNC..$END</h2>

<p>
$RETURN may be used to jump out of any macro <b>$PROC..$END</b>
or <b>$FUNC..$END</b>

<p>
Function $RETURN delivers the value of its argument.

<p>
The function HIGH in the following example returns the upper
8 bits of a 16-bit value:
<pre>

MASMX/24592 1r1X
high.msm 5
CONT_CHAR=
LTERM=;
QDELIM='
STERM=.
*EOF*  :                        628:         $list   2
  :                        629: high*   $func
  :                        630: v       $set    high(1,1)        
  :                        631:         $return v/*8
  :                        632:         $end
  :                        2: 
  :                        3: 
  :                        4: 
00:0000 00AA          +5         +       high(170*256)
*EOF*:$(00):0000:0002 :$(01):0400:0400 
Object Code 59 Bytes: 0 Errors: 0 Undefined Labels

</pre>
<p>
Functional results are 192 bits.
 


<h2>8.44: $ROOT              Foot of Structured Name Space</h2>

<p>
$ROOT is the end of a structured name space. See Section
8.53: $TREE, 8.4: $BRANCH



<h2>8.45: $SET               Assign Reassignable Value to Label</h2>


<p>
$SET is a temporary equate. A label may be set many times, and
$SET is actioned on both first and second assembly passes.

<p>
The label may be set to any value which can be expressed
in 192 bits.
<pre>

label   $set    262144*/160
label2	$set	262.144e+3*/160

</pre>
<p>
A <b>$set</b> label can reference itself the first time it is declared.
Its value is zero.
<pre>

increment $equ	6
label_new $set	label_new+increment

</pre>
<p>If <b>label_new</b> was never mentioned before, its value is now 6.
Otherwise undeclared labels can only be interrogated for their type,
which is zero
<pre>

	$do	$t(alabelname)=0,	....

</pre>
<h2>8.46: $SET_OPTION</h2>

<h3>8.46.1:Set Option Flags</h3>

<pre>



	$set_option     "a..z"

</pre>
<p>
sets the option flags which can otherwise be set on the command
line:
<pre>

       >masmx input [output] -a..z

</pre>
<p>
Therefore if the command line is
<pre>

       >masmx source1 -klm

</pre>
<p>
and source1.msm contains 
<pre>

	$set_option     "pno"

</pre>
<p>
The total effect is the same as
<pre>

       >masmx source1 -klmnop

</pre>
<p>
The option letters are case significant.
<b>-QZ</b> are different options from <b>-qz</b>

<p>
Flags <b>-ksy</b> are only actioned on the command line,
not via <b>$set_option</b> directive

<h3>8.46.1: Interaction of Run Options and List Directives</h3>


<p>
<b>$LIST</b> and <b>$PLIST</b> directives interact with options
<b>-lpqr</b> in these ways:
<pre>

	$list   0

</pre>
<p>
prevents source or generated code from printing at all. Labels declared
or imported while <b>$list</b> is zero are also not listed or exported.
see Section 8.28: <b>$list 0</b>, masking names from list/export
<pre>

	$list   1

</pre>
<p>
prints the main file and generated code if option <b>-l</b> is on.
The default value is 1.

<p>
The larger the <b>$list</b> value, the deeper nested includes are listed.
If flag <b>-l</b> is off, only summary information is listed.

<p>
If flag <b>-w</b> is on, assembly is silent and summary information
is not listed.

<p>
<b>$PLIST</b> directive interacts with <b>-pqr</b> options:        
<pre>
	
	$plist  0

</pre>
<p>
prevents all macro expansion from printing.
<pre>

	$plist  2

</pre>
<p>
displays <b>$PROC</b> macro language one macro deep if <b>-p</b> is on, and
<p>
displays <b>$FUNC</b> macro language one macro deep if	<b>-q</b> is on.

<p>
The larger the value of <b>$plist</b>, the deeper nested macro language
is displayed.

<p>
<b>-r</b> flag allows macro language up to <b>$plist</b> depth to be displayed
on the first assembly pass. This is for investigating serious problems
in macro language which prevent a second assembly pass. Otherwise
nothing is listed until the second assembly pass.

<p>
The option values are listed in Section 3.1: The Command Line



<h2>8.47: $SNAP              List Label Table</h2>


<p>
$SNAP lists labels. Default behaviour is to list the fixed part 
of the label table in load order, or sorted if <b>-y</b> flag has been opted.
$SNAP may take an argument
<pre>

	$SNAP	expression

</pre>
<p>
$SNAP lists the fixed part of the label table unless the argument
expression has the value 2
<pre>

	$SNAP		2

</pre>
<p>
With an argument of 2, $SNAP lists the labels which exist temporarily
during macro expansion. The $SNAP directive is inside the macro text
in order to achieve this
<pre>

mymacro* $proc
	.
	.
	$snap		2
	.
	.
	$end

</pre>
<p>
$SNAP is only actioned during the second assembly
pass, unless it has a subcommand of 1 
<pre>

	$SNAP,1		[argument 0..2]

</pre>


<h2>8.48: $STERM             Change the Substring Sentinel Character</h2>
<pre>

	$term	divider_character

</pre>
<p>
The substring character is changed to the value of the $TERM argument.
The substring character is
<ul>

	<li>-a character in a label

	<li>-the divider between substrings:of:subfields in parameter
	 actual arguments

	<li>-a join in a structured label

	<li>-a join in a text string

</ul>
<p>
The default value of $STERM is colon : 

<p>
In the following assembly

<p>
Line 4 changes $STERM to period. Here period
is a term in a label.

<p>
Line 16 in nested macro "q" resolves q(1,1) 
to the label on line 6, "p3.1" = 32+1

<p>
Line 17 in nested macro "q" resolves q(1,1:1) from "p3.1"
to the label on line 5, "p3" = 32.

<p>
The paraform q(1,1:1) looks for the substring divided by the substring
terminator. Whatever the current value of the substring terminator,
paraforms which search for substrings contain the colon character.
<pre>

then    q(1,1:2) is 1 from p3.1
	
	q(1,2:1) is -32 from -p3.1
	q(1,2:2) is 1 from -p3.1

Then "p" calls "q" again and

	there isn't a label "10.9", so q(1,1) is 10

then    q(1,1:1) is 10 from 10.9
	q(1,1:2) is 9 from 10.9....

MASMX 7r2
3/sterm.msm
CONT_CHAR=\
LTERM=;
STERM=.
*EOF*
  :                            1         $word   16
  :                            2         $cont_char '\'
  :                            3         $lterm  ';'
  :                            4         $sterm  '.'
  :                            5 p3      $equ    32
  :                            6 p3.1    $equ    32+1
  :                            7 
  :                            8 p*      $proc
  :                            9 *       $tree
  :                            10 times   $do     p(1),branch(times)*  q p(1, times), -p(1, times)
  :                            11         $root
  :                            12         $end
  :                            13 
  :                            14 q*      $proc
  :                            15 *       $tree
  :                            16 h       +       q(1,1)
  :                            17 again   $do     2,leaf(again)   + q(1,again:1), q(1,again:2)
  :                            18         $root
  :                            19         $end
  :                            20 
00:0000 0021                  +21 trunk   p       p3.1, 10.9, 8.8
00:0001 2001                  +21 
00:0002 E001                  +21 
00:0003 000A                  +21 
00:0004 0A09                  +21 
00:0005 F609                  +21 
00:0006 0008                  +21 
00:0007 0808                  +21 
00:0008 F808                  +21 
  :                            22 
00:0009 0008                  +23         +       trunk.branch(3).leaf(2)
  :                            24         
00:000A 4669727374204C696E65206F6620546578740A5365636F6E
                              +26         	"First Line of Text".10."Second Line of Text".10.\
        	"Third Line of Text".12
00:0016 64204C696E65206F6620546578740A5468697264204C696E
                              +26 
00:0022 65206F6620546578740C  +26 
  :                            27 
*EOF*
:$(00):0000:0027 
sterm.msm: object code 198 bytes: 0 errors: 0 undefined labels

</pre>
<p>
In Line 23 the $STERM character, currently ".", is used to
identify components of a hierarchic structure "trunk".."branch".."leaf"
which was constructed by nested $TREE..$ROOT directives
-see section 8.54: $TREE directive

<p>
In lines 26..27 $STERM connects parts of a text string. Here $STERM
is used to include linefeeds and formfeeds on the string.

<p>
Whatever substring terminator has been set to, macro language
interrogates for substrings with the colon : character
<pre>

	p(1,1:)		how many substrings in subfield 1

	p(1,1:1)	value substring 1 in subfield 1

	p(1,1:*1)	unary * from substring 1 in subfield 1

	p(1,1:#1)	unary # from substring 1 in subfield 1


</pre>
<h2>8.49: $STORE		Set Default Output Name</h2>

<p>
Directive <b>$STORE</b> sets a default name for the file where the output
text encoded binary is stored. A second filename on the command line
overrides the <b>$STORE</b> name
<pre>

	$store	filename

</pre>
<p>
The default filename extension is txo
<pre>

	$store	reloca1

</pre>
<p>
is the same as
<pre>

	$store	"reloca1.txo"

</pre>
<h2>8.50: $SUFFIX    Use Suffix for Number String Interpretation</h2> 


<p>
Suffix flags on number strings are supported for Intel-style source code

<p>
$SUFFIX setting can be set to 0, 1 or 2, and the default is 0.
<pre>


	$suffix 0       ; suffix letters are not used
			; for interpreting number strings

	$suffix 1       ; suffix letters ..D ..d	= DECIMAL
			;                ..H ..h 	= HEX
			;                ..B ..b	= BIT PATTERN
			;                ..Q ..q ..O ..o =OCTAL
			

			; default is decimal except leading zero = hex

	$suffix 2       ; as "$suffix 1", except default is always decimal.

</pre>
<p>
When $SUFFIX is 1, then a string beginning 0 is interpreted as
hex (or octal if $OCTAL is set ), when there is no actual suffix.

<p>
Default with first digit 1..9 is decimal

<p>
When $SUFFIX is 2, any number string is decimal when there is no actual
suffix.

<p>
Suffix letters are only examined on a number string beginning
with a digit 0..9.

<p>
decimal/hex/octal/bit-binary suffixes do not
conflict with the size flags which can appear at the
trailing end of masmx number constants.

<p>
These are 
<ul>

	:S		one word

<pre></pre>
	:D or :L	two words

<pre></pre>
	:T		three words

<pre></pre>
	:Q		four words

<pre></pre>
	:P		five words

<pre></pre>
	:H		six words

<pre></pre>
	:O		eight words


</ul>
<p>
The length override is the last token on a number item line.

<p>
It is recognised first and the value expression is inside it.

<p>
Where a notation suffix D Q H O is the last symbol in a number
string token, any size override goes after it:
<pre>

MASMX 7r2
0/-INPUT>>
        $word   16
        $suffix 2

        +0bbbbhq
        $end
  :                            1  $word 16
  :                            2         $suffix 2
  :                            3 
00:0000 000000000000BBBB      +4         +0bbbbhq
  :                            5         $end
:$(00):0000:0004 

</pre>
<p>
Number suffix notation is mostly encountered in macros, because suffixes
appear on instruction operands and on the arguments of pseudo-directives
like DD and DW. All of these are macros for masmx:
<pre>

MASMX/24592 1r1X
dde.msm 5
CONT_CHAR=
LTERM=;
QDELIM='
STERM=.
*EOF*  :                        46:         $list           2
  :                        47:         $word           8
  :                        48:         $byte           8
  :                        49:         $quantum        8
  :                        50:         $awidth         16

  :                        81:         $list   2
  :                        82: dd*     macro
  :                        83:         $do     dd(1)
  :                        84: v       $set    dd(1,$d+1)        
  :                        85:         +       v, v/*8, v/*16, v/*24:q
  :                        86:         $endo
  :                        87:         macend

00:0000 01000063      +2         dd      99*4096*4096+1, 63h*4096*4096+2 
00:0004 02000063      +2 
*EOF*:$(00):0000:0008 :$(01):0400:0400 
Object Code 71 Bytes: 0 Errors: 0 Undefined Labels


</pre>
<h2>8.51: $TEXT              Translate Input Text Patterns</h2>

<p>
$TEXT directive is used for syntax translations which cannot
be reached any other way. Examples are where source code
contains operators which are not the masmx operators:
<pre>

	$text   \ div \/\
	$text   \ shl \*/\
	$text   / and /**/

</pre>
<p>
All the <b>$TEXT</b> patterns must be placed adjacent to each other
in the assembly header. Any separated from the first block of
them will not be used.



<h2>8.52: $TRACE             Display Value</h2>
        
<p>
Directive
<pre>

	$trace	argument

</pre>
<p>
Displays the value of its argument
<pre>


p       $proc
add     $name   1
subtract $name  2
	aform   $n, p(1,1), p(1,2)
	$trace  p(1, 1)
	$end

</pre>
<p>
That would show the left side operand of the add or subtract
instruction.

<p>
To produce $TRACE on the first assembly pass, a subcommand
of value 1 is added:
<pre>

	$trace,1        ...


</pre>
<p>
When a macro actual argument is an automatic literal, $TRACE
obtains the literal value and not the literal address


<h2>8.53: $TREE              Head of Structured Name Space</h2>


<p>
$TREE is used to structure a name space containing data or code.

<p>
The structure is ended with $ROOT. The tree must 
have a label:
<pre>

name    $TREE
	.
	.
	$ROOT

</pre>
<p>
$TREEs may be nested for a hierarchy of structures. $TREEs
may be inside a $PROC macro or not. If a $TREE is inside a
$PROC, the label of the $TREE may be the inherited label from
the macro call line, for example
<pre>

p       $proc
species $name
*       $tree
branches +      p(1,1)
many    $do     p(1,1),branch(many)   $res    4
	$root
	$end

</pre>
<p>
For reference the components of the resulting structured
labels are separated with the $STERM symbol, default : colon.
Therefore if the above macro is expanded with label "aspen":

aspen   species 3

<p>
labels exist called
<ul>
		     	aspen:branches, 
<pre></pre>
			aspen:branch(1), 
<pre></pre>
			aspen:branch(2), 
<pre></pre>
			aspen:branch(3)

</ul>
<p>
and ASPEN:BRANCHES has 3 assembled into it. 

<p>
In the following assembly, an 8051 system has four UARTs each
with their eight register files locationed nearly adjacent at
XRAM addresses 128..135, 144..151, 160..167, 176..191:

<p>
The input side of a device driver scans each receive channel.
The code is generated using a structure with subscripted
components. 30 bytes of code is generated to scan each UART
for input. A developer might choose to do this with a variable
pointer instead, but this sample shows how to do it with trees
of structured names:
<pre>


MASMX 7r2
3/uart.msm
CONT_CHAR=
LTERM=;
QDELIM='
STERM=.
*EOF*
  :                            1:         $include   "8051_7r2.def"
  :                            2 
  :                            3 LSR_RDR EQU     0       ; Data In Receive FIFO
  :                            4 
  :                            5 serial*  $proc     
  :                            6         $res    (($+15)**-16)-$
  :                            7 *       $tree          
  :                            8 rhr
  :                            9 thr     $res    1
  :                            10 ier     $res    1
  :                            11 isr     $res    1
  :                            12 lcr     $res    1
  :                            13 mcr     $res    1
  :                            14 lsr     $res    1
  :                            15 msr     $res    1
  :                            16 spr     $res    1
  :                            17         $root
  :                            18         $end
  :                            19 
  :                            20 '$bit'*       $func
  :                            21       $if     $bit(1,1:1)<128
  :                            22       $return (($bit(1,1:1)**31)*/3)++$bit(1,1:2)
  :                            23       $else
  :                            24       $return $bit(1,1:1)++$bit(1,1:2)
  :                            25       $end
  :                            26 
  :                            27 generate* $proc *
  :                            28 Sample:
  :                            29         jb      $bit(FULL.device),leave ; Is there any buffer space?
  :                            30         mov     dptr,#uart(device).lsr  ; Is there data on COM1 input FIFO?
  :                            31         movx    a,@dptr
  :                            32         jnb     $bit(acc.LSR_RDR), Leave; No more so Next UART
  :                            33         mov     dptr,#uart(device).rhr  ; Yes
  :                            34         movx    a,@dptr                 ; Read
  :                            35         mov     dptr,#buffer(device)    ; Find Place in Circular Input Buffer
  :                            36         mov     dpl,write_cursor(device); By Means of the Running Cursor
  :                            37         movx    @dptr,a                 ; Write the Data to XRAM
  :                            38         inc     write_cursor(device)    ; Advance the Input Cursor
  :                            39         mov     a,read_cursor(device)   ; If write starts to equal read
  :                            40         cjne    a,write_cursor(device),Sample ; Is there any more? 
  :                            41         setB    $bit(FULL.device)       ; Stop reading from FIFO to XRAM
  :                            42 leave:       
  :                            43         $end
  :                            44 
  :                            45 
  :                            46 DEVICES equ     128
  :                            47 DATA    equ     1024
  :                            48 TOTAL   equ     4
  :                            49 RTVARS  equ     64
  :                            50 Full    equ     32
  :                            51 
  :                            52 $(3:RTVARS)
  :                            53 device  $do     TOTAL,write_cursor(device)      $res    1
  :                            54 device  $do     TOTAL,read_cursor(device)       $res    1
  :                            55 $(2:DEVICES)
  :                            56 device  $do     TOTAL,uart(device)              serial
  :                            57 $(1:DATA)
  :                            58 device  $do     TOTAL,buffer(device)            VAR    256
  :                            59 
  :                            60 
  :                            61 $(0:64)
00:0040 20011B                +62 device        $do     TOTAL,  generate
00:0043 900085                +62 
00:0046 E0                    +62 
00:0047 30E014                +62 
00:004A 900080                +62 
00:004D E0                    +62 
00:004E 900400                +62 
00:0051 854082                +62 
00:0054 F0                    +62 
00:0055 0540                  +62 
00:0057 E544                  +62 
00:0059 B540E4                +62 
00:005C D201                  +62 
00:005E 20021B                +62 
00:0061 900095                +62 
00:0064 E0                    +62 
00:0065 30E014                +62 
00:0068 900090                +62 
00:006B E0                    +62 
00:006C 900500                +62 
00:006F 854182                +62 
00:0072 F0                    +62 
00:0073 0541                  +62 
00:0075 E545                  +62 
00:0077 B541E4                +62 
00:007A D202                  +62 
00:007C 20031B                +62 
00:007F 9000A5                +62 
00:0082 E0                    +62 
00:0083 30E014                +62 
00:0086 9000A0                +62 
00:0089 E0                    +62 
00:008A 900600                +62 
00:008D 854282                +62 
00:0090 F0                    +62 
00:0091 0542                  +62 
00:0093 E546                  +62 
00:0095 B542E4                +62 
00:0098 D203                  +62 
00:009A 20041B                +62 
00:009D 9000B5                +62 
00:00A0 E0                    +62 
00:00A1 30E014                +62 
00:00A4 9000B0                +62 
00:00A7 E0                    +62 
00:00A8 900700                +62 
00:00AB 854382                +62 
00:00AE F0                    +62 
00:00AF 0543                  +62 
00:00B1 E547                  +62 
00:00B3 B543E4                +62 
00:00B6 D204                  +62 
  :                            63 
*EOF*

....

BUFFER(1)=$01:0400
BUFFER(2)=$01:0500
BUFFER(3)=$01:0600
BUFFER(4)=$01:0700

....

READ_CURSOR(1)=$03:44
READ_CURSOR(2)=$03:45
READ_CURSOR(3)=$03:46
READ_CURSOR(4)=$03:47

....

TCON=0088
TMOD=0089
TOTAL=04
UART(1)=$02:0080
UART(1):RHR=$02:0080
UART(1):THR=$02:0080
UART(1):IER=$02:0081
UART(1):ISR=$02:0082
UART(1):LCR=$02:0083
UART(1):MCR=$02:0084
UART(1):LSR=$02:0085
UART(1):MSR=$02:0086
UART(1):SPR=$02:0087
UART(2)=$02:0090
UART(2):RHR=$02:0090
UART(2):THR=$02:0090
UART(2):IER=$02:0091
UART(2):ISR=$02:0092
UART(2):LCR=$02:0093
UART(2):MCR=$02:0094
UART(2):LSR=$02:0095
UART(2):MSR=$02:0096
UART(2):SPR=$02:0097
UART(3)=$02:00A0
UART(3):RHR=$02:00A0
UART(3):THR=$02:00A0
UART(3):IER=$02:00A1
UART(3):ISR=$02:00A2
UART(3):LCR=$02:00A3
UART(3):MCR=$02:00A4
UART(3):LSR=$02:00A5
UART(3):MSR=$02:00A6
UART(3):SPR=$02:00A7
UART(4)=$02:00B0
UART(4):RHR=$02:00B0
UART(4):THR=$02:00B0
UART(4):IER=$02:00B1
UART(4):ISR=$02:00B2
UART(4):LCR=$02:00B3
UART(4):MCR=$02:00B4
UART(4):LSR=$02:00B5
UART(4):MSR=$02:00B6
UART(4):SPR=$02:00B7
VAR=:P1:(1)0:07
WRITE_CURSOR(1)=$03:40
WRITE_CURSOR(2)=$03:41
WRITE_CURSOR(3)=$03:42
WRITE_CURSOR(4)=$03:43
XCH=:N1:P:0:0C
XCHD=:P1:0:1C
XRL=:N1:P:0:06
8051_7r2.def=1<0005
uart.msm=0<0003
:$(00):0000:00B8 :$(01):0400:0800 :$(02):0080:00B8 :$(03):0040:0048 
uart.msm: object code 381 bytes: 0 errors: 0 undefined labels


</pre>
<p>
In the following assembly, a structure is 
constructed at address 0x00037300 in PowerPC system memory. 

<p>
Components of the structure are accessed with labels containing 
period . which is conventionally the value given to $STERM in 
PowerPC definition header files.

<p>
Some of the components are repeated and subscripted. The
repeat directive is $DO, and the $DO tag value is used
to generate a numeric label subscript (see Section 7:
Iterated Code and Structured Data, Section 7.1: $DO and macros
and Section 7.2: Subscripted Labels).

<p>
Because all the addresses are 0x00037300 or more, PowerPC
load/store instructions can't access them directly, so the
location counter declaration on line 22 instructs the assembler
to answer label references as base-displacement tuples which 
assume R12 is pointing to 0x00037300.
<pre>

MASMX 7r2
3/ppcsinga.msm
LTERM=#
CONT_CHAR=
STERM=.
*EOF*
  :                            1 record* $proc        
  :                            2 *       $tree
  :                            3 h       +       record(1,1)
  :                            4 times   $do     record(1,1),t(times)       $res  4
  :                            5         $root
  :                            6         $end
  :                            7 
  :                            8:         $include        "ppc1.def"
  :                            9 tree*   $proc
  :                            10 *       $tree
  :                            11 times   $do     3,dibber(times) record    tree(1,1)
  :                            12         $root
  :                            13         $end
  :                            14 
  :                            15 inline*       $proc
  :                            16         lwz   r8, raddle1(1).dibber(3).t(index)
  :                            17         add   r0,0,r8
  :                            18       $end
  :                            19 
  :                            20 SEGMENT $set    55*4096+768
  :                            21 
  :                            22 $(49::SEGMENT,r12)
  :                            23 this_segment    $equ    .
31:00037300 00000012          +24 times   $do     2,raddle1(times) tree    18
31:0003734C 00000012          +24 
31:00037398 00000012          +24 
31:000373E4 00000012          +24 
31:00037430 00000012          +24 
31:0003747C 00000012          +24 
31:000374C8 0000001E          +25 raddle2 tree    30
31:00037544 0000001E          +25 
31:000375C0 0000001E          +25 
  :                            26 
  :                            27 $(0:980*1024)
00:000F5000 640C0003          +28         oris    r12,,SEGMENT/*16
00:000F5004 618C7300          +29         ori     r12,r12,SEGMENT
00:000F5008 806C004C          +30         lwz     r3, raddle1(1).dibber(2)
00:000F500C 808C017C          +31         lwz     r4, raddle1(2).dibber(3).h
00:000F5010 80AC01AC          +32         lwz     r5, raddle1(2).dibber(3).t(12)
00:000F5014 80CC01C8          +33         lwz     r6, raddle2
00:000F5018 616C0000          +34         mr      r11, r12
  :                            35 
  :                            36       $if     0
  :                            37       lwz     r7, raddle2.dibber(1).t(9), r11
  :                            38       $else
00:000F501C 80EB01EC          +39         lwz     r7, raddle2.dibber(1).t(9)(r11)
  :                            40       $endif
  :                            41 
00:000F5020 810C009C          +42 index   $do     raddle1(1).dibber(3).t(),    inline
00:000F5024 7C004214          +42 
00:000F5028 810C00A0          +42 
00:000F502C 7C004214          +42 
00:000F5030 810C00A4          +42 
00:000F5034 7C004214          +42 
00:000F5038 810C00A8          +42 
00:000F503C 7C004214          +42 
00:000F5040 810C00AC          +42 
00:000F5044 7C004214          +42 
00:000F5048 810C00B0          +42 
00:000F504C 7C004214          +42 
00:000F5050 810C00B4          +42 
00:000F5054 7C004214          +42 
00:000F5058 810C00B8          +42 
00:000F505C 7C004214          +42 
00:000F5060 810C00BC          +42 
00:000F5064 7C004214          +42 
00:000F5068 810C00C0          +42 
00:000F506C 7C004214          +42 
00:000F5070 810C00C4          +42 
00:000F5074 7C004214          +42 
00:000F5078 810C00C8          +42 
00:000F507C 7C004214          +42 
00:000F5080 810C00CC          +42 
00:000F5084 7C004214          +42 
00:000F5088 810C00D0          +42 
00:000F508C 7C004214          +42 
00:000F5090 810C00D4          +42 
00:000F5094 7C004214          +42 
00:000F5098 810C00D8          +42 
00:000F509C 7C004214          +42 
00:000F50A0 810C00DC          +42 
00:000F50A4 7C004214          +42 
00:000F50A8 810C00E0          +42 
00:000F50AC 7C004214          +42 
  :                            43 
  :                            44 SEGMENT       $set    .(49)+SEGMENT
  :                            45 $(49::SEGMENT,r11)
  :                            46 new_segment $equ .
31:0003763C 00000006          +47 jessalabel tree 6
31:00037658 00000006          +47 
31:00037674 00000006          +47 
31:00037690 00000004          +48 jumbly  tree    4
31:000376A4 00000004          +48 
31:000376B8 00000004          +48 
  :                            49 $(0)
00:000F50B0 640B0003          +50         oris    r11,,SEGMENT/*16
00:000F50B4 616B763C          +51         ori     r11,r11,SEGMENT
00:000F50B8 806B0054          +52         lwz     r3, jumbly
00:000F50BC 808B0058          +53         lwz     r4, jumbly+4
00:000F50C0 906B0038          +54         stw     r3, jessalabel.dibber(3).h
00:000F50C4 90800006          +55         stw     r4, jessalabel.dibber(3).t()
00:000F50C8 80A34000          +56         lwz     r5, 0x4000(r3)
00:000F50CC 658402C0          +57         li      r4, raddle2.dibber(3)
00:000F50D0 658500E4          +58         li      r5, raddle1(2)
  :                            59 down
00:000F50D4 4800000C          +60       b       up
00:000F50D8 4BFFFFFC          +61       b       down
00:000F50DC 48000004          +62       b       up
  :                            63 up
*EOF*
:$(00):000F5000:000F50E0 :$(31):00000000:00000090 
ppcsinga.msm: object code 924 bytes: 0 errors: 0 undefined labels


</pre>
<h2>8.54: $TWOS_COMPLEMENT   Change Negative Value Representation</h2>


<p>
$TWOS_COMPLEMENT defaults to 1 and should never be set to
anything except 1 or 0.
<pre>

	$twos_complement        1

</pre>
<p>
is the default, and causes integers to generate with twos 
complement representation via twos complement calculation.
<pre>

	$twos_complement        0

</pre>
<p>
causes integers to generate with ones complement representation.
Computation of ones complement expressions uses end-around-carry.
Negative values are reached by simple bit inversion (instead
of inversion + 1 as twos complement).

<p>
$TWOS_COMPLEMENT only affects assembler output (constants and
instructions), not anything which directs the assembler's
actions, such as $DO counts. For example,
<pre>

	$WORD   32
	.
	.
	$DO     2+0FFFFFFFF

</pre>
<p>
will always cause one iteration. $IF and $ELSEIF use twos
complement arithmetic if it has been selected, but expressions
containing comparisons = # < > will find negative zero
less than zero nevertheless.
<pre>

MASMX/24592 1r1X
compo.msm 5
*EOF*  :                        1:         $word   32
  :                        2: all1s   $equ    0ffffffffffffffffffffffffffffffffffffffffffffffff        
  :                        3:         $twos_complement        0
00:00000000 00000010      +4         -8*(-2)
00:00000001 FFFFFFFF      +5         -0
00:00000002 FFFFFFEF      +6         -8*2
00:00000003 FFFFEFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
			 +7         -16*/168
  :                        8:         $if     all1s<0
00:00000009 00000001      +9         +       1+all1s:s
  :                        10:         $endif
  :                        11:         $twos_complement        1
00:0000000A 00000010      +12         -8*(-2)
00:0000000B 00000000      +13         -0
00:0000000C FFFFFFF0      +14         -8*2
00:0000000D FFFFF0000000000000000000000000000000000000000000
			 +15         -16*/168
  :                        16:         $if     all1s<0
00:00000013 00000000      +17         +       1+all1s:s
  :                        18:         $endif
*EOF*:$(00):00000000:00000014 
Object Code 221 Bytes: 0 Errors: 0 Undefined Labels


</pre>

<h2>8.55: $WORD              Set the Size of a Target Computer Word</h2>

<p>
Directive
<pre>

	$WORD	size

</pre>
<p>
sets bit multiple in which code is generated

<p>
A source line which generates any code at all generates an integral 
number of words. 

<p>
The word size may not be less than the size of the 
smallest instruction in the target instruction set.
 
<p>
A machine may have 32- (or even 64-) bit addressing and computation.

<p>
If nevertheless the machine can fetch instructions from an
odd octet address, or has single-byte instructions, 
then word size has to be 8. A machine like that would have
parameters like
<pre>

	$word   8
	$byte   8
	$quantum 8
	$awidth 32

</pre>
<p>
It does not follow that integers need to be 8 bits.

<p>
Code for machines like this usually has command names for generating
numbers, and these commands can be reproduced as macros:
<pre>


MASMX/24592 1r1X
dl.msm 5
*EOF*  :                        1:         $word   8
  :                        2:         $awidth 32
  :                        3:         
  :                        4: dl      $proc
  :                        5: x       $do     dl(1)
  :                        6: v       $set    dl(1, x)
  :                        7:         +       v, v/*8, v/*16, v/*24:q
  :                        8:         $endo
  :                        9:         $end
  :                        10: 
00:00000000 010000AA      +11         dl      0AA000001, 0BB000002, 0CC000003 
00:00000004 020000BB      +11 
00:00000008 030000CC      +11 
*EOF*:$(00):00000000:0000000C 
Object Code 75 Bytes: 0 Errors: 0 Undefined Labels


</pre>
<p>
$AWIDTH and $QUANTUM must be set after $WORD unless they are the same
as $WORD. A suitable parameter set for M68K is
<pre>

	$word   16
	$awidth 32
	$quantum 8

</pre>
<p>
because 68000 do not have instructions less than 16 bits in size
or fetch them from odd boundaries.

<p>
A suitable parameter set for PowerPC is
<pre>

	$word   32
	$quantum 8

</pre>
<p>
A suitable parameter set for 8-bit microcontrollers is
<pre>

	$word   8
	$awidth 16



</pre>
<h1>9: Output File Formats, Relocation, Linking, Giant Address Spaces
   Interfacing with GNU Tools</h1>


<h2>9.1: Text Encoded Binary Format, S-Records and Intel Hex Records</h2>

<p>
<i>See also <b>8.28: $LIST 0, masking names from list and export</b></i>

<p>
masmx output is in Text Encoded Binary Output format.

<p>
This assembly produces absolute .txo code:
<pre>


  :                            27 generate* $proc *
  :                            28 Sample:
  :                            29         jb      $bit(FULL.device),leave ; Is there any buffer space?
  :                            30         mov     dptr,#uart(device).lsr  ; Is there data on COM1 input FIFO?
  :                            31         movx    a,@dptr
  :                            32         jnb     $bit(acc.LSR_RDR), Leave; No more so Next UART
  :                            33         mov     dptr,#uart(device).rhr  ; Yes
  :                            34         movx    a,@dptr                 ; Read
  :                            35         mov     dptr,#buffer(device)    ; Find Place in Circular Input Buffer
  :                            36         mov     dpl,write_cursor(device); By Means of the Running Cursor
  :                            37         movx    @dptr,a                 ; Write the Data to XRAM
  :                            38         inc     write_cursor(device)    ; Advance the Input Cursor
  :                            39         mov     a,read_cursor(device)   ; If write starts to equal read
  :                            40         cjne    a,write_cursor(device),Sample ; Is there any more? 
  :                            41         setB    $bit(FULL.device)       ; Stop reading from FIFO to XRAM
  :                            42 leave:       
  :                            43         $end
  :                            44 
  :                            45 
  :                            46 DEVICES equ     128
  :                            47 DATA    equ     1024
  :                            48 TOTAL   equ     4
  :                            49 RTVARS  equ     64
  :                            50 Full    equ     32
  :                            51 
  :                            52 $(3:RTVARS)
  :                            53 device  $do     TOTAL,write_cursor(device)      $res    1
  :                            54 device  $do     TOTAL,read_cursor(device)       $res    1
  :                            55 $(2:DEVICES)
  :                            56 device  $do     TOTAL,uart(device)              serial
  :                            57 $(1:DATA)
  :                            58 device  $do     TOTAL,buffer(device)            VAR    256
  :                            59 
  :                            60 
  :                            61 $(0:64)
00:0040 20011B                +62 device        $do     TOTAL,  generate
00:0043 900085                +62 
00:0046 E0                    +62 
00:0047 30E014                +62 
00:004A 900080                +62 
00:004D E0                    +62 
00:004E 900400                +62 
00:0051 854082                +62 
00:0054 F0                    +62 
00:0055 0540                  +62 
00:0057 E544                  +62 
00:0059 B540E4                +62 
00:005C D201                  +62 
00:005E 20021B                +62 
00:0061 900095                +62 
00:0064 E0                    +62 
00:0065 30E014                +62 
00:0068 900090                +62 
00:006B E0                    +62 
00:006C 900500                +62 
00:006F 854182                +62 
00:0072 F0                    +62 
00:0073 0541                  +62 
00:0075 E545                  +62 
00:0077 B541E4                +62 
00:007A D202                  +62 
00:007C 20031B                +62 
00:007F 9000A5                +62 
00:0082 E0                    +62 
00:0083 30E014                +62 
00:0086 9000A0                +62 
00:0089 E0                    +62 
00:008A 900600                +62 
00:008D 854282                +62 
00:0090 F0                    +62 
00:0091 0542                  +62 
00:0093 E546                  +62 
00:0095 B542E4                +62 
00:0098 D203                  +62 
00:009A 20041B                +62 
00:009D 9000B5                +62 
00:00A0 E0                    +62 
00:00A1 30E014                +62 
00:00A4 9000B0                +62 
00:00A7 E0                    +62 
00:00A8 900700                +62 
00:00AB 854382                +62 
00:00AE F0                    +62 
00:00AF 0543                  +62 
00:00B1 E547                  +62 
00:00B3 B543E4                +62 
00:00B6 D204                  +62 
  :                            63 
*EOF*
:$(00):0000:00B8 :$(01):0400:0800 :$(02):0080:00B8 :$(03):0040:0048 
uart.msm: object code 381 bytes: 0 errors: 0 undefined labels

</pre>
<p>
The output code is represented in text.
It can be viewed in a text editor or a shell.

<p>
This is the output of
<pre>


PROMPT\>masmx uart uart -l

</pre>
<p>
Text Encoded Binary format represents code with hexadecimal symbols.
<pre>

$00:0040
20011B 900085 E0 30E014 900080 E0 900400 854082 F0 0540 E544
B540E4 D201 20021B 900095 E0 30E014 900090 E0 900500 854182
F0 0541 E545 B541E4 D202 20031B 9000A5 E0 30E014 9000A0 E0
900600 854282 F0 0542 E546 B542E4 D203 20041B 9000B5 E0
30E014 9000B0 E0 900700 854382 F0 0543 E547 B543E4 D204
:$00*0000:0000:00B8
:$01*0000:0400:0800
:$02*0000:0080:00B8
:$03*0000:0040:0048

</pre>
<p>
The first line shows the tag of locator zero and a 16 bit load address
equal to 64.

<p>
The following fields are superwords.

<p>
Superwords are fields representing one or more words of code.

<p>
If there is any address jump or change of location counter,
another location line like the first intervenes.

<p>
Finally there are four lines of summary information.


<p>
Converter utility <b>imx</b> generates Intel load strings from
Text Encoded Binary
<pre>

PROMPT\>imx uart.txo uart.hex

</pre>

<p>
And that produces
<pre>


:2000400020011B900085E030E014900080E0900400854082F00540E544B540E4D201200254
:200060001B900095E030E014900090E0900500854182F00541E545B541E4D20220031B9083
:2000800000A5E030E0149000A0E0900600854282F00542E546B542E4D20320041B9000B532
:1800A000E030E0149000B0E0900700854382F00543E547B543E4D2042D
:00FFFF0101


</pre>
<p>
Code for converting to Motorola S-Records is also assembled to .txo format
first:
<pre>

MASMX 7r2
3/qplain.msm
LTERM=#
CONT_CHAR=|
STERM=.
  :                            1:         $include        "ppc_603.def"
  :                            2 
  :                            3 SEGMENT .equ    511*1024
  :                            4 $(48:SEGMENT,r15)
30:0007FC00 0000000000400000  +5 part1   +       2048*2048d
30:0007FC08 0000000000000064  +6 part2   +       100d
  :                            7 part3   $res    2048*2048-16
  :                            8 
30:0047FC00 0007FC10          +9 	+	.absolute(part3)
  :                            10 
  :                            11 $(0:3*65536)
00:00030000 640F0008          +12 start   oris    r15,, SEGMENT@ha     
00:00030004 39E0FC00          +13         addi    r15, SEGMENT@l 
00:00030008 806F0000          +14         lwz     r3, part1
00:0003000C 808F0008          +15         lwz     r4, part2
00:00030010 80AF0010          +16         lwz     r5, part3
00:00030014 4E800020          +17         blr
  :                            18         $end    start
:$(00):00030000:00030018 :$(30):0007FC00:0047FC04 
qplain.msm: object code 214 bytes: 0 errors: 0 undefined labels


</pre>
PROMPT\>masmx -ld qplain qplain

<p>
Produces qplain.txo

<p>
The <b>-d</b> flag displayed the real addresses in SEGMENT instead of the
displacements.

<p>
qplain.txo contains:
<pre>

$30:0007FC00
0000000000400000 0000000000000064
$30:0047FC00
0007FC10
$00:00030000
640F0008 39E0FC00 806F0000 808F0008 80AF0010 4E800020
>00:00030000

:$00*00000000:00030000:00030018
:$30*00000000:0007FC00:0047FC04
</pre
<ul>
	a counter 48 location line with the address 0007FC00
<pre></pre>
	two two-word number values

<pre></pre>
	a counter 48 location line with the address 0047FC00

<pre></pre>
	an address constant pointing to the 16th byte of locator 48

<pre></pre>
	a counter zero location line with the address 00030000

<pre></pre>
	two instructions which load the address SEGMENT to r15

<pre></pre>
	three instructions which reference SEGMENT with base
	register R15

<pre></pre>
	a return instruction

<pre></pre>
	a transfer address symbol >00:00030000 pointing to the label start

<pre></pre>
	summary information for two absolute addressed segments


</ul>
There is no relocation information in qplain.txo. It goes
to the S-records converter, mmx:
<pre>

PROMPT\>mmx qplain.txo qplain.hex

</pre>
<p>
mmx utility writes S-records in qplain.hex:
<pre>

S00600004844521B
S3150007FC000000000000400000000000000000006443
S3090047FC000007FC10A0
S31900030000640F000839E0FC00806F0000808F000880AF00100E
S309000300144E800020F1
S70500030000F7

</pre>
<p>
A transfer address has to be present if GNU tools objcopy is used
to copy the S-records to binary. objcopy otherwise refuses. Transfer
address is the S7 record.


<h2>9.2: Relocation, Linking, Giant Addresses and Interfacing with GNU Tools</h2>


<h3>9.2.1: Relocation Information in Text Encoded Binary</h3>

<p>
To list the relocation information in a relocatable assembly,
assemble with <b>-nl</b> flags.

<p>
<b>-l</b> is for list, <b>-n</b> for list relocation information:
<pre>

	>masmx -ln zactor

MASMX 7r2
3/zactor.msm
LTERM=#
CONT_CHAR=|
STERM=.
*EOF*
  :                            1 __relocatable $set	1
  :                            2: 	$include	"ppc_603.def"
  :                            3 
  :                            4 	$if	1
  :                            5 $(.data)
03:00000000 00000063          +6 myword	.long		99
  :                            7 	$endif
  :                            8 
  :                            9 $(.text)
  :                            10 zactor*
[+0000:00008000/*10]10
01:00000000 3D200000          +11         lis 9,factor@ha
[+0000]10-
01:00000004 80090000          +12         lwz 0,factor@l(9)
  :                            13 
  :                            14 	$if	1
(+03:00008000/*10)10
01:00000008 3D400000          +15 	lis 10,myword@ha
(+03)10-
01:0000000C 816A0000          +16 	lwz 11,myword@l(10)
  :                            17 	$endif
  :                            18 
[+0001:fffffff0/*02]18*/02+
(-01:fffffff0/*02)18*/02+
01:00000010 4BFFFFF1          +19 	bl	soso
01:00000014 4E800020          +20 	blr
*EOF*
:$(01):00000000:00000018 :$(03):00000000:00000004 
zactor.msm: object code 343 bytes: 0 errors: 2 undefined labels

</pre>
<p>
And the relocation information displayed maps to the relocation
information in the Text Encoded Binary
<pre>

$03:*00000004
$03:00000000
00000063
$01:*00000004
$01:00000000
[0000:00008000/*10]10:3D200000 [0000]10-:80090000 (03:00008000/*10)10:3D400000
(03)10-:816A0000 [0001:FFFFFFF0/*02]18*/02+:(-01:FFFFFFF0/*02)18*/02+:4BFFFFF1
4E800020
+ZACTOR:$01:00000000
-FACTOR:[0000]
-SOSO:[0001]
:$01*00000004:00000000:00000018
:$03*00000004:00000000:00000004

</pre>
<ul>

	counter 3 has a relocation alignment factor 4.
	Definition "ppc_603.def" maps counter 3 to
	ELF section .data

<pre></pre>
	relocatable counter 3 starts with zero offset

<pre></pre>
	a data word contains 99

<pre></pre>
	counter 1 has a relocation alignment factor 4.
	Definition "ppc_603.def" maps counter 1 to
	ELF section .text

<pre></pre>
	relocatable counter 1 starts with zero offset

<pre></pre>
	There is one relocation clause on the first superword:
<ul>
	    [0000:00008000/*10]10:

<pre></pre>
	    [0000:xxxxxxxxxxxx]10: means add the value of the
	    unknown name FACTOR, which is encoded as the index
	    number [0000], to 16 bits of the instruction code 3D200000

<pre></pre>
	    Macro code at assembly adjusted the unrelocated value
	    00000000 with the formula +32768/*16 (macro @ha).

<pre></pre>
	    That is reflected in this linker information: 00008000/*10
	    The rounding addition is because of sign extension on
	    base-displacement references

<pre></pre>
	    This is the operand factor@ha
</ul>
<pre></pre>
	There is one relocation clause on the second superword:
<ul>
	    [0000]10-: means add the value of unknown name FACTOR
	    to 16 bits of instruction code 80090000. The trailing
	    minus means: range checking not required, truncation
	    is expected.

<pre></pre>
	    The addend offset is read out of the instruction
	    code itself. This is operand factor@l
</ul>
<pre></pre>
	There is one relocation clause on the third superword:
<ul>
	    (03:00008000/*10)10:
<pre></pre>
	    (03:xxxxxxxxxxxx)10: means add the segment base of
	    section 3 (.data) to sixteen bits of instruction code 3D400000

<pre></pre>
	    Macro code at assembly adjusted the unrelocated value
	    00000000 (first location in .data) with the formula
	    +32768/*16 (macro @ha).

<pre></pre>
	    That is reflected in this linker information: 00008000/*10
	    The rounding addition is because of sign extension on
	    base-displacement references

<pre></pre>
	    This is the operand myword@ha
</ul>
<pre></pre>
	There is one relocation clause on the fourth superword:
<ul>
	    (03)10-: means add the segment base of section 3 (.data)
	    to 16 bits of instruction code 816A0000. The trailing
	    minus means, do not check range: truncation is expected.
	   
<pre></pre>
	    The addend offset is read out of the instruction
	    code itself. This is operand myword@l
</ul>
<pre></pre>
	There are two relocation clauses on the fifth superword:
<ul>
	    [0001:FFFFFFF0/*02]18*/02+:
<pre></pre>
	    [0001:xxxxxxxxxxxx]18*/02+: means add the value of the
	    unknown name SOSO, encoded as the index number [0001],
	    to the operand address, to be encoded in 24 bits of
	    the instruction 4BFFFFF1 starting 2 bits up.
	     + means range check as signed.

<pre></pre>
	    The additional linker information FFFFFFF0/*02 means
	    take the unrelocated address information from here,
	    not from the instruction, and shift it after relocation.

<pre></pre>
	    This is a relative jump instruction. Macro code at
	    assembly applied the formula TARGET-HERE*/-2

</ul>
<pre></pre>
	    This is the jump to soso. There is a second relocation
	    tuple on this instruction, becauses the jump-from address
	    is also relocatable.
<ul>
	The second relocation tuple is
<pre></pre>
	    (-01:FFFFFFF0/*02)18*/02+
<pre></pre>
	    (-01:xxxxxxxxxxxx)18*/02+ means subtract the segment base
	    of locator 1 (.text) from the operand address 

<pre></pre>
	    the unrelocated part of HERE is known = 00000010

<pre></pre>
	    the unrelocated part of target SOSO is known = 00000000
	    because all the value of SOSO is in its relocated part

<pre></pre>
	    assembly was able to encode 00000000-00000010=FFFFFFF0

<pre></pre>
	    the link must add the relocated part of SOSO and subtract
	    the relocated part of HERE

<pre></pre>
	    the part about shift right and then store in a left
	    shifted field is because the low two address bits
	    are zero and not encoded in the instruction.
<pre></pre>
	    When there is a right shift in a relocatable operand,
	    the additional linker information here shown as
	    FFFFFFF0/*02 is output from assembly, so that the
	    whole address is relocated before shifting.
<pre></pre>
	    All relocation tuples for one field of code are
	    effectively accumulated.

</ul>
<p>
	The return instruction in the sixth superword has no
	relocation clauses.

<pre></pre>
	The label list shows ZACTOR exported, FACTOR and SOSO imported,
	relocatable counter 1 (.text) with aligment factor 4 and
	24 bytes long, relocatable counter 3 (.data) with alignment
	factor 4 and 4 bytes long.

</ul>

<h3>9.2.2:  masmx Linking in Principle</h3>


<p>
Link is a set of masmx features, and a link is an assembly

<p>
Linking begins when a Text Encoded Binary is included
<pre>

	$include,$binary	file[.txo]	$(locator, locator...

</pre>
<p>
The second argument for picking and ordering segments is optional.

<p>
macro $MAP must be declared before any binary includes.
<pre>

	$include		"map_macro.def"

	$include,$binary	file1
	$include,$binary	file2

</pre>
<p>
Files of code for inclusion are Text Encoded Binary. They may be with
or without relocation information.

<p>
The link combines files, and some of the binary includes would contain
relocatable code although not all must:
<pre>

	$include		"map_macro.def"

	$include,$binary	absolute
	$include,$binary	relative1
	$include,$binary	relative2

</pre>
<p>
$INCLUDE,$BINARY sends all the superwords in the Text Encoded Binary files
to the $MAP macro, one line of superwords at a time.

<p>
The $MAP macro is not part of the assembler. Definitions for PowerPC
linking, <b>map_ppc.def</b> and <b>ppc64map.def</b>, are in this package
and have a $MAP macro for PowerPC.

<p>
masmx itself uses the location lines and summary tables. Only the
superwords of code go to $MAP macro.

<p>
$MAP macro uses some or all of these masmx linking features:
<ul>	
	directive	$SET,$BINARY
<pre>
</pre>

	directive	$LOAD,$BITS
<pre>
</pre>

	directive	$PUSHREL
<pre>
</pre>

	directive	$PUSHREL,$LONG_ABSOLUTE
<pre>
</pre>

	directive	$INFO,$OFFSET
<pre>
</pre>

 	directive	$INFO,$RANGE_CHECK
<pre>
</pre>

 	directive	$INFO,$RANGE_CHECK1


</ul>
<p>
The outline use of the directives is
<pre>

code_label	$SET,$BINARY	superword_code_part
		$LOAD,$BITS	code_label

</pre>
<p>
code_label is a user-supplied name. $SET,$BINARY loads the value
of a code superword to code_label and sets the automatic label
$BITS to the number of bits read.

<p>
$LOAD,$BITS writes the new superword in the output Text Encoded Binary,
prefixing any oustanding relocation clauses.
<pre>

parameter_label $PUSHREL	relocation_clause

</pre>
<p>
parameter_label is a user supplied name. $PUSHREL types it as $EQUF
and it contains three or five values for adjusting the code part
of the superword.

<p>
The first of these five values is the relocation value, and is normally
retrieved
<pre>

value	$set	parameter_label

</pre>
<p>
Absolute addresses wider than 32 bits are instead retrieved with different
use of $PUSHREL
<pre>

value	$PUSHREL,$LONG_ABSOLUTE	relocation_clause

</pre>
<p>
$INFO directive
<pre>

	$INFO,$OFFSET	value

</pre>
<p>
adjusts an addend encoding. This is done when the segment root of some
addresses is changed but not yet absolute (cumulative link).

<p>
The affected addresses are exclusively addresses which assembly must encode
separately alongside the instruction code, because they will be manipulated
with a rightward shift after relocation. This allows any overflow from the
truncated part to be included correctly.

<p>
Macro language need not be aware whether the output is relocatable, because
if is safe to order <b>$info,$offset</b> whether relocation information
will be output or not. When no relocation information will be output,
no action takes place.
<pre>

	$INFO,$RANGE_CHECK	value
	$INFO,$RANGE_CHECK1	value

</pre>
<p>
These calls request masmx linker section to range check <b>value</b>
according to the size and signed-or-not character of the relocatable
field represented at the top the of the relocation stack.

<p>
<b>value</b> is the relocated value which macro language will write
to "this" field.

<p>
<b>$range_check1</b> is of higher stringency than <b>$range_check</b>. See
Section 8.26.2, and Section 9.2.3: Link Examples. A $MAP macro using
<b>$range_check</b> maintains (where multiple relocation tuples may drive
a field out of range and then again into range) intermediate results
at 192-bit precision.
<p>
$MAP is the name of a macro from outside the assembler. It is
"user written". There is a working $MAP macro for PowerPC in this
package

<p>
$MAP macro in the supplied definition "map_ppc.def" is of this structure:
<pre>

p	$proc
"$map"*	$name

p	$proc
superword*	$name
clauses	$set	p(1,1:)
"$data"	$set,$binary	p(1,1:clauses)

clause	$do	clauses-1,	relocate	p(1, 1:clause)
	$load,$bits	$data
	$end	. of SUPERWORD

p	$proc
relocate* $name

rel_params $pushrel	p(1,1)

value	$set	rel_params\1

bits    $set    rel_params\2
scale   $set    rel_params\3
offset  $set    rel_params\4
descant $set    rel_params\5

limit   $set    1*/bits
mask    $set    limit-1
unmask  $set    ^(mask*/scale)

	$if	descant<0
field	$set	value+offset
	$info,$range_check1	field
	$info,$offset		field
field	$set	field*/descant
	$else
field	$set	value+(($data/*scale)**mask)
	$info,$range_check1	field
	$endif

"$data"* $set	((field**mask)*/scale)++($data**unmask)

	$end	. of RELOCATE

index	$do	p(),	superword	p(index, 1)
	$end	. of $MAP


</pre>
<p>
$MAP macro is called for each line of Text Encoded Binary which
contains any code superwords.

<p>
The second last line of macro language calls embedded macro
superword once for each superword.

<p>
macro superword
<ul>
	caches the code from the last clause of the superword:
<pre>

	data	$set,$binary	p(1,1:clauses)

</pre>

	calls embedded macro relocate once for each relocation clause:
<pre>

	clause	$do	clauses-1,	relocate	p(1,1:clause)

</pre>

	writes out the code adjusted by relocate macro:
</ul>
<pre>

		$load,$bits	data

</pre>
<p>
macro relocate
<ul>
	updates the code according to the relocation clause,
	with update information tabled by $PUSHREL
<pre>
</pre>

	in some cases adjusts forwarded information for
	further relocation.

</ul>

<h3>9.2.3: Demonstration Links</h3>


<p>
These examples are different kinds of link and their output

<p>
First two small c files, soso.c and factor.c are compiled with
gcc -S
<pre>

$ gcc -S soso.c

	extern int       factor;
	extern int       adjustment(int *where);

	int              clanjamfrie = 55;

	static int       yasimi = 99;
	static int       startfromhere;
	static int      *cu = &startfromhere;

	int soso()
	{
	   static int    separate_static_item = 0xa5a5a5a5;
	   static long long clearly_so;

	   int           x = startfromhere++;

	   x *= factor;
	   x += adjustment(cu);
	   x -= yasimi;
	   return x;
	}

$ gcc -S factor.c

	extern int soso(int *there);

	extern int       clanjamfrie;

	int              factor = 88;

	static int      *acu = &factor;

	int     adjustment()
	{
	   return 33;
	}

	int overcoat()
	{
	   soso(acu);
	}

</pre>
<p>
Then wrapper files are constructed
<pre>

$ cat soso.msm

__relocatable $set	1
	$include	"ppc_603.def"
	$store		soso
	$list		2
	$include	soso.s

$ cat factor.msm

	$list		1
__relocatable $set	1
	$include	"ppc_603.def"
	$list		2
	$store		factor
	$include	factor.s

</pre>
<p>
and the wrapper files are assembled
<pre>

$ masmx soso -ln

MASMX 7r2
3/soso.msm
LTERM=#
CONT_CHAR=|
STERM=.
*EOF*
  :                            1 __relocatable $set	1
  :                            2: 	$include	"ppc_603.def"
  :                            3 	$store		soso
  :                            4 	$list		2
  :                            5: 	$include	soso.s
  :                            1 	.file	"soso.c"
  :                            2 	.globl clanjamfrie
  :                            3 	.section	.sdata,"aw",@progbits
  :                            4 	.align 2
  :                            5 	.type	clanjamfrie, @object
  :                            6 	.size	clanjamfrie, 4
  :                            7 clanjamfrie:
06:00000000 00000037          +8 	.long	55
  :                            9 	.section	".data"
  :                            10 	.align 2
  :                            11 	.type	yasimi, @object
  :                            12 	.size	yasimi, 4
  :                            13 yasimi:
03:00000000 00000063          +14 	.long	99
  :                            15 	.align 2
  :                            16 	.type	cu, @object
  :                            17 	.size	cu, 4
  :                            18 cu:
(+05)20
03:00000004 00000008          +19 	.long	startfromhere
  :                            20 	.lcomm	clearly_so.1543,8,8
  :                            21 	.type	clearly_so.1543, @object
  :                            22 	.align 2
  :                            23 	.type	separate_static_item.1542, @object
  :                            24 	.size	separate_static_item.1542, 4
  :                            25 separate_static_item.1542:
03:00000008 A5A5A5A5          +26 	.long	-1515870811
  :                            27 	.section	".text"
  :                            28 	.align 2
  :                            29 	.globl soso
  :                            30 	.type	soso, @function
  :                            31 soso:
01:00000000 9421FFE0          +32 	stwu 1,-32(1)
01:00000004 7C0802A6          +33 	mflr 0
01:00000008 93E1001C          +34 	stw 31,28(1)
01:0000000C 90010024          +35 	stw 0,36(1)
01:00000010 63E10000          +36 	mr 31,1
(+05:00008008/*10)10
01:00000014 3D200000          +37 	lis 9,startfromhere@ha
(+05)10-
01:00000018 81290008          +38 	lwz 9,startfromhere@l(9)
01:0000001C 913F0008          +39 	stw 9,8(31)
01:00000020 38010009          +40 	addi 0,9,1
(+05:00008008/*10)10
01:00000024 3D200000          +41 	lis 9,startfromhere@ha
(+05)10-
01:00000028 90090008          +42 	stw 0,startfromhere@l(9)
[+0000:00008000/*10]10
01:0000002C 3D200000          +43 	lis 9,factor@ha
[+0000]10-
01:00000030 81290000          +44 	lwz 9,factor@l(9)
01:00000034 801F0008          +45 	lwz 0,8(31)
01:00000038 7C0049D6          +46 	mullw 0,0,9
01:0000003C 901F0008          +47 	stw 0,8(31)
(+03:00008004/*10)10
01:00000040 3D200000          +48 	lis 9,cu@ha
(+03)10-
01:00000044 80090004          +49 	lwz 0,cu@l(9)
01:00000048 60600000          +50 	mr 3,0
[+0001:ffffffb4/*02]18*/02+
(-01:ffffffb4/*02)18*/02+
01:0000004C 4BFFFFB5          +51 	bl adjustment
01:00000050 61230000          +52 	mr 9,3
01:00000054 801F0008          +53 	lwz 0,8(31)
01:00000058 7C004A14          +54 	add 0,0,9
01:0000005C 901F0008          +55 	stw 0,8(31)
(+03:00008000/*10)10
01:00000060 3D200000          +56 	lis 9,yasimi@ha
(+03)10-
01:00000064 81290000          +57 	lwz 9,yasimi@l(9)
01:00000068 801F0008          +58 	lwz 0,8(31)
01:0000006C 7C090050          +59 	subf 0,9,0
01:00000070 901F0008          +60 	stw 0,8(31)
01:00000074 801F0008          +61 	lwz 0,8(31)
01:00000078 60600000          +62 	mr 3,0
01:0000007C 81610000          +63 	lwz 11,0(1)
01:00000080 800B0004          +64 	lwz 0,4(11)
01:00000084 7C0803A6          +65 	mtlr 0
01:00000088 83EBFFFC          +66 	lwz 31,-4(11)
01:0000008C 602B0000          +67 	mr 1,11
01:00000090 4E800020          +68 	blr
  :                            69 	.size	soso, .-soso
  :                            70 	.lcomm	startfromhere,4,4
  :                            71 	.type	startfromhere, @object
  :                            72 	.ident	"GCC: (GNU) 4.2.1"
*EOF*
:$(01):00000000:00000094 :$(03):00000000:0000000C :$(05):00000000:0000000C :$(06):00000000:00000004 
soso.msm: object code 887 bytes: 0 errors: 2 undefined labels

$ cat soso.txo

$06:*00000004
$06:00000000
00000037
$03:*00000004
$03:00000000
00000063
$03:00000004
(05)20:00000008
$03:00000008
A5A5A5A5
$01:*00000004
$01:00000000
9421FFE0 7C0802A6 93E1001C 90010024 63E10000 (05:00008008/*10)10:3D200000
(05)10-:81290008 913F0008 38010009 (05:00008008/*10)10:3D200000
(05)10-:90090008 [0000:00008000/*10]10:3D200000 [0000]10-:81290000
801F0008 7C0049D6 901F0008 (03:00008004/*10)10:3D200000
(03)10-:80090004 60600000 [0001:FFFFFFB4/*02]18*/02+:(-01:FFFFFFB4/*02)18*/02+:4BFFFFB5
61230000 801F0008 7C004A14 901F0008 (03:00008000/*10)10:3D200000
(03)10-:81290000 801F0008 7C090050 901F0008 801F0008 60600000
81610000 800B0004 7C0803A6 83EBFFFC 602B0000 4E800020
+CLANJAMFRIE:$06:00000000
+SOSO:$01:00000000
-ADJUSTMENT:[0001]
-FACTOR:[0000]
:$01*00000004:00000000:00000094
:$03*00000004:00000000:0000000C
:$05*FFFFFFFC:00000000:0000000C
:$06*00000004:00000000:00000004

</pre>
<p>
A number of superwords in the Text Encoded Binary soso.txo have
relocation tuples, some to request fixed addresses for the segments
of soso itself, others to locate external names ADJUSTMENT and FACTOR
<pre>

$ masmx -ln factor

MASMX 7r2
3/factor.msm
LTERM=#
CONT_CHAR=|
STERM=.
*EOF*
  :                            1 	$list		1
  :                            2 __relocatable $set	1
  :                            3: 	$include	"ppc_603.def"
  :                            4 	$list		2
  :                            5 	$store		factor
  :                            6: 	$include	factor.s
  :                            1 	.file	"factor.c"
  :                            2 	.globl factor
  :                            3 	.section	.sdata,"aw",@progbits
  :                            4 	.align 2
  :                            5 	.type	factor, @object
  :                            6 	.size	factor, 4
  :                            7 factor:
06:00000000 00000058          +8 	.long	88
  :                            9 	.section	".data"
  :                            10 	.align 2
  :                            11 	.type	acu, @object
  :                            12 	.size	acu, 4
  :                            13 acu:
(+06)20
03:00000000 00000000          +14 	.long	factor
  :                            15 	.section	".text"
  :                            16 	.align 2
  :                            17 	.globl adjustment
  :                            18 	.type	adjustment, @function
  :                            19 adjustment:
01:00000000 9421FFF0          +20 	stwu 1,-16(1)
01:00000004 93E1000C          +21 	stw 31,12(1)
01:00000008 63E10000          +22 	mr 31,1
01:0000000C 64000021          +23 	li 0,33
01:00000010 60600000          +24 	mr 3,0
01:00000014 81610000          +25 	lwz 11,0(1)
01:00000018 83EBFFFC          +26 	lwz 31,-4(11)
01:0000001C 602B0000          +27 	mr 1,11
01:00000020 4E800020          +28 	blr
  :                            29 	.size	adjustment, .-adjustment
  :                            30 	.align 2
  :                            31 	.globl overcoat
  :                            32 	.type	overcoat, @function
  :                            33 overcoat:
01:00000024 9421FFF0          +34 	stwu 1,-16(1)
01:00000028 7C0802A6          +35 	mflr 0
01:0000002C 93E1000C          +36 	stw 31,12(1)
01:00000030 90010014          +37 	stw 0,20(1)
01:00000034 63E10000          +38 	mr 31,1
(+03:00008000/*10)10
01:00000038 3D200000          +39 	lis 9,acu@ha
(+03)10-
01:0000003C 80090000          +40 	lwz 0,acu@l(9)
01:00000040 60600000          +41 	mr 3,0
[+0000:ffffffbc/*02]18*/02+
(-01:ffffffbc/*02)18*/02+
01:00000044 4BFFFFBD          +42 	bl soso
01:00000048 81610000          +43 	lwz 11,0(1)
01:0000004C 800B0004          +44 	lwz 0,4(11)
01:00000050 7C0803A6          +45 	mtlr 0
01:00000054 83EBFFFC          +46 	lwz 31,-4(11)
01:00000058 602B0000          +47 	mr 1,11
01:0000005C 4E800020          +48 	blr
  :                            49 	.size	overcoat, .-overcoat
  :                            50 	.ident	"GCC: (GNU) 4.2.1"
*EOF*
:$(01):00000000:00000060 :$(03):00000000:00000004 :$(06):00000000:00000004 
factor.msm: object code 594 bytes: 0 errors: 1 undefined labels

$ cat factor.txo

$06:*00000004
$06:00000000
00000058
$03:*00000004
$03:00000000
(06)20:00000000
$01:*00000004
$01:00000000
9421FFF0 93E1000C 63E10000 64000021 60600000 81610000
83EBFFFC 602B0000 4E800020
$01:00000024
9421FFF0 7C0802A6 93E1000C 90010014 63E10000 (03:00008000/*10)10:3D200000
(03)10-:80090000 60600000 [0000:FFFFFFBC/*02]18*/02+:(-01:FFFFFFBC/*02)18*/02+:4BFFFFBD
81610000 800B0004 7C0803A6 83EBFFFC 602B0000 4E800020
+ADJUSTMENT:$01:00000000
+FACTOR:$06:00000000
+OVERCOAT:$01:00000024
-SOSO:[0000]
:$01*00000004:00000000:00000060
:$03*00000004:00000000:00000004
:$06*00000004:00000000:00000004

</pre>
<p>
The call to soso is relative, so the unrelocated address is
"unknown" minus hex 00000044 = FFFFFFBC


<h4>9.2.3.1: The Simplest Link</h4>


<p>
The first link is the simplest kind. An absolute start address is
given, and all segments are placed in the order they were found.

<p>
The first link pass arranges the placement of segments
<pre>

$ masmx map1 -l

MASMX 7r2
3/map1.msm
soso.txo:$(1) 148 bytes decimal from hexadecimal 000A0000 to 000A0094
soso.txo:$(3) 12 bytes decimal from hexadecimal 000A0094 to 000A00A0
soso.txo:$(5) 12 bytes decimal from hexadecimal 000A00A0 to 000A00AC
soso.txo:$(6) 4 bytes decimal from hexadecimal 000A00AC to 000A00B0
factor.txo:$(1) 96 bytes decimal from hexadecimal 000A00B0 to 000A0110
factor.txo:$(3) 4 bytes decimal from hexadecimal 000A0110 to 000A0114
factor.txo:$(6) 4 bytes decimal from hexadecimal 000A0114 to 000A0118
*EOF*
  :                            1: 	$include	"map_ppc.def"
  :                            2 $(0:000A0000)
  :                            3 	$plist			7
  :                            4: 	$include,$binary	soso
  :                            5: 	$include,$binary	factor
  :                            6 
  :                            7 	$store			image1
*EOF*
:$(00):000A0000:000A0000 :$(01):000A0000:000A0110 :$(03):000A0094:000A0114 :$(05):000A00A0:000A00AC :$(06):000A00AC:000A0118 
map1.msm: object code 994 bytes: 0 errors: 0 undefined labels

$ cat image1.txo

$06:000A00AC
00000037
$03:000A0094
00000063
$03:000A0098
000A00A8
$03:000A009C
A5A5A5A5
$01:000A0000
9421FFE0 7C0802A6 93E1001C 90010024 63E10000 3D20000A
812900A8 913F0008 38010009 3D20000A 900900A8 3D20000A
81290114 801F0008 7C0049D6 901F0008 3D20000A 80090098
60600000 48000065 61230000 801F0008 7C004A14 901F0008
3D20000A 81290094 801F0008 7C090050 901F0008 801F0008
60600000 81610000 800B0004 7C0803A6 83EBFFFC 602B0000
4E800020
$06:000A0114
00000058
$03:000A0110
000A0114
$01:000A00B0
9421FFF0 93E1000C 63E10000 64000021 60600000 81610000
83EBFFFC 602B0000 4E800020
$01:000A00D4
9421FFF0 7C0802A6 93E1000C 90010014 63E10000 3D20000A
80090110 60600000 4BFFFF0D 81610000 800B0004 7C0803A6
83EBFFFC 602B0000 4E800020
+ADJUSTMENT:$01:000A00B0
+CLANJAMFRIE:$06:000A00AC
+FACTOR:$06:000A0114
+OVERCOAT:$01:000A00D4
+SOSO:$01:000A0000
:$00*00000000:000A0000:000A0000
:$01*00000000:000A0000:000A0110
:$03*00000000:000A0094:000A0114
:$05*00000000:000A00A0:000A00AC
:$06*00000000:000A00AC:000A0118


</pre>
<h4>9.2.3.2: Link Collected by Section</h4>


<p>
The second link uses <b>-b</b> option, which collects the segments by section.

<p>
A start address has to be given for each section.

<p>
Definition "ppc_603.def" maps these counters to ELF sections:
<pre>

	$(1)	.text
	$(3)	.data
	$(5)	.bss
	$(6)	.sdata
	$(11)	.rodata

$ masmx map2 -l

MASMX 7r2
3/map2.msm
soso.txo:$(1) 148 bytes decimal from hexadecimal 000A0000 to 000A0094
soso.txo:$(3) 12 bytes decimal from hexadecimal 000B0000 to 000B000C
soso.txo:$(5) 12 bytes decimal from hexadecimal 000B8000 to 000B800C
soso.txo:$(6) 4 bytes decimal from hexadecimal 000C0000 to 000C0004
factor.txo:$(1) 96 bytes decimal from hexadecimal 000A0094 to 000A00F4
factor.txo:$(3) 4 bytes decimal from hexadecimal 000B000C to 000B0010
factor.txo:$(6) 4 bytes decimal from hexadecimal 000C0004 to 000C0008
*EOF*
  :                            1:       $include        "map_ppc.def"
  :                            2        $set_option     "b"
  :                            3 $(1:000A0000)
  :                            4 $(3:000B0000)
  :                            5 $(5:000B8000)
  :                            6 $(6:000C0000)
  :                            7:       $include,$binary        soso
  :                            8:       $include,$binary        factor
  :                            9 
  :                            10       $store                  image2
*EOF*
:$(01):000A0000:000A00F4 :$(03):000B0000:000B0010 :$(05):000B8000:000B800C :$(06):000C0000:000C0008 
map2.msm: object code 962 bytes: 0 errors: 0 undefined labels


</pre>

<h4>9.2.3.3: Link Specific Segments</h4>


<p>
The third link picks the segments individually, in case none of the
automatic order methods is adequate:
<pre>

$ masmx map3 -l

MASMX 7r2
3/map3.msm
soso.txo:$(1) 148 bytes decimal from hexadecimal 000A0000 to 000A0094
factor.txo:$(1) 96 bytes decimal from hexadecimal 000A0094 to 000A00F4
soso.txo:$(3) 12 bytes decimal from hexadecimal 000A00F4 to 000A0100
factor.txo:$(3) 4 bytes decimal from hexadecimal 000A0100 to 000A0104
soso.txo:$(5) 12 bytes decimal from hexadecimal 000C0000 to 000C000C
soso.txo:$(6) 4 bytes decimal from hexadecimal 000C000C to 000C0010
factor.txo:$(6) 4 bytes decimal from hexadecimal 000C0010 to 000C0014
*EOF*
  :                            1:       $include        "map_ppc.def"
  :                            2 
  :                            3 text   $equ    1
  :                            4 data   $equ    3
  :                            5 bss    $equ    5
  :                            6 sdata  $equ    6
  :                            7 
  :                            8 $(1:000A0000)
  :                            9:       $include,$binary   soso    $(text)
  :                            10:      $include,$binary   factor  $(text)
  :                            11:      $include,$binary   soso    $(data)
  :                            12:      $include,$binary   factor  $(data)
  :                            13 
  :                            14 $(0:000C0000)
  :                            15:     $include,$binary soso  $(bss, sdata)
  :                            16:     $include,$binary factor $(bss,sdata)
  :                            17 
  :                            18       $store                  image3
*EOF*
:$(00):000C0000:000C0000 :$(01):000A0000:000A00F4 :$(03):000A00F4:000A0104 :$(05):000C0000:000C000C :$(06):000C000C:000C0014 
map3.msm: object code 994 bytes: 0 errors: 0 undefined labels


</pre>
<h4>9.2.3.4: Link an Output Relocatable</h4>


<p>
The fourth link is cumulative. The output is relocatable. The input
segments combine by section. Relocatable output is switched with the
relocatable location counter control <b>$(0:*4)</b>. The segment alignment
value <b>*4</b> indicates relocatable code.
<pre>

$ masmx map4 -ln

MASMX 7r2
3/map4.msm
soso.txo:$(1) 148 bytes decimal [*4] from hexadecimal 00000000 to 00000094
soso.txo:$(3) 12 bytes decimal [*4] from hexadecimal 00000000 to 0000000C
soso.txo:$(5) 12 bytes decimal [*-4] from hexadecimal 00000000 to 0000000C
soso.txo:$(6) 4 bytes decimal [*4] from hexadecimal 00000000 to 00000004
factor.txo:$(1) 96 bytes decimal [*4] from hexadecimal 00000094 to 000000F4
factor.txo:$(3) 4 bytes decimal [*4] from hexadecimal 0000000C to 00000010
factor.txo:$(6) 4 bytes decimal [*4] from hexadecimal 00000004 to 00000008
*EOF*
  :                            1: 	$include	"map_ppc.def"
  :                            2 $(0:*4)
  :                            3 	$list			2
  :                            4: 	$include,$binary	soso
06:00000000 00000037          +4 00000037
03:00000000 00000063          +7 00000063
(+05)20
03:00000004 00000008          +9 (05)20:00000008
03:00000008 A5A5A5A5          +11 A5A5A5A5
01:00000000 9421FFE0          +14 9421FFE0 7C0802A6 93E1001C 90010024 63E10000 (05:00008008/*10)10:3D200000
01:00000004 7C0802A6          +14 
01:00000008 93E1001C          +14 
01:0000000C 90010024          +14 
01:00000010 63E10000          +14 
(+05:00008008/*10)10
01:00000014 3D200000          +14 
(+05)10-
01:00000018 81290008          +15 (05)10-:81290008 913F0008 38010009 (05:00008008/*10)10:3D200000
01:0000001C 913F0008          +15 
01:00000020 38010009          +15 
(+05:00008008/*10)10
01:00000024 3D200000          +15 
(+05)10-
01:00000028 90090008          +16 (05)10-:90090008 [0000:00008000/*10]10:3D200000 [0000]10-:81290000
(+06:00008004/*10)10
01:0000002C 3D200000          +16 
(+06)10-
01:00000030 81290004          +16 
01:00000034 801F0008          +17 801F0008 7C0049D6 901F0008 (03:00008004/*10)10:3D200000
01:00000038 7C0049D6          +17 
01:0000003C 901F0008          +17 
(+03:00008004/*10)10
01:00000040 3D200000          +17 
(+03)10-
01:00000044 80090004          +18 (03)10-:80090004 60600000 [0001:FFFFFFB4/*02]18*/02+:(-01:FFFFFFB4/*02)18*/02+:4BFFFFB5
01:00000048 60600000          +18 
(-01:00000048/*02)18*/02+
(+01:00000048/*02)18*/02+
01:0000004C 48000049          +18 
01:00000050 61230000          +19 61230000 801F0008 7C004A14 901F0008 (03:00008000/*10)10:3D200000
01:00000054 801F0008          +19 
01:00000058 7C004A14          +19 
01:0000005C 901F0008          +19 
(+03:00008000/*10)10
01:00000060 3D200000          +19 
(+03)10-
01:00000064 81290000          +20 (03)10-:81290000 801F0008 7C090050 901F0008 801F0008 60600000
01:00000068 801F0008          +20 
01:0000006C 7C090050          +20 
01:00000070 901F0008          +20 
01:00000074 801F0008          +20 
01:00000078 60600000          +20 
01:0000007C 81610000          +21 81610000 800B0004 7C0803A6 83EBFFFC 602B0000 4E800020
01:00000080 800B0004          +21 
01:00000084 7C0803A6          +21 
01:00000088 83EBFFFC          +21 
01:0000008C 602B0000          +21 
01:00000090 4E800020          +21 
  :                            5: 	$include,$binary	factor
06:00000004 00000058          +4 00000058
(+06)20
03:0000000C 00000004          +7 (06)20:00000000
01:00000094 9421FFF0          +10 9421FFF0 93E1000C 63E10000 64000021 60600000 81610000
01:00000098 93E1000C          +10 
01:0000009C 63E10000          +10 
01:000000A0 64000021          +10 
01:000000A4 60600000          +10 
01:000000A8 81610000          +10 
01:000000AC 83EBFFFC          +11 83EBFFFC 602B0000 4E800020
01:000000B0 602B0000          +11 
01:000000B4 4E800020          +11 
01:000000B8 9421FFF0          +13 9421FFF0 7C0802A6 93E1000C 90010014 63E10000 (03:00008000/*10)10:3D200000
01:000000BC 7C0802A6          +13 
01:000000C0 93E1000C          +13 
01:000000C4 90010014          +13 
01:000000C8 63E10000          +13 
(+03:0000800c/*10)10
01:000000CC 3D200000          +13 
(+03)10-
01:000000D0 8009000C          +14 (03)10-:80090000 60600000 [0000:FFFFFFBC/*02]18*/02+:(-01:FFFFFFBC/*02)18*/02+:4BFFFFBD
01:000000D4 60600000          +14 
(-01:ffffff28/*02)18*/02+
(+01:ffffff28/*02)18*/02+
01:000000D8 4BFFFF29          +14 
01:000000DC 81610000          +15 81610000 800B0004 7C0803A6 83EBFFFC 602B0000 4E800020
01:000000E0 800B0004          +15 
01:000000E4 7C0803A6          +15 
01:000000E8 83EBFFFC          +15 
01:000000EC 602B0000          +15 
01:000000F0 4E800020          +15 
  :                            6 
  :                            7 	$store			rel4
*EOF*
:$(01):00000000:000000F4 :$(03):00000000:00000010 :$(05):00000000:0000000C :$(06):00000000:00000008 
map4.msm: object code 1246 bytes: 0 errors: 0 undefined labels

$ cat rel4.txo

$06:00000000
00000037
$03:00000000
00000063
$03:00000004
(05)20:00000008
$03:00000008
A5A5A5A5
$01:00000000
9421FFE0 7C0802A6 93E1001C 90010024 63E10000 (05:00008008/*10)10:3D200000
(05)10-:81290008 913F0008 38010009 (05:00008008/*10)10:3D200000
(05)10-:90090008 (06:00008004/*10)10:3D200000 (06)10-:81290004
801F0008 7C0049D6 901F0008 (03:00008004/*10)10:3D200000
(03)10-:80090004 60600000 (-01:00000048/*02)18*/02+:(01:00000048/*02)18*/02+:48000049
61230000 801F0008 7C004A14 901F0008 (03:00008000/*10)10:3D200000
(03)10-:81290000 801F0008 7C090050 901F0008 801F0008 60600000
81610000 800B0004 7C0803A6 83EBFFFC 602B0000 4E800020
$06:00000004
00000058
$03:0000000C
(06)20:00000004
$01:00000094
9421FFF0 93E1000C 63E10000 64000021 60600000 81610000
83EBFFFC 602B0000 4E800020
$01:000000B8
9421FFF0 7C0802A6 93E1000C 90010014 63E10000 (03:0000800C/*10)10:3D200000
(03)10-:8009000C 60600000 (-01:FFFFFF28/*02)18*/02+:(01:FFFFFF28/*02)18*/02+:4BFFFF29
81610000 800B0004 7C0803A6 83EBFFFC 602B0000 4E800020
+ADJUSTMENT:$01:00000094
+CLANJAMFRIE:$06:00000000
+FACTOR:$06:00000004
+OVERCOAT:$01:000000B8
+SOSO:$01:00000000
:$01*00000004:00000000:000000F4
:$03*00000004:00000000:00000010
:$05*FFFFFFFC:00000000:0000000C
:$06*00000004:00000000:00000008

</pre>
<p>
If this link is repeated with <b>-j</b> flag, the treatment of external
references is different but the final effect the same:
<pre>

$ ../masmx map4 -lj

MASMX 7r2
3/map4.msm
soso.txo:$(1) 148 bytes decimal [*4] from hexadecimal 00000000 to 00000094
soso.txo:$(3) 12 bytes decimal [*4] from hexadecimal 00000000 to 0000000C
soso.txo:$(5) 12 bytes decimal [*-4] from hexadecimal 00000000 to 0000000C
soso.txo:$(6) 4 bytes decimal [*4] from hexadecimal 00000000 to 00000004
factor.txo:$(1) 96 bytes decimal [*4] from hexadecimal 00000094 to 000000F4
factor.txo:$(3) 4 bytes decimal [*4] from hexadecimal 0000000C to 00000010
factor.txo:$(6) 4 bytes decimal [*4] from hexadecimal 00000004 to 00000008
*EOF*
  :                            1: 	$include	"map_ppc.def"
  :                            2 $(0:*4)
  :                            3 	$list			1
  :                            4: 	$include,$binary	soso
  :                            5: 	$include,$binary	factor
  :                            6 
  :                            7 	$store			rel4
*EOF*
SOSO awaiting absolute part
ADJUSTMENT awaiting absolute part
FACTOR awaiting absolute part
:$(01):00000000:000000F4 :$(03):00000000:00000010 :$(05):00000000:0000000C :$(06):00000000:00000008 
map4.msm: object code 1301 bytes: 0 errors: 0 undefined labels

$ cat rel4.txo

$06:00000000
00000037
$03:00000000
00000063
$03:00000004
(05)20:00000008
$03:00000008
A5A5A5A5
$01:00000000
9421FFE0 7C0802A6 93E1001C 90010024 63E10000 (05:00008008/*10)10:3D200000
(05)10-:81290008 913F0008 38010009 (05:00008008/*10)10:3D200000
(05)10-:90090008 [03FF:00008000/*10]10:3D200000 [03FF]10-:81290000
801F0008 7C0049D6 901F0008 (03:00008004/*10)10:3D200000
(03)10-:80090004 60600000 (-01:FFFFFFB4/*02)18*/02+:[03FE:FFFFFFB4/*02]18*/02+:4BFFFFB5
61230000 801F0008 7C004A14 901F0008 (03:00008000/*10)10:3D200000
(03)10-:81290000 801F0008 7C090050 901F0008 801F0008 60600000
81610000 800B0004 7C0803A6 83EBFFFC 602B0000 4E800020
$06:00000004
00000058
$03:0000000C
(06)20:00000004
$01:00000094
9421FFF0 93E1000C 63E10000 64000021 60600000 81610000
83EBFFFC 602B0000 4E800020
$01:000000B8
9421FFF0 7C0802A6 93E1000C 90010014 63E10000 (03:0000800C/*10)10:3D200000
(03)10-:8009000C 60600000 (-01:FFFFFF28/*02)18*/02+:[03FD:FFFFFF28/*02]18*/02+:4BFFFF29
81610000 800B0004 7C0803A6 83EBFFFC 602B0000 4E800020
+ADJUSTMENT:$01:00000094
+CLANJAMFRIE:$06:00000000
+FACTOR:$06:00000004
+OVERCOAT:$01:000000B8
+SOSO:$01:00000000
-SOSO:[03FD]
-ADJUSTMENT:[03FE]
-FACTOR:[03FF]
:$01*00000004:00000000:000000F4
:$03*00000004:00000000:00000010
:$05*FFFFFFFC:00000000:0000000C
:$06*00000004:00000000:00000008

</pre>
<p>
With <b>-j</b> option, external names which are found but are still
relocatable are requested again later.

<p>
Without <b>-j</b> option the request for an external name is changed into
a request relating to a location counter if the imported name is still
relocatable.

<p>
Because the cumulative link has moved the .text (counter 1) segment of
factor.txo from relocatable 00000000 to relocatable 00000094 hex,
the relative jump from function overcoat in factor.c to 
function soso in soso.c has changed from "unknown" minus 00000044 to
"unknown" minus 000000D8, or FFFFFF28

<p>
The adjusted offset addend in FFFFFF28 is placed in the relocation
stack by macro language in $MAP macro with the $INFO,$OFFSET directive.

<p>
This step is necessary when three circumstances combine:
<ul>

	the offset is extracted and marked up for shift
	right after relocation, as <b>(rel:offset/*shift)</b>
	or <b>[name:offset/*shift]</b>
<pre>
</pre>

	A segment base address used in the field value
	has moved as a result of relocation
<pre>
</pre>
	target is not yet absolute and the relocation clause will
	be forwarded in the output Text Encoded Binary

</ul>
<p>
Without the <b>-j</b> option, the "unknown" is instead relocatable 00000000,
which is arithmetically identical, because function soso is at the start.

<p>
So without the <b>-j</b> option, jump root and target are on output in the
same segment. The same segment base will be added and subtracted at the next
link.

<p>
Relative jumps within one segment at source time don't cause any
relocation. masmx suppresses relocation information in
<b>location_X-location_Y</b>

if <b>location_X</b> and <b>location_Y</b> are in the same segment.


<h4>9.2.3.5: Link an Accumulated Relocatable plus a New Relocatable</h4>


<p>
The fifth link adds relocatable zactor.txo to the relocatable link
output of the fourth link. The output is absolute.

<p>
<b>-b</b> option and section start addresses cause the segments to be
collected by section:
<pre>

$ masmx map5 -l

MASMX 7r2
3/map5.msm
rel4.txo:$(1) 244 bytes decimal from hexadecimal 000A0000 to 000A00F4
rel4.txo:$(3) 16 bytes decimal from hexadecimal 000B0000 to 000B0010
rel4.txo:$(5) 12 bytes decimal from hexadecimal 000B8000 to 000B800C
rel4.txo:$(6) 8 bytes decimal from hexadecimal 000C0000 to 000C0008
zactor.txo:$(1) 24 bytes decimal from hexadecimal 000A00F4 to 000A010C
zactor.txo:$(3) 4 bytes decimal from hexadecimal 000B0010 to 000B0014
*EOF*
  :                            1:       $include        "map_ppc.def"
  :                            2        $set_option     "b"
  :                            3 $(1:000A0000)
  :                            4 $(3:000B0000)
  :                            5 $(5:000B8000)
  :                            6 $(6:000C0000)
  :                            7:       $include,$binary        rel4
  :                            8:       $include,$binary        zactor
  :                            9 
  :                            10       $store                  image5
*EOF*
:$(01):000A0000:000A010C :$(03):000B0000:000B0014 :$(05):000B8000:000B800C :$(06):000C0000:000C0008 
map5.msm: object code 1072 bytes: 0 errors: 0 undefined labels


</pre>
<h4>9.2.3.6: The Incremental Link</h4>


<p>
The sixth link adds relocatable zactor.txo as an increment to an absolute.
The absolute is the earlier (2nd) -b option link of soso.txo and factor.txo

<p>
The output is identical with the link just above.
<pre>

$ ../masmx map6 -l

MASMX 7r2
3/map6.msm
image2.txo:$(1) 244 bytes decimal from hexadecimal 000A0000 to 000A00F4
image2.txo:$(3) 16 bytes decimal from hexadecimal 000B0000 to 000B0010
image2.txo:$(5) 12 bytes decimal from hexadecimal 000B8000 to 000B800C
image2.txo:$(6) 8 bytes decimal from hexadecimal 000C0000 to 000C0008
zactor.txo:$(1) 24 bytes decimal from hexadecimal 000A00F4 to 000A010C
zactor.txo:$(3) 4 bytes decimal from hexadecimal 000B0010 to 000B0014
*EOF*
  :                            1:       $include        "map_ppc.def"
  :                            2 
  :                            3        $set_option     "b"
  :                            4 
  :                            5:       $include,$binary        image2
  :                            6:       $include,$binary        zactor
  :                            7 
  :                            8        $store                  image6
*EOF*
:$(01):000A0000:000A010C :$(03):000B0000:000B0014 :$(05):000B8000:000B800C :$(06):000C0000:000C0008 
map6.msm: object code 1072 bytes: 0 errors: 0 undefined labels

$ diff -w image5.txo image6.txo

$ 

</pre>
<h4>9.2.3.7: The Link into Giant Address Space</h4>


<p>
In order to have control over code architecture in the 64-bit environment,
the next illustrations are a departure from compiler output.

<p>
In order to see all over the large address space, the entry sequence
to external-visible routines bases a literal pool, which contains
64-bit pointers to 64K parts of storage.

<p>
It would be possible to base the assembly's own static along with its
literal pool, if  components like zero-initial static, nonzero
initial static and public data were placed in one section.

<pre>

MASMX 7r2
3/gsoso.msm
LTERM=#
CONT_CHAR=
STERM=.
*EOF*
  :                            1 __giant		$set	1
  :                            2 __relocatable	$set	1
  :                            3: 	$include	"ppc_64.def"
  :                            4 	$list		2
  :                            5 __litseg $set		36
  :                            6 $(__litseg:*8,r30/__literal)
  :                            7 __base36
  :                            8: 	$include	gsoso.s
  :                            1 	.file	"soso.c"
  :                            2 	.globl clanjamfrie
  :                            3 	.section	.sdata,"aw",@progbits
  :                            4 	.align 2
  :                            5 	.type	clanjamfrie, @object
  :                            6 	.size	clanjamfrie, 4
  :                            7 clanjamfrie:
06:00000000 00000037          +8 	.int	55
  :                            9 	.section	".data"
  :                            10 	.align 2
  :                            11 	.type	yasimi, @object
  :                            12 	.size	yasimi, 4
  :                            13 yasimi:
03:00000000 00000063          +14 	.int	99
  :                            15 	.align 2
  :                            16 	.type	cu, @object
  :                            17 	.size	cu, 8
  :                            18 cu:
(+05)40
03:00000004 0000000000000008  +19 	.quad	startfromhere
  :                            20 	.lcomm	clearly_so.1543,8,8
  :                            21 	.type	clearly_so.1543, @object
  :                            22 	.align 2
  :                            23 	.type	separate_static_item.1542, @object
  :                            24 	.size	separate_static_item.1542, 4
  :                            25 separate_static_item.1542:
03:0000000C A5A5A5A5          +26 	.int	-1515870811
  :                            27 	.section	".text"
  :                            28 	.align 2
  :                            29 	.globl soso
  :                            30 	.type	soso, @function
  :                            31 
  :                            32 x	$equf	16, 31	# dynamic integer in the stack frame
  :                            33 
  :                            34 soso:
01:00000000 F821FFC1          +35 	stdu	1, -64(1)
01:00000004 7C0802A6          +36 	mflr	0
01:00000008 FBE10038          +37 	std   31, 56(1)	# save r31 just below the previous stack frame 
01:0000000C F8010048          +38 	std   0, 72(1)	# save LR value inside the previous stack frame
01:00000010 63E10000          +39 	mr    31, 1	# use a frame pointer in case the stack is pushed
01:00000014 FBDF0030          +40 	std	30, 48(31)	# save the literals base register
  :                            41 
01:00000018 4800000D          +42 	bl	__haulup
(+24)40
01:0000001C 0000000000000000  +43 	+	.absolute(__base36):d
  :                            44 __haulup
01:00000024 7FC802A6          +45 	mflr	30	# .literal segment 36 holds __literal table
  :                            46 			# which is accessed base_displacement with r30
  :                            47 	
01:00000028 EBDE0000          +48 	ld	30, 0(30) # LR was pointing to the pointer
  :                            49 
01:0000002C E93E0000          +50 	ld	9, __literal(	__upper48	startfromhere@ha)
(+05:00000008/*02)0e*/02-
01:00000030 E929000A          +51 	lwa	9, startfromhere@l(9)
01:00000034 913F0010          +52 	stw	9, x
  :                            53 
01:00000038 38010009          +54 	addi	0, 9, 1
  :                            55 
01:0000003C E93E0000          +56 	ld	9, __literal(	__upper48	startfromhere@ha)
(+05)10-
01:00000040 90090008          +57 	stw	0, startfromhere@l(9)
  :                            58 
01:00000044 E93E0008          +59 	ld	9, __literal(	__upper48	factor@ha)
[+0000:00000000/*02]0e*/02-
01:00000048 E9290002          +60 	lwa	9, factor@l(9)
01:0000004C E81F0012          +61 	lwa	0, x
  :                            62 
01:00000050 7C0049D6          +63 	mullw	0, 0, 9
01:00000054 901F0010          +64 	stw	0, x
  :                            65 
01:00000058 E93E0010          +66 	ld	9, __literal(	__upper48	cu@ha)
(+03:00000004/*02)0e*/02-
01:0000005C E8090004          +67 	ld	0, cu@l(9)
01:00000060 60600000          +68 	mr	3, 0
  :                            69 
[+0001:ffffff9c/*02]18*/02+
(-01:ffffff9c/*02)18*/02+
01:00000064 4BFFFF9D          +70 	bl	adjustment
01:00000068 61230000          +71 	mr	9, 3
01:0000006C 801F0010          +72 	lwz	0, x
  :                            73 
01:00000070 7C004A14          +74 	add	0, 0, 9
01:00000074 901F0010          +75 	stw	0, x
  :                            76 
01:00000078 E93E0018          +77 	ld	9, __literal(	__upper48	yasimi@ha)
(+03:00000000/*02)0e*/02-
01:0000007C E9290002          +78 	lwa	9, yasimi@l(9)
  :                            79 
01:00000080 E81F0012          +80 	lwa	0, x
01:00000084 7C090050          +81 	subf	0, 9, 0
  :                            82 
  :                            83 #	stw	0, x
  :                            84 #	lwz	0, x	# the compiler had these lines in
  :                            85 
01:00000088 60600000          +86 	mr	3, 0	# this ABI has r3 for results
  :                            87 
  :                            88 #	the geography of the stack frame is
  :                            89 #	LOW ADDRESS REPRESENTED HERE    ______________________________
  :                            90 #	STACK TOP R31 points to ------> |   saved SP (r1) 8 bytes    |
  :                            91 #					|............................|
  :                            92 #				+ 8	| next LR save area 8 bytes  |
  :                            93 #					|............................|
  :                            94 #				+ 16	| var x 4 bytes|/////////////|
  :                            95 #					|..............|.............|
  :                            96 
  :                            97 
  :                            98 
  :                            99 #				+ 48	|     saved r30 8 bytes      |
  :                            100 #					|............................|
  :                            101 #				+ 56	|     saved r31 8 bytes      |
  :                            102 #					|____________________________|
  :                            103 #	PREVIOUS STACK FRAME ---------> | previous saved r1 8 bytes  |
  :                            104 #					|............................|
  :                            105 #				+ 72	|  actual saved LR 8 bytes   |
  :                            106 
  :                            107 
  :                            108 
01:0000008C E9610000          +109 	ld	11, 0(1)	# there is complete confidence r1 unchanged
01:00000090 E80B0008          +110 	ld	0, 8(11)	# pick up LR
01:00000094 7C0803A6          +111 	mtlr	0
01:00000098 EBDF0030          +112 	ld	30, 48(31)
01:0000009C EBEBFFF8          +113 	ld	31, -8(11)
  :                            114 
01:000000A0 602B0000          +115 	mr	1,11
  :                            116 
01:000000A4 4E800020          +117 	blr
  :                            118 
  :                            119 	.size	soso, .-soso
  :                            120 	.lcomm	startfromhere,4,4
  :                            121 	.type	startfromhere, @object
  :                            122 	.ident	"GCC: (GNU) 4.2.1"
  :                            9 	$store		gsoso
  :                            10 	.align		3	# align for 64-bit literal pointer constants
*EOF*
24:00000000+(05:00008008/*10)30*/10:0000000000000000
24:00000008+[0000:00008000/*10]30*/10:0000000000000000
24:00000010+(03:00008004/*10)30*/10:0000000000000000
24:00000018+(03:00008000/*10)30*/10:0000000000000000
:$(01):00000000:000000A8 :$(03):00000000:00000010 :$(05):00000000:0000000C :$(06):00000000:00000004 :$(24):00000000:00000020 
gsoso.msm: object code 1138 bytes: 0 errors: 2 undefined labels
 
</pre>

<p>
Here the principle of basing a literal table for long base address
pointers has been collected in a header file.

<pre>

#*************************************************************
#
#		enter64.def
#
#		This file is enter64.def for source generating
#		RELOCATABLES which will be INCLUDED in 64-BIT LINKS
#		and for ABSOLUTE 64-BIT SOURCE
#
#		enter and leave macros:
#
#			enter64			frame_size_32_or_more
#
#               	return64,64		something_64_bits
#               	return64,__immediate	something
#               	return64		something_32_bits
#               	leave64
#
#		enter64 frame size gets rounded up to 32-byte blocks
#		exactly 32 bytes is enough without local variables
#
#		for variables, frame size is 32+variables_size
#
#		The frame is based on r31
#		and the variables start at frame+16, so for example
#
#		mylocal64	$equf	16, r31
#		mylocal32	$equf	24, r31
#		myother32	$equf	32, r31
#
#		enter64 bases the __literal pool on register 30
#		so that 64-bit pointers to anywhere in memory
#		can be picked up with
#
#			ld	rX, __literal(address)
#
#		Because literals are not duplicated in any one assembly
#		a very good density of literal use can be had with
#		literals which fix the upper 48 bits of the address
#
#			ld	rX, __literal(	__upper48	operand@ha)
#			lwa	rY, operand@l(rX)
#
#		And the good density of literal use minimises
#		the work of cache and tlb.
#
#		An assembly mostly generates only a handful of literals
#
#		The four return macros
#
#                       return64,64             something_64_bits
#                       return64,__immediate    something
#                       return64                something_32_bits
#                       leave64
#
#		all restore r30 and r31
#
#		The operands and jump targets named in literals
#		may be external or relocatable:
#
#			ld	r0, __literal(far_function:d)
#			mtlr	r0
#			blrl
#
#
#*************************************************************

.literal	$equ	36
__immediate	$equ	-16

p	$proc	*

enter64* $name

__FRAME	$set	(p(1, 1)+31)**-32

	$do	__FRAME<32,	$flag	frame size param 1 must be > 0

#**************************************************************
#
#		$(36) is a base_displacement segment
#		so that address constant literals are in reach
#
#		base_displacement references are never relocatable
#
#		a 64-bit constant of __base36 plus all its
#		relocation information must be generated just below here.
#
#		masmx internal function $a, called .absolute in ppc_*.def
#		stops __base36 from being a base_displacement name
#		and instead associates all its relocation information
#
#		in 64-bit absolute source the $a function obtains
#		the long absolute address immediately
#
#			+	.absolute(__base36):d
#
#		After linking,  that constant will contain the true
#		address of the segment $(36) containing literals
#
#**************************************************************

	stdu	1, -__FRAME(1)
	mflr	0
	std	31, __FRAME-8(1)	# save r31 just below
				# the previous stack frame

	std	0, __FRAME+8(1) 	# save LR in the second 64-bit word
				# of the previous stack frame

	mr	31, 1		# have a frame pointer in case
				# the stack is pushed

	std	30, __FRAME-16(31) # save the literals base register

	bl	__haulup
	+	.absolute(__base36):d
__haulup
	mflr	30		# .text segment holds literal table
				# which is accessed base_displacement

	ld	30,,30		# LR was pointing to the pointer
	$end

#*********************************************************************
#
#	the geography of the MINIMUM stack frame is
#	LOW ADDRESS REPRESENTED HERE    ______________________________
#	STACK TOP R31 points to ------> |   saved SP (r1) 8 bytes    |
#					|............................|
#				+ 8	| next LR save area 8 bytes  |
#					|............................|
#				+ 16	|     saved r30 8 bytes      |
#					|............................|
#				+ 24	|     saved r31 8 bytes      |
#					|____________________________|
#	PREVIOUS STACK FRAME ---------> | previous saved r1 8 bytes  |
#					|............................|
#				+ 40	|  actual saved LR 8 bytes   |
#
#*********************************************************************



#********************************************************************
#
#	the geography of A SAMPLE stack frame WITH LOCAL VARIABLES is
#	LOW ADDRESS REPRESENTED HERE    ______________________________
#	STACK TOP R31 points to ------> |   saved SP (r1) 8 bytes    |
#					|............................|
#				+ 8	| next LR save area 8 bytes  |
#					|............................|
#	FOR EXAMPLE		+ 16	| var y 8 bytes              |
#					|............................|
#	FOR EXAMPLE		+ 24	| var x 4 bytes|/////////////|
#					|..............|.............|
#					|			     |
#	per these examples
#				y	$EQUF	16, r31
#				x	$EQUF	24, r31



#	PREVIOUS STACK FRAME - 16	|     saved r30 8 bytes      |
#					|............................|
#	PREVIOUS STACK FRAME - 8	|     saved r31 8 bytes      |
#					|____________________________|
#	PREVIOUS STACK FRAME ---------> | previous saved r1 8 bytes  |
#					|............................|
#	PREVIOUS STACK FRAME + 8	|  actual saved LR 8 bytes   |
#
#
#*********************************************************************


p	$proc

return64* $name

	$if	p(0, 2)=64	#	return64,64	something_64_bits
	ld	3, p(1, 1)	# or
	$elseif	p(0, 2)=__immediate #	return64,__immediate	something
	li	3, p(1, 1)	# or
	$else			#	return64	something_32_bits
	lwa	3, p(1, 1)	# or
	$endif			#	leave64

leave64* $name
	ld	1,,31		# old SP is 1st word of this frame
	ld	0, 8, 1		# old LR is 2nd word of this other frame
	mtlr	0
	ld	30, -16, 1	# old base register is 2nd last word/frame
	ld	31,  -8, 1	# old frame pointer is last word in frame
	blr

	$end


MASMX 7r2
3/gfactor.msm
LTERM=#
CONT_CHAR=
STERM=.
*EOF*
  :                            1 __giant		$set	1
  :                            2 __relocatable	$set	1
  :                            3: 	$include	"ppc_64.def"
  :                            4: 	$include	enter64.def
  :                            5 	$list		2
  :                            6 __litseg $set           36
  :                            7 $(__litseg:*8,r30/__literal)
  :                            8 __base36
  :                            9: 	$include	gfactor.s
  :                            1 	.file	"factor.c"
  :                            2 	.globl factor
  :                            3 	.section	.sdata,"aw",@progbits
  :                            4 	.align 2
  :                            5 	.type	factor, @object
  :                            6 	.size	factor, 4
  :                            7 factor:
06:00000000 00000058          +8 	.int	88
  :                            9 	.section	".data"
  :                            10 	.align 2
  :                            11 	.type	acu, @object
  :                            12 	.size	acu, 4
  :                            13 acu:
(+06)40
03:00000000 0000000000000000  +14 	.long	factor
  :                            15 	.section	".text"
  :                            16 	.align 2
  :                            17 	.globl adjustment
  :                            18 	.type	adjustment, @function
  :                            19 adjustment:
01:00000000 F821FFE1          +20 	enter64	32
01:00000004 7C0802A6          +20 
01:00000008 FBE10018          +20 
01:0000000C F8010028          +20 
01:00000010 63E10000          +20 
01:00000014 FBDF0010          +20 
01:00000018 4800000D          +20 
(+24)40
01:0000001C 0000000000000000  +20 
01:00000024 7FC802A6          +20 
01:00000028 EBDE0000          +20 
01:0000002C 64030021          +21 	return64,__immediate	33
01:00000030 E83F0000          +21 
01:00000034 E8010008          +21 
01:00000038 7C0803A6          +21 
01:0000003C EBC1FFF0          +21 
01:00000040 EBE1FFF8          +21 
01:00000044 4E800020          +21 
  :                            22 	.size	adjustment, .-adjustment
  :                            23 	.align 2
  :                            24 	.globl overcoat
  :                            25 	.type	overcoat, @function
  :                            26 overcoat:
01:00000048 F821FFE1          +27 	enter64	32
01:0000004C 7C0802A6          +27 
01:00000050 FBE10018          +27 
01:00000054 F8010028          +27 
01:00000058 63E10000          +27 
01:0000005C FBDF0010          +27 
01:00000060 4800000D          +27 
(+24)40
01:00000064 0000000000000000  +27 
01:0000006C 7FC802A6          +27 
01:00000070 EBDE0000          +27 
01:00000074 E93E0000          +28 	ld	9, __literal(	__upper48	acu@ha)
(+03:00000000/*02)0e*/02-
01:00000078 E8090000          +29 	ld	0, acu@l(9)
01:0000007C 60600000          +30 	mr	3,0
[+0000:ffffff80/*02]18*/02+
(-01:ffffff80/*02)18*/02+
01:00000080 4BFFFF81          +31 	bl	soso
01:00000084 E83F0000          +32 	leave64
01:00000088 E8010008          +32 
01:0000008C 7C0803A6          +32 
01:00000090 EBC1FFF0          +32 
01:00000094 EBE1FFF8          +32 
01:00000098 4E800020          +32 
  :                            33 	.size	overcoat, .-overcoat
  :                            34 	.ident	"GCC: (GNU) 4.2.1"
  :                            10 	$store		gfactor
  :                            11 	.align		3
*EOF*
24:00000000+(03:00008000/*10)30*/10:0000000000000000
:$(01):00000000:000000A0 :$(03):00000000:00000008 :$(06):00000000:00000004 :$(24):00000000:00000008 
gfactor.msm: object code 847 bytes: 0 errors: 1 undefined labels


</pre>


<p>
The seventh link places relocatables in giant absolute address space.
The displayed summary information only shows the non-giant parts of
the addresses, but the label values and the text-encoded binary
(and the generated code listed because of <b>$list 2</b>) show the
whole addresses.
<pre>


$ ../masmx map7 -l

MASMX 7r2
3/map7.msm
gsoso.txo:$(1) 168 bytes decimal from hexadecimal 00000000 to 000000A8
gsoso.txo:$(3) 16 bytes decimal from hexadecimal 00000000 to 00000010
gsoso.txo:$(5) 12 bytes decimal from hexadecimal 00000000 to 0000000C
gsoso.txo:$(6) 4 bytes decimal from hexadecimal 00000000 to 00000004
gsoso.txo:$(36) 32 bytes decimal from hexadecimal 00000000 to 00000020
gfactor.txo:$(1) 160 bytes decimal from hexadecimal 000000A8 to 00000148
gfactor.txo:$(3) 8 bytes decimal from hexadecimal 00000010 to 00000018
gfactor.txo:$(6) 4 bytes decimal from hexadecimal 00000004 to 00000008
gfactor.txo:$(36) 8 bytes decimal from hexadecimal 00000020 to 00000028
*EOF*
  :                            1 __giant	$set		1
  :                            2 
  :                            3: 	$include	"ppc64map.def"
  :                            4 
  :                            5 $(1::*000A000000000000)
  :                            6 $(36::*000A800000000000)
  :                            7 $(3::*000B000000000000)
  :                            8 $(5::*000B800000000000)
  :                            9 $(6::*000C000000000000)
  :                            10 	$list			2
  :                            11: 	$include,$binary	gsoso
06:000C000000000000:00000037  +4 00000037
03:000B000000000000:00000063  +7 00000063
03:000B000000000004:000B800000000008
                              +9 (05)40:0000000000000008
03:000B00000000000C:A5A5A5A5  +11 A5A5A5A5
01:000A000000000000:F821FFC1  +14 F821FFC1 7C0802A6 FBE10038 F8010048 63E10000 FBDF0030
01:000A000000000004:7C0802A6  +14 
01:000A000000000008:FBE10038  +14 
01:000A00000000000C:F8010048  +14 
01:000A000000000010:63E10000  +14 
01:000A000000000014:FBDF0030  +14 
01:000A000000000018:4800000D  +15 4800000D (24)40:0000000000000000 7FC802A6 EBDE0000 E93E0000
01:000A00000000001C:000A800000000000
                              +15 
01:000A000000000024:7FC802A6  +15 
01:000A000000000028:EBDE0000  +15 
01:000A00000000002C:E93E0000  +15 
01:000A000000000030:E929000A  +16 (05:00000008/*02)0E*/02-:E929000A 913F0010 38010009 E93E0000
01:000A000000000034:913F0010  +16 
01:000A000000000038:38010009  +16 
01:000A00000000003C:E93E0000  +16 
01:000A000000000040:90090008  +17 (05)10-:90090008 E93E0008 [0000:00000000/*02]0E*/02-:E9290002
01:000A000000000044:E93E0008  +17 
01:000A000000000048:E9290006  +17 
01:000A00000000004C:E81F0012  +18 E81F0012 7C0049D6 901F0010 E93E0010 (03:00000004/*02)0E*/02-:E8090004
01:000A000000000050:7C0049D6  +18 
01:000A000000000054:901F0010  +18 
01:000A000000000058:E93E0010  +18 
01:000A00000000005C:E8090004  +18 
01:000A000000000060:60600000  +19 60600000 [0001:FFFFFF9C/*02]18*/02+:(-01:FFFFFF9C/*02)18*/02+:4BFFFF9D
01:000A000000000064:48000045  +19 
01:000A000000000068:61230000  +20 61230000 801F0010 7C004A14 901F0010 E93E0018 (03:00000000/*02)0E*/02-:E9290002
01:000A00000000006C:801F0010  +20 
01:000A000000000070:7C004A14  +20 
01:000A000000000074:901F0010  +20 
01:000A000000000078:E93E0018  +20 
01:000A00000000007C:E9290002  +20 
01:000A000000000080:E81F0012  +21 E81F0012 7C090050 60600000 E9610000 E80B0008 7C0803A6
01:000A000000000084:7C090050  +21 
01:000A000000000088:60600000  +21 
01:000A00000000008C:E9610000  +21 
01:000A000000000090:E80B0008  +21 
01:000A000000000094:7C0803A6  +21 
01:000A000000000098:EBDF0030  +22 EBDF0030 EBEBFFF8 602B0000 4E800020
01:000A00000000009C:EBEBFFF8  +22 
01:000A0000000000A0:602B0000  +22 
01:000A0000000000A4:4E800020  +22 
24:000A800000000000:000B800000000000
                              +25 (05:00008008/*10)30*/10:0000000000000000
24:000A800000000008:000C000000000000
                              +26 [0000:00008000/*10]30*/10:0000000000000000
24:000A800000000010:000B000000000000
                              +27 (03:00008004/*10)30*/10:0000000000000000
24:000A800000000018:000B000000000000
                              +28 (03:00008000/*10)30*/10:0000000000000000
  :                            12: 	$include,$binary	gfactor
06:000C000000000004:00000058  +4 00000058
03:000B000000000010:000C000000000004
                              +7 (06)40:0000000000000000
01:000A0000000000A8:F821FFE1  +10 F821FFE1 7C0802A6 FBE10018 F8010028 63E10000 FBDF0010
01:000A0000000000AC:7C0802A6  +10 
01:000A0000000000B0:FBE10018  +10 
01:000A0000000000B4:F8010028  +10 
01:000A0000000000B8:63E10000  +10 
01:000A0000000000BC:FBDF0010  +10 
01:000A0000000000C0:4800000D  +11 4800000D (24)40:0000000000000000 7FC802A6 EBDE0000 64030021
01:000A0000000000C4:000A800000000020
                              +11 
01:000A0000000000CC:7FC802A6  +11 
01:000A0000000000D0:EBDE0000  +11 
01:000A0000000000D4:64030021  +11 
01:000A0000000000D8:E83F0000  +12 E83F0000 E8010008 7C0803A6 EBC1FFF0 EBE1FFF8 4E800020
01:000A0000000000DC:E8010008  +12 
01:000A0000000000E0:7C0803A6  +12 
01:000A0000000000E4:EBC1FFF0  +12 
01:000A0000000000E8:EBE1FFF8  +12 
01:000A0000000000EC:4E800020  +12 
01:000A0000000000F0:F821FFE1  +14 F821FFE1 7C0802A6 FBE10018 F8010028 63E10000 FBDF0010
01:000A0000000000F4:7C0802A6  +14 
01:000A0000000000F8:FBE10018  +14 
01:000A0000000000FC:F8010028  +14 
01:000A000000000100:63E10000  +14 
01:000A000000000104:FBDF0010  +14 
01:000A000000000108:4800000D  +15 4800000D (24)40:0000000000000000 7FC802A6 EBDE0000 E93E0000
01:000A00000000010C:000A800000000020
                              +15 
01:000A000000000114:7FC802A6  +15 
01:000A000000000118:EBDE0000  +15 
01:000A00000000011C:E93E0000  +15 
01:000A000000000120:E8090010  +16 (03:00000000/*02)0E*/02-:E8090000 60600000 [0000:FFFFFF80/*02]18*/02+:(-01:FFFFFF80/*02)18*/02+:4BFFFF81
01:000A000000000124:60600000  +16 
01:000A000000000128:4BFFFED9  +16 
01:000A00000000012C:E83F0000  +17 E83F0000 E8010008 7C0803A6 EBC1FFF0 EBE1FFF8 4E800020
01:000A000000000130:E8010008  +17 
01:000A000000000134:7C0803A6  +17 
01:000A000000000138:EBC1FFF0  +17 
01:000A00000000013C:EBE1FFF8  +17 
01:000A000000000140:4E800020  +17 
24:000A800000000020:000B000000000000
                              +20 (03:00008000/*10)30*/10:0000000000000000
  :                            13 
  :                            14 	$store			image7
*EOF*
:$(01):00000000:00000148 :$(03):00000000:00000018 :$(05):00000000:0000000C :$(06):00000000:00000008 :$(24):00000000:00000028 
map7.msm: object code 1448 bytes: 0 errors: 0 undefined labels

$ cat image7.txo

@:06:000C000000000000
$06:00000000
00000037
@:03:000B000000000000
$03:00000000
00000063
$03:00000004
000B800000000008
$03:0000000C
A5A5A5A5
@:01:000A000000000000
$01:00000000
F821FFC1 7C0802A6 FBE10038 F8010048 63E10000 FBDF0030
4800000D 000A800000000000 7FC802A6 EBDE0000 E93E0000 E929000A
913F0010 38010009 E93E0000 90090008 E93E0008 E9290006
E81F0012 7C0049D6 901F0010 E93E0010 E8090004 60600000
48000045 61230000 801F0010 7C004A14 901F0010 E93E0018
E9290002 E81F0012 7C090050 60600000 E9610000 E80B0008
7C0803A6 EBDF0030 EBEBFFF8 602B0000 4E800020
@:24:000A800000000000
$24:00000000
000B800000000000 000C000000000000 000B000000000000
000B000000000000
$06:00000004
00000058
$03:00000010
000C000000000004
$01:000000A8
F821FFE1 7C0802A6 FBE10018 F8010028 63E10000 FBDF0010
4800000D 000A800000000020 7FC802A6 EBDE0000 64030021 E83F0000
E8010008 7C0803A6 EBC1FFF0 EBE1FFF8 4E800020
$01:000000F0
F821FFE1 7C0802A6 FBE10018 F8010028 63E10000 FBDF0010
4800000D 000A800000000020 7FC802A6 EBDE0000 E93E0000 E8090010
60600000 4BFFFED9 E83F0000 E8010008 7C0803A6 EBC1FFF0
EBE1FFF8 4E800020
$24:00000020
000B000000000000
+ADJUSTMENT:$01:000A0000000000A8
+CLANJAMFRIE:$06:000C000000000000
+FACTOR:$06:000C000000000004
+OVERCOAT:$01:000A0000000000F0
+SOSO:$01:000A000000000000
:$01*00000000:00000000:00000148
:$03*00000000:00000000:00000018
@:05:000B800000000000
:$05*00000000:00000000:0000000C
:$06*00000000:00000000:00000008
:$24*00000000:00000000:00000028


</pre>
<p>
Segments are always gathered by section with giant addresses. The
giant addresses can come from the link source or from the input
Text Encoded Binary

<p>
The $MAP macro used in giant space has this structure.

<p>
Where operand fields can relocate out of their range and then
relocate back into range again, because of multiple relocation
clauses for relative address calculations, a value <b>sum</b> is
maintained at 192-bits precision.

<p>
The $INFO subcommand $RANGE_CHECK requires only the last written
value to be in field range.

<p>
The $PUSHREL subcommand $LONG_ABSOLUTE allows a segment base value
or external label value 192 bits in size to be retrieved
<pre>

p	$proc
"$map"*	$name

p	$proc
superword* $name
parts	$set	p(1,1:)
"$data"	$set,$binary	p(1,1:parts)

column	$set	$bits

part	$do	parts-1,	relocate	p(1, 1:part)
	$load,$bits	$data
	$end	. SUPERWORD

p	$proc
relocate* $name


rel_params $pushrel	p(1,1)

value	$pushrel,$long_absolute	p(1,1)

bits    $set    rel_params\2
scale   $set    rel_params\3
offset  $set    rel_params\4
descant $set    rel_params\5

limit   $set    1*/bits
mask    $set    limit-1
unmask  $set    ^(mask*/scale)

	$if	scale^=column
sum*	$set	0
column*	$set	scale
	$endif

sum*	$set	value+sum

	$if	descant<0

field	$set	sum+offset
	$info,$range_check	field
field	$set	(field*/descant)**mask

	$else

field	$set	sum+(($data/*scale)**mask)

	$info,$range_check	field

	$endif


"$data"* $set	(field*/scale)++($data**unmask)

	$end	. RELOCATE

index	$do	p(),	word	p(index, 1)
	$end	. $MAP

</pre>
<h4>9.2.3.8: The Incremental Link in Giant Address Space</h4>


<p>
The eighth link increments relocatable gzactor.txo on the end of the giant
address absolute from the seventh link. 
<pre>

$ ../cat gzactor.msm
__relocatable	$set	1
__giant		$set	1

	$include	"ppc_64.def"
	$include	 enter64.def

__litseg $set           36
$(__litseg:*8,r30/__literal)
__base36

	$if	1
$(.data)
myword	.int		99
	$endif

$(.text)
zactor*
	enter64	32
        ld	9, __literal(	__upper48	factor@ha)
        lwz	0, factor@l(9)

	ld	10, __literal(	__upper48	myword@ha)
	lwz	11, myword@l(10)

	bl	soso

	leave64

	$store	gzactor

$ ../masmx map8 -l

MASMX 7r2
3/map8.msm
image7.txo:$(1) 328 bytes decimal from hexadecimal 00000000 to 00000148
image7.txo:$(3) 24 bytes decimal from hexadecimal 00000000 to 00000018
image7.txo:$(5) 12 bytes decimal from hexadecimal 00000000 to 0000000C
image7.txo:$(6) 8 bytes decimal from hexadecimal 00000000 to 00000008
image7.txo:$(36) 40 bytes decimal from hexadecimal 00000000 to 00000028
gzactor.txo:$(1) 88 bytes decimal from hexadecimal 00000148 to 000001A0
gzactor.txo:$(3) 4 bytes decimal from hexadecimal 00000018 to 0000001C
gzactor.txo:$(36) 16 bytes decimal from hexadecimal 00000028 to 00000038
*EOF*
  :                            1 __giant	$set		1
  :                            2: 	$include	"ppc64map.def"
  :                            3 	$list		 1
  :                            4 
  :                            5 .	$set_option	"b"
  :                            6 
  :                            7: 	$include,$binary	image7
  :                            8: 	$include,$binary	gzactor
  :                            9 
  :                            10 	$store			image8
*EOF*
:$(01):00000000:000001A0 :$(03):00000000:0000001C :$(05):00000000:0000000C :$(06):00000000:00000008 :$(24):00000000:00000038 
map8.msm: object code 1756 bytes: 0 errors: 0 undefined labels

$ cat image8.txo

@:06:000C000000000000
$06:00000000
00000037
@:03:000B000000000000
$03:00000000
00000063
$03:00000004
000B800000000008
$03:0000000C
A5A5A5A5
@:01:000A000000000000
$01:00000000
F821FFC1 7C0802A6 FBE10038 F8010048 63E10000 FBDF0030
4800000D 000A800000000000 7FC802A6 EBDE0000 E93E0000 E929000A
913F0010 38010009 E93E0000 90090008 E93E0008 E9290006
E81F0012 7C0049D6 901F0010 E93E0010 E8090004 60600000
48000045 61230000 801F0010 7C004A14 901F0010 E93E0018
E9290002 E81F0012 7C090050 60600000 E9610000 E80B0008
7C0803A6 EBDF0030 EBEBFFF8 602B0000 4E800020
@:24:000A800000000000
$24:00000000
000B800000000000 000C000000000000 000B000000000000
000B000000000000
$06:00000004
00000058
$03:00000010
000C000000000004
$01:000000A8
F821FFE1 7C0802A6 FBE10018 F8010028 63E10000 FBDF0010
4800000D 000A800000000020 7FC802A6 EBDE0000 64030021 E83F0000
E8010008 7C0803A6 EBC1FFF0 EBE1FFF8 4E800020
$01:000000F0
F821FFE1 7C0802A6 FBE10018 F8010028 63E10000 FBDF0010
4800000D 000A800000000020 7FC802A6 EBDE0000 E93E0000 E8090010
60600000 4BFFFED9 E83F0000 E8010008 7C0803A6 EBC1FFF0
EBE1FFF8 4E800020
$24:00000020
000B000000000000
$03:00000018
00000063
$01:00000148
F821FFE1 7C0802A6 FBE10018 F8010028 63E10000 FBDF0010
4800000D 000A800000000028 7FC802A6 EBDE0000 E93E0000 80090004
E95E0008 816A0018 4BFFFE7D E83F0000 E8010008 7C0803A6
EBC1FFF0 EBE1FFF8 4E800020
$24:00000028
000C000000000000 000B000000000000
+ADJUSTMENT:$01:000A0000000000A8
+CLANJAMFRIE:$06:000C000000000000
+FACTOR:$06:000C000000000004
+OVERCOAT:$01:000A0000000000F0
+SOSO:$01:000A000000000000
+ZACTOR:$01:000A000000000148
:$01*00000000:00000000:000001A0
:$03*00000000:00000000:0000001C
@:05:000B800000000000
:$05*00000000:00000000:0000000C
:$06*00000000:00000000:00000008
:$24*00000000:00000000:00000038

</pre>

<h4>9.2.3.9: Linking with Void Inclusion</h4>


<p>
The ninth and tenth links have void inclusions. A void inclusion integrates
the new code onto the referenced absolute without including the referenced
absolute. So the new Text Encoded Binary knows the addresses in the
referenced absolute, but is a separate load.

<p>
relocatable zactor.txo is integrated with absolute image2 = soso + factor:
<pre>

$ ../masmx map9 -l

MASMX 7r2
3/map9.msm
image2.txo:$(1) 244 bytes decimal from hexadecimal 000A0000 to 000A00F4
image2.txo:$(3) 16 bytes decimal from hexadecimal 000B0000 to 000B0010
image2.txo:$(5) 12 bytes decimal from hexadecimal 000B8000 to 000B800C
image2.txo:$(6) 8 bytes decimal from hexadecimal 000C0000 to 000C0008
zactor.txo:$(1) 24 bytes decimal from hexadecimal 000A00F4 to 000A010C
zactor.txo:$(3) 4 bytes decimal from hexadecimal 000B0010 to 000B0014
*EOF*
  :                            1:       $include        "map_ppc.def"
  :                            2 
  :                            3        $set_option     "b"
  :                            4 
  :                            5        $include,$void          image2
  :                            6:       $include,$binary        zactor
  :                            7 
  :                            8        $store                  image9
*EOF*
:$(01):000A0000:000A010C :$(03):000B0000:000B0014 :$(05):000B8000:000B800C :$(06):000C0000:000C0008 
map9.msm: object code 352 bytes: 0 errors: 0 undefined labels

$ cat image9.txo

$03:000B0010
00000063
$01:000A00F4
3D20000C 80090004 3D40000B 816A0010 4BFFFEFD 4E800020
+ADJUSTMENT:$01:000A0094
+CLANJAMFRIE:$06:000C0000
+FACTOR:$06:000C0004
+OVERCOAT:$01:000A00B8
+SOSO:$01:000A0000
+ZACTOR:$01:000A00F4
:$01*00000000:000A0000:000A010C
:$03*00000000:000B0000:000B0014
:$05*00000000:000B8000:000B800C
:$06*00000000:000C0000:000C0008


</pre>
<h4>9.2.3.10: Linking With Void Inclusion in Giant Address Space</h4>


<p>
The tenth link does a void include with giant addresses:

<pre>
$ ../masmx map10 -l

MASMX 7r2
3/map10.msm
image7.txo:$(1) 328 bytes decimal from hexadecimal 00000000 to 00000148
image7.txo:$(3) 24 bytes decimal from hexadecimal 00000000 to 00000018
image7.txo:$(5) 12 bytes decimal from hexadecimal 00000000 to 0000000C
image7.txo:$(6) 8 bytes decimal from hexadecimal 00000000 to 00000008
image7.txo:$(36) 40 bytes decimal from hexadecimal 00000000 to 00000028
gzactor.txo:$(1) 88 bytes decimal from hexadecimal 00000148 to 000001A0
gzactor.txo:$(3) 4 bytes decimal from hexadecimal 00000018 to 0000001C
gzactor.txo:$(36) 16 bytes decimal from hexadecimal 00000028 to 00000038
*EOF*
  :                            1 __giant	$set		1
  :                            2: 	$include	"ppc64map.def"
  :                            3 	$list		 2
  :                            4 
  :                            5 	$include,$void		image7
  :                            6: 	$include,$binary	gzactor
03:000B000000000018:00000063  +4 00000063
01:000A000000000148:F821FFE1  +7 F821FFE1 7C0802A6 FBE10018 F8010028 63E10000 FBDF0010
01:000A00000000014C:7C0802A6  +7 
01:000A000000000150:FBE10018  +7 
01:000A000000000154:F8010028  +7 
01:000A000000000158:63E10000  +7 
01:000A00000000015C:FBDF0010  +7 
01:000A000000000160:4800000D  +8 4800000D (24)40:0000000000000000 7FC802A6 EBDE0000 E93E0000
01:000A000000000164:000A800000000028
                              +8 
01:000A00000000016C:7FC802A6  +8 
01:000A000000000170:EBDE0000  +8 
01:000A000000000174:E93E0000  +8 
01:000A000000000178:80090004  +9 [0000]10-:80090000 E95E0008 (03)10-:816A0000 [0001:FFFFFFC4/*02]18*/02+:(-01:FFFFFFC4/*02)18*/02+:4BFFFFC5
01:000A00000000017C:E95E0008  +9 
01:000A000000000180:816A0018  +9 
01:000A000000000184:4BFFFE7D  +9 
01:000A000000000188:E83F0000  +10 E83F0000 E8010008 7C0803A6 EBC1FFF0 EBE1FFF8 4E800020
01:000A00000000018C:E8010008  +10 
01:000A000000000190:7C0803A6  +10 
01:000A000000000194:EBC1FFF0  +10 
01:000A000000000198:EBE1FFF8  +10 
01:000A00000000019C:4E800020  +10 
24:000A800000000028:000C000000000000
                              +13 [0000:00008000/*10]30*/10:0000000000000000
24:000A800000000030:000B000000000000
                              +14 (03:00008000/*10)30*/10:0000000000000000
  :                            7 
  :                            8 	$store			image10
*EOF*
:$(01):00000000:000001A0 :$(03):00000000:0000001C :$(05):00000000:0000000C :$(06):00000000:00000008 :$(24):00000000:00000038 
map10.msm: object code 732 bytes: 0 errors: 0 undefined labels

$ cat image10.txo

@:03:000B000000000000
$03:00000018
00000063
@:01:000A000000000000
$01:00000148
F821FFE1 7C0802A6 FBE10018 F8010028 63E10000 FBDF0010
4800000D 000A800000000028 7FC802A6 EBDE0000 E93E0000 80090004
E95E0008 816A0018 4BFFFE7D E83F0000 E8010008 7C0803A6
EBC1FFF0 EBE1FFF8 4E800020
@:24:000A800000000000
$24:00000028
000C000000000000 000B000000000000
+ADJUSTMENT:$01:000A0000000000A8
+CLANJAMFRIE:$06:000C000000000000
+FACTOR:$06:000C000000000004
+OVERCOAT:$01:000A0000000000F0
+SOSO:$01:000A000000000000
+ZACTOR:$01:000A000000000148
:$01*00000000:00000000:000001A0
:$03*00000000:00000000:0000001C
@:05:000B800000000000
:$05*00000000:00000000:0000000C
@:06:000C000000000000
:$06*00000000:00000000:00000008
:$24*00000000:00000000:00000038

</pre>
<h1>10: Byte-Addressing Machines with 32 and 64 Bit Bus:
Managing Alignments</h1>


<p>
Word size set with the $WORD directive does not always mean the
architectural word size of the target.

<p>
If the address quantum of the target is also its word size, then
then the real architectural word size is the only possible $WORD value.

<p>
This discussion concerns byte-addressing machines.

<p>
In masmx $WORD sets the quantum of data which a line of assembly
can generate. A line may generate no code, a word or some words.

<p>
Targets which can fetch instructions from any byte address and can have
instructions one byte long have to be described as having the geometry
<pre>

	$cont_char	'|'
	$lterm		';'

	$word	8
	$awidth	32	; or however wide an address is

</pre>
<p>
32-bit and 64-bit integers are then described as quadwords and octowords,
here for a reverse-byte-order target:
<pre>

dl*	$proc
?	$do	dl(1),	+	dl(1, ?),	dl(1, ?)/*8,	|
				dl(1, ?)/*16,	dl(1, ?)/*24:q
	$end


p	$proc
long_long* $name
?	$do	p(1),	+	p(1, ?), 	p(1, ?)/*8,	|
				p(1, ?)/*16, 	p(1, ?)/*24,	|
				p(1, ?)/*32, 	p(1, ?)/*40,	|
				p(1, ?)/*48, 	p(1, ?)/*56:o
	$end

</pre>
<p>
An integer longer than than an octoword can be described with $FORM
<pre>

i128	$form	8,8,8,8, 8,8,8,8, 8,8,8,8, 8,8,8,8

d128*	$proc
	i128	d128,     d128/*8,  d128/*16, d128/*24,	|
	 	d128/*32, d128/*40, d128/*48, d128/*56,	|
	 	d128/*64, d128/*72, d128/*80, d128/*88,	|
	 	d128/*96, d128/*104,d128/*112,d128/*120
	$end

</pre>
<p>
And this would apply to most Intel targets. Aligment directives
or macros are added where needed.

<p>
This does not in any way affect the target's ability to make full use
of its 32-bit or 64-bit data path.

<p>
Cache memory can make alignments less important, because the actual
burst from memory is some 16 or 32 bytes containing operands somewhere
within it.

<p>
Architectures like MIPS, ARM and PowerPC always fetch 32-bit aligned
instructions, and cannot jump to a location which is not 32-bit
aligned.

<p>
However data may be unaligned. The address quantum for these architectures
is 8 bits, and directives with names like .byte .half .ascii .asciiz .space
may leave the next available location xxxxxx01 or xxxxxx10 or xxxxxx11.

<p>
The load/store instructions however need xxxxxx00 alignment for 32-bit
loads and stores and xxxxxxx0 alignment for 16-bit loads and stores.

<p>
ARM carries out a compensatory manipulation if the subject of a 32-bit
load is not aligned, but the target integer is not completely retrieved.

<p>
A directive usually called .align and usually having a power-2 argument
is mostly placed in front of items which need to be aligned. .align is
macro-implemented in definitions "mips.def" "arm.def" "ppc_603.def"

<p>
The $WORD directive can be used to set an alignment policy for data.

<p>
The following three assemblies take MIPS for a model. In the first
assembly, the geometry in definition "mips.def" is
<pre>

	$word	8
	$awidth	32

</pre>
<p>
The commands .ascii .asciiz .byte and .half do not restore alignment.

<p>
The <b>-c</b> flag enables C-Language style \escape sequences in strings.
<pre>

MASMX 7r2
3/prelude.msm
CONT_CHAR=|
LTERM=#
STERM=.
  :                            1:       $include        "mips.def"
  :                            1        $list           2
  :                            2        $word           8
  :                            3        $awidth         32
  :                            4 
  :                            5        $cont_char       '|'
  :                            6        $lterm          '#'
  :                            7        $sterm          '.'
  :                            8 
  :                            9        $set_option     "c"
  :                            10 
  :                            11       $do     $t(__LITTLE_END)=0,__LITTLE_END	$set     0
  :                            12 
  :                            202              $list   2
  :                            203 
  :                            204 p            $proc
  :                            205 j*           $name   2
  :                            206 jal*         $name   3
  :                            207 
  :                            208 target               $set    p(1, 1)
  :                            210              $do     ($net(target)**3)^=0,  |
                        $flag   you can't jump there
  :                            211 
  :                            212              $ij     p(0, 0), target/*2
  :                            213              $end
  :                            214 
Note: mips.def Line 228: end of header file include
  :                            2 $(__data:0x3000)
  :                            3 $(__text:0x1000)
  :                            4 
  :                            5        .data
03:00003000 2247727565737365220A6175730A5361616E656E4C616E64
                              +6        .asciiz """Gruesse""\naus\nSaanenLand\"Pays\777\666d\'enHaut\r\n"
03:00003018 2250617973FFB66427656E486175740D0A00
                              +6 
03:0000302A 4A756C6907080C0B0900
                              +7        .asciiz "Juli\a\b\f\v\t"
Note: prelude.msm Line 8: exactly 3 octal symbols expected here
03:00003034 626973313453657074656D6265720A6C736F206B6F6D6D74
                              +8        .asciiz "bis\61\064September\x0also kommt\xc"
Note: prelude.msm Line 8: exactly 2 hexadecimal symbols expected here
03:0000304C 0C00              +8 
  :                            9 
03:0000304E 596568756469      +10       .ascii  "Yehudi"
03:00003054 20                +11       .byte   32
03:00003055 4D656E7568696E    +12       .ascii  "Menuhin"
03:0000305C 0A                +13       .byte   10
03:0000305D 466F7220657665720A+14       .ascii  "For ever\n"
  :                            15 
03:00003066 456D696C696100    +16         .asciiz "Emilia", "Kopatchinskaja"
03:0000306D 4B6F7061746368696E736B616A6100
                              +16 
03:0000307C 4C65696600        +17         .asciiz "Leif", "Ove", "Andsnes"
03:00003081 4F766500          +17 
03:00003085 416E64736E657300  +17 
03:0000308D 536F6C00          +18         .asciiz "Sol", "Gabetta"
03:00003091 4761626574746100  +18 
03:00003099 43687269737469616E00
                              +19         .asciiz "Christian", "Tetzlaff"
03:000030A3 5465747A6C61666600+19 
03:000030AC 5665726F6E69636100+20         .asciiz "Veronica", "Eberle"
03:000030B5 456265726C6500    +20 
  :                            21 
  :                            22       .align  1
03:000030BC 01F4              +23       .half   500
  :                            24 
  :                            25       .align  2
03:000030C0 00000063          +26       .word   99, 100, 101
03:000030C4 00000064          +26 
03:000030C8 00000065          +26 
  :                            27 
  :                            28       .text
  :                            29 
  :                            30 usefully      $equ    0x18C
  :                            31 upward        $equ    65536
  :                            32 
01:00001000 8D250040          +33       lw      $5, 64($9)
01:00001004 0085001A          +34       div     $4, $5
01:00001008 0C000063          +35       jal     usefully
01:0000100C 08004000          +36       j       upward
  :                            37 
  :                            38       $end
:$(01):00001000:00001010 :$(03):00003000:000030CC 
prelude.msm: object code 581 bytes: 0 errors: 0 undefined labels

</pre>
<p>
The second assembly shows a stern alignment forced by 32-bit word size.
Strings are padded to word. Because <b>-c</b> flag is on, the padding is zero.

<p>
Without <b>-c</b> flag the padding is space.

<p>
Setting is big-endian in this assembly.
<p>
.half and .byte are at the left of their containing word. Otherwise
the labels byte1 byte2 and half1 would not point at the generated items.
<pre>

MASMX 7r2
3/interlud.msm
CONT_CHAR=|
LTERM=#
STERM=.
  :                            1:       $include        "mips32.def"
  :                            1        $list   2
  :                            2        $word           32
  :                            3        $quantum        8
  :                            4 
  :                            5        $cont_char       '|'
  :                            6        $lterm          '#'
  :                            7        $sterm          '.'
  :                            8 
  :                            9        $set_option     "c"
  :                            10 
  :                            11       $do     $t(__LITTLE_END)=0,__LITTLE_END	$set     0
  :                            12 
  :                            131      $list   2
  :                            132 
  :                            133 .byte*               $proc
  :                            134 ?    $do     .byte(1),       +       .byte(1, ?), 0, 0, 0
  :                            135              $note   8-bit value in 32-bit word
  :                            136              $end
  :                            137 
  :                            138 .half*               $proc
  :                            139 ?    $do     .half(1),       +       .half(1, ?), 0
  :                            140              $note   16-bit value in 32-bit word
  :                            141              $end
  :                            142 
  :                            2 $(__data:0x3000)
  :                            3 $(__text:0x1000)
  :                            4 
  :                            5        .data
03:00003000 2247727565737365220A6175730A5361616E656E4C616E64
                              +6        .asciiz """Gruesse""\naus\nSaanenLand\"Pays\777\666d\'enHaut\r\n"
03:00003018 2250617973FFB66427656E486175740D0A000000
                              +6 
03:0000302C 4A756C6907080C0B09000000
                              +7        .asciiz "Juli\a\b\f\v\t"
Note: interlud.msm Line 8: exactly 3 octal symbols expected here
03:00003038 626973313453657074656D6265720A6C736F206B6F6D6D74
                              +8         .asciiz "bis\61\064September\x0also kommt\xc"
Note: interlud.msm Line 8: exactly 2 hexadecimal symbols expected here
03:00003050 0C000000          +8 
  :                            9 
03:00003054 5965687564690000  +10       .ascii  "Yehudi"
03:0000305C 20000000          +11 byte1 .byte   32
Note: interlud.msm Line 11: 8-bit value in 32-bit word
03:00003060 4D656E7568696E00  +12       .ascii  "Menuhin"
03:00003068 0A000000          +13 byte2 .byte   10
Note: interlud.msm Line 13: 8-bit value in 32-bit word
03:0000306C 466F7220657665720A000000
                              +14       .ascii  "For ever\n"
  :                            15 
03:00003078 456D696C69610000  +16       .asciiz "Emilia", "Kopatchinskaja"
03:00003080 4B6F7061746368696E736B616A610000
                              +16 
03:00003090 4C65696600000000  +17       .asciiz "Leif", "Ove", "Andsnes"
03:00003098 4F766500          +17 
03:0000309C 416E64736E657300  +17 
03:000030A4 536F6C00          +18       .asciiz "Sol", "Gabetta"
03:000030A8 4761626574746100  +18 
03:000030B0 43687269737469616E000000
                              +19       .asciiz "Christian", "Tetzlaff"
03:000030BC 5465747A6C61666600000000
                              +19 
03:000030C8 5665726F6E69636100000000
                              +20       .asciiz "Veronica", "Eberle"
03:000030D4 456265726C650000  +20 
  :                            21 
03:000030DC 01F40000          +22 half1 .half   500
Note: interlud.msm Line 22: 16-bit value in 32-bit word
  :                            23 
03:000030E0 00000063          +24       .word   99, 100, 101
03:000030E4 00000064          +24 
03:000030E8 00000065          +24 
  :                            25 
  :                            26       .text
  :                            27 
  :                            28 usefully      $equ    0x18C
  :                            29 upward  	$equ    65536
  :                            30 
01:00001000 8D250040          +31       lw      $5, 64($9)
01:00001004 0085001A          +32       div     $4, $5
01:00001008 0C000063          +33       jal     usefully
01:0000100C 08004000          +34       j       upward
  :                            35 
  :                            36       $end
:$(01):00001000:00001010 :$(03):00003000:000030EC 
interlud.msm: object code 623 bytes: 0 errors: 0 undefined labels

</pre>
<p>
The assembly is repeated here for reverse-byte-order. Macro language takes
a slightly different path:
<pre>

MASMX 7r2
3/interlud.msm
CONT_CHAR=|
LTERM=#
STERM=.
  :                            1 __LITTLE_END   $set    1
  :                            2:       $include        "mips32.def"
  :                            1        $list   2
  :                            2        $word           32
  :                            3        $quantum        8
  :                            4 
  :                            5        $cont_char       '|'
  :                            6        $lterm          '#'
  :                            7        $sterm          '.'
  :                            8 
  :                            9        $set_option     "c"
  :                            10 
  :                            11       $do     $t(__LITTLE_END)=0,__LITTLE_END	$set     0
  :                            12 
  :                            111              $list   2
  :                            112 
  :                            113              $if     __LITTLE_END
  :                            114 
  :                            115 .byte*               $proc
  :                            116 ?    $do     .byte(1),       +       .byte(1, ?), 0, 0, 0
  :                            117              $note   8-bit value in 32-bit word
  :                            118              $end
  :                            119 
  :                            120 .half*               $proc
  :                            121 ?    $do     .half(1),       +       .half(1, ?), .half(1, ?)/*8, 0, 0
  :                            122              $note   16-bit value in 32-bit word
  :                            123              $end
  :                            124 
  :                            125 .word*               $proc
  :                            127 ?    $do     .word(1),       +       .word(1, ?),    .word(1, ?)/*8, |
                                        .word(1, ?)/*16,.word(1, ?)/*24
  :                            128              $end
  :                            129 
  :                            3 $(__data:0x3000)
  :                            4 $(__text:0x1000)
  :                            5 
  :                            6        .data
03:00003000 2247727565737365220A6175730A5361616E656E4C616E64
                              +7        .asciiz """Gruesse""\naus\nSaanenLand\"Pays\777\666d\'enHaut\r\n"
03:00003018 2250617973FFB66427656E486175740D0A000000
                              +7 
03:0000302C 4A756C6907080C0B09000000
                              +8        .asciiz "Juli\a\b\f\v\t"
Note: interlud.msm Line 9: exactly 3 octal symbols expected here
03:00003038 626973313453657074656D6265720A6C736F206B6F6D6D74
                              +9         .asciiz "bis\61\064September\x0also kommt\xc"
Note: interlud.msm Line 9: exactly 2 hexadecimal symbols expected here
03:00003050 0C000000          +9 
  :                            10 
03:00003054 5965687564690000  +11       .ascii  "Yehudi"
03:0000305C 20000000          +12 byte1 .byte   32
Note: interlud.msm Line 12: 8-bit value in 32-bit word
03:00003060 4D656E7568696E00  +13       .ascii  "Menuhin"
03:00003068 0A000000          +14 byte2 .byte   10
Note: interlud.msm Line 14: 8-bit value in 32-bit word
03:0000306C 466F7220657665720A000000
                              +15       .ascii  "For ever\n"
  :                            16 
03:00003078 456D696C69610000  +17       .asciiz "Emilia", "Kopatchinskaja"
03:00003080 4B6F7061746368696E736B616A610000
                              +17 
03:00003090 4C65696600000000  +18       .asciiz "Leif", "Ove", "Andsnes"
03:00003098 4F766500          +18 
03:0000309C 416E64736E657300  +18 
03:000030A4 536F6C00          +19       .asciiz "Sol", "Gabetta"
03:000030A8 4761626574746100  +19 
03:000030B0 43687269737469616E000000
                              +20       .asciiz "Christian", "Tetzlaff"
03:000030BC 5465747A6C61666600000000
                              +20 
03:000030C8 5665726F6E69636100000000
                              +21       .asciiz "Veronica", "Eberle"
03:000030D4 456265726C650000  +21 
  :                            22 
03:000030DC F4010000          +23 half1 .half   500
Note: interlud.msm Line 23: 16-bit value in 32-bit word
  :                            24 
03:000030E0 63000000          +25       .word   99, 100, 101
03:000030E4 64000000          +25 
03:000030E8 65000000          +25 
  :                            26 
  :                            27       .text
  :                            28 
  :                            29 usefully        $equ    0x18C
  :                            30 upward  $equ    65536
  :                            31 
01:00001000 8D250040          +32       lw      $5, 64($9)
01:00001004 0085001A          +33       div     $4, $5
01:00001008 0C000063          +34       jal     usefully
01:0000100C 08004000          +35       j       upward
  :                            36 
  :                            37       $end
:$(01):00001000:00001010 :$(03):00003000:000030EC 
interlud.msm: object code 623 bytes: 0 errors: 0 undefined labels

</pre>
<p>
Quote character is the masmx command to assemble a string.
<pre>

	""."one".10."two".10."three".10

</pre>
<p>
A string is composed of strings and other tokens joined with
the substring character. The line shown here assembles to
<pre>

	6F6E650A74776F0A74687265650A

</pre>
<p>
plus any padding to the next word.	

<h1>11: Tuning Macro Language and Fixing Problems</h1>

<h2> 11.1: Fixing a Macro Parameter Reference</h2>

<p>
If a macro appears unable to reference an actual parameter, equate a
local label to the parameter and reference the label (this problem won't
arise in an example as simple as this one):
<pre>

p	$proc
addo*	$name	0
subo*	$name	1

operand	$equ	p(1, 1)

	format	p(0, 0), operand
	$end

</pre>
<p>
It's in any case advisable to cache the parameters in local labels
if they are being referenced more than once. This is because the
actual parameter is not predictable to the macro, and referencing it
may, for example, cause functions to be called. One case of multiple
references to macro parameters is where range checks are carried out.

<h2> 11.2: Label Cannot Be Referenced</h2>

<p>
Another possible cause of confusion, is that a label can't be
referenced when it has been declared. This doesn't always mean that
the reference is spelled wrong. The cause is sometimes that the label
has remained local to a macro expansion. To be visible outside the
containing macro, the label must be promoted* with asterisks*
<pre>

p	$proc
generate* $name

"p(1, 1)_generated_name"***	. label is visible three macro nesting
				. levels higher than this level

	.
	.
	.

	$end

</pre>
<h2> 11.3: Changed Label Value Disappears</h2>

<p>
This is the same problem as the previous one. If you have
<pre>

macro1*	$proc
alabel	$set	SOMETHING
	macro2
	$end

macro2*	$proc
alabel	$set	SOMETHING_ELSE
	$end

</pre>
Calling <b>macro2</b> from <b>macro1</b> does not appear to change
<b>alabel</b>.

<p>
This is because two different labels have the name <b>alabel</b>.
If <b>macro2</b> must set <b>alabel</b> for <b>macro1</b>,
<b>macro2</b> must be coded like this, with an asterisk on <b>alabel*</b>
<pre>

macro2*	$proc
alabel*	$set	SOMETHING_ELSE
	$end

</pre>

<h2> 11.4: Tracing Macro Expansion</h2>

<p>
For monitoring the expansion of $PROC and $FUNC macros, see especially
Section 8.47.1: Interaction of Run Options and List Directives.

<p>
The path through macro language and presentation of actual parameters
to macros can be traced. <b>-p</b> Flag traces $PROC macro steps and
<b>-q</b> Flag traces $FUNC macro steps. Neither are traced unless $PLIST
directive has set a threshold higher than current macro nest depth:
<pre>

masmx	-lpq

	$plist	5

	.
	.

</pre>
<p>
Where assembly does not advance to the second assembly pass, <b>-r</b> flag
enables macro step display in the first assembly pass. Then the macro
step display is then shown out of listing context, because listings are
only produced on the second assembly pass.

<p>
See also Sections 8.48: $SNAP directive and 8.53: $TRACE directive.

<h2> 11.5: Aliasing masmx Internal Functions</h2>

<p>
If you want to give a new name to a masmx internal function <b>$ $a $b $n
$net $o $r $rel $t</b>
<pre>

absolute	$equ, $function		"$a"

</pre>
<p>
The quotes on the masmx function name, here <b>$a</b>, are necessary.

<p>
Without the quotes, absolute will not have the functional meaning
<b>$a</b>, but instead the value returned from <b>$a</b> at this
point in the assembly.


<h2> 11.6: Error Diagnostic about a Label Address</h2>


<p>
An error diagnostic is issued like the one in this assembly
<pre>

$masmx -l
MASMX 7r2
0/-INPUT>>
	$list	0
	$include 8051.def
CONT_CHAR=
LTERM=;
QDELIM='
STERM=.
	$list	2

first	var	size?

second	var	8

size?	equ	1024
	$end
  :                            677  $list 2
  :                            678 
  :                            679 first var size?
  :                            680 
SECOND [80000/40000]
Error: -INPUT>> Line 681: displacement changed between 1st and 2nd passes
Note: -INPUT>> Line 681: foregoing object has been sized by forward reference
  :                            681 second var 8
  :                            682 
  :                            683 size? equ 1024
  :                            684  $end
:$(01):0400:0808 
-INPUT>>: object code 20 bytes: 1 errors: 0 undefined labels

</pre>
<p>
The explanation and solution is: <b>size?</b> must be known when the buffer
<b>first</b> is declared. Sizes cannot be fixed by forward reference.

<p>
The problem is noticed with the label <b>second</b>, but the cause
of the problem is earlier.

<p>
The problem in the next assembly is similar, but the solution is different:
<pre>

$ masmx -l
MASMX 7r2
0/-INPUT>>

	$word	32

early	+	pattern
late	+	99
pattern	$equ	0800000000000
	$end
  :                            1 
  :                            2  $word 32
  :                            3 
00:00000000 0000800000000000  +4 early + pattern
LATE [2000000/1000000]
Error: -INPUT>> Line 5: displacement difference between 1st and 2nd passes
Note: -INPUT>> Line 5: foregoing object has been sized by forward reference
00:00000002 00000063          +5 late + 99
  :                            6 pattern $equ 0800000000000
  :                            7  $end
:$(00):00000000:00000003 
-INPUT>>: object code 71 bytes: 1 errors: 0 undefined labels
 
</pre>
<p>
The size of the integer <b>early</b> is unexpectedly two words.
The solution is to decide what size integer <b>early</b> should be:
<pre>

$ masmx -l
MASMX 7r2
0/-INPUT>>

	$word	32

early	+	pattern:d
late	+	99
pattern	$equ	0800000000000
	$end
  :                            1 
  :                            2  $word 32
  :                            3 
00:00000000 0000800000000000  +4 early + pattern:d
00:00000002 00000063          +5 late + 99
  :                            6 pattern $equ 0800000000000
  :                            7  $end
:$(00):00000000:00000003 
-INPUT>>: object code 71 bytes: 0 errors: 0 undefined labels

</pre>

<h2>11.7: Label fails to be Exported</h2>

<p>
Labels are not catalogued for listing or export if they are declared
or included while <b>$LIST</b> is zero

<p>
<b>$LIST</b> must be greater or less than zero when a label is declared
or binary-included for export

<p>
This example is a cumulative link which wants to pass labels in
the output binary. The labels imported from the input binary
<b>rel_file.txo</b> and the new label <b>location_after</b> are exported in
the output binary <b>new_rel.txo</b> because <b>$LIST</b> is other than 0
<pre>

	$list	0
	$include		linkrule.def
	$list	-1
	$include, $binary	rel_file
location_after*
	$list
	$store			new_rel	

</pre>
<p>
See also 8.28: <b>$LIST 0</b>, masking names from list and export


<h1>Appendix A: What's new in 7r2?</h1>
<ul>

Faster

<pre></pre>
More Stable

<pre></pre>
Address Schemes Better Integrated

<pre></pre>
Inconsistencies Removed

<pre></pre>
<b>$path</b> directive helps neat and efficient inclusion
across file trees.

<pre></pre>
Has Linker

<pre></pre>
Assembles gcc Output
<pre></pre>
Macros concealed in macros:

</ul>

<pre>

one*	$proc
two*	$proc
three*	$func
	$end
	$end
	$end

</pre>
<pre></pre>
$RES buffers (section 8.43) may be zero-filled instead of void

<pre></pre>
The command line option flags are newly case significant and there are now
28 of them: <b>-abcdefghijklmnopqrsuvwxyzQZ+</b>
(section 3.2: Command Line Options)


<h1>Appendix B: The masmx Product Road Map</h1>


<p>
One further tool is planned to convert relocatable Text Encoded Binaries
to ELF, because macro language alone cannot quite do this.

<p>
Further output converters like the already-packaged imx (irec)
and mmx (srec) may be distributed on request.

<p>
It is otherwise intended mainly to distribute macro source for new
targets on request.

<p>
All requests to masmx@gmx.ch



<h1>Appendix C: masmx's Potential for High Level Languages</h1>

<p>
masmx is independent of target architecture. It is possible for
compilers to generate a single macro language for masmx assembly
for any target.

<p>
Compilers can therefore be concentrated entirely on functionality
and need have no knowledge of architecture.

<p>
Tuning, efficiency, and architectural innovation then become matters
for the implementation of the single macro language per individual target.

<p>
The development of macro language for masmx requires no builds,
compilations or links. New macro definition is source and remains source:
<pre>


	__________________		______________________
	| source program |		| high level language |
	| in high level	 |------------->| compiler	      |
	| language       |		|_____________________|
	|________________|			   |
						   |
	_________________		___________|__________
	| macro language |		| application in macro|
	| target specific|		| language common to  |
	| definition     |		| all targets         |
	|________________|		|_____________________|
		 |				   |
		 |				   |
		 |				   |
		 |				   |
		 |				   |
	_________|_________________________________|___________
	|						      |
	|			masmx			      |
	|						      |
	|_____________________________________________________|
				   |
				   |
				   |
			___________|__________
			|		      |
			|  binary application |
			|		      |
			|_____________________|



</pre>
<p>
Developers using masmx can assign complex typing to identifiers
with the $EQUF directive. This is intended to assist high-level-language
implementation



<h1>Appendix D: Disclaimer and Contact</h1>


<p>
The executables in this package should not harm any
systems on which you run them. No responsibility is
accepted for them. They carry no garauntee.

<p>
These are free products.

<p>
Assistance can be requested at masmx@gmx.ch

<p>
Tim Cox
<p>
+41 78 629 86 11
<p>
01 January 2012

<i>
<pre>
_______________________________________________________________________________________


LICENCE NOTE

    Copyright Tim Cox, 2012
    TimMilesCox@gmx.ch

    This document describes the masmx.7r2 target-independent meta-assembler.

    masmx.7r2 is free software. It is licensed
    under the GNU General Public Licence Version 3

    You can redistribute it and/or modify masmx.7r2
    under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    masmx.7r2 is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with masm.7r2.  If not, see &lt;http://www.gnu.org/licenses/&gt;.

</i>
</pre>



</div>
