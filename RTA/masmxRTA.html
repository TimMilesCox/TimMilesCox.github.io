<html>

<div>

<center>
<h1>masmx.7r2 for RTA1</h1>

<i>
Copyright Tim Cox, 2012
<p>
This document is part of the RTA1 Processor Programmable Architecture Specification<br>
RTA1 is a free computer programmable architecture licensed under the GNU General Public Licence Version 3<br>

The same licence encompasses all software and documentation delivered with RTA1 Specification

<br>
The masmx.7r2 meta-assembler is free software separately licensed with the GNU General Public Licence Version 3

<br>
The full text of GNU General Public Licence Version 3 is included with these materials<br>
See also the licensing notice at the foot of this document

</i>
</center>

<div    style="color:FF0000;margin-left:280pt;font-size:14pt">

        please be aware:<br>
        this manual is still being written. All the others are now considered complete<br>
        to find examples of masmx code for RTA1:<br>
        complete source code and assembly listing of the smaragd7 kernel are in the repository RTA1<br>
</div>
<h2>Larger Document Link</h2>

This is a summary for programming RTA1

<p>
To see everything masmx does,
refer to <a href="http://timmilescox.github.io/masmx">
masmx documentation and download</a>

<p>
To see RTA architecture and instruction set in full,
refer to <a href="http://timmilescox.github.io/RTA/rta">
RTA Processor Programmable Architecture Specification</a>


<h2>Settings for RTA1</h2>

masmx is a target-independent meta-assembler.
Macro-language in <b>rta.def</b>
specifies registers and instructions to masmx

<p>
masmx default architectural settings are already
correct for RTA1 architecture. Constants can
be assembled without including <b>rta.def</b>

<p>
The RTA1 default settings already in masmx are
<pre>

        $word                   24
        $address_quantum        24
        $awidth                 24:48
        $floating_point         96
        $characteristic         24
        $characteristic,48      12
        $byte                   8

</pre>

masmx default byte size is 8 and data code is ASCII.
<b>$byte</b> and the data code can be changed during
an assembly

<p>
The second value of <b>$awidth</b> is for load addresses
beyond the address space. RTA1 executable space is larger
than the address space

<p>
masmx syntax element defaults are also
correct for RTA1
<pre>

	$lterm			'.'
	$sterm			':'
	$cont_char		';'			

</pre>



<p>
To change the data code see the main documentation of masmx



<h2>Numbers</h2>

<p>
Number constants have the default masmx syntax. Leading 0 means hex
<pre>

$(3:03000)
	
	$list	0
	$include	freeware/RTA1/rta/def/rta.def
	$list

        +       99
        -       101:d
        +       3071:t
        +       0ffffffEEEEEEffffffcccccc:q
        -       100000*/96:p

        +       1.75*+1200000

	$end
  :                            1 
  :                            2 $(3:03000)
  :                            3 
  :                            430  $list
  :                            431 
03:003000 000063              +432         +       99
03:003001 FFFFFFFFFF9B        +433         -       101:d
03:003003 000000000000000BFF  +434         +       3071:t
03:003006 FFFFFFEEEEEEFFFFFFCCCCCC
                              +435         +       0ffffffEEEEEEffffffcccccc:q
03:00300A FE7960000000000000000000000000
                              +436         -       100000*/96:p
  :                            437 
03:00300F 7CD38BB7B396D7AA20B6E083
                              +438         +       1.75*+1200000
  :                            439 
  :                            440  $end
:$(03):003000:003013 


</pre>
<p>
Fixed point numbers are autosized. masmx adds an extra word of signs
where the high order bit of the magnitude is not a sign.
Specific size can be suffixed
<pre>

$ masmx -ln
MASMX 7r2
0/-INPUT>>
	+	255*/16
	+	255*/16:s
	$end
00:000000 000000FF0000        +1  + 255*/16
00:000002 FF0000              +2  + 255*/16:s
  :                            3  $end
:$(00):000000:000003 


</pre>
The size suffixes are :s (one word) :d (two words) :t (three words)
:q (four words) :p (five words) :h (six words) :o (eight words)

<p>
:d and :l are synonymous. The size suffix does not always need a colon
but it is never wrong to type the colon. The size suffix can equally be
upper or lower case, whether the assembly is case-sensitive or not

<p>
A decimal point or the exponent operators <b>*+ *-</b> make a number
floating-point

<p>
Floating point numbers do not autosize.
They are four words.

<p>
The two-word suffix may be used to assemble a 48-bit
compressed floating constant which RTA1 can
expand to four words at the internal stack top with the
<b>floating push and expand</b> instruction <b>fpx</b>

<p>
RTA1 computes 96-bit floating-point but the <b>floating pop and pack</b>
instruction <b>fpp</b> can store the number in a 48-bit
floating format if that has enough range for its value
<pre>

	$ masmx -ln
MASMX 7r3
0/-INPUT>>

	$list		0
	$include	freeware/RTA1/rta/def/rta.def
	$list

$(0:64)

	fpx		(4.096:d*+200)		. this instruction loads the internal stack from storage
	fa		0, sp			. use the expanded number

	qs		0, sp
	fpp		compressed_storage	. compress the 4-word result
						. this instruction pops the internal stack to storage	
	$do		$<256,$(0:256)

$(3:03000)
compressed_storage $res	2
	$end
  :                            1 
  :                            429  $list
  :                            430 
  :                            431 $(0:64)
  :                            432 
00:000040 5F0100              +433  fpx  (4.096:d*+200)
00:000041 67F000              +434  fa  0, sp   . use the expanded number
  :                            435 
00:000042 47F000              +436  qs  0, sp
00:000043 573000              +437  fpp  compressed_storage . compress the 4-word result
  :                            438  
  :                            439  $do  $<256,$(0:256)
  :                            440 
  :                            441 $(3:03000)
  :                            442 compressed_storage $res 2
  :                            443  $end
00:000100+69BAB3C2FDDF
:$(00):000040:000102 :$(03):003000:003002 


</pre>

48-bit compressed floating format has only 11 exponent bits, so its range difference
from 96-bit compute-format is a larger difference that a difference in mantissa
precision
<pre>

	47 46        36 35                                      0
	__________________________________________________________
	|s|xxxxx xxxxxx|mmmmmm mmmmmm mmmmmm mmmmmm mmmmmm mmmmmm|
	|_|____________|_________________________________________|________________________________________________________
	|s|xxxxx xxxxxx xxxxxx xxxxxx|mmmmmm mmmmmm mmmmmm mmmmmm mmmmmm mmmmmm mmmmmm mmmmmm mmmmmm mmmmmm mmmmmm mmmmmm|
	|_|__________________________|___________________________________________________________________________________|
	95 94                      72 71                                                                                0

</pre>

<p>
RTA1 two- and four-word burst reads and writes are at any word address

<p>
It's foreseen that for network transfer native RTA1 96-bit and 48-bit numbers be
translated dynamically to and from XDR formats

<p>
However XDR and non-RTA1 machines can only represent a microscopic
part of RTA1 floating range. The exchange format for large numbers is
ASCII edit string




<h2>Literals</h2>

The floating-point assembly example also shows an automatic literal.
The two-word floating operand of the <b>fpx</b> instruction is assembled
at address 256, beyond the addresses of the RTA1 registers

<p>
A literal is a constant declared as an operand and
assembled at the end of a designated section

<p>
Literals look like immediate operands but are storage
constants of any size. The instruction contains their
address, not their value

<p>
An automatic literal is an operand starting and ending
with parenthesis. Automatic literals are  enabled with
assembly flag -a in <b>rta.def</b>
<pre>

	$set_option	"a"
	
</pre>
By default automatic literals are assembled at the end
of program section $(0)

<p>
The <b>$lit</b> directive may place automatic literals 
at the end of another program section
<pre>

[tag]	$lit	55

</pre>
A literal which is not automatic  has a literal pool
tag before the opening parenthesis
<pre>

$ masmx -lnz
MASMX 7r2
0/-INPUT>>

        $list   0
        $include        freeware/RTA1/rta/def/rta.def
        $list

$(3:03000/$literals3)
$(0:64)

	lx, xi		$literals3("this way to the gastronomy hall")

	$end
  :                            1 
  :                            428         $list
  :                            429 
  :                            430 $(3:03000/$literals3)
  :                            431 $(0:64)
  :                            432 
00:000040 553000              +433  lx, xi  $literals3("this way to the gastronomy hall")
  :                            434 
  :                            435  $end
03:003000+746869732077617920746F207468652067617374726F6E6F
6D792068616C6C0000
:$(00):000040:000041 :$(03):003000:00300B 

</pre>

<h2>More about Strings</h2>

The last literal example was a string. Bytes are any size you
say they are, padded with either zero or space to integral words
<pre>

$ masmx strings -ln
MASMX 7r2
3/strings.msm
*EOF*
  :                            1 	$set_option	"z"
00:000000 737472696E67        +2 	"string"
  :                            3 	$byte	12
00:000002 07307407206906E067  +4 	"string"
  :                            5 	$byte	16
00:000005 0073007400720069006E0067
                              +6 	"string"
  :                            7 	$byte	24
00:000009 00007300007400007200006900006E000067
                              +8 	"string"
  :                            9 	$byte	6
00:00000F CF4CA9BA7000        +10 	"string"
  :                            11 	$byte	7
Note: strings.msm Line 12: trailing zero bits in last data word of string
00:000011 E7D3969DD9C0        +12 	"string"
  :                            13 	$byte	8
00:000013 737472696E67        +14 	"string"
  :                            15 
*EOF*
:$(00):000000:000015 

</pre>
String padding is zero with option <b>-c</b> or <b>-z</b> and space
with neither or both <b>-cz</b>

<h2>$form Structures</h2>

Directive <b>$form</b> types structures up to 192 bits in size


<h2>Location Counters, Load Images, Banks and Address Windows</h2>

smaragd7 kernel may be embedded in a ROM system image including
applications, may be in a ROM which will load applications, or
may itself be loaded by a boot ROM

<h3>Location Counters</h3>

Location counters correspond to program sections. There are 72 location counters.
Their usage convention is

<p>
$(0) contains instruction code in bank B0 and a few constants which are locally visible only

<p>
Simplest assemblies have one B0 bank starting at program-visible address zero
<pre>

$(0)
name1	$vector	entry1
name2	$vector entry2
	$do	8-$,	fret	0	. unused vectors

entry1
	.
	.

</pre>
<p>
In a ROM system image, B0 load address is preassigned at image construction
<pre>

$(0::B0_LOAD_ADDRESS)


</pre>
<p>
If the application contains several instruction banks, $(0) declares all of them at
different load addresses. Their program-visible addresses are all based at address zero
<pre>


$(0:0:MY_BANK1_LOAD_ADDRESS)
	.
	.
	.
$(0:0:MY_BANK2_LOAD_ADDRESS)
	.
	.
	.


</pre>
Many B0-banks can't be coded interleaved, just one after the other, in one assembly or
several linked assemblies. Each separate B0 has its own literal table

<p>
$(1) contains private data in bank B1 starting at program-visible address 4096
<pre>

$(1:01000)

</pre>
smaragd7 kernel assigns at least one 4096 B1 bank at thread start, but does not place
any values in it. The application may assemble B1 at a read-only load-address in the
ROM system image, and copy the initial values on startup. In this example, part of B0
is a constant pool for initializing B1
<pre>

$ masmx aqt -ln
MASMX 7r3
3/aqt.msm
*EOF*
  :                            1: 	$include	freeware/RTA1/rta/def/rta.def
  :                            2: 	$include	freeware/RTA1/rta/language/stack.def
  :                            3 
  :                            4 
  :                            5 B0_LOAD_ADDRESS $equ	30*4096
  :                            6 
  :                            7 $(0::B0_LOAD_ADDRESS)
  :                            8 
  :                            9 $(1:01000:B0_LOAD_ADDRESS+3072)
01:001000 000063              +10 one	+	99
01:001001 000064              +11 two	+	100
01:001002 616263              +12 three	"abc"
  :                            13 
  :                            14 $(0)
00:000000 B60040              +15 entry1*	$vector	fireup
  :                            18 	$list
  :                            19 
00:000040 551000              +20 fireup	lx, xi	one
00:000041 5D0C00              +21 	ly, xi	3072
00:000042 4500BF              +22 	lr, xi	768/4-1
  :                            23 
  :                            24 fireup_quad
00:000043 8FB000              +25 	qpush	0, y
00:000044 87A000              +26 	qpop	0, x
00:000045 850004              +27 	ax, xi	4
00:000046 8D0004              +28 	ay, xi	4
00:000047 1E0043              +29 	jdr	fireup_quad
  :                            30 
  :                            31 	.
  :                            32 	.
  :                            33 
*EOF*
:$(00):000000:000048 :$(01):001000:001003 

</pre>

Assembling again with -d option lists the load addresses, which are not the
program-visible addresses
<pre>

$ masmx aqt -lnd
MASMX 7r3
3/aqt.msm
*EOF*
  :                            1: 	$include	freeware/RTA1/rta/def/rta.def
  :                            2: 	$include	freeware/RTA1/rta/language/stack.def
  :                            3 
  :                            4 
  :                            5 B0_LOAD_ADDRESS $equ	30*4096
  :                            6 
  :                            7 $(0::B0_LOAD_ADDRESS)
  :                            8 
  :                            9 $(1:01000:B0_LOAD_ADDRESS+3072)
01:01EC00 000063              +10 one	+	99
01:01EC01 000064              +11 two	+	100
01:01EC02 616263              +12 three	"abc"
  :                            13 
  :                            14 $(0)
00:01E000 B60040              +15 entry1*	$vector	fireup
  :                            18 	$list
  :                            19 
00:01E040 551000              +20 fireup	lx, xi	one
00:01E041 5D0C00              +21 	ly, xi	3072
00:01E042 4500BF              +22 	lr, xi	768/4-1
  :                            23 
  :                            24 fireup_quad
00:01E043 8FB000              +25 	qpush	0, y
00:01E044 87A000              +26 	qpop	0, x
00:01E045 850004              +27 	ax, xi	4
00:01E046 8D0004              +28 	ay, xi	4
00:01E047 1E0043              +29 	jdr	fireup_quad
  :                            30 
  :                            31 	.
  :                            32 	.
  :                            33 
*EOF*
:$(00):000000:000048 :$(01):001000:001003 


</pre>
$(2) contains the vector bank. smaragd7 constructs the 4096-word vector-bank on
process launch at program-visible address 8192 = 02000 hex, based as bank B2

<p>
$(2) is declared by including vector.def. It is common to the whole process and
contains elements which are shared between all threads. These include all handle
descriptors and pointers to all initial banks and entry points of this process.

<p>
Process RAM bank addresses are not known until the kernel stores their pointer
in the vector bank. Dynamic load programs also know their own B0 addresses from the
vector bank, which is necessary for multi-banked programs


<h3>ROM Total System Image</h3>

Total system images are simplest to construct, because all address
resolution is complete in the image construction


<h3>System with Independent Applications Load</h3>

A load area is chosen at load time for the program or shared instruction
bank

<p>
The only loadables which have a fixed location in storage are the booter
which must load at zero, and the kernel, which must load at 4096 to
program the internal interrupt vector locations. The booter and kernel
may be a single ROM image, and so may an entire system image with
applications

<p>
Applications otherwise load anywhere. Their addresses are internally
absolute because of hardware relocation

<p>
The loader places the program's bank identifiers and call vectors in the
program's vector bank at address window 02000..02FFF

<p>
There are four chief ways of using the location counter
control in RTA1


<h3>Simple Load Address</h3>
<pre>

$(4:address/literal_pool_name)

</pre>
<b>/literal_pool_name</b> is optional in these examples

<p>
In the first and simplest example the address is both the
program-relative address understood by the code, and also
load-region-relative address passed to the loader

<h3>Address Translated within Load Region</h3>
<p>
In the second example, the program-relative address is
followed by a <i>different</i> load-region-relative
address. The second address is passed to the loader
<pre>

$(0::0)

$(0::16384)

$(0::24576)

</pre>
These three banks are all at zero... but not all at once.
They are all instruction banks called at different times.
Their load addresses are in three different places, zero,
16K and 24K relative to whatever place the program is
loaded

<p>
Another use if this logical_space:load_address construct
is a variable data segment loaded as part of the code,
possibly included in a ROM. Initialisation must copy the
values to the variable space:
<pre>

$ masmx startup -ln
MASMX 7r2
3/startup.msm
*EOF*
  :                            1: 	$include	freeware/RTA1/rta/def/rta.def
  :                            2: 	$include	freeware/RTA1/rta/def/ii.def
  :                            3 
  :                            4 INTEGER_CONSTANT	$equ	99
  :                            5 FLOATING_MANTISSA	$equ	100100100100100100100
  :                            6 FLOATING_EXPONENT	$equ	1200000
  :                            7 
  :                            8 $(3:03000:16384+3072/bank3_literals)
  :                            9 
03:003000 000063              +10 one     +       INTEGER_CONSTANT
03:003001 737472696E6720636F6E7374616E74
                              +11 two            "string constant"
03:003006 7CD3CD8E6809AA7EBE381207
                              +12 three   +       FLOATING_MANTISSA*+FLOATING_EXPONENT
  :                            13 four	$res	800
  :                            14 
  :                            15 $(0::16384)
  :                            16 
00:000000 B60040              +17 	j	startup
  :                            20 	$list
  :                            21 
  :                            22 startup
00:000040 650400              +23 	la, xi	1024	. obtain variable memory
00:000041 750043              +24 	ii	BANK$
00:000042 C6004D              +25 	jza	"can't"
00:000043 340003              +26 	sabr	3	. base at window 03000
  :                            27 
00:000044 4500FF              +28 	lr, xi	1024/4-1
00:000045 5D0C00              +29 	ly, xi	3072
00:000046 553000              +30 	lx, xi	one
  :                            31 
  :                            32 transfer
00:000047 8FB000              +33 	qpush	0, y	. into the internal stack
00:000048 87A000              +34 	qpop	0, x	. into variable RAM
00:000049 850004              +35 	ax, xi	4
00:00004A 8D0004              +36 	ay, xi	4
00:00004B 1E0047              +37 	jdr	transfer
  :                            38 
00:00004C 3D0001              +39 ready	fret	1	. good result
  :                            40 
  :                            41 "can't"
00:00004D 3D0000              +42 	fret	0	. less good result
*EOF*
:$(00):000000:00004E :$(03):003000:00332A 

</pre>
Here the instruction bank at load address 16K (but program-relative address
zero) has 1K words initial data values at program-relative address 3K (load
address 16K + 3K)

<p>
The variables appear to code at addresses 03000 (12K). Initialisation copies
the values to RAM at program-relative address 12K

<p>
Instruction banks have a jump pad of 64 locations or eight locations at the
start, so this bank started with a jump

<h3>Address Translated within Giant Structure</h3>
<p>
A variation on the load-region-relative address is the very large
load-region-relative address, indicated by a <b>*</b>
<pre>

$(31::*00000A000000)

</pre>
This can be used where data or code loads to a load-region-relative
address higher than the 16-megaword address space

<p>
A normalised long pointer is used here to access data via a 48-bit address
<pre>

$ masmx alaska -lnk
MASMX 7r2
3/alaska.msm
*EOF*
  :                            1: 	$include	freeware/RTA1/rta/def/rta.def
  :                            2 
  :                            3 f	$func
  :                            4 pointer* $name
  :                            5 	$return	1*/46++f(1, 1)**0003FFFC0000*/12++$r(f(1, 1))*/18++f(1, 1)**03FFFF
  :                            6 	$end
  :                            7 
  :                            8 BASE	$set	42
  :                            9 
  :                            10 $(BASE::*03C000000)
2A:00003C000000:000063        +11 neck	+	99
2A:00003C000001:000065        +12 mutton	+	101
  :                            13 
  :                            14 $(0:64)
  :                            15 
00:000040 CF0100              +16 	dl	(pointer(mutton))
00:000041 34002A              +17 	sabr	BASE
00:000042 60D000              +18 	la	0, b
  :                            19 
  :                            20 	$do	$<256,$(0:256)
  :                            21 
*EOF*
00:000100+43C000A80001
:$(00):000040:000102 :$(2A):000000:000002 


</pre>
<p>
A very large RTA address is 48 bits in size. This accommodates the
16-gigaword executable space and any future executable space up to
256 terawords

<p>
A data array might be loaded to an area much larger than the address
space. See <b>Appendix A: Giant Structures in Memory</b>

<h3>Relocatable Sections</h3>

Relocatable code must be made absolute before passing to the load
string formatter <b>lstring</b>

<p>
Linking is a further assembly which includes
binary in the Text-Encoded-Object format *.txo

<p>
See <b>Appendix B: masmx Linking for RTA1</b>


<h2>Appendix A: Giant Structures in Memory</h2>

<h2>Appendix B: masmx Linking for RTA1</h2>





_____________________________________________________________________
<pre>
<i>

    LICENCE NOTICE


    Copyright Tim Cox, 2012
    TimMilesCox@gmx.ch

    This document is part of the RTA1 processor programmable
    architecture.

    RTA1 is a free processor architecture specification.
    It is licensed under the GNU General Public Licence Version 3

    The executable emulation of RTA1 is free software.

    Instruction code for the target RTA1 architecture is free software
    if it is delivered with this software

    Software programs delivered with this software to connect the
    emulated RTA1 with real network interfaces in the emulator host
    are free software

    Scripts and programs delivered with this software for running
    on other computers and interacting with the RTA1 are free software

    The masmx target-independent meta-asembler delivered here
    is free software whether it is used for constructing RTA1 code
    or any other code. masmx is a separate free program by the
    same author and included with this software to save searching for it

    Scripts and utility programs for constructing RTA1 target
    executable software are free software

    You can redistribute it and/or modify RTA1
    under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    RTA1 is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with RTA1.  If not, see &lt;http://www.gnu.org/licenses/&gt;.

</i>
</pre>


</div>
</html>
