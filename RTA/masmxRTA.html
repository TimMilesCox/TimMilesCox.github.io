<html>
<div>

<center>
<h1>masmx.7r2 for RTA1</h1>

<i>
Copyright Tim Cox, 2012
<p>
This document is part of the RTA1 Processor Programmable Architecture<br>
RTA1 is a free computer programmable architecture licensed under the GNU General Public Licence Version 3<br>

The same licence encompasses all software and documentation delivered with RTA1 Specification

<p>
The masmx.7r2 meta-assembler is free software separately licensed with the GNU General Public Licence Version 3

<p>
The full text of GNU General Public Licence Version 3 is included with these materials<br>
See also the licensing notice at the foot of this document

</i>
</center>

<h2>Larger Document Link</h2>

This is a summary for programming RTA1

<p>
To see everything masmx does,
refer to <a href="http://timmilescox.github.io/masmx">
masmx documentation and download</a>

<p>
To see RTA architecture and instruction set in full,
refer to <a href="http://timmilescox.github.io/RTA/rta">
RTA Processor Programmable Architecture Specification</a>


<h2>Settings for RTA1</h2>

masmx is a target-independent meta-assembler.
Macro-language in <b>rta.def</b>
specifies registers and instructions to masmx

<p>
masmx default architectural settings are already
correct for RTA1 architecture. Constants can
be assembled without including <b>rta.def</b>

<p>
The RTA1 default settings already in masmx are
<pre>

        $word                   24
        $address_quantum        24
        $awidth                 24:48
        $floating_point         96
        $characteristic         24
        $characteristic,48      12
        $byte                   8

</pre>

masmx default byte size is 8 and data code is ASCII.
<b>$byte</b> and the data code can be changed during
an assembly

<p>
The second value of <b>$awidth</b> is for load addresses
beyond the address space. RTA1 executable space is larger
than the address space

<p>
To change the data code see the main documentation of masmx



<h2>Numbers</h2>

<p>
Number constants have the default masmx syntax
<pre>

$(3:03000)
	
	$list	0
	$include	freeware/RTA1/rta/def/rta.def
	$list

        +       99
        -       101:d
        +       3071:t
        +       0ffffffEEEEEEffffffcccccc:q
        -       100000*/96:p

        +       1.75*+1200000

	$end
  :                            1 
  :                            2 $(3:03000)
  :                            3 
  :                            430  $list
  :                            431 
03:003000 000063              +432         +       99
03:003001 FFFFFFFFFF9B        +433         -       101:d
03:003003 000000000000000BFF  +434         +       3071:t
03:003006 FFFFFFEEEEEEFFFFFFCCCCCC
                              +435         +       0ffffffEEEEEEffffffcccccc:q
03:00300A FE7960000000000000000000000000
                              +436         -       100000*/96:p
  :                            437 
03:00300F 7CD38BB7B396D7AA20B6E083
                              +438         +       1.75*+1200000
  :                            439 
  :                            440  $end
:$(03):003000:003013 


</pre>
<p>
Fixed point numbers are autosized. masmx adds an extra word of signs
where the high order bit of the magnitude is not a sign.
Specific size can be suffixed
<pre>

$ masmx -ln
MASMX 7r2
0/-INPUT>>
	+	255*/16
	+	255*/16:s
	$end
00:000000 000000FF0000        +1  + 255*/16
00:000002 FF0000              +2  + 255*/16:s
  :                            3  $end
:$(00):000000:000003 


</pre>
The size suffixes are :s (one word) :d (two words) :t (three words)
:q (four words) :p (five words) :h (six words) :o (eight words)

<p>
Floating point numbers do not autosize.
They are four words.

<p>
Suffixes can can also be used to make floating point numbers
another size, but the only usable size different from 96 bits
for an RTA1 floating constant is 48 bits or two words

<p>
This produces a compressed floating constant which RTA1 can
expand to four words at the internal stack top with the
<b>floating push and expand</b> instruction. RTA1 computes
96-bit floating-point but can store in a 48-bit floating
format if that has enough range for the value
<pre>

:$(00):000040:000102 
mx -ln
MASMX 7r2
0/-INPUT>>

        $list   0
        $include        freeware/RTA1/rta/def/rta.def
        $list

$(0:64)

        fpx             (4.096:d*+200)

	$do	        $<256,$(0:256)
	$end
  :                            1 
  :                            428         $list
  :                            429 
  :                            430 $(0:64)
  :                            431 
00:000040 5F0100              +432         fpx             (4.096:d*+200)
  :                            433 
  :                            434  $do  $<256,$(0:256)
  :                            435  $end
00:000100+69BAB3C2FDDF
:$(00):000040:000102 


</pre>

<h2>Literals</h2>

That example also shows an automatic literal. The two-word
floating operand of the <b>fpx</b> instruction is assembled
at address 256, beyond the addresses of the RTA1 registers

<p>
A literal is a constant declared as an operand and
assembled at the end of a designated section

<p>
Literals look like immediate operands but are storage
constants of any size. The instruction contains their
address, not their value

<p>
An automatic literal is an operand starting and ending
with parenthesis. Automatic literals are  enabled with
assembly flag -a in <b>rta.def</b>
<pre>

	$set_option	"a"
	
</pre>
By default automatic literals are assembled at the end
of program section $(0)

<p>
The <b>$lit</b> directive may place automatic literals 
at the end of another program section
<pre>

[tag]	$lit	55

</pre>
A literal which is not automatic  has a literal pool
tag before the opening parenthesis
<pre>

$ masmx -lnz
MASMX 7r2
0/-INPUT>>

        $list   0
        $include        freeware/RTA1/rta/def/rta.def
        $list

$(3:03000/$literals3)
$(0:64)

	lx, xi		$literals3("this way to the gastronomy hall")

	$end
  :                            1 
  :                            428         $list
  :                            429 
  :                            430 $(3:03000/$literals3)
  :                            431 $(0:64)
  :                            432 
00:000040 553000              +433  lx, xi  $literals3("this way to the gastronomy hall")
  :                            434 
  :                            435  $end
03:003000+746869732077617920746F207468652067617374726F6E6F
6D792068616C6C0000
:$(00):000040:000041 :$(03):003000:00300B 

</pre>

<h2>More about Strings</h2>

The last literal example was a string. Bytes are any size you
say they are, padded with either zero or space to integral words
<pre>

$ masmx strings -ln
MASMX 7r2
3/strings.msm
*EOF*
  :                            1 	$set_option	"z"
00:000000 737472696E67        +2 	"string"
  :                            3 	$byte	12
00:000002 07307407206906E067  +4 	"string"
  :                            5 	$byte	16
00:000005 0073007400720069006E0067
                              +6 	"string"
  :                            7 	$byte	24
00:000009 00007300007400007200006900006E000067
                              +8 	"string"
  :                            9 	$byte	6
00:00000F CF4CA9BA7000        +10 	"string"
  :                            11 	$byte	7
Note: strings.msm Line 12: trailing zero bits in last data word of string
00:000011 E7D3969DD9C0        +12 	"string"
  :                            13 	$byte	8
00:000013 737472696E67        +14 	"string"
  :                            15 
*EOF*
:$(00):000000:000015 

</pre>
String padding is zero with option <b>-c</b> or <b>-z</b> and space
with neither or both <b>-cz</b>

<h2>Constructing Banks and Address Windows</h2>

A load area is chosen at load time for the program or shared instruction
bank

<p>
The only loadables which have a fixed location in storage are the booter
which must load at zero, and the kernel, which must load at 4096 to
program the internal interrupt vector locations. The booter and kernel
may be a single ROM image, and so may an entire system image with
applications

<p>
Applications otherwise load anywhere. Their addresses are internally
absolute because of hardware relocation

<p>
The loader places the program's bank identifiers and call vectors in the
program's vector bank at address window 02000..02FFF

<p>
There are four chief ways of using the location counter
control in RTA1


<h3>Simple Load Address</h3>
<pre>

$(4:address/literal_pool_name)

</pre>
<b>/literal_pool_name</b> is optional in these examples

<p>
In the first and simplest example the address is both the
program-relative address understood by the code, and also
load-region-relative address passed to the loader

<h3>Address Translated within Load Region</h3>
<p>
In the second example, the program-relative address is
followed by a <i>different</i> load-region-relative
address. The second address is passed to the loader
<pre>

$(0::0)

$(0::16384)

$(0::24576)

</pre>
These three banks are all at zero... but not all at once.
They are all instruction banks called at different times.
Their load addresses are in three different places, zero,
16K and 24K relative to whatever place the program is
loaded

<p>
Another use if this logical_space:load_address construct
is a variable data segment loaded as part of the code,
possibly included in a ROM. Initialisation must copy the
values to the variable space:
<pre>

$ masmx startup -ln
MASMX 7r2
3/startup.msm
*EOF*
  :                            1: 	$include	freeware/RTA1/rta/def/rta.def
  :                            2: 	$include	freeware/RTA1/rta/def/ii.def
  :                            3 
  :                            4 INTEGER_CONSTANT	$equ	99
  :                            5 FLOATING_MANTISSA	$equ	100100100100100100100
  :                            6 FLOATING_EXPONENT	$equ	1200000
  :                            7 
  :                            8 $(3:03000:16384+3072/bank3_literals)
  :                            9 
03:003000 000063              +10 one     +       INTEGER_CONSTANT
03:003001 737472696E6720636F6E7374616E74
                              +11 two            "string constant"
03:003006 7CD3CD8E6809AA7EBE381207
                              +12 three   +       FLOATING_MANTISSA*+FLOATING_EXPONENT
  :                            13 four	$res	800
  :                            14 
  :                            15 $(0::16384)
  :                            16 
00:000000 B60040              +17 	j	startup
  :                            20 	$list
  :                            21 
  :                            22 startup
00:000040 650400              +23 	la, xi	1024	. obtain variable memory
00:000041 750043              +24 	ii	BANK$
00:000042 C6004D              +25 	jza	"can't"
00:000043 340003              +26 	sabr	3	. base at window 03000
  :                            27 
00:000044 4500FF              +28 	lr, xi	1024/4-1
00:000045 5D0C00              +29 	ly, xi	3072
00:000046 553000              +30 	lx, xi	one
  :                            31 
  :                            32 transfer
00:000047 8FB000              +33 	qpush	0, y	. into the internal stack
00:000048 87A000              +34 	qpop	0, x	. into variable RAM
00:000049 850004              +35 	ax, xi	4
00:00004A 8D0004              +36 	ay, xi	4
00:00004B 1E0047              +37 	jdr	transfer
  :                            38 
00:00004C 3D0001              +39 ready	fret	1	. good result
  :                            40 
  :                            41 "can't"
00:00004D 3D0000              +42 	fret	0	. less good result
*EOF*
:$(00):000000:00004E :$(03):003000:00332A 

</pre>
Here the instruction bank at load address 16K (but program-relative address
zero) has 1K words initial data values at program-relative address 3K (load
address 16K + 3K)

<p>
The variables appear to code at addresses 03000 (12K). Initialisation copies
the values to RAM at program-relative address 12K

<p>
Instruction banks have a jump pad of 64 locations or eight locations at the
start, so this bank started with a jump

<h3>Address Translated within Giant Structure</h3>
<p>
A variation on the load-region-relative address is the very large
load-region-relative address, indicated by a <b>*</b>
<pre>

$(31::*00000A000000)

</pre>
This can be used where data or code loads to a load-region-relative
address higher than the 16-megaword address space

<p>
A normalised long pointer is used here to access data via a 48-bit address
<pre>

$ masmx alaska -lnk
MASMX 7r2
3/alaska.msm
*EOF*
  :                            1: 	$include	freeware/RTA1/rta/def/rta.def
  :                            2 
  :                            3 f	$func
  :                            4 pointer* $name
  :                            5 	$return	1*/46++f(1, 1)**0003FFFC0000*/12++$r(f(1, 1))*/18++f(1, 1)**03FFFF
  :                            6 	$end
  :                            7 
  :                            8 BASE	$set	42
  :                            9 
  :                            10 $(BASE::*03C000000)
2A:00003C000000:000063        +11 neck	+	99
2A:00003C000001:000065        +12 mutton	+	101
  :                            13 
  :                            14 $(0:64)
  :                            15 
00:000040 CF0100              +16 	dl	(pointer(mutton))
00:000041 34002A              +17 	sabr	BASE
00:000042 60D000              +18 	la	0, b
  :                            19 
  :                            20 	$do	$<256,$(0:256)
  :                            21 
*EOF*
00:000100+43C000A80001
:$(00):000040:000102 :$(2A):000000:000002 


</pre>
<p>
A very large RTA address is 48 bits in size. This accommodates the
16-gigaword executable space and any future executable space up to
256 terawords

<p>
A data array might be loaded to an area much larger than the address
space. See <b>Appendix A: Giant Structures in Memory</b>

<h3>Relocatable Sections</h3>

Relocatable code must be made absolute before passing to the load
string formatter <b>lstring</b>

<p>
Linking is a further assembly which is able to include relocatable
binary in the Text-Encoded-Object format *.txo

<p>
See <b>Appendix B: masmx Linking for RTA1</b>


<h2>Appendix A: Giant Structures in Memory</b>

<h2>Appendix B: masmx Linking for RTA1</h2>

<pre>



</pre>

_____________________________________________________________________
<pre>
<i>

    LICENCE NOTICE


    Copyright Tim Cox, 2012
    TimMilesCox@gmx.ch

    This document is part of the RTA1 processor programmable
    architecture.

    RTA1 is a free processor architecture specification.
    It is licensed under the GNU General Public Licence Version 3

    The executable emulation of RTA1 is free software.

    Instruction code for the target RTA1 architecture is free software
    if it is delivered with this software

    Software programs delivered with this software to connect the
    emulated RTA1 with real network interfaces in the emulator host
    are free software

    Scripts and programs delivered with this software for running
    on other computers and interacting with the RTA1 are free software

    The masmx target-independent meta-asembler delivered here
    is free software whether it is used for constructing RTA1 code
    or any other code. masmx is a separate free program by the
    same author and included with this software to save searching for it

    Scripts and utility programs for constructing RTA1 target
    executable software are free software

    You can redistribute it and/or modify RTA1
    under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    RTA1 is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with RTA1.  If not, see &lt;http://www.gnu.org/licenses/&gt;.

</i>
</pre>


</div>
</html>
