<html>

<div>

<center>
<h1>masmx.7r2 for RTA1</h1>

<i>
Copyright Tim Cox, 2012
<p>
This document is part of the RTA1 Processor Programmable Architecture Specification<br>
RTA1 is a free computer programmable architecture licensed under the GNU General Public Licence Version 3<br>

The same licence encompasses all software and documentation delivered with RTA1 Specification

<br>
The masmx.7r2 meta-assembler is free software separately licensed with the GNU General Public Licence Version 3

<br>
The full text of GNU General Public Licence Version 3 is included with these materials<br>
See also the licensing notice at the foot of this document

</i>
</center>

<h2>Larger Document Link</h2>

This is a summary for programming RTA1

<p>
To see everything masmx does,
refer to <a href="http://timmilescox.github.io/masmx">
masmx documentation and download</a>

<p>

For RTA1 assembly examples,        
Complete source code and assembly listing of the smaragd7 kernel and of some application protocols are in the repository RTA1

<p>
To see RTA architecture and instruction set specification,
refer to <a href="http://timmilescox.github.io/RTA/rta">
RTA Processor Programmable Architecture Specification</a>

<p>
Or on your emulated machine <b>http://172.29.7.7:8080</b> and hit the architecture specification button <b>rta</b>

<h2>Settings for RTA1</h2>

masmx is a target-independent meta-assembler.
Macro-language in <b>rta.def</b>
specifies registers and instructions to masmx

<p>
masmx default architectural settings are already
correct for RTA1 architecture. Constants can
be assembled without including <b>rta.def</b>

<p>
The RTA1 default settings already in masmx are
<pre>

        $word                   24
        $address_quantum        24
        $awidth                 24:48
        $floating_point         96
        $characteristic         24
        $characteristic,48      12
        $byte                   8

</pre>

masmx default byte size is 8 and data code is ASCII.
<b>$byte</b> and the data code can be changed during
an assembly

<p>
To change the data code see the main documentation of masmx

<p>
The second value of <b>$awidth</b> is for load addresses
beyond the address space. RTA1 executable space is larger
than the address space

<p>
masmx syntax element defaults are also
correct for RTA1
<pre>

	$lterm			'.'	. comments follow PERIOD SPACE
	$sterm			':'	. substrings are lexical:divisions
	$cont_char		';'	. line continuation sentinel

</pre>




<h2>Numbers</h2>

<p>
Number constants have the default masmx syntax. Leading 0 means hex
<pre>

$(3:03000)
	
	$list	0
	$include	freeware/RTA1/rta/def/rta.def
	$list

        +       99
        -       101:d
        +       3071:t
        +       0ffffffEEEEEEffffffcccccc:q
        -       100000*/96:p

        +       1.75*+1200000

	$end
  :                            1 
  :                            2 $(3:03000)
  :                            3 
  :                            430  $list
  :                            431 
03:003000 000063              +432         +       99
03:003001 FFFFFFFFFF9B        +433         -       101:d
03:003003 000000000000000BFF  +434         +       3071:t
03:003006 FFFFFFEEEEEEFFFFFFCCCCCC
                              +435         +       0ffffffEEEEEEffffffcccccc:q
03:00300A FE7960000000000000000000000000
                              +436         -       100000*/96:p
  :                            437 
03:00300F 7CD38BB7B396D7AA20B6E083
                              +438         +       1.75*+1200000
  :                            439 
  :                            440  $end
:$(03):003000:003013 


</pre>
<p>
Fixed point numbers are autosized. masmx adds an extra word of signs
where the high order bit of the magnitude is not a sign.
Specific size can be suffixed
<pre>

$ masmx -ln
MASMX 7r2
0/-INPUT>>
	+	255*/16
	+	255*/16:s
	$end
00:000000 000000FF0000        +1  + 255*/16
00:000002 FF0000              +2  + 255*/16:s
  :                            3  $end
:$(00):000000:000003 


</pre>
The size suffixes are :s (one word) :d (two words) :t (three words)
:q (four words) :p (five words) :h (six words) :o (eight words)

<p>
:d and :l are synonymous. The size suffix does not always need a colon
but it is never wrong to type the colon. The size suffix can equally be
upper or lower case, whether the assembly is case-sensitive or not

<p>
A decimal point or the exponent operators <b>*+ *-</b> make a number
floating-point

<p>
Integers are twos-complement negative and floating numbers are 1s-complement negative
<pre>

	$ masmx -ln
MASMX 7r3
0/-INPUT>>
	-       6
	-	0.5
	$end
00:000000 FFFFFA              +1  - 6
00:000001 BFFFFF7FFFFFFFFFFFFFFFFF
                              +2  - 0.5
  :                            3  $end
:$(00):000000:000005 


</pre>
The floating mantissa is a simple fraction.
Its integral part is derived by hauling the mantissa
upwards through the fractional point the number of
positions by which the exponent exceeds the midpoint
value <b>0400000</b>
<pre>

	$ masmx -ln
MASMX 7r3
0/-INPUT>>
	+	1.5
	$end
00:000000 400001C00000000000000000
                              +1  + 1.5
  :                            2  $end
:$(00):000000:000004 


</pre>
Floating point numbers do not autosize.
They are four words
<pre>


		$ masmx -ln
MASMX 7r3
0/-INPUT>>
	+	1.75*+1250000
	+	1.75*-1250000
	$end
00:000000 7F5C5BF331AD4B6FFBBCAAB2
                              +1  + 1.75*+1250000
00:000004 00A3A7CE52225BC80EDFF592
                              +2  + 1.75*-1250000
  :                            3  $end
:$(00):000000:000008 


</pre>
<p>
The two-word suffix may be used to assemble a 48-bit
compressed floating constant which RTA1 can
expand to four words at the internal stack top with the
<b>floating push and expand</b> instruction <b>fpx</b>

<p>
RTA1 computes 96-bit floating-point but the <b>floating pop and pack</b>
instruction <b>fpp</b> can store the number in a 48-bit
floating format if that has enough range for its value
<pre>

	$ masmx -ln
MASMX 7r3
0/-INPUT>>

	$list		0
	$include	freeware/RTA1/rta/def/rta.def
	$list

$(0:64)

	fpx		(4.096:d*+200)		. this instruction loads the internal stack from storage
	fa		0, sp			. use the expanded number

	qs		0, sp
	fpp		compressed_storage	. compress the 4-word result
						. this instruction pops the internal stack to storage	
	$do		$<256,$(0:256)

$(3:03000)
compressed_storage $res	2
	$end
  :                            1 
  :                            429  $list
  :                            430 
  :                            431 $(0:64)
  :                            432 
00:000040 5F0100              +433  fpx  (4.096:d*+200)
00:000041 67F000              +434  fa  0, sp   . use the expanded number
  :                            435 
00:000042 47F000              +436  qs  0, sp
00:000043 573000              +437  fpp  compressed_storage . compress the 4-word result
  :                            438  
  :                            439  $do  $<256,$(0:256)
  :                            440 
  :                            441 $(3:03000)
  :                            442 compressed_storage $res 2
  :                            443  $end
00:000100+69BAB3C2FDDF
:$(00):000040:000102 :$(03):003000:003002 


</pre>

48-bit compressed floating format has only 11 exponent bits, so its range difference
from 96-bit compute-format is a larger difference that a difference in mantissa
precision
<pre>

	47 46        36 35                                      0
	__________________________________________________________
	|s|xxxxx xxxxxx|mmmmmm mmmmmm mmmmmm mmmmmm mmmmmm mmmmmm|
	|_|____________|_________________________________________|________________________________________________________
	|s|xxxxx xxxxxx xxxxxx xxxxxx|mmmmmm mmmmmm mmmmmm mmmmmm mmmmmm mmmmmm mmmmmm mmmmmm mmmmmm mmmmmm mmmmmm mmmmmm|
	|_|__________________________|___________________________________________________________________________________|
	95 94                      72 71                                                                                0

</pre>

<p>
RTA1 two- and four-word burst reads and writes are at any word address

<p>
It's foreseen that for network transfer native RTA1 96-bit and 48-bit numbers be
translated dynamically to and from XDR formats

<p>
However XDR and non-RTA1 machines can only represent a microscopic
part of RTA1 floating range. The exchange format for large numbers is
ASCII edit string




<h2>Literals</h2>

The last floating-point assembly example also shows an automatic literal.
The two-word floating operand of the <b>fpx</b> instruction is assembled
at address 256, beyond the addresses of the RTA1 registers

<p>
A literal is a constant declared as an operand and
assembled at the end of a designated section

<p>
Literals look like immediate operands but are storage
constants of any size. The instruction contains their
address, not their value

<p>
An automatic literal is an operand starting and ending
with parenthesis. Automatic literals are  enabled with
assembly flag -a in <b>rta.def</b>
<pre>

	$set_option	"a"
	
</pre>
By default automatic literals are assembled at the end
of program section $(0)

<p>
The <b>$lit</b> directive may place automatic literals 
at the end of another program section
<pre>

[tag]	$lit	55

</pre>
A literal which is not automatic  has a literal pool
tag before the opening parenthesis
<pre>

$ masmx -lnz
MASMX 7r2
0/-INPUT>>

        $list   0
        $include        freeware/RTA1/rta/def/rta.def
        $list

$(3:03000/$literals3)
$(0:64)

	lx, xi		$literals3("this way to the gastronomy hall")

	$end
  :                            1 
  :                            428         $list
  :                            429 
  :                            430 $(3:03000/$literals3)
  :                            431 $(0:64)
  :                            432 
00:000040 553000              +433  lx, xi  $literals3("this way to the gastronomy hall")
  :                            434 
  :                            435  $end
03:003000+746869732077617920746F207468652067617374726F6E6F
6D792068616C6C0000
:$(00):000040:000041 :$(03):003000:00300B 

</pre>

<h2>More about Strings</h2>

The last literal example was a string. Bytes are any size you
say they are, default 8-bits, padded with either zero or space to integral words
<pre>

$ masmx strings -ln
MASMX 7r2
3/strings.msm
*EOF*
  :                            1 	$set_option	"z"
00:000000 737472696E67        +2 	"string"
  :                            3 	$byte	12
00:000002 07307407206906E067  +4 	"string"
  :                            5 	$byte	16
00:000005 0073007400720069006E0067
                              +6 	"string"
  :                            7 	$byte	24
00:000009 00007300007400007200006900006E000067
                              +8 	"string"
  :                            9 	$byte	6
00:00000F CF4CA9BA7000        +10 	"string"
  :                            11 	$byte	7
Note: strings.msm Line 12: trailing zero bits in last data word of string
00:000011 E7D3969DD9C0        +12 	"string"
  :                            13 	$byte	8
00:000013 737472696E67        +14 	"string"
  :                            15 
*EOF*
:$(00):000000:000015 

</pre>
String padding is zero with option <b>-c</b> or <b>-z</b> and space
with neither or both <b>-cz</b>

<p>
In <b>masmx.7r3</b> the masmx-internal label <b>$bits</b> contains
the number of bits containing the characters in the string after the
string is assembled. This does not include word-fill padding<pre>

$ masmx -lnz
MASMX 7r3
0/-INPUT>>
	"abcd"
	+	$bits
	+	$bits/$byte
	$end
00:000000 616263640000        +1  "abcd"
00:000002 000020              +2  + $bits
00:000003 000004              +3  + $bits/$byte
  :                            4  $end
:$(00):000000:000004 

</pre>

<h2>$form Structures</h2>

Directive <b>$form</b> types structures up to 192 bits in size


<h2>Location Counters, Load Images, Banks and Address Windows</h2>

<h3>Location Counters</h3>

Location counters correspond to program sections. There are 72 location counters.
Their usage convention is

<p>
$(0) contains instruction code in bank B0 and a few constants which are locally visible only

<p>
Simplest assemblies have one B0 bank starting at program-visible address zero
<pre>

$(0)
name1	$vector	entry1
name2	$vector entry2
	$do	8-$,	fret	0	. unused vectors

entry1
	.
	.

</pre>
<p>
In a ROM system image, absolute address zero is not available for an application. B0 load address is preassigned at image construction
<pre>

$(0::B0_LOAD_ADDRESS)


</pre>
<p>
If the application contains several instruction banks, $(0) declares all of them at
different load addresses. Their program-visible addresses are all based at address zero
<pre>


$(0::0)

$(0::16384)

$(0::24576)


</pre>
This is called breakpointing. Each new load address makes a new B0.
Each new bank has its own literal table. In a ROM application, the
breakpoint addresses are the absolute load addresses. In a loadable
application, the breakpoint addresses are relative to the RAM region
where the code is loaded

<p>
All locators can be breakpointed for multiple instances, but some
have special uses where breakpointing would not be useful 

<p>
$(1) contains private data in bank B1 starting at program-visible address 4096
<pre>

$(1:01000)

</pre>
smaragd7 kernel assigns at least one 4096 B1 bank at thread start, but does not place
any values in it. The application may assemble B1 at a read-only load-address in the
ROM system image, and copy the initial values on startup.

<p>
$(2) contains the vector bank. smaragd7 constructs the 4096-word vector-bank on
process launch at program-visible address 8192 = 02000 hex, based as bank B2

<p>
$(2) is declared by including vector.def. It is common to the whole process and
contains elements which are shared between all threads. These include all handle
descriptors and pointers to all initial banks and entry points of this process.

<p>
$(3) is assigned by the kernel to contain the program data in address windows
B3..B31

<p>
However at process start B3 is not based and the program's RAM initial data is not loaded

<p>
A typical ROM application memory configuration is
<pre>

	$include	def/rta.def
	$include	def/vector.def		. this defines the vector bank
						. in address window 02000

$(0::INSTRUCTIONS_LOAD_ADDRESS)
$(1:01000)					. private RAM
	+	variables
$(3:03000)					. application RAM
	+	data

$(0)
callname* $vector get_going
	$do	64-$,	fret	0

get_going
	$base_d	MY_APPLICATION_DATA_SIZE	. this macro reads VECTOR_D
						. from the vector bank,
						. bases enough windows to hold
						. the application data in B3..B31
						. points external stack pointer fp
						. to the high end of that

	c	(seg$load)	CORE_FS,,xi	;	. this call copies initialised
				my_data_segments,,xi 	. variables to process RAM space

	.
	.

	fret	0



</pre>


<p>
Process RAM bank addresses are not known until the kernel stores their pointer
in the vector bank. Programs which are loaded during system run instead of
ROM-image-fixed also know their own B0 addresses from the
vector bank, which is necessary for multi-banked programs

<h3>seg$load Realtime RAM Initialisation</h3>
<p>
smaragd7 kernel can unpack program RAM initial values from
ROM-resident (or RAM-resident) file systems which are linked
into the application image or the total system image

<p>
A sequence of link operations and file system image operations
separate the program writeable parts into a dynamic load segment

<p>
Core file system image construction exports a link label for each
dynamic load segment. An application instance references this
label to request initialization of its writeable data part
<pre>

	c	(seg$load)	BANK_INDEX_OF_CORE_FS_START,,xi	;
				my_ram_loadup_filename,,xi	

</pre>
There is no directory search in the core file system. The link
label of the file has effectively completed a file open at
assembly time. <b>seg$load</b> starts unpacking load strings in
realtime. All the target windows must be based

<p>
<b>seg$load</b> call is present in case no file systems except
core-resident file systems are present. A discussion of simpler techniques
for copying assembly-time variable values to program RAM follows, but the
<b>seg$load</b> service has distinct advantages

<blockquote>

	<b>seg$load</b> loads all the RAM sections of the application in one call<br><br>

	<b>seg$load</b> does not write locations which have don't-care values<br><br>

	RAM images in ROM / core file systems do not buffer don't-care values<br><br>

	<b>seg$load</b> is not limited in the size of RAM image it loads<br><br>

	Each core-resident file system may contain the the RAM images of many programs<br><br>

	There may be many core-resident file systems<br><br>

</blockquote>

The steps for placing RAM assembly-time variable values in ROM or core resident
file systems are described in the linking and utilities section of this manual. 


<h3>Simple Alternatives to seg$load for Limited-Size RAM Segment Loads</h3>
<p>
A simple alternative technique for copying ROM to RAM initial data involves the breakpointed
load addressing described earlier

In this example, part of B0 is a constant pool for initializing B1
<pre>

	$ masmx -ln
MASMX 7r3
0/-INPUT>>
	$list	0
	$include	freeware/RTA1/rta/def/rta.def
	$include	freeware/RTa1/rta/language/stack.def
	$list

B0_LOAD_ADDRESS $equ    30*4096

$(0::B0_LOAD_ADDRESS)

$(1:01000:B0_LOAD_ADDRESS+3072)
one     +       99
two     +       100
three   "abc"

$(0)
entry1* $vector fireup
        $list   0
        $do     64-$,   fret    0
        $list

fireup  lx, xi  one
        ly, xi  3072
        lr, xi  768/4-1

fireup_quad
        qpush   0, y
        qpop    0, x
        ax, xi  4
        ay, xi  4
        jdr     fireup_quad

        .
        .

	$end
  :                            821  $list
  :                            822 
  :                            823 B0_LOAD_ADDRESS $equ    30*4096
  :                            824 
  :                            825 $(0::B0_LOAD_ADDRESS)
  :                            826 
  :                            827 $(1:01000:B0_LOAD_ADDRESS+3072)
01:001000 000063              +828 one     +       99
01:001001 000064              +829 two     +       100
01:001002 616263              +830 three   "abc"
  :                            831 
  :                            832 $(0)
00:000000 B60040              +833 entry1* $vector fireup
  :                            836         $list
  :                            837 
00:000040 551000              +838 fireup  lx, xi  one
00:000041 5D0C00              +839         ly, xi  3072
00:000042 4500BF              +840         lr, xi  768/4-1
  :                            841 
  :                            842 fireup_quad
00:000043 8FB000              +843         qpush   0, y
00:000044 87A000              +844         qpop    0, x
00:000045 850004              +845         ax, xi  4
00:000046 8D0004              +846         ay, xi  4
00:000047 1E0043              +847         jdr     fireup_quad
  :                            848 
  :                            849         .
  :                            850         .
  :                            851 
  :                            852  $end
:$(00):000000:000048 :$(01):001000:001003 

</pre>

Assembling again with -d option lists the load addresses, which are not the
program-visible addresses
<pre>

	$ masmx -lnd
MASMX 7r3
0/-INPUT>>
	$list	0
	$include	freeware/RTA1/rta/def/rta.def
	$include	freeware/RTa1/rta/language/stack.def
	$list

B0_LOAD_ADDRESS $equ    30*4096

$(0::B0_LOAD_ADDRESS)

$(1:01000:B0_LOAD_ADDRESS+3072)
one     +       99
two     +       100
three   "abc"

$(0)
entry1* $vector fireup
        $list   0
        $do     64-$,   fret    0
        $list

fireup  lx, xi  one
        ly, xi  3072
        lr, xi  768/4-1

fireup_quad
        qpush   0, y
        qpop    0, x
        ax, xi  4
        ay, xi  4
        jdr     fireup_quad

        .
        .

	$end
  :                            821  $list
  :                            822 
  :                            823 B0_LOAD_ADDRESS $equ    30*4096
  :                            824 
  :                            825 $(0::B0_LOAD_ADDRESS)
  :                            826 
  :                            827 $(1:01000:B0_LOAD_ADDRESS+3072)
01:01EC00 000063              +828 one     +       99
01:01EC01 000064              +829 two     +       100
01:01EC02 616263              +830 three   "abc"
  :                            831 
  :                            832 $(0)
00:01E000 B60040              +833 entry1* $vector fireup
  :                            836         $list
  :                            837 
00:01E040 551000              +838 fireup  lx, xi  one
00:01E041 5D0C00              +839         ly, xi  3072
00:01E042 4500BF              +840         lr, xi  768/4-1
  :                            841 
  :                            842 fireup_quad
00:01E043 8FB000              +843         qpush   0, y
00:01E044 87A000              +844         qpop    0, x
00:01E045 850004              +845         ax, xi  4
00:01E046 8D0004              +846         ay, xi  4
00:01E047 1E0043              +847         jdr     fireup_quad
  :                            848 
  :                            849         .
  :                            850         .
  :                            851 
  :                            852  $end
:$(00):000000:000048 :$(01):001000:001003 


</pre>
The ROM copy source doesn't have to be in B0. A separate bank or page can be assigned,
but needs to be based in an address window before it can be copied. This technique
may be good for programs which, like C-Language programs, have no don't-care-value
locations in their data section
<pre>

$(3:03000:0C000)

?	$do	1000,	+	7.5*+?
buffer	$res	96
	

$(0)
	la	(0C000)
	sabr	34
	ly	(34*/12)
	lx, xi	03000
	lr, xi	4096/4-1

load	qpush	0, y
	qpop	0, x
	ax, xi 	4
	ay, xi	4
	jdr	load

	.
	.

</pre>



<h3>ROM System Image vs Independent Applications Load</h3>

The kernel and applications may be a single ROM image

<p>
Applications otherwise load anywhere. Their addresses are internally
absolute because of hardware relocation

<p>
The loader places the program's bank identifiers and call vectors in the
program's vector bank at address window 02000..02FFF



<h3>Giant Breakpoint Address</h3>
<p>

Breakpoint addresses may be larger than the address space. This is
signaled with an *asterisk on the breakpoint address

<pre>

$(31::*00000A000000)

</pre>

<p>
A normalised long pointer is used here to access data via a 48-bit address
<pre>

$ masmx alaska -lnk
MASMX 7r2
3/alaska.msm
*EOF*
  :                            1: 	$include	freeware/RTA1/rta/def/rta.def
  :                            2 
  :                            3 f	$func
  :                            4 pointer* $name
  :                            5 	$return	1*/46++f(1, 1)**0003FFFC0000*/12++$r(f(1, 1))*/18++f(1, 1)**03FFFF
  :                            6 	$end
  :                            7 
  :                            8 BASE	$set	42
  :                            9 
  :                            10 $(BASE::*03C000000)
2A:00003C000000:000063        +11 neck	+	99
2A:00003C000001:000065        +12 mutton	+	101
  :                            13 
  :                            14 $(0:64)
  :                            15 
00:000040 CF0100              +16 	dl	(pointer(mutton))
00:000041 34002A              +17 	sabr	BASE
00:000042 60D000              +18 	la	0, b
  :                            19 
  :                            20 	$do	$<256,$(0:256)
  :                            21 
*EOF*
00:000100+43C000A80001
:$(00):000040:000102 :$(2A):000000:000002 


</pre>
<p>
A very large RTA address is 48 bits in size. This accommodates the
16-gigaword executable space and any future executable space up to
256 terawords

<p>
If a large array is part of a ROM, its giant addresses are physically absolute.
Otherwise its giant addresses must are relative to a load address. See the
section on linking and utilities

<p>
A data array might be loaded to an area much larger than the address
space. See <b>Appendix A: Giant Structures in Memory</b>

<h3>Relocatable Sections</h3>

Relocatable code must be made absolute before passing to the load
string formatter <b>lstring</b>

<p>
Linking is a further assembly which includes
binary in the Text-Encoded-Object format *.txo

<p>
Relocatable sections can accumulate the alike segments of many assemblies

<p>
The relocatable location counter declaration contains no addresses
but an alignment factor marked with an asterisk
<pre>

$(3:*4[/literal_pool_name])

</pre>
<p>
See <b>Appendix B: masmx Linking for RTA1</b>

<h3>Void Sections and Structure Pointers</h3>


<h2>Appendix A: Giant Structures in Memory</h2>

<h2>Appendix B: masmx Linking for RTA1</h2>


<p>
There are two more variants of <b>seg$load</b>

<p>
<b>recursive$seg$load</b> is used in the recursive subprogramming model.
This technique replicates the unpacking of program data to an external stack
frame when a thread calls the program recursively. This is for calling programs
as if they were functions with new copies of a data segment of any size and
complexity. External stack pointer <b>fp</b> must contain the new segment
address before <b>recursive$seg$load</b>
<pre>

	c	(recursive$seg$load)	BANK_INDEX_OF_CORE_FS_START,,xi	;
					my_dynamic_segment_filename,,xi

</pre>
block structured programs use the xframe() part of <b>$head_near/far</b>
macro to load dynamic values in the external stack at a functional rather
than a program level

<p>
The third variant of <b>seg$load</b> is <b>array$seg$load</b>. This loads
multi-bank arrays with assembly-time initial values. The target windows
are dynamically overlaid and cannot be based before the call. The third
argument is zero if the array is assembled with absolute load addresses
and is a bank index if storage for the array has been obtained dynamically
with system calls <b>ii BANK$</b> or <b>ii ARRAY$</b>
<pre>

	la, xi	30000*262144
	ii	ARRAY$
	jza	sorry

	c	(array$seg$load)	BANK_INDEX_OF_CORE_FS_START,,xi		;
					my_assembled_array_segment_filename,,xi	;
					a		
 
</pre>



_____________________________________________________________________
<pre>
<i>

    LICENCE NOTICE


    Copyright Tim Cox, 2012
    TimMilesCox@gmx.ch

    This document is part of the RTA1 processor programmable
    architecture.

    RTA1 is a free processor architecture specification.
    It is licensed under the GNU General Public Licence Version 3

    The executable emulation of RTA1 is free software.

    Instruction code for the target RTA1 architecture is free software
    if it is delivered with this software

    Software programs delivered with this software to connect the
    emulated RTA1 with real network interfaces in the emulator host
    are free software

    Scripts and programs delivered with this software for running
    on other computers and interacting with the RTA1 are free software

    The masmx target-independent meta-asembler delivered here
    is free software whether it is used for constructing RTA1 code
    or any other code. masmx is a separate free program by the
    same author and included with this software to save searching for it

    Scripts and utility programs for constructing RTA1 target
    executable software are free software

    You can redistribute it and/or modify RTA1
    under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    RTA1 is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with RTA1.  If not, see &lt;http://www.gnu.org/licenses/&gt;.

</i>
</pre>


</div>
</html>
