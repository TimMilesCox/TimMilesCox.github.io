<html>
<div    style="font-size:15pt">

<center>

<h1>RTA1: Q & A</h1>


<i>
Copyright Tim Cox, 2012<br>
This document is part of the RTA1 Processor Programmable Architecture Specification<br>
The RTA1 Architecture is freeware licensed with the GNU General Public Licence Version 3<br>
The same licence encompasses all accompanying software and documentation <br>
The full licence text is included with these materials<br>
See also the licensing notice at the foot of this document
</i>

</center>

<ol>
	<li>Why so much effort for floating point?</li>
	<ol>
		<li>what?</li>
                <li>why isn't it IEEE754 floating point?</li>
                <li>isn't 96 bits too large for some things?</li>
		<li>why isn't it triadic floating operation?</li>
	</ol>
	<li>can RTA1 access bytes efficiently?</li>
</ol>



<h2>1. Why so much Effort for Floating Point?</h2>

Because it's the best way of doing fixed point arithmetic


<h3>1.1 What?</h3>

<p>
Many very small &mu;Cs acquire a coprocessor or an emulation
library quite early in their product history

<p>
RTA1 starts with big number capacity that is simple
to implement and needs no extras

<p>
The crunch really comes when you have multipliers or
divisors longer than the word size

<p>
Floating point is 100% deterministic and integer-accurate
so long as the composite of significands is not larger
than the mantissa length

<p>
This means that RTA1 floating-point is 100% deterministic
and integer-accurate with any total of multiplicand and
and multiplier significands up to 72

<p>
like a multiplicand 35 bits wide and multiplier 37 bits
wide, for example

<p>
and any dividend size up to 72 significands with any
divisor size up to 72 significands


<h3>1.2 Why isn't it IEEE754 Floating Point?</h3>

IEEE754 floating arithmetic in PCs has reached its capacity

<p>
64-bit format only has exponentiation equivalent to
about &plusmn;300 decimal places

<p>
The 80-bit format in some PC co-processors is a more
pragmatic number. It has 64 significands and exponentiation
equivalent to about &plusmn;5000 decimal places

<p>
The 128-bit IEEE754  also has exponentiation equivalent to
about &plusmn;5000 decimal places. This format doesn't seem to
be widely implemented

<p>
The 112-bit mantissa of the 128-bit IEEE754 format doesn't
look like future-proofing to me, not with a 15-bit exponent

<p>
RTA1 has light years more number range, 72 significands and
exponentiation for &plusmn;1262611 decimal places. That's right,
&plusmn; one and one quarter million decimal places

<p>
RTA1 <i>could</i> eventually need more mantissa significands
than 72, but not for many applications, because that is already
a row of 21 decimal digits

<p>
Additionally the RTA1 96-bit floating format is simple to
implement. Ones-complement negative makes subtract the
same operation as add

<p>
Naturally RTA1 supports XDR externally, as far as XDR
reaches. Neither XDR nor other computers have a format
for the largest RTA1 numbers. Except for printable
ASCII format in XDR string items


<h3>1.3 Isn't 96 Bits Too Large for Some Things?</h3>

Yes. RTA1 computes 96-bit floating point but can
store in a 48-bit compressed floating format, if
that can represent your number

<p>
And there is always fixed-point arithmetic. 24-bit and 48-bit



<h3>1.4 Why isn't it Triadic Floating Operation?</h3>

Here a simple algorithm with five inputs is executed in five instructions, including
operand acquisition from storage
<pre>


$ masmx -ln r2xample.msm
MASMX 7r3
3/r2xample.msm
*EOF*
  :                            1        $path           ../def
  :                            2:       $include        rta.def
  :                            3        $path           ../language
  :                            4:       $include        stack.def
  :                            5:       $include        fpxpress.def
  :                            6        $path
  :                            7 $(0:0)
  :                            8
00:000000 B60040              +9 floating_algorithm*  $vector fp_routine
  :                            10
  :                            11 $(0:64)
  :                            12
  :                            13 fp_routine
                                        $head_far        params(one,    float           ;
                                                                two,    float           ;
  :                            16                               three,  float)
  :                            17
00:000040 4FF003              +18       $xqt_fp         one*1.75*+1200000*two/3.0*-625000-three
00:000041 770100              +18
00:000042 77F007              +18
00:000043 7F0104              +18
00:000044 6FF00B              +18
  :                            19
  :                            20
00:000045 3D0000              +21       fret            0
  :                            22
  :                            23       $do             $<256,$(0:256)
  :                            24
*EOF*
00:000100+7CD38BB7B396D7AA20B6E083
00:000104+2051D5B8447B77478A23F5F7
:$(00):000000:000108
r2xample.msm: object code 190 bytes: 0 errors: 0 undefined labels


</pre>


RTA1 multadic arithmetic reduces instruction
processing to just one instruction per operand

<p>
Load-store triadic architectures need twice so many
instructions as this to load operands and then compute

<p>
RTA1's seamless data hierarchy of registers and memory
produces irreducible code density and economy

<p>
There's nowhere further to go in straight-line architectures





<h2>2. Can RTA1 access Bytes Efficiently?</h2>

<p>
Concerning access to bytes and byte-strings in a 24-bit word-addressing
machine: RTA1 bit-stream-channels are the most efficient handler for
unaligned strings in any architecture anywhere

<p>
RTA1 bit-stream-channels deliver any size data field to the application,
but read and write memory in 24-bit words

<p>
Very unaligned network protocols like SNMP run more efficiently on RTA1
than anywhere else

<p>
Application instructions have, quite separately from the bit-stream-channels,
direct access to octets and to 12-bit halfwords.

<p>
Because the RTA is designed to run without operand cache, there is an obvious
question, how shall the hardware do thirdword- and halfword-writes? After all
I see memory access as words and bursts of words

<p>
Well a byte-write, even if it is implemented as a read-modify, saves about
five instructions and saves occupying two registers. That's of gigantic value
to applications. Byte writes need not be memory-locked for SMPs because they
are not used in arbitration

<p>
Arbitration is the job of Test-and-Set, and seven other instructions which
in application terms are modify-cycles

<p>
It's still better to structure your data in words, however the hardware
implements byte-writes. You save two thirds of your instructions

<p>
And for many applications, the perfect byte-size is... 24 bits

<i>
<pre>

_______________________________________________________________________________________


LICENCE NOTE

    Copyright Tim Cox, 2012
    TimMilesCox@gmx.ch

    This document is part of the RTA1 Processor Programmable Architecture.

    RTA1 is a free processor architecture specification. It is licensed
    under the GNU General Public Licence Version 3

    The executable emulation of RTA1 is free software.

    Instruction code for the target RTA1 architecture is free software
    if it is delivered with this software

    Software programs delivered with this software to connect the
    emulated RTA1 with real network interfaces in the emulator host
    are free software

    Scripts and programs delivered with this software for running
    on other computers and interacting with the RTA1 are free software

    The masmx target-independent meta-asembler delivered here
    is free software whether it is used for constructing RTA1 code
    or any other code. masmx is a separate free program by the
    same author and included with this software to save searching for it

    Scripts and utility programs for constructing RTA1 target
    executable software are free software

    You can redistribute it and/or modify RTA1
    under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    RTA1 is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with RTA1.  If not, see &lt;http://www.gnu.org/licenses/&gt;.


</pre>
</i>


</div>
</html

