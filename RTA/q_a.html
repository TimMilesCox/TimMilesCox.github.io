<html>
<div    style="font-size:15pt">

<h1>RTA1: Q & A</h1>
<h3>A note on economy in arithmetic processing</h3>

RTA1 multadic arithmetic reduces instruction
processing to just one instruction per operand

<p>
The seamless data hierarchy of registers and memory
produces irreducible code density and economy

<p>
There's nowhere further to go in straight-line architectures


<pre>



</pre>

<h3>A note about doing bytes on the 24-bit bus. Plus a bit about SMP arbitration</h3>
<p>
RTA1 is a word addressing machine, and the fastest applications structure
their data for memory read and write in words and bursts of words

<p>
Concerning access to bytes and byte-strings in a 24-bit word-addressing
machine: RTA1 bit-stream-channels are the most efficient handler for
unaligned strings in any architecture anywhere

<p>
RTA1 bit-stream-channels deliver any size data field to the application,
but read and write memory in 24-bit words

<p>
Very unaligned network protocols like SNMP run more efficiently on RTA1
than anywhere else

<p>
Application instructions have, quite separately from the bit-stream-channels,
direct access to octets and to 12-bit halfwords.

<p>
Because the RTA is designed to run without operand cache, there is an obvious
question, how shall the hardware do thirdword- and halfword-writes? After all
I see memory access as words and bursts of words

<p>
Well a byte-write, even if it is implemented as a read-modify, saves about
five instructions and saves occupying two registers. That's of gigantic value
to applications. Byte writes need not be memory-locked for SMPs because they
are not used in arbitration

<p>
Arbitration is the job of Test-and-Set, and seven other instructions which
in application terms are modify-cycles

<p>
It's still better to structure your data in words, however the hardware
implements byte-writes. You save two thirds of your instructions

<p>
And for many applications, the perfect byte-size is... 24 bits

</div>
</html

