<html>
<div    style="font-size:15pt">

<center>

<h1>RTA1: Q & A</h1>


<i>
Copyright Tim Cox, 2012<br>
This document is part of the RTA1 Processor Programmable Architecture Specification<br>
The RTA1 Architecture is freeware licensed with the GNU General Public Licence Version 3<br>
The same licence encompasses all accompanying software and documentation <br>
The full licence text is included with these materials<br>
See also the licensing notice at the foot of this document
</i>

</center>

<ol>
	<li>Why so much effort for floating point?</li>
	<ol>
		<li>what?</li>
                <li>why isn't it IEEE754 floating point?</li>
                <li>isn't 96 bits too large for some things?</li>
		<li>why isn't it triadic floating operation?</li>
	</ol>
	<li>can RTA1 access bytes efficiently?</li>
	<li>does the internal stack run out of space?</li>
	<ol>
		<li>structured realtime in the internal stack</li>
		<li>recursive programming and zero-net internal stack</li>
	</ol>
</ol>



<h2>1. Why so much Effort for Floating Point?</h2>

Because it's the best way of doing fixed point arithmetic


<h3>1.1 What?</h3>

<p>
Many very small &mu;Cs acquire a coprocessor or an emulation
library quite early in their product history

<p>
They don't need big arithmetic except when they do

<p>
RTA1 starts with big number capacity that is simple
to implement and needs no extras

<p>
The crunch really comes when you have multipliers or
divisors longer than the word size

<p>
Floating point is 100% deterministic and integer-accurate
so long as the composite of significands is not larger
than the mantissa length

<p>
This means that RTA1 floating-point is 100% deterministic
and integer-accurate with any total of multiplicand and
multiplier significands up to 72

<p>
like a multiplicand 35 bits wide and multiplier 37 bits
wide, for example

<p>
and any dividend size up to 72 significands with any
divisor size up to 72 significands


<h3>1.2 Why isn't it IEEE754 Floating Point?</h3>

IEEE754 floating arithmetic in PCs has reached its capacity

<p>
64-bit format only has exponentiation equivalent to
about &plusmn;300 decimal places

<p>
The 80-bit format in some PC co-processors is a more
pragmatic number. It has 64 significands and exponentiation
equivalent to about &plusmn;5000 decimal places. This format
isn't IEEE754 either

<p>
The 128-bit IEEE754  also has exponentiation equivalent to
about &plusmn;5000 decimal places. This format doesn't seem to
be widely implemented

<p>
The 112-bit mantissa of the 128-bit IEEE754 format doesn't
look like future-proofing to me, not with a 15-bit exponent

<p>
RTA1 has light years more number range, 72 significands and
exponentiation for &plusmn;1262611 decimal places. That's right,
&plusmn; one and one quarter million decimal places

<p>
RTA1 <i>could</i> eventually need more mantissa significands
than 72, but not for many applications, because that is already
a row of 21 decimal digits

<p>
Additionally the RTA1 96-bit floating format is simple to
implement in hardware. Ones-complement negative makes subtract the
same operation as add

<p>
Naturally RTA1 supports XDR externally, as far as XDR
reaches. Neither XDR nor other computers have a format
for the largest RTA1 numbers. Except for printable
ASCII format in XDR string items


<h3>1.3 Isn't 96 Bits Too Large for Some Things?</h3>

Yes. RTA1 computes 96-bit floating point but can
store in a 48-bit compressed floating format, if
that can represent your number

<p>
And there is always fixed-point arithmetic. 24-bit and 48-bit



<h3>1.4 Why isn't it Triadic Floating Operation?</h3>

Here a simple algorithm with five inputs is executed in five instructions, including
operand acquisition from storage
<pre>


$ masmx -ln r2xample.msm
MASMX 7r3
3/r2xample.msm
*EOF*
  :                            1        $path           ../def
  :                            2:       $include        rta.def
  :                            3        $path           ../language
  :                            4:       $include        stack.def
  :                            5:       $include        fpxpress.def
  :                            6        $path
  :                            7 $(0:0)
  :                            8
00:000000 B60040              +9 floating_algorithm*  $vector fp_routine
  :                            10
  :                            11 $(0:64)
  :                            12
  :                            13 fp_routine
                                        $head_far        params(one,    float           ;
                                                                two,    float           ;
  :                            16                               three,  float)
  :                            17
00:000040 4FF003              +18       $xqt_fp         one*1.75*+1200000*two/3.0*-625000-three
00:000041 770100              +18
00:000042 77F007              +18
00:000043 7F0104              +18
00:000044 6FF00B              +18
  :                            19
  :                            20
00:000045 3D0000              +21       fret            0
  :                            22
  :                            23       $do             $<256,$(0:256)
  :                            24
*EOF*
00:000100+7CD38BB7B396D7AA20B6E083
00:000104+2051D5B8447B77478A23F5F7
:$(00):000000:000108
r2xample.msm: object code 190 bytes: 0 errors: 0 undefined labels


</pre>


RTA1 multadic arithmetic reduces instruction
processing to just one instruction per operand

<p>
Load-store triadic architectures need twice so many
instructions as this to load operands and then compute

<p>
RTA1's seamless data hierarchy of registers and memory
produces irreducible code density and economy

<p>
There's nowhere further to go in straight-line architectures





<h2>2. Can RTA1 access Bytes Efficiently?</h2>

<p>
Concerning access to bytes and byte-strings in a 24-bit word-addressing
machine: RTA1 bit-stream-channels are the most efficient handler for
unaligned strings in any architecture anywhere

<p>
RTA1 bit-stream-channels deliver any size data field to the application,
but read and write memory in 24-bit words

<p>
Very unaligned network protocols like SNMP run more efficiently on RTA1
than anywhere else

<p>
Application instructions have, quite separately from the bit-stream-channels,
direct access to octets and to 12-bit halfwords.

<p>
Because the RTA is designed to run without operand cache, there is an obvious
question, how shall the hardware do thirdword- and halfword-writes? After all
I see memory access as words and bursts of words

<p>
Well a byte-write, even if it is implemented as a read-modify, saves about
five instructions and saves occupying two registers. That's of gigantic value
to applications. Byte writes need not be memory-locked for SMPs because they
are not used in arbitration

<p>
Arbitration is the job of Test-and-Set, and seven other instructions which
in application terms are modify-cycles

<p>
It's still better to structure your data in words, however the hardware
implements byte-writes. You save two thirds of your instructions

<p>
And for many applications, the perfect byte-size is... 24 bits

<h2>3. Does the Internal Stack run out of Space?</h2>

<h3>3.1 Structured Realtime in the Internal Stack</h3>

This extract from the accompanying document <b>Towards Compiler Languages for RTA1
Architecture</b> describes internal stack use for two contrasting needs

<p>
The RTA1 internal stack is a register array for  realtime programming.
Realtime problem solving typically executes routines to a depth of between
four and eight nested subroutine calls, each with between two and six
parameter words in the stack

<p>
The internal stack contains approaching twice this intended maximum.
Here a routine is called with two  parameter words on the internal stack
<pre>

  :                            242
00:000553 FCF003              +243      lc   ber_sequence_scan a snmp_rseq,,i
00:000554 F80004              +243
00:000555 FCF002              +243
00:000556 3E0755              +243
00:000557 38000F              +243
  :                            244


</pre>
There are also a return address and a stack walkback pointer in each call,
so the stack use in this  call is four words. The application can keep on
like this for a nested depth of 26 calls

<p>
If the the internal stack overflows, the guard interrupt removes the thread
from the switch list

<p>
If that problem has been avoided, all the operands in the instruction path
are in a register array, namely the internal stack

<p>
That's the realtime intention of RTA1

<p>
If applications need more stack, there is no solution in building  a
larger internal stack into RTA1. That would make task switch slower and
applications could still overflow the internal stack

<p>
Some kinds of processing are not realtime, and must go about things in
a different way

<h3>3.2 Recursive Programming and Zero-Net Internal Stack</h3>

<p>
Recursion is a programming technique used rather indiscriminately
because of its popularity in education circles and because of a
widespread reluctance to understand anything in detail

<p>
Nevertheless recursive programming is really needed in some applications.
Macro language supports net-zero internal stack demand applied to individual
routines within a program

<p>
In realtime use, the <b>$head_near/far</b> macro claims and maps internal
stack words at the head of a routine

<p>
The addition of the <b>$zero_stack</b> keyword keeps the internal stack
pointer <b>sp</b> at the same place however many nested calls routines
with <b>$zero_stack</b> make to themselves or to each other

<pre>

$ masmx recursiv -ln
MASMX 7r3
3/recursiv.msm
*EOF*
  :                            1 	$path		freeware/RTA1/rta/def
  :                            2: 	$include	rta.def
  :                            3 	$path
  :                            4: 	$include	stack.def
  :                            5 
  :                            6 $(0:64)
  :                            7 
                                inwego	$head_near,$zero_stack	 params(one,	float	;
                                					two,	float	;
                                					three,	float)	;
                                							;
00:000040 FDFFF2              +12 				 xframe()
00:000041 2F000E              +12 
00:000042 38E000              +12 
00:000043 38E001              +12 
00:000044 87E002              +12 
00:000045 87E006              +12 
00:000046 87E00A              +12 
00:000047 780010              +13 	tp	16
00:000048 B60054              +14 	j	enough
00:000049 1F0010              +15 	dec	16
  :                            16 
00:00004A 4FE002              +17 	ql	one
00:00004B 77E006              +18 	fm	two
00:00004C 770100              +19 	fm	(0.875)
00:00004D 67E00A              +20 	fa	three
  :                            21 
00:00004E 8FE00A              +22 	lc	inwego	a,,float two,,float three,,float
00:00004F 8FE006              +22 
00:000050 8F0004              +22 
00:000051 FCF00C              +22 
00:000052 3E0040              +22 
00:000053 38000F              +22 
  :                            23 
  :                            24 enough
00:000054 9FE000              +25 	$ret
00:000055 FCE00E              +25 
00:000056 38000E              +25 
00:000057 350000              +25 
  :                            26 
  :                            27 	$do	$<256,$(0:256)
*EOF*
00:000100+400000E00000000000000000
:$(00):000040:000104 :$(46):000000:00000E 
recursiv.msm: object code 279 bytes: 0 errors: 0 undefined labels


</pre>
Routines constructed with <b>$zero_stack</b> can interact completely
with routines constructed without

<p>
The external stack pointer <b>fp</b> must point to the high-memory
end of a sufficient buffer

<p>
Call sequences constructed with the <b>c/lc</b> macro push the parameter
list onto the internal stack. This is not different where <b>$zero_stack</b>
is opted. There is no faster or better way of delivering a parameter list
of arbitrary size. The <b>lc</b> macro shown above pushes twelve parameter
words and a walkback pointer, then calls the target routine, itself in
this example
<pre>

	.------>_________________________________________________________________
	|	|   floating parameter three					|
	|	|_______________|_______________|_______________|_______________|
	|	|   floating parameter two					|
	|	|_______________|_______________|_______________|_______________|
	|	|   floating parameter one 					|
	|	|_______________|_______________|_______________|_______________|
	._______| stack walkback| return address|
		|_______________|_______________|


</pre>
If there are no parameters, the <b>c/lc</b> macro does not push a walkback
pointer or pop it afterwards. This follows a principle, that routines which
do not expect parameters can be called with <b>call</b> <b>lcal</b> instructions
without preliminaries. In realtime programming, instructions which
do not do anything are avoided where possible

<p>
A called routine with <b>$zero_stack</b> unloads the call frame that it expects.
Its <b>xframe()</b> is larger than otherwise by the size of the expected call frame

<p>
<b>xframe()</b> must be declared when <b>$zero_stack</b> is opted, even if
<b>xframe()</b> is otherwise void. <b>head_near/far</b> macro uses uppercase <b>-V</b>
option to highlight its path. masmx has not assigned <b>-VUWS</b> for itself
<pre>

                                inwego	$head_near,$zero_stack	 params(one,	float	;
                                					two,	float	;
                                					three,	float)	;
                                							;
Note: recursiv.msm Line 12: buy external $$xframe
00:000040 FDFFF2              +12 				 xframe()
00:000041 2F000E              +12 
Note: recursiv.msm Line 12: internal stack zero net demand
00:000042 38E000              +12 
00:000043 38E001              +12 
00:000044 87E002              +12 
00:000045 87E006              +12 
00:000046 87E00A              +12 


</pre>
The expected call frame is popped in four-word blocks per instruction,
and the parameter names are mapped to the external stack locations

<p>
Without <b>$zero_stack</b> the parameter names are mapped to their internal
stack locations

<p>
If variables are constructed in <b>scalars()</b> they are in the internal stack.
To flat-line the internal stack, dynamic variables must be in <b>xframe()</b>

<p>
The default behaviour of a <b>$zero_stack</b> routine before return is to
push the stack walkback word if parameters were expected and then to push
the return address. Because there is optional behaviour, a <b>$ret</b>
macro is supplied to match the <b>$head_near/far</b> macro
<pre>

  :                            23 
  :                            24 enough
Note: recursiv.msm Line 25: internal stack zero net demand
Note: recursiv.msm Line 25: parameter list walkback
00:000054 9FE000              +25 	$ret
Note: recursiv.msm Line 25: sell external $$xframe
00:000055 FCE00E              +25 
00:000056 38000E              +25 
Note: recursiv.msm Line 25: near return
00:000057 350000              +25 
  :                            26 


</pre>
<p>
Alternatively the <b>-S</b> flag opts to push all of the call frame back
into the internal stack. This mostly makes no difference, because <b>c/lc</b>
macro immediately frees the call frame by popping the walkback word onto the
internal stack pointer
<pre>

  :                            23 
  :                            24 enough
Note: recursiv.msm Line 25: internal stack zero net demand
Note: recursiv.msm Line 25: restore internal stack $$list -S
00:000054 8FE00A              +25 	$ret
00:000055 8FE006              +25 
00:000056 8FE002              +25 
00:000057 9FE000              +25 
Note: recursiv.msm Line 25: sell external $$xframe
00:000058 FCE00E              +25 
00:000059 38000E              +25 
Note: recursiv.msm Line 25: near return
00:00005A 350000              +25 
  :                            26 


</pre
<p>
A difference which <b>-S</b> option does make is that changes which the called
routine makes inside its parameters are written back to the internal stack,
which is also the effect without <b>$zero_stack</b>

<p>
That might be an unorthodox way of passing results which are otherwise passed
in arithmetic registers <b>a:b:mantissa2:mantissa3</b>

<p>
<b>-S</b> restore to the internal stack can also paint over some accidental damage
where a routine has not been given the correct internal stack frame in the first place.
The <b>$zero_stack</b> routine pops the call frame it thinks it has.

<p>
The internal stack may underflow. The guard interrupt then isolates the wrong call
at this point

<p>
Otherwise <b>sp</b> points some words below (address-wise above) the stack top.
Further call and push activity now overwrites previously stacked words energetically.
If the called <b>$zero_stack</b> routine has <i>not</i> written to its copied
parameters in the external stack frame, the complete restore may undo one consequence
of a problem. If this makes a difference, it should only be done diagnostically and
not used to bring faulty code into service. The parameters which the <b>$zero_stack</b>
routine thinks it has are not the intended parameters until the real problem is fixed

<p>
<i>For the accompanying discussion <b>Trapping Wrong Argument Lists</b> please see
the accompanying document <b>Towards Compiler Languages for RTA1 Architecture</b></i>

<i>
<pre>

_______________________________________________________________________________________


LICENCE NOTE

    Copyright Tim Cox, 2012
    TimMilesCox@gmx.ch

    This document is part of the RTA1 Processor Programmable Architecture.

    RTA1 is a free processor architecture specification. It is licensed
    under the GNU General Public Licence Version 3

    The executable emulation of RTA1 is free software.

    Instruction code for the target RTA1 architecture is free software
    if it is delivered with this software

    Software programs delivered with this software to connect the
    emulated RTA1 with real network interfaces in the emulator host
    are free software

    Scripts and programs delivered with this software for running
    on other computers and interacting with the RTA1 are free software

    The masmx target-independent meta-asembler delivered here
    is free software whether it is used for constructing RTA1 code
    or any other code. masmx is a separate free program by the
    same author and included with this software to save searching for it

    Scripts and utility programs for constructing RTA1 target
    executable software are free software

    You can redistribute it and/or modify RTA1
    under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    RTA1 is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with RTA1.  If not, see &lt;http://www.gnu.org/licenses/&gt;.


</pre>
</i>


</div>
</html

