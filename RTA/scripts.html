<div	style="font-size:16pt">

<h2>Building Applications</h2>

<ol>
        <li><a href="#build">Application Build</a></li>
	<li><a href="#application_group">Loadable and NVRAM Applications</a></li>
	<ol>
		<li><a href="#singlemu">Single and Group Applications</a></li>
	</ol>
	<li><a href="#application">How is an Application?</a></li>
        <li><a href="#source">How do Applications Look?</a></li>
        <ol>
                <li><a href="#source">Source Code</a></li>
		<li><a href="#loadfs">loadfs File: Launch Templates and Initial Data Load</a></li>
        </ol>
	<li><a href="#run">How is the Application Run?</a></li>
	<li><a href="#nvram">If Applications are ROM instead of Dynamic?</a>
	<li><a href="#group">Multiple Applications in one Load or ROM Group</a></li>
	<ol>
		<li><a href="#group">Application Collections</a></li>
		<li><a href="#make_rel">make_rel File</a></li>
		<li><a href="#link_u">Linking Assembly</a></li>
	</ol>
	<li><a href="#iframes">iframe Construction and Macro Language</a></li>
	<ol>
		<li><a href="#_macros">Macros which frame Instruction Code</a></li>
		<li><a href="#_catalog">catalog</a></li>
		<li><a href="#_application">$application</a></li>
		<li><a href="#_iframe">$iframe</a></li>
		<li><a href="#_library">Independent Library Iframes</a></li>
		<li><a href="#_without">Without any Framing by Macro</a></li>
		<li><a href="#_app4kp">Simple 4K Application Iframes</a></li>
		<li><a href="#_app4kq">Simplified Application Iframes</a></li>
		<li><a href="#_app_launch">Application Launch</a></li>
	</ol>
	<li><a href="#literal_tables">Literal Tables</a></li>
</ol>
<ul	type="none">
	<li><a href="#load_app">Appendix A: load Application</a></li>
        <li><a href="#iframe_examples">Appendix B: iframe Examples</a></li>
	<li><a href="#locators">Appendix C: Application Memory Map</a></li>
	<li><a href="#auto">Appendix D: Scripts and Automatic Start</a></li>
</ul>

<a      name="build"/>
<h3>1: Application Build</h3>
An application is typically a subdirectory of <a style="color:#0000FF">$YOU/<a><a style="color:#FF0000">rta/target.rta/</a>

<p>
<a      name="amake"/>
Directory path <a style="color:#FF0000">rta/target.rta/image.app</a> needs to be in your environment
<p>

<pre    style="font-size:12pt;color:#0000FF">

        $ cd rta/target.rta/hello.app
        $ amake hello

</pre>

<a	name="application_group"/>
<h3>2: Loadable and NVRAM Applications</h3>

<a	name="singlemu"/>
<h4>2.1: Single and Group Applications</h4>
<p>
command <a style="color:#FF0000">amake</a> builds

<ul     type="square">
        <li>multiple or single dynamically loadable applications of any size</li>

        <li>multiple or single applications of any size for inclusion in NVRAM system image</li>

</ul>
Multiple applications are applications with their instruction part in shared iframes in order to optimise instruction memory

<p>
Memory is assignable in multiples of 4K-word pages and while large applications may be constructed in scores of memory pages, other applications may only take some dozens or hundreds of instructions and may be packed several in one 4K-word page

<p>
The presence of a file <a href="#make_rel">make_rel</a> in the application directory signals a multiple-application iframe

<p>
If the application directory has no file make_rel, amake command constructs a single application in absolute code


<a	name="application"/>
<h3>3: How is an Application?</h3>

An application or group of applications is realised in a subdirectory of
<a style="color:#0000FF">{ $HOME | $YOU | $SOMEWHERE }/<a><a style="color:#FF0000">/rta/target.rta/</a>

<p>
<a style="color:#0000FF">$YOU</a><a style="color:#FF0000">/rta/target.rta/</a><a style="color:#0000FF">your.app.for_example/</a> contains two or more of these files

<pre	style="font-size:12pt;color:#0000FF">

	[ <a href="#make_rel">make_rel</a> ]		optionally a one-line text command naming multiple applications for constructing as a group


	my_application[s].msm	<a href="#source"/>source file[s].msm</a>
				one source file has the application name for building plus extension .msm


	<a href="#loadfs">loadfs</a>			a text file of 4+ lines
				generates a file system in the application binary image to bind

					lookup by name

					launch parameters

					program data sections load
					per application process instance

</pre>

<a      name="source"/>
<h3>4: How do Applications look?</h3>
<h4>4.1: Source Code</h3>

How might a source file and a loadfs file look?
<pre	style="font-size:10pt;color:#0000FF">

cd rta/target/hello.app
$ cat hello.msm 

		$list		0			. keep system  names out of your label lists
		$path		../			. some system headers
		$include	def/rta.def		. define the machine
		$include	def/ii.def		. low-level system calls
		$include	def/vector.def		. map your vector list
		$include	language/catalog.def	. application template and lookup anchor
		$include	language/stack.def	. if the application calls out to anything at all
		$include	stream/stream.def	. for example printf, sscanf
		$include	fs/fs24.def		. a couple of file I/O equates may be needed
		$include	image.app/imports.def	. most of the kernel exports
		$path		
		$list					. any names after here are in your label lists
							. source listing is by default this file
							. to list includes $list 2 or more

		$set_option	"z"			. string zero-padding

LF		$equ	10				. definition line feed, also in ../lib/ascii.def

$(1:01000)						. you can put variable indirection pointers in here
indirectp	+	remember_who?			. plus private data not referenced by routines outside your application
							. this section is also called your B1 section

$(3:03000/$3)						. your static variable data goes in here
from_all	"from all the crew!":0
remember_who?	"Remember us?":0
<a	name="__base"/>
__BASE		$equ		HELLO_START_PAGE_INDEX	. start page index if you know it (fixed in system image)
							. or if you don't for that matter (dynamic iframe load)
							. HELLO_START_PAGE_INDEX is undefined, so hello is dynamic load
$(0:0/$0)
. hello*	$vector		jump2it	. (commented)	. the simplest way of having a vector (entry point) in a 4k-word iframe
							. there are 64 $vector slots at the front of an iframe
							. but hello is dynamic and is called a different way

		catalog					. catalog is the minimal startup macro for a single application of any size
							.	-which is dynamic loadable or
							.	-which is fixed and may be larger than one 4k page
							.	-which is fixed and can be found by name

							. for multiple applications macro $application is used instead of catalog


jump2it		$base_d		$zenith(3)-03000 1024	. you need 1K words external stack for every thread which does printf
							. $base_d macro places assigned static memory at address space 03000 hex

		c	(seg$load) 0,,xi (my_data_segment:L),,long

							. kernel routine (seg$load) initialises static data
							. for this process instance of this application
							. 1st argument rom file system start page index zero
							. means file system is inside this calling iframe (it is)
							. 2nd argument is the 48-bit address of your static data load file
							.
							. my_data_segment is included and named in a small text file loadfs
							. you're ready to execute application code

		printf	$3("Hello World %s %s":LF:0),,xi	; 	. the output string is unnecessarily three strings
			from_all,,xi				;	. even more unnecessarily
			*indirectp,,i					. the third string is addressed indirectly

							. string arguments are in static data literal table $3
							. so other iframes can see them. Other iframes can't see this iframe
							. arguments by value can be from anywhere
							. if arguments are by address that must be specified argument,,xi
							.					          or argument,[index],i

							. arguments by value larger than one word are	argument,,long
							.						argument,,triple
							.						argument,,float
							.						argument,,float192
							.						argument,,floating_packed

		fret		0			. or ii EXIT$

	$do		$<256,$(0:256)		. literal constants at the end of this iframe
						. with values (seg$load) (my_data_segment:L) (__fprintf)
						. must be forced to address 256+ to be addressable
						. lower addressed operands than that are registers 

</pre>
Literals are automatic constants generated by reference at the end of the program section where they are directed

<p>
More is explained about <a href="#literal_tables">literal tables</a> and <a href="#iframes">iframe Construction and Macro Language</a>

<a	name="loadfs"/>
<h4>4.2: loadfs File: Launch Template and Initial Data Load</h4>

loadfs describes a file system embedded and linked in the application image

<p>
All applications are re-entrant shared code and application initial data is unpacked from the embedded file system

<p>
The file system is included in the link of the application group, exports the names of data sections which it contains, and imports execution parameter descriptors as file-system link targets of with class tag G

<p>
volume, file and link names are developer-chosen. A single application has one data sections file and one launch link

<p>
The link entry shown here is not really needed to find hello, because a single loadable application is found by its <a href="#load_app">load</a> path name

<p>
The name assigned on the link entry is a look-up name for execution

<pre	style="font-size:12pt;color:#0000FF">

	$ cd rta/target.rta/hello.app
	$ cat loadfs
	volume embedded
	file my_data_segment lsegment
	tree application_templates
	link hello launch_gate G
	$

</pre>
macro <a style="color:#0000FF">catalog</a> exports application template launch_gate

<a	name="run"/>
<h3>5: How is the Application run?</h3>

Hello is dynamic and is included in <a href="kernel.html#fsda">Device 1 file system</a> where it is located by pathname
<pre	style="font-size:12pt;color:#0000FF">

	$ telnet 172.29.7.7
	Trying 172.29.7.7...
	Connected to 172.29.7.7.
	Escape character is '^]'.
	RTA1 smaragd7 OS shared console
	<a style="color:#000000">r load /test/hello</a>
	00001e
	loader: load /test/hello
	[000050000018:001000003013]
	000023 
	<a style="color:#FF0000">Hello World from all the crew! Remember us?</a>
	load>

</pre>
<a href="#load_app">load</a> is a fixed application in the system image

<p>
<a href="#load_app">load</a> reads file system <a href="kernel.html#fsda">Device 1</a> which is read-only and constructed offline by the system administrator

<pre	style="font-size:12pt;color:#0000FF">

	$ cd rta
	$ more fsimages/baseload
	.
	tree test
	file hello target.rta/hello.app/hello
	.

	$
	$ ./mrand7		# construct the file system

</pre>

<a	name="nvram">
<h3>6: If Applications are ROM instead of Dynamic?</h3>

Applications in NVRAM

<ul	type="square">
	<li>export the name <a href="#__base">__BASE</a> equated to a known start page index:
	<pre	style="color:#0000FF;font-size:14pt">
	 __BASE*	$equ	APPLICATION(5)/*12
	</pre></li>
	
        <li>names <a style="color:#0000FF">APPLICATION(1..1024)</a> are switched in <a style="color:#FF0000">rta/target.rta/def.app</a> to inform kernel routines which NVRAM pages are the Start Page of a fixed application group. Each application group contains a search directory of launch names and parameters
	<pre	style="color:#0000FF;font-size:14pt">

	APPLICATION(5)	$equ	02A000		. for example
	</pre></li>

        <li>script <a style="color:#FF0000">target.rta/def.app/nvlist</a> generates datafile <a style="color:#FF0000">def.app/nvframes.rom</a> containing pointers to ROM application iframes
	<pre	style="color:#0000FF;font-size:14pt">

	$ cd rta/target.rta/def.app

	$ cat iframes.def
	APPLICATION(1)	$equ	00B000		. unless kernel and libraries get larger
	APPLICATION(2)	$equ			. depends how many pages APPLICATION(1) takes
						. and if any fixed library pages intervene
	.
	.
	APPLICATION(5)	$equ	02A000		. for example

	$ ./nvlist	# construct <a style="color:#FF0000">def.app/nvframes.rom</a>

	</pre></li>

        <li><a style="color:#FF0000">nvframes.rom</a> is included in <a href="kernel.html#fsda">file system Device 1</a> and tabled in kernel vectors at system start. <a href="kernel.html#fsda">File system Device 1</a> is constructed offline:
	<pre	style="color:#0000FF;font-size:14pt">

	$ cd rta
	$ ./mrand7
	</pre></li>

        <li>ROM application iframes are invidually searchable for launching applications by name</li><br>

        <li>directory <a style="color:#FF0000">application_templates/</a> in each iframe embedded filesystem links a searchable name to each application:
	<pre	style="color:#0000FF;font-size:14pt">

	$cat loadfs
	volume embedded_fs
	tree data_segments
	file app1_data app1_lsegment
        file app2_data app2_lsegment
	.
	<a style="color:#FF0000">tree application_templates
	link request_name1 _launch_gate_app1 G
        link request_name2 _launch_gate_app2 G</a>
	.
	.
	</pre>
	</li>

        <li>applications are constructed in ROM format and catenated to the system image</li><br>

        <li>have a script named <a style="color:#FF0000">amass</a> in their application directory to govern catenation to the system image:
	<pre	style="color:#0000FF;font-size:14pt">

	insert this_app.rom ../up2here.apps/sysimage.rom
	</pre></li>
	<li>are called with telnet command <a style="color:#0000FF">r </a><a style="color:#FF0000">name</a> or from a script by <a style="color:#FF0000">name</a> or programmatically at their fixed address</li>

</ul>

<a	name="group"/>
<h3>7: Multiple Applications in one Load or ROM Group</h3>

<h4>7.1: Application Collections</h4>
Applications in shared iframes are assembled with relocatable instruction sections and linked

<p>
Their data sections are all at absolute 001000<sub>16</sub> and 003000<sub>16</sub> as all applications

<p>
The application directory has a file <a href="#make_rel">make_rel</a> to command relocatable assemblies of each application for collection

<p>
Applications for combining have no $vector lines at the front and the instruction code section declaration <a style="color:#0000FF;font-family:courier">$(0:*1/$0)</a> has instead of an address a relocation alignment term <a style="color:#0000FF;font-family:courier">*1</a>
<pre	style="font-size:12pt;color:#0000FF">

$(0:*1/$0)

</pre>
Separate assemblies export entry points [ <a style="color:#FF0000">first* second* third*</a> ] for linking

<pre	style="font-size:12pt;color:#0000FF">

<div	style="width:500pt;border-radius:5pt;background-color:#F0F0F0">
$(1:01000)		. B1 frame still absolute
$(3:03000)		. static variable section absolute as ever
	$lit	4
$(4:*1)			. iframe literal constants section
$(0:*1/$0)		. relocatable instruction code section
<a style="color:#FF0000">first*</a>			. exported start address
	$base_d		$zenith(3)-003000	1024
	c		(seg$load)	0,,xi	(data_1st:d),,long
	.
	.
	fret	0	. or ii EXIT$
</div>


<div	style="width:500pt;border-radius:5pt;background-color:#B0B0B0">
$(1:01000)		. B1 frame still absolute
$(3:03000)		. static variable section absolute as ever
	$lit	4
$(4:*1)			. iframe literal constants section
$(0:*1/$0)		. relocatable instruction code section
<a style="color:#FF0000">second*</a>			. exported start address
	$base_d		$zenith(3)-003000	1024
	c		(seg$load)	0,,xi	(data_2nd:d),,long
	.
	.
	fret	0	. or ii EXIT$
</div>

<div	style="width:500pt;border-radius:5pt;color:#00FF00;background-color:#707070">
$(1:01000)		. B1 frame still absolute
$(3:03000)		. static variable section absolute as ever
	$lit	4
$(4:*1)			. iframe literal constants section
$(0:*1/$0)		. relocatable instruction code section
<a style="color:#FF0000">third*</a>			. exported start address
	$base_d		$zenith(3)-003000	1024
	c		(seg$load)	0,,xi	(data_3rd:d),,long
	.
	.
	fret	0	. or ii EXIT$
</div>

</pre>

<a>
A new relocatable section $(4:*1) also appears. This is explained at <a href="#literal_tables">literal tables</a>

<p>
Only instruction sections are constructed as relocatable. Data sections $(1) variable pointers / private data and $(3) static are at absolute 001000 hex and 003000 hex (but physically anywhere) for all instances of all applications


<a	name="make_rel"/>
<h4>7.2: make_rel File</h4>


Applications for linking in a group are named to command <a style="color:FF0000">rels</a>
in one-line text file <a style="color:#FF0000">make_rel</a>
<pre    style="font-size:12pt;color:#0000FF">

	$ cd    rta/target.rta/your.app.for_example
	$ cat   make_rel

        rels app1 app2 app3
        $
        $       # application source files <a style="color:FF0000">app1.msm app2.msm app3.msm</a> are in the directory

</pre>

<a name="link_u"/>
<h4>7.3: Linking Assembly</h4>

<p>
Command <a style="color:#FF0000">amake</a> assembles the files on the <a href="#make_rel"/>rels</a> line then assembles another file to construct the load object (whether actually loadable or in NVRAM)

<p>
In this example the linking assembly  is apps_group.msm

<pre	style="font-size:12pt;color:#0000FF">

	amake apps_group	# the file which collects the applications is apps_group.msm in this example

</pre>

<p>
The combined application contains the entry vectors which jump to the application start locations

<p>
Macro <a style="color:#FF0000">$application</a> is used instead of macro catalog

<p>
<a style="color:#FF0000">$application</a> exports multiple application load-go templates
<a	name="_group_link"/>
<pre	style="font-size:12pt;color:#0000FF">

	$list		0
	$path		../
	$include	def/rta.def
	$include	def/map1.def
	$include	fs/fs24.def
	$include	language/iframe.def
	$path
	$include	../image.app/imports.def
	$list

__BASE	$equ	_MULTIPLE_LOADP

	$list		2

$(0:0)
	<a style="color:#FF0000">$application,1</a>		0:first	0:second 0:third

	$include,$binary	first.rel	$(0)
	$include,$binary	second.rel	$(0)
	$include,$binary	third.rel	$(0)

	$do	$<256,$(0:256)
	$include,$binary	first.rel	$(4)
	$include,$binary	second.rel	$(4)
	$include,$binary	third.rel	$(4)


</pre>
<p>
It is important that the linking assembly includes segments from make_rel outputs *.rel

<p>
make_rel also outputs *.txo files but segments from these do not have all the required information for successful construction
	
<a	name="iframes"/>

<h3>8: iframe Construction and Macro Language</h3>


<a	name="_macros"/>
<h4>8.1: Macros which frame Instruction Code</h4>

Three alternative macros construct iframes. Application and library iframes may alternatively be constructed <a href="#_without">without macro framing</a> 
<ul     type="square">

        <li><a href="#_catalog">catalog</a> constructs a single application</li>
        <li><a href="#_application">$application</a> constructs a densely packed group of applications</li>
        <li><a href="#_iframe">$iframe</a> constructs a block of subroutines</li>

</ul>
iframes can be constructed singly or in a related load group

<p>
Each iframe is any size within direct addressing plus further space for metadata and data section load

<p>
An iframe may contain from 1 to 30 applications or may be a library or block of subroutines

<p>
Direct address space is eight 4K-word pages or 32768 words containing up to 32700+ application instructions

<p>
RTA1 application code is compact to the extent that one 4K-word page of memory may contain the instruction part of 30 applications

<p>
Simplest iframes have 64 vector locations which can be exported as an encoded value of <a style="color:#0000FF"><i>PAGE:OFFSET</i></a>

<p>
Macros <a href="#_catalog">catalog</a> <a href="#_application">$application</a> <a href="#_iframe">$iframe</a> construct gates which point to any offset in the iframe group which may be any size and either fixed or loadable

<p>
Entry to an iframe larger than one 4k-word page must be via a gate and not directly to a known <a style="color:#0000FF"><i>PAGE:OFFSET</i></a> in order to execute instruction code in all the pages of the iframe


<a      name="_catalog"/>
<h4>8.2: catalog</h4>

<a style="color:#0000FF">catalog</a> constructs one loadable or fixed application iframe one or more pages in size

<pre	style="font-size:12pt;color:#0000FF">

	[vector_name* $vector offset]

		catalog[,page_high_index]	[offset]

</pre>

<a style="color:#0000FF">page_high_index</a> is the number less one of 4k-word pages in the iframe

<p>
<a style="color:#0000FF">page_high_index</a> defaults to zero indicating an iframe of one page

<p>
developer tools indicate if iframe storage is insufficient and needs correction by raising <a style="color:#0000FF">page_high_index</a>

<a      name="_application"/>
<h4>8.3: $application</h4>

<a style="color:#0000FF">$application</a> constructs a group of multiple applications in one loadable or fixed iframe one or more pages in size

<pre	style="font-size:12pt;color:#0000FF">

	[vector_name* $vector offset]
	[vector_name* $vector offset]

		$application[,page_high_index]	[iframe:offset iframe:offset...]

</pre>

<a style="color:#0000FF">page_high_index</a> is the number less one of 4k-word pages in the iframe
 
<p>
<a style="color:#0000FF">page_high_index</a> defaults to zero indicating an iframe of one page 

<p>
developer tools indicate if iframe storage is insufficient and needs correction by raising <a style="color:#0000FF">page_high_index</a>



<a      name="_iframe"/>
<h4>8.4: $iframe</h4>

<a style="color:#0000FF">iframe</a> constructs one loadable or fixed subroutine iframe one or more pages in size

<pre	style="font-size:12pt;color:#0000FF">

	[vector_name* $vector offset]
	[vector_name* $vector offset]

		$iframe[,page_high_index]

</pre>

<p>
$iframe frames integrated in dynamically loadable application groups and are not callable from outside the loadable iframe group

<a	name="_library"/>
<h4>8.5: Independent Library Iframes</h4>
Independent libraries (libraries not specific to individual applications) at fixed and known addresses are suitable for construction <a href="#_without">without any framing by macro</a>

<p>
Independent libraries may be constructed in 4k-pages using up to 64 vectors and 64 far returns in each page


<a      name="_without"/>
<h4>8.6: Without any Framing by Macro</h4>
<pre	style="font-size:12pt;color:#0000FF">

	vector_name* $vector offset
	[vector_name* $vector offset]
	[vector_name* $vector offset]

		$list	0
		$do	64-$,	fret	0
		$list

	offset	.
		.
		fret	0

</pre>

<a	name="_app4kp"/>
<h4>8.7: Simple 4K Application Iframes</h4>
A complete and efficient application system image can be constructed without any instruction framing macros if
<ul	type="square">

	<li>instruction frames are one page of 4096 words</li>
	<ul	type="square">
		<li>4K application iframes may contain multiple applications</li>
		<li>4K application iframes may be joined together with <a href="rta.html#call">call</a> <a href="rta.html#fret">fret</a> and <a href="rta.html#go">go</a> instructions to construct large applications</li>
	</ul>
	<li>instruction frames are at fixed storage locations</li>

	<li>library calls are programmatic because they always are</li>

	<li>application startups are</li>
	<ul	type="square"> 
		<li>programmatic, or</li>
		<li>have lookup by name programmed by the integrator, or</li>
		<li>use framing macros <a href="#_catalog">catalog</a> for one application or <a href="#_application">$application</a> for application group iframes</li>
	</ul>
</ul>
Vector values are exported. They are encoded information and not address labels

<p>
Application <a style="color:#0000FF">2simple</a> is constructed without framing macros
<pre	style="font-size:12pt;color:#0000FF">

$ cat 2simple.msm
	$list		0
	$path		../
	$include	def/rta.def
	$include	def/vector.def
	$include	language/stack.def
	$include	stream/stream.def
	$path
	$include	../image.app/imports.def
	$list	

$(3:03000/$3)
$(0:0/$0)
simpl*	$vector	simple
	$list	0
	$do	64-$,	fret	0
	$list
simple	$base_d	$zenith(3)-03000 1024
	c	(seg$load)	0,,xi	(mydata:d),,long
	printf	$3("that ought to be simple enough 4u":10:0),,xi
	fret	0
	$do	$<256,$(0:256)

</pre>
The directory must contain a text file loadfs
<pre	style="font-size:12pt;color:#0000FF">

$ cat loadfs
volume embedded
file mydata lsegment

</pre>
2simple is then built like this
<pre	style="font-size:12pt;color:#0000FF">

$ amake 2simple
$ slab 2simple 2simple.rom 4096
$ cat ../up2here.apps/sysimage.rom 2simple.rom &gt; ./sysimage.rom		# for example

</pre>
Then the integrator must 
<ul	type="square">

	<li>keep track at what page address the application is catenated</li>
	<li>use that Start Page Index * 64 as the application launch vector value [<i>PAGE</i>:000000<sub>2</sub>]</a></li>
	<li>have a way if required of looking up the application by name</li>
	<li>parameter needed for the launch service call <a href="#_app_launch">SPAWN$</a> are { vector, priority, static data size, -B1_frames }</li>

</ul>

<a	name="_app4kq">
<h4>8.8: Simplified Application Iframes</h4>

Application <a style="color:#0000FF">simple</a> is less work for the integrator than application <a style="color:#0000FF">2simple</a> because
<ul	 type="square">

	<li>lookup and vector information is checked to correspond with load location derived from catenation</li>
	<li>data sizes are carried forward automatically into launch parameters</li>
	<li>the <a href="#nvram">application [group]</a> contains a directory of launch name[s] and parameters</li>
	<li>the containing storage block is <a href="#nvram">listed at system start</a> for application lookup and launch</li>

</ul>
<pre	style="font-size:12pt;color:#0000FF">

$ cat simple.msm 
	$list		0
	$path		../
	$include	def/rta.def
	$include	def/vector.def
	$include	language/stack.def
	$include	stream/stream.def
	$include	def.app/iframes.def
	$include	language/catalog.def
	$path
	$include	../image.app/imports.def
	$list	

__BASE*	$equ	<a style="color:#FF0000">APPLICATION(4)</a>/*12

$(3:03000/$3)
$(0:0/$0)
simpl*	$vector	simple

	<a style="color:#FF0000">catalog</a>

simple	$base_d	$zenith(3)-03000 1024
	c	(seg$load)	0,,xi	(mydata:d),,long
	printf	$3("that ought to be simple enough 4u":10:0),,xi
	fret	0
	$do	$<256,$(0:256)

</pre>
__BASE is exported

<p>
<a style="color:#0000ff">iframes.def</a> is introduced to explain <a style="color:#FF0000">APPLICATION(4)</a>

<p>
<a style="color:#0000ff">catalog.def<a> is introduced to explain <a style="color:#FF0000">catalog</a>

<p>
Two more lines in file loadfs assure a name lookup <a style="color:#0000ff">simple</a>
<pre	style="font-size:12pt;color:#0000FF">

$ cat loadfs
volume embedded
file mydata lsegment
tree application_templates
link simple launch_gate G

</pre>
Storage block <a style="color:#FF0000">APPLICATION(4)</a> is identified to the kernel as containing applications for lookup and launch

<p>
A file <a style="color:#0000ff">amass</a> in the directory checks the location of <a style="color:#FF0000">APPLICATION(4)</a> and does the catenation
<pre	style="font-size:12pt;color:#0000FF">

$ cat amass
insert simple ../up2here.apps/sysimage.rom

</pre>
Application <a style="color:#0000FF">simple</a> is simpler. Build is just one command

<pre	style="font-size:12pt;color:#0000FF">

	$ amake simple

</pre>
The result of doing that is <a style="color:#0000FF">simple.app/sysimage.rom</a>

<p>
If simple is the last in the chain then
<pre	style="font-size:12pt;color:#0000FF">

$ cd rta/rta.run
$ export RTA_IMAGE=../target.rta/simple.app/sysimage.rom

</pre>
Otherwise the chain modules after <a style="color:#0000FF">simple</a> must be serially reinserted starting with with the module with <a style="color:#0000FF">amass</a> file command
<pre	style="font-size:12pt;color:#0000FF">

insert this_module ../simple.app/sysimage.rom

</pre>
<a href="#nvram">def.app/nvframes.rom</a> must be constructed for the application number of application <a style="color:#0000FF">simple</a> and built into File System Device 1

<p>
Application <a style="color:#0000FF">simple</a> is fixed in the system image and available after restart
<pre	style="font-size:12pt;color:#0000FF">

$ telnet 172.29.7.7
RTA1 smaragd7 OS shared console
r simple
00001f 
that ought to be simple enough 4u

</pre>

Macro <a style="color:#FF0000">catalog</a> can be used to launch large and loadable single applications

<p>
Application framing  macros <a href="#_catalog">catalog</a> <a href="#_application">$application</a> automatically measure data section size and necessary heaps and stacks

<a	name="_app_launch">
<h4>8.9: Application Launch</h4>
Application launch call is <a href="kernel.html#spawn_ii">SPAWN$</a>
<pre	style="font-size:12pt;color:#0000FF">

	ql	(vector, PRIORITY, STATIC_SIZE, -B1_FRAMES:q)
	ii	SPAWN$

</pre>
Process primary thread identifier is returned in application register a

<p>
System call to <a href="kernel.html#tag_ii">TAG$</a> attaches a displayable name to thread [register a]
<pre	style="font-size:12pt;color:#0000FF">

	lb	$3("name":0),,xi	. leftside word zero means this thread 
	ii	TAG$

</pre>
A thread calling TAG$ with zero in register a names itself


<a      name="literal_tables"/>
<h3>9: Literal Tables</h3>

Literals are data constants generated by reference

<p>
In RTA1 literals may be big numbers, callable vector names, strings or structures
<pre	style="font-size:12pt;color:#0000FF">

	c	(__sscanf)	$3("%s %d":0),,xi	string,,xi	number,,xi

</pre>
Literals are recognised

<ul	type="square">

	<li>by being in parentheses without operators attached front or back</li>

	<li>by being in parentheses with a label of type <a href="">literal pool tag</a> on the front</li>

</ul>
Literal pool tags are declared on program section headers
<pre	style="font-size:12pt;color:#0000FF">

__STATIC	$equ	3
$(__STATIC:03000/$3)		. literal pool tag in static data section is $3

</pre>
There is a default program section for literals and it is $(0), the iframe. An assembly directive <a href="http://timmilescox.github.io/masmx/masmx.html#lit">$lit</a> may change the default and may also tag the default literal pool
<pre	style="font-size:12pt;color:#0000FF">

"$4"	$lit	4

</pre>
Literals may be indirection constants for very large addresses which don't fit inside an instruction
<pre	style="font-size:12pt;color:#0000FF">

	tz	<a style="color:#000000">*</a>(_IO_WINDOW*/18++131072<a style="color:#000000">s</a>)	. force the literal to single word with suffix <a style="color:#000000">s</a>

</pre>
The indirection operator <a style="color:#0000FF">*</a> is allowed on the front of a literal

<p>
Variables and constants in the first 8192 locations of address space may be indirection pointers. These locations are
<ul	type="square">

	<li>256 registers: addresses [000000..0000FF]</li>
	<li>words 256..4095 of the actual iframe: addresses [000100..000FFF]</li>
	<li>all 4096 words if the actual B1 frame: addresses [001000..001FFF]</li>

</ul>
Integer constants add a word of signs if the highest bit is not a sign. So an address literal pointing to the high half of address space needs to be suffixed <a style="color:#0000FF">s</a> to prevent a prefix of 24 zero bits

<p>
Literals can be any data which can't be an immediate operand because of its size
<pre	style="font-size:12pt;color:#0000FF">

	qpush	(1.5)		. that generates 4 words
	d	(3000000)	. that's within 1 word but larger than &plusmn;32767

</pre>
Literals can go in any program section where data can be generated but most of them go in iframe $(0, 4) or static $(3)

<p>
Literals are placed in static if another iframe references them. That other iframe cannot address anything in this iframe
<pre	style="font-size:12pt;color:#0000FF">

	c	(__sscanf)	<a style="color:#FF0000">$3("%s %d":0),,xi</a>	string,,xi	number,,xi

</pre>
By default literals are in the current iframe. Many iframe literals are call vectors to other iframes and must be constants or variables because the operand of instructions go and call is a constant or variable
<pre	style="font-size:12pt;color:#0000FF">


	c	<a style="color:#FF0000">(__sscanf)</a>	$3("%s %d":0),,xi	string,,xi	number,,xi
	.
	$do	$<256),$(0:256)

</pre>
Literals in the iframe must be in words 256..4095 of the iframe. Lower operand adresses than 256 are registers. Operand adresses 4096+ are not in the iframe. Only instructions can be obtained from addresses 4096+ of the iframe

<p>
The construct <a style="color:#0000FF">$do  $<256),$(0:256)</a> at iframe end forces location counter to 256 if it has not reached 256, so that the automatic literal table is in memory address space

<p>
If instructions + literals > 4096, literals need to be placed in front of instructions, not after

<p>
Macro <a style="color:#0000FF">$lits4</a> places the default literal table in a new section $(4) starting at address 256 

<p>
Macro <a style="color:#0000FF">$check4</a> at the end of the instruction section checks if the default literal table is inside the number of words allowed on the <a style="color:#0000FF">$lits4</a> line. The default is 20 words. Fewer or more words are reserved with an argument to <a style="color:#0000FF">$lits4</a>

<pre	style="font-size:12pt;color:#0000FF">

$(0::0/$0)

        $application,1  startup

        $lits4	[words]
startup
	.
	.
        $check4
	

</pre>

If multiple applications are linked in one iframe all their default literal pools must be collected within iframe locations 256..4096, either before instruction code or after it if instructions + literals < 4097

<p>
All <a href="#group">relocatable applications</a> included must be assembled with automatic literals in a separate relocatable section, here $(4), from instruction code in $(0)

<pre    style="font-size:12pt;color:#0000FF">

$(1:01000)              . B1 frame still absolute
$(3:03000)              . static variable section absolute as ever
        $lit    4
$(4:*1)
$(0:*1/$0)              . relocatable instruction code section
first*                  . exported start address
        $base_d         $zenith(3)-003000       1024
        c               (seg$load)      0,,xi   (data_1st:d),,long
        .
        .
        fret    0       . or ii EXIT$


</pre>

<p>
In this <a href=="#_group_link">linking assembly</a> three small applications have instructions in program section $(0) and literals in $(4)

<pre	style="font-size:12pt;color:#0000FF">


$(0:0)
        <a style="color:#FF0000">$application,1</a>             0:first 0:second 0:third

        $include,$binary        first.rel       $(0)
        $include,$binary        second.rel      $(0)
        $include,$binary        third.rel       $(0)

        $do     $<256,$(0:256)
        $include,$binary        first.rel       $(4)
        $include,$binary        second.rel      $(4)
        $include,$binary        third.rel       $(4)

</pre>
For an applications group iframe > 4096 words it is necessary to place iframe literal pools before the instructions

<pre	style="font-size:12pt;color:#0000FF">

$(0:0)
        <a style="color:#FF0000">$application,1</a>             0:first 0:second 0:third

	$do	$<256,$(0:256)
        $include,$binary        first.rel       $(4)
        $include,$binary        second.rel      $(4)
        $include,$binary        third.rel       $(4)
	$do	$>4096,		$flag	default literal tables larger than possible

        $include,$binary        first.rel       $(0)
        $include,$binary        second.rel      $(0)
        $include,$binary        third.rel       $(0)

</pre>

<a	name="load_app"/>
<h3>Appendix A: load Application</h3>

load Application loads applications to executable space from filestore and optionally starts a process instance of the application

<p>
load is itself an application and has a command interface

<p>
load is started from <a href="connect.html=connect#telnet">telnet</a> or from a <a href="#auto">script</a>

<p>
load is started from telnet with the console command <a href="connect.html=connect#telnet">r</a>
<pre	style="font-size:12pt;color:#0000FF">

	r load [ first command ]
	.
	.	commands
	.
	@eof

</pre>

load is started by name from a line of <a href="#auto">script</a> text
<pre	style="font-size:12pt;color:#0000FF">

	load [ first command ]
	.
	.	commands
	.
	@eof

</pre>
Commands to load are
<pre	style="font-size:12pt;color:#0000FF">

	a path name		/directory[/directories...]/file[* { + | application } ]

				path name with no *suffix	load, execute the 1st application in the file
				path name*+			load
				path/file*application		load, execute the <a href="scripts.html#group">named application within the file</a>

								in all cases the file remains loaded

	name of a loaded file	filename			execute the 1st application in the loaded file
				filename*application		execute the named application
				filename*-			unload


	built-in commands	@?				list loaded files

				@run <a href="#auto">script_path</a>		start a script from a new thread

				@eof				exit load, all binaries unload

</pre>
All loaded files are in the memory estate of load and are removed from memory when load exits

<p>
This has the effect that the loaded files are only executable from the calling instance of load application

<p>
This permits prototyping and testing

<p>
However all RTA1 applications are shared-code reentrant

<p>
It is projected to assign the loaded files optionally to kernel vectors, making the loaded applications common for system runtime

<p>
load is only from <a href="kernel.html#fsda">file system Device 1</a>, which is not online updatable

<p>
Applications may be loaded and started programmatically using

<ul	type="none">
	<li><a href="kernel.html#fs_loadgo">kernel routines</a></li>
	<ul	type="none">
		<li><a href ="kernel.html#iframe_load">fspath</a></li>
		<li><a href ="kernel.html#iframe_load">iframe_load</al></li>
		<li><a href="kernel.html#qstart">qstart</a></li>
	</ul>
	<li>and <a href="kernel.html#ii">system calls</a></li>
	<ul	type="none">
		<li><a href="kernel.html#spawn_ii">SPAWN$</a></li>
		<li><a href="kernel.html#thread_state_ii">THREAD$STATE</a></li>
	</ul>
</ul>

<a	name="iframe_examples"/>
<h3>Appendix B: iframe Examples</h3>

<ul	type="square">
	<li><a href="array.html">array and 1off</a> are a load group of SIMD demonstrations</li>
	<li><a href="#source">hello.msm</a> is a simple loadable application</li>
	<li><a href="iframe.html">gate.msm</a> is a large loadable application consisting multiple iframes</li>
	<li><a href="#_app4kq">simple.msm</a> is a simple ROM application</li>
</ul>



<div	style="font-size:14pt">

<a      name="locators"/>
<h2>Appendix C: Application Memory Map</h2>

<h3>Application Memory, Location Counters and Dynamic Data Segment Load</h3>

<a href="scripts.html#application_group">Applications</a> are written in absolute code, as if each application occupies a computer

<p>
This is because RTA1 machine translates addresses using 72 I/O ports as relocation pointers

<p>
A suite of applications may be linked from <a href="scripts.html#singlemu">relocatable code</a> in an absolute load image to optimise instruction code storage

<p>
Program sections are declared with <a href="language.html#application_structure">location counter command</a> $(.. in column 1

<p>
Instruction Frame is in $(0). See <a href="app.html">Simplest Application Structure</a>
and <a href="iframe.html">Large and Loadable Instruction Frames</a>

<p>
Multiple small applications can be packed in one 4096-word iframe. See <a href="#linking">Linking</a>

<p>
iframe shares its first page @ addresses 256..4095 with operand space but may have more pages of instructions from address 4096 outside operand space

<pre    style="font-size:12pt;color:#0000FF">

__BASE	$equ	APPLICATION_START_PAGE_INDEX	. known or unknown, see <a href="#__base">B0 description</a>

$(0:__BASE/$0)         . iframe @ logical address zero
iframe_name     $application

$(1:01000)                      . private data + variable indirection pointers @ logical address 001000 hex

$(3:03000/$3)                   . static data @ logical address 003000 hex

</pre>

Program or static date occupies as many windows 3..31 as required at addresses 003000..01FFFF / 0C0000..7FFFFF

<p>
An application starts by placing assigned data memory in windows 3.. with
<a      href="language.html#base_d">$base_d</a> macro

and calling kernel routine <a href="language.html#seg_load">seg$load</a> to unpack initial data values from ROM image.
All RTA1 instruction code is shared code

<p>
Vector list which every application needs to run is preconstructed by the kernel in window 2 at addresses 002000..002FFF

<p>
Instruction memory begins at address zero in the current instruction frame

<p>
Words 0..255 of operand space are registers

<h3>Location Counters</h3>

Location counters correspond to program sections. masmx has 72 location counters

<p>
Applications running on the actual kernel have this memory map
<pre	style="font-size:12pt;background-color:#0000C0;color:#FFFFFF;border-radius:10px">


_________________________________________________________________________________________________
|   $(locator)	|       address window			|	    purpose / address range	|
|_______________|_______________________________________|_______________________________________|________________________
<a style="background-color:#000080">|$(0) [ + $(4) ]|       instruction frame B0            |      [data read space] 000100..000FFF /  instruction space	|</a>
<a style="background-color:#000080">|_______________|_______execute_+_read__________________|________________________________________  000000..		|</a> 
|   $(1:01000)	|       private stack frame B1		| application data space 001000..001FFF	|<a style="background-color:#000080">			|</a>
|_______________|_______________________________________|_______________________________________|<a style="background-color:#000080">			|</a>
<a style="background-color:#000080">|   $(2)	|       vector list B2 read-only	|      data memory space 002000..002FFF	|			|</a>
<a style="background-color:#000080">|_______________|_______________________________________|_______________________________________|			|</a>
|   $(3:03000)	|       data windows  B3..B31		| application data space 003000..01FFFF	|<a style="background-color:#000080">			|</a>
|									      or C00000..7FFFFF |<a style="background-color:#000080">			|</a>	
|												|<a style="background-color:#000080">			|</a>
|												|<a style="background-color:#000080">			|</a>
|												|<a style="background-color:#000080">			|</a>
|_______________|_______________________________________|_______________________________________|<a style="background-color:#000080">_______________________|</a>
<a style="background-color:#0000FF">|		|       data windows B32..B47		|     application / kernel interface	|			|</a>
<a style="background-color:#0000FF">|															|</a>
<a style="background-color:#0000FF">|															|</a>
<a style="background-color:#0000FF">|															|</a>
<a style="background-color:#0000FF">|_______________|_______________________________________|_______________________________________|	    accessed by	|</a>
<a style="background-color:#0000FF">|		|       data windows B48..B63           |      kernel default socket buffers	|	kernel routines	|</a>
<a style="background-color:#0000FF">|															|</a>
<a style="background-color:#0000FF">|															|</a>
<a style="background-color:#0000FF">|															|</a>
<a style="background-color:#0000FF">|_______________|_______________________________________|_______________________________________|_______________________|</a>
|   $(66::,x)	|       pointer in index register x	|
|_______________|_______________________________________|
|   $(67::,y)	|       pointer in index register y	|
|_______________|_______________________________________|
|   $(68::,a)	|       pointer in arithmetic register a|
|_______________|_______________________________________|
|   $(69::,b)	|       pointer in arithmetic register b|
|_______________|_______________________________________|
|   $(70::,fp)	|       frame at external stack pointer |
|_______________|_______________________________________|
|   $(71::,sp)  |       frame at internal stack pointer |
|_______________|_______________________________________|


</pre>
$(0) : window B0 is the current instruction frame and contains locally accessed constants

<p>
See also <a href="app.html">The Simplest Application Structure</a> and <a href="iframe.html">Large and Loadable Instruction Frames</a>

<p>
Program visible addresses start at zero

<p>
<a	name="__base">
The second field of the $(0:__BASE/$0) ist __BASE which is the Start Page Index of the iframe and has been equated to a known like APPLICATION(5) or a dynamic unknown like LOAD_PAGE_THIS_APP

<pre	style="font-size:12pt;background-color:#0000C0;color:#FFFFFF;border-radius:10px">

__BASE	$equ	LOAD_PAGE_THIS_APP	. stays unknown until load time

. __BASE $equ	APPLICATION(5)/*12	. for example: absolute page address defined in rta/target.rta/def.app/iframes.def 
					. generated for lookup list in kernel vectors by running rta/target.rta/def.app/nvlist
					. included in File System 1 for read on startup by running rta/mrand

$(0::__BASE/$0)				. These /$0 /$3 etc clauses on program section headers are literal table flags
					. and it's sometimes good to have followed that naming convention for them

</pre>
<p>
If the application contains multiple instruction frames, successive load addresses are larger relative to the first

<h3>7.3: Data Sections $(1) and $(3)</h3>

<p>
$(1) contains private data in bank B1 starting at program-visible address 4096
<pre	style="font-size:12pt;background-color:#0000C0;color:#FFFFFF;border-radius:10px">

$(1:01000)

</pre>

<p>
The kernel constructs the vector list window $(2) and places the containing page in address space 002000..002FFF

<p>
The vector list  is defined in including target.rta/def/vector.def and is shared by all threads of the process.

<p>
File and socket handles are in the vector list and are common to all threads of the process

<p>
The kernel places initial B1 frame pointer in I/O port 1

<p>
Application static data buffer is in the vector list. Macro $base_d reads this value and places
pages in address windows $(3) from address 003000

<p>
A simple application example might be
<pre	style="font-size:12pt;background-color:#0000C0;color:#FFFFFF;border-radius:10px">

	$include	def/rta.def		. registers and instruction set
	$include	def/vector.def		. this defines the vector list
						. in address window 02000

$(0::INSTRUCTIONS_LOAD_ADDRESS)
$(1:01000)					. private RAM
	+	variables
$(3:03000)					. application RAM
	+	data

$(0)
callname* $vector get_going
	$do	64-$,	fret	0

get_going	<a	name="base_d"/>
	$base_d	APPLICATION_DATA_SIZE [EXTERNAL_STACK_SIZE]
						. macro base_d reads VECTOR_D static 1st page index
						. and bases enough windows for application data in B3..B31
						. and points external stack pointer fp
						. to the high end of APPLICATION_DATA_SIZE + EXTERNAL_STACK_SIZE
						. and open-file-descriptor heap pointer
						. to the high end of APPLICATION_DATA_SIZE

	<a	name="seg_load"/>
	c	(seg$load)	CORE_FS,,xi	;	. this call copies initialised
				(my_data_segments:d),,long  . variables to process RAM space

	.
	.

	fret	0

</pre>

<p>
The second argument of $base_d EXTERNAL_STACK_SIZE is needed

<blockquote>
 
	if the application uses any external stack for
	<blockquote>
		loading dynamic data sections<br><br>
		paging internal stack with $zero_stack flag<br><br>
		xframe dynamic variables
	</blockquote>
	for fprintf or printf because formatting takes a 1024-word frame<br><br>
	for open data file descriptors but not for network sockets

</blockquote>
Data file open descriptors are in a heap from the end of static data mounting towards external stack top
and are common to threads as their handles in the vector list are common to threads

<p>
External stack must be large enough for all threads which use any


<h3>seg$load Realtime RAM Initialisation</h3>
Application code is reentrant shared code and each process instance of the application
loads initial data to B1 and $(3) spaces with kernel call seg$load


<p>
seg$load unpacks initial values from the micro-filesystem embedded in the application image

<p>
START_PAGE_INDEX_OF_CORE_FS is usually zero to mean <i>this iframe Start Page Index</i>

The 48-bit file pointer <i>my_ram_loadup_filename</i> is exported from the link of the
micro-filesystem into the application image and is known not searched
<pre	style="font-size:12pt;background-color:#0000C0;color:#FFFFFF;border-radius:10px">

	$base_d MY_APPLICATION_DATA_SIZE EXTERNAL_STACK_SIZE	. base the memory space

	c	(seg$load)	START_PAGE_INDEX_OF_CORE_FS,,xi	;
				(my_ram_loadup_filename:d),,long	

</pre>


<h3>Void Sections and Structure by Pointer</h3>

A program section may have no addresses but instead a pointer.

<p>
The pointer is a register capable of indexing [ x y a b fp sp ] and reference may override which register that is 

<pre	style="font-size:12pt;background-color:#0000C0;color:#FFFFFF;border-radius:10px">

$(66::,x)
label	$res	4
label2	structure

$(70::,fp)
descriptor acw

</pre>
If address and load address are both declared zero then the program section number is reusable
for different pointer-based structures

<p>
Locator numbers are not fixed to any pointer register, but as specific purposes have been assigned
to [ $(0) $(1) $(2) $(3) $(4) ] supplied code keeps a convention of assigning to index registers 
[ $(66) $(67) $(68) $(69) $(70) $(71) ]

<pre	style="font-size:12pt;background-color:#0000C0;color:#FFFFFF;border-radius:10px">

$(66::,x)
$(67::,y)
$(68::,a)
$(69::,b)
$(70::,fp)
$(71::,sp)

</pre>

The indentifiers inside these sections are base + displacement tuples.
masmx calls these names $equf labels. In the example
<pre	style="font-size:12pt;background-color:#0000C0;color:#FFFFFF;border-radius:10px">

	$include	dq.def

$(70::,fp)
descriptor	acw

	la	descriptor:bytes

</pre>
is the same as
<pre	style="font-size:12pt;background-color:#0000C0;color:#FFFFFF;border-radius:10px">

	la	descriptor:bytes, fp

</pre>
The base register assigned at the section head can be overriden on reference
<pre	style="font-size:12pt;background-color:#0000C0;color:#FFFFFF;border-radius:10px">

$(70::,fp)
descriptor      acw

$(67::,y)
dgram           datagram

$(0)

        ly      descriptor:dgram
        dl      dgram:ipsource


	lx	descriptor:next
	lr	descriptor:bytes, x

</pre>


No data is generated inside void sections.
macros which generate data do not generate any data in a void section

<h3>Data-Tables with Base +  Displacement View</h3>

It is also possible to have data tables at high addresses accessed by base register plus displacement

<pre	style="font-size:12pt;background-color:#0000C0;color:#FFFFFF;border-radius:10px">

$ masmx oreilly -lnke oreilly
MASMX 7r3A Build 8
3/oreilly.msm
*EOF*
  :                            1: 	$include	..//def/rta.def
  :                            2 
  :                            3 TABLE1	$equ	79*1024
  :                            4 
  :                            5 $(20:TABLE1,x)
14:000000  400001 C00000 000000 000000
                              +6 one	+	1.5
14:000004  400001 D00000 000000 000000
                              +7 two	+	1.625
14:000008  400001 E00000 000000 000000
                              +8 three	+	1.75
14:00000C  400001 F00000 000000 000000
                              +9 "O'Leary" +	1.875
  :                            10 
  :                            11 $(0:64)
00:000040  500100              +12 	lx	(TABLE1)
00:000041  77A000              +13 	fm	one
00:000042  67A004              +14 	fa	two
00:000043  6FA008              +15 	fan	three
00:000044  7FA00C              +16 	fd	"O'Leary"
  :                            17 
  :                            18 	$do	$<256,$(0:256)	. force literal table above register addresses
*EOF*
00:000100+013C00
:$(00):000040:000101 :$(14):013C00:013C10 

$ cat oreilly.txo

$14:013C00
400001C00000000000000000 400001D00000000000000000
400001E00000000000000000 400001F00000000000000000
$00:000040
500100 77A000 67A004 6FA008 7FA00C
$00:000100
013C00

:$00*000000:000040:000101
:$14*000000:013C00:013C10

</pre>
</div>

<a	name="auto"/>
<h3>Appendix D: Scripts and Automatic Start</h3>

Kernel routine <a style="color:#FF0000">run_start</a> runs applications serially from a script at absolute path in <a href="kernel.html#fsda">file system Device 1</a>
<pre	style="font-size:12pt;color:#0000FF">

	c	(run_start)	$3("/directory[/directory...]/script":0),,xi

</pre>

Scripts may be nested to a depth of three

<p>
A nested script path in the text has the syntax <a style="color:#0000FF">/directory[/directory...]/script</a>

<p>
Text lines are otherwise application command lines followed optionally by lines of stdin

<p>
The first stdin line available to an application is its own command line which may have argument fields

<p>
stdin text may be commands to applications like shells

<p>
script execution is sequential. Each application ends before more script text is read. This allows applications to read script lines as stdin
<pre	style="font-size:12pt;color:#0000FF">

load /production/multiple*applications1	# run load application: command to load + run /production/multiple*applications1
inputs to applications1
.					# end command of application1
multiple*applications2			# run another part of the application group now loaded
multiple*applications3			# and another part
@eof					# end command of load application, loaded apps get unloaded
read_the_post				# another application
/another/script				# a nested script

</pre>
Although <a style="color:#FF0000">run_start</a> processes strictly sequentially, a caller may process multiple scripts simultaneously from separate threads

<p>
A script <a style="color:#0000FF">/initial/script</a> is run automatically at system start if it is present in <a href="kernel.html#fsda">file system Device 1</a>

<p>
Scripts are not always started interactively and therefore terminal output for input is not assumed

<p>
stdout from script-activated applications is a UDP broadcast displayed in a shell running platform utility <a style="color:#FF0000">oconsole</a>
<pre	style="font-size:12pt;color:#0000FF">

	sudo oconsole

</pre>

Multiple platforms anywhere in the local net may run <a style="color:#FF0000">oconsole</a>

<p>
stdout of background processes can only be broadcast if broadcast address 255.255.255.255 has an interface route in $HOME/.rta_net, for example
<pre	style="font-size:12pt;color:#0000FF">

	export RTA_WIFI=172.29.7.72/12@0.0.0.0/0*192.168.1.254@192.168.0.0/16@172.16.0.0/12<a style="color:#FF0000">@255.255.255.255/32</a>

</pre>

If an emulator platform doesn't appear to receive its own broadcast run the <a href="connect.html#run">network trunk process</a> with -o option. If RTA1 has a script /initial/script then -o should be opted on runL before the emulator is started
<pre	style="font-size:12pt;color:#0000FF">

	./runL -o		# forward background console output to platform loopback before RTA1 runs

</pre>
or else
<pre	style="font-size:12pt;color:#0000FF">

	./runL			
	-o			# start forwarding background console output to platform loopback

</pre>

<pre	style="font-size:10pt;background-color:#FFFFFF00">
<div	style="border-radius:5px;background-color:#FF0000;color:#FFFFFF;width:75pt;height:100pt;top:25pt;right:375pt;position:absolute">    NVRAM
_____________
 application
        code
_____________

 initial data<a style="color:#000000">------------</a>
 load strings

</div>

<div	style="border-radius:5px;background-color:#00FF00;width:75pt;height:100pt;top:25pt;right:225pt;position:absolute">     RAM
_____________




----->
</div>

</a>

<a      href="#application_group">
<div	style="border-radius:5px;color:#FFFFFF;background-color:#0000FF;
	width:75pt;height:75pt;top:25pt;right:125pt;position:absolute">


   fixed and
    loadable
applications
</div>
</a>

	<a	href="program.html#overview" style="font-size:17pt;top:200;right:125pt;position:absolute">to app development overview page</a>

<a      href="masmx7r3.html">
<div	style="border-radius:5px;color:#FFFFFF;background-color:#0000FF;width:75pt;height:75pt;top:25pt;right:25pt;position:absolute">
        meta
   assembler

      binary
   utilities

</div>
</a>

<div	style="border-radius:5px;background-color:#FF0000;color:FFFFFF;
	width:225pt;height:100pt;top:200pt;right:225pt;position:absolute">    NVRAM
____________________________________________________________________________________________
	            fixed   more fixed
      kernel applications applications
	   +	      		    
    embedded  app lookups  app lookups
 app servers ------------------------>
             initial data initial data
</div>

<div	style="border-radius:5px;background-color:#00FF00;
	width:75pt;height:100pt;top:200pt;right:150pt;position:absolute">     RAM
_____________
     loadable
 applications


 application
        data
</div>
<div	style="background-color:FFFFFF;width:1pt;height:166pt;top:200pt;right:300pt;position:absolute">
</div>

<div	style="background-color:FFFFFF;width:1pt;height:166pt;top:200pt;right:375pt;position:absolute">
</div>


<a      href="language.html">
<div	style="border-radius:5px;color:#FFFFFF;background-color:#0000FF;
	width:75pt;height:75pt;top:125pt;right:25pt;position:absolute">
   functions

        call
    sequence
      macros

</div>
</a>

<a      href="#build">
<div	style="border-radius:5px;color:#FFFFFF;background-color:#0000FF;
	width:75pt;height:75pt;top:225pt;right:25pt;position:absolute">


 application
       build
     scripts

</div>
</a>

<a      href="kernel.html">
<div    style="border-radius:5px;color:#FFFFFF;background-color:#0000FF;
        width:75pt;height:75pt;top:325pt;right:25pt;position:absolute">


 
  Kernel API

</div>
</a>

<a      href="index.html">
<div    style="border-radius:5px;color:#FFFFFF;background-color:#0000FF;
        width:75pt;height:75pt;top:325pt;right:125pt;position:absolute">



  INTRO PAGE


</div>
</a>
</pre>
</div>
