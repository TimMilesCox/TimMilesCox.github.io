<div	style="font-size:16pt">

<h2>Building Applications</h2>

<ol>
        <li><a href="#build">Application Build</a></li>
	<li><a href="#application_group">Loadable and NVRAM Applications</a></li>
	<ol>
		<li><a href="#singlemu">Single and Group Applications</a></li>
	</ol>
	<li><a href="#application">How is an Application?</a></li>
        <li><a href="#source">How do Applications Look?</a></li>
        <ol>
                <li><a href="#source">Source Code</a></li>
		<li><a href="#loadfs">loadfs File: Launch Templates and Initial Data Load</a></li>
        </ol>
	<li><a href="#run">How is the Application Run?</a></li>
	<li><a href="#nvram">If Applications are ROM instead of Dynamic?</a>
	<li><a href="#group">Multiple Applications in one Load or ROM Group</a></li>
	<ol>
		<li><a href="#group">Application Collections</a></li>
		<li><a href="#make_rel">make_rel File</a></li>
		<li><a href="#link_u">Linking Assembly</a></li>
	</ol>
	<li><a href="#iframes">iframe Construction and Macro Language</a></li>
	<ol>
		<li><a href="#_macros">Macros which frame Instruction Code</a></li>
		<li><a href="#_catalog">catalog</a></li>
		<li><a href="#_application">$application</a></li>
		<li><a href="#_iframe">$iframe</a></li>
		<li><a href="#_library">Independent Library Iframes</a></li>
		<li><a href="#_without">Without any Framing by Macro</a></li>
		<li><a href="#_app4kp">Simple 4K Application Iframes</a></li>
		<li><a href="#_app4kq">Simplified Application Iframes</a></li>
		<li><a href="#_app_launch">Application Launch</a></li>
	</ol>
	<li><a href="#literal_tables">Literal Tables</a></li>
</ol>
<ul	type="none">
	<li><a href="#load_app">Appendix A: load Application</a></li>
        <li><a href="#iframe_examples">Appendix B: iframe Examples</a></li>
	<li><a href="#auto">Appendix C: Scripts and Automatic Start</a></li>
</ul>

<a      name="build"/>
<h3>1: Application Build</h3>
An application is typically a subdirectory of <a style="color:#0000FF">$YOU/<a><a style="color:#FF0000">rta/target.rta/</a>

<p>
<a      name="amake"/>
Directory path <a style="color:#FF0000">rta/target.rta/image.app</a> needs to be in your environment
<p>

<pre    style="font-size:12pt;color:#0000FF">

        $ cd rta/target.rta/hello.app
        $ amake hello

</pre>

<a	name="application_group"/>
<h3>2: Loadable and NVRAM Applications</h3>

<a	name="singlemu"/>
<h4>2.1: Single and Group Applications</h4>
<p>
command <a style="color:#FF0000">amake</a> builds

<ul     type="square">
        <li>multiple or single dynamically loadable applications of any size</li>

        <li>multiple or single applications of any size for inclusion in NVRAM system image</li>

</ul>
Multiple applications are applications with their instruction part in shared iframes in order to optimise instruction memory

<p>
Memory is assignable in multiples of 4K-word pages and while large applications may be constructed in scores of memory pages, other applications may only take some dozens or hundreds of instructions and may be packed several in one 4K-word page

<p>
The presence of a file <a href="#make_rel">make_rel</a> in the application directory signals a multiple-application iframe

<p>
If the application directory has no file make_rel, amake command constructs a single application in absolute code


<a	name="application"/>
<h3>3: How is an Application?</h3>

An application or group of applications is realised in a subdirectory of
<a style="color:#0000FF">{ $HOME | $YOU | $SOMEWHERE }/<a><a style="color:#FF0000">/rta/target.rta/</a>

<p>
<a style="color:#0000FF">$YOU</a><a style="color:#FF0000">/rta/target.rta/</a><a style="color:#0000FF">your.app.for_example/</a> contains two or more of these files

<pre	style="font-size:12pt;color:#0000FF">

	[ <a href="#make_rel">make_rel</a> ]		optionally a one-line text command naming multiple applications for constructing as a group


	my_application[s].msm	<a href="#source"/>source file[s].msm</a>
				one source file has the application name for building plus extension .msm


	<a href="#loadfs">loadfs</a>			a text file of 4+ lines
				generates a file system in the application binary image to bind

					lookup by name

					launch parameters

					program data sections load
					per application process instance

</pre>

<a      name="source"/>
<h3>4: How do Applications look?</h3>
<h4>4.1: Source Code</h3>

How might a source file and a loadfs file look?
<pre	style="font-size:10pt;color:#0000FF">

cd rta/target/hello.app
$ cat hello.msm 

		$list		0			. keep system  names out of your label lists
		$path		../			. some system headers
		$include	def/rta.def		. define the machine
		$include	def/ii.def		. low-level system calls
		$include	def/vector.def		. map your vector list
		$include	language/catalog.def	. application template and lookup anchor
		$include	language/stack.def	. if the application calls out to anything at all
		$include	stream/stream.def	. for example printf, sscanf
		$include	fs/fs24.def		. a couple of file I/O equates may be needed
		$include	image.app/imports.def	. most of the kernel exports
		$path		
		$list					. any names after here are in your label lists
							. source listing is by default this file
							. to list includes $list 2 or more

		$set_option	"z"			. string zero-padding

LF		$equ	10				. definition line feed, also in ../lib/ascii.def

$(1:01000)						. you can put variable indirection pointers in here
indirectp	+	remember_who?			. plus private data not referenced by routines outside your application
							. this section is also called your B1 section

$(3:03000/$3)						. your static variable data goes in here
from_all	"from all the crew!":0
remember_who?	"Remember us?":0
<a	name="__base"/>
__BASE		$equ		HELLO_START_PAGE_INDEX	. start page index if you know it (fixed in system image)
							. or if you don't for that matter (dynamic iframe load)
							. HELLO_START_PAGE_INDEX is undefined, so hello is dynamic load
$(0:0/$0)
. hello*	$vector		jump2it	. (commented)	. the simplest way of having a vector (entry point) in a 4k-word iframe
							. there are 64 $vector slots at the front of an iframe
							. but hello is dynamic and is called a different way

		catalog					. catalog is the minimal startup macro for a single application of any size
							.	-which is dynamic loadable or
							.	-which is fixed and may be larger than one 4k page
							.	-which is fixed and can be found by name

							. for multiple applications macro $application is used instead of catalog


jump2it		$base_d		$zenith(3)-03000 1024	. you need 1K words external stack for every thread which does printf
							. $base_d macro places assigned static memory at address space 03000 hex

		c	(seg$load) 0,,xi (my_data_segment:L),,long

							. kernel routine (seg$load) initialises static data
							. for this process instance of this application
							. 1st argument rom file system start page index zero
							. means file system is inside this calling iframe (it is)
							. 2nd argument is the 48-bit address of your static data load file
							.
							. my_data_segment is included and named in a small text file loadfs
							. you're ready to execute application code

		printf	$3("Hello World %s %s":LF:0),,xi	; 	. the output string is unnecessarily three strings
			from_all,,xi				;	. even more unnecessarily
			*indirectp,,i					. the third string is addressed indirectly

							. string arguments are in static data literal table $3
							. so other iframes can see them. Other iframes can't see this iframe
							. arguments by value can be from anywhere
							. if arguments are by address that must be specified argument,,xi
							.					          or argument,[index],i

							. arguments by value larger than one word are	argument,,long
							.						argument,,triple
							.						argument,,float
							.						argument,,float192
							.						argument,,floating_packed

		fret		0			. or ii EXIT$

	$do		$<256,$(0:256)		. literal constants at the end of this iframe
						. with values (seg$load) (my_data_segment:L) (__fprintf)
						. must be forced to address 256+ to be addressable
						. lower addressed operands than that are registers 

</pre>
Literals are automatic constants generated by reference at the end of the program section where they are directed

<p>
More is explained about <a href="#literal_tables">literal tables</a> and <a href="#iframes">iframe Construction and Macro Language</a>

<a	name="loadfs"/>
<h4>4.2: loadfs File: Launch Template and Initial Data Load</h4>

loadfs describes a file system embedded and linked in the application image

<p>
All applications are re-entrant shared code and application initial data is unpacked from the embedded file system

<p>
The file system is included in the link of the application group, exports the names of data sections which it contains, and imports execution parameter descriptors as file-system link targets of with class tag G

<p>
volume, file and link names are developer-chosen. A single application has one data sections file and one launch link

<p>
The link entry shown here is not really needed to find hello, because a single loadable application is found by its <a href="#load_app">load</a> path name

<p>
The name assigned on the link entry is a look-up name for execution

<pre	style="font-size:12pt;color:#0000FF">

	$ cd rta/target.rta/hello.app
	$ cat loadfs
	volume embedded
	file my_data_segment lsegment
	tree application_templates
	link hello launch_gate G
	$

</pre>
macro <a style="color:#0000FF">catalog</a> exports application template launch_gate

<a	name="run"/>
<h3>5: How is the Application run?</h3>

Hello is dynamic and is included in <a href="kernel.html#fsda">Device 1 file system</a> where it is located by pathname
<pre	style="font-size:12pt;color:#0000FF">

	$ telnet 172.29.7.7
	Trying 172.29.7.7...
	Connected to 172.29.7.7.
	Escape character is '^]'.
	RTA1 smaragd7 OS shared console
	<a style="color:#000000">r load /test/hello</a>
	00001e
	loader: load /test/hello
	[000050000018:001000003013]
	000023 
	<a style="color:#FF0000">Hello World from all the crew! Remember us?</a>
	load>

</pre>
<a href="#load_app">load</a> is a fixed application in the system image

<p>
<a href="#load_app">load</a> reads file system <a href="kernel.html#fsda">Device 1</a> which is read-only and constructed offline by the system administrator

<pre	style="font-size:12pt;color:#0000FF">

	$ cd rta
	$ more fsimages/baseload
	.
	tree test
	file hello target.rta/hello.app/hello
	.

	$
	$ ./mrand7		# construct the file system

</pre>

<a	name="nvram">
<h3>6: If Applications are ROM instead of Dynamic?</h3>

Applications in NVRAM

<ul	type="square">
	<li>export the name <a href="#__base">__BASE</a> equated to a known start page index:
	<pre	style="color:#0000FF;font-size:14pt">
	 __BASE*	$equ	APPLICATION(5)/*12
	</pre></li>
	
        <li>names <a style="color:#0000FF">APPLICATION(1..1024)</a> are switched in <a style="color:#FF0000">rta/target.rta/def.app</a> to inform kernel routines which NVRAM pages are the Start Page of a fixed application group. Each application group contains a search directory of launch names and parameters
	<pre	style="color:#0000FF;font-size:14pt">

	APPLICATION(5)	$equ	02A000		. for example
	</pre></li>

        <li>script <a style="color:#FF0000">target.rta/def.app/nvlist</a> generates datafile <a style="color:#FF0000">def.app/nvframes.rom</a> containing pointers to ROM application iframes
	<pre	style="color:#0000FF;font-size:14pt">

	$ cd rta/target.rta/def.app

	$ cat iframes.def
	APPLICATION(1)	$equ	00B000		. unless kernel and libraries get larger
	APPLICATION(2)	$equ			. depends how many pages APPLICATION(1) takes
						. and if any fixed library pages intervene
	.
	.
	APPLICATION(5)	$equ	02A000		. for example

	$ ./nvlist	# construct <a style="color:#FF0000">def.app/nvframes.rom</a>

	</pre></li>

        <li><a style="color:#FF0000">nvframes.rom</a> is included in <a href="kernel.html#fsda">file system Device 1</a> and tabled in kernel vectors at system start. <a href="kernel.html#fsda">File system Device 1</a> is constructed offline:
	<pre	style="color:#0000FF;font-size:14pt">

	$ cd rta
	$ ./mrand7
	</pre></li>

        <li>ROM application iframes are invidually searchable for launching applications by name</li><br>

        <li>directory <a style="color:#FF0000">application_templates/</a> in each iframe embedded filesystem links a searchable name to each application:
	<pre	style="color:#0000FF;font-size:14pt">

	$cat loadfs
	volume embedded_fs
	tree data_segments
	file app1_data app1_lsegment
        file app2_data app2_lsegment
	.
	<a style="color:#FF0000">tree application_templates
	link request_name1 _launch_gate_app1 G
        link request_name2 _launch_gate_app2 G</a>
	.
	.
	</pre>
	</li>

        <li>applications are constructed in ROM format and catenated to the system image</li><br>

        <li>have a script named <a style="color:#FF0000">amass</a> in their application directory to govern catenation to the system image:
	<pre	style="color:#0000FF;font-size:14pt">

	insert this_app.rom ../up2here.apps/sysimage.rom
	</pre></li>
	<li>are called with telnet command <a style="color:#0000FF">r </a><a style="color:#FF0000">name</a> or from a script by <a style="color:#FF0000">name</a> or programmatically at their fixed address</li>

</ul>

<a	name="group"/>
<h3>7: Multiple Applications in one Load or ROM Group</h3>

<h4>7.1: Application Collections</h4>
Applications in shared iframes are assembled with relocatable instruction sections and linked

<p>
Their data sections are all at absolute 001000<sub>16</sub> and 003000<sub>16</sub> as all applications

<p>
The application directory has a file <a href="#make_rel">make_rel</a> to command relocatable assemblies of each application for collection

<p>
Applications for combining have no $vector lines at the front and the instruction code section declaration <a style="color:#0000FF;font-family:courier">$(0:*1/$0)</a> has instead of an address a relocation alignment term <a style="color:#0000FF;font-family:courier">*1</a>
<pre	style="font-size:12pt;color:#0000FF">

$(0:*1/$0)

</pre>
Separate assemblies export entry points [ <a style="color:#FF0000">first* second* third*</a> ] for linking

<pre	style="font-size:12pt;color:#0000FF">

<div	style="width:500pt;border-radius:5pt;background-color:#F0F0F0">
$(1:01000)		. B1 frame still absolute
$(3:03000)		. static variable section absolute as ever
	$lit	4
$(4:*1)			. iframe literal constants section
$(0:*1/$0)		. relocatable instruction code section
<a style="color:#FF0000">first*</a>			. exported start address
	$base_d		$zenith(3)-003000	1024
	c		(seg$load)	0,,xi	(data_1st:d),,long
	.
	.
	fret	0	. or ii EXIT$
</div>


<div	style="width:500pt;border-radius:5pt;background-color:#B0B0B0">
$(1:01000)		. B1 frame still absolute
$(3:03000)		. static variable section absolute as ever
	$lit	4
$(4:*1)			. iframe literal constants section
$(0:*1/$0)		. relocatable instruction code section
<a style="color:#FF0000">second*</a>			. exported start address
	$base_d		$zenith(3)-003000	1024
	c		(seg$load)	0,,xi	(data_2nd:d),,long
	.
	.
	fret	0	. or ii EXIT$
</div>

<div	style="width:500pt;border-radius:5pt;color:#00FF00;background-color:#707070">
$(1:01000)		. B1 frame still absolute
$(3:03000)		. static variable section absolute as ever
	$lit	4
$(4:*1)			. iframe literal constants section
$(0:*1/$0)		. relocatable instruction code section
<a style="color:#FF0000">third*</a>			. exported start address
	$base_d		$zenith(3)-003000	1024
	c		(seg$load)	0,,xi	(data_3rd:d),,long
	.
	.
	fret	0	. or ii EXIT$
</div>

</pre>

<a>
A new relocatable section $(4:*1) also appears. This is explained at <a href="#literal_tables">literal tables</a>

<p>
Only instruction sections are constructed as relocatable. Data sections $(1) variable pointers / private data and $(3) static are at absolute 001000 hex and 003000 hex (but physically anywhere) for all instances of all applications


<a	name="make_rel"/>
<h4>7.2: make_rel File</h4>


Applications for linking in a group are named to command <a style="color:FF0000">rels</a>
in one-line text file <a style="color:#FF0000">make_rel</a>
<pre    style="font-size:12pt;color:#0000FF">

	$ cd    rta/target.rta/your.app.for_example
	$ cat   make_rel

        rels app1 app2 app3
        $
        $       # application source files <a style="color:FF0000">app1.msm app2.msm app3.msm</a> are in the directory

</pre>

<a name="link_u"/>
<h4>7.3: Linking Assembly</h4>

<p>
Command <a style="color:#FF0000">amake</a> assembles the files on the <a href="#make_rel"/>rels</a> line then assembles another file to construct the load object (whether actually loadable or in NVRAM)

<p>
In this example the linking assembly  is apps_group.msm

<pre	style="font-size:12pt;color:#0000FF">

	amake apps_group	# the file which collects the applications is apps_group.msm in this example

</pre>

<p>
The combined application contains the entry vectors which jump to the application start locations

<p>
Macro <a style="color:#FF0000">$application</a> is used instead of macro catalog

<p>
<a style="color:#FF0000">$application</a> exports multiple application load-go templates
<a	name="_group_link"/>
<pre	style="font-size:12pt;color:#0000FF">

	$list		0
	$path		../
	$include	def/rta.def
	$include	def/map1.def
	$include	fs/fs24.def
	$include	language/iframe.def
	$path
	$include	../image.app/imports.def
	$list

__BASE	$equ	_MULTIPLE_LOADP

	$list		2

$(0:0)
	<a style="color:#FF0000">$application,1</a>		0:first	0:second 0:third

	$include,$binary	first.rel	$(0)
	$include,$binary	second.rel	$(0)
	$include,$binary	third.rel	$(0)

	$do	$<256,$(0:256)
	$include,$binary	first.rel	$(4)
	$include,$binary	second.rel	$(4)
	$include,$binary	third.rel	$(4)


</pre>
<p>
It is important that the linking assembly includes segments from make_rel outputs *.rel

<p>
make_rel also outputs *.txo files but segments from these do not have all the required information for successful construction
	
<a	name="iframes"/>

<h3>8: iframe Construction and Macro Language</h3>


<a	name="_macros"/>
<h4>8.1: Macros which frame Instruction Code</h4>

Three alternative macros construct iframes. Application and library iframes may alternatively be constructed <a href="#_without">without macro framing</a> 
<ul     type="square">

        <li><a href="#_catalog">catalog</a> constructs a single application</li>
        <li><a href="#_application">$application</a> constructs a densely packed group of applications</li>
        <li><a href="#_iframe">$iframe</a> constructs a block of subroutines</li>

</ul>
iframes can be constructed singly or in a related load group

<p>
Each iframe is any size within direct addressing plus further space for metadata and data section load

<p>
An iframe may contain from 1 to 30 applications or may be a library or block of subroutines

<p>
Direct address space is eight 4K-word pages or 32768 words containing up to 32700+ application instructions

<p>
RTA1 application code is compact to the extent that one 4K-word page of memory may contain the instruction part of 30 applications

<p>
Simplest iframes have 64 vector locations which can be exported as an encoded value of <a style="color:#0000FF"><i>PAGE:OFFSET</i></a>

<p>
Macros <a href="#_catalog">catalog</a> <a href="#_application">$application</a> <a href="#_iframe">$iframe</a> construct gates which point to any offset in the iframe group which may be any size and either fixed or loadable

<p>
Entry to an iframe larger than one 4k-word page must be via a gate and not directly to a known <a style="color:#0000FF"><i>PAGE:OFFSET</i></a> in order to execute instruction code in all the pages of the iframe


<a      name="_catalog"/>
<h4>8.2: catalog</h4>

<a style="color:#0000FF">catalog</a> constructs one loadable or fixed application iframe one or more pages in size

<pre	style="font-size:12pt;color:#0000FF">

	[vector_name* $vector offset]

		catalog[,page_high_index]	[offset]

</pre>

<a style="color:#0000FF">page_high_index</a> is the number less one of 4k-word pages in the iframe

<p>
<a style="color:#0000FF">page_high_index</a> defaults to zero indicating an iframe of one page

<p>
developer tools indicate if iframe storage is insufficient and needs correction by raising <a style="color:#0000FF">page_high_index</a>

<a      name="_application"/>
<h4>8.3: $application</h4>

<a style="color:#0000FF">$application</a> constructs a group of multiple applications in one loadable or fixed iframe one or more pages in size

<pre	style="font-size:12pt;color:#0000FF">

	[vector_name* $vector offset]
	[vector_name* $vector offset]

		$application[,page_high_index]	[iframe:offset iframe:offset...]

</pre>

<a style="color:#0000FF">page_high_index</a> is the number less one of 4k-word pages in the iframe
 
<p>
<a style="color:#0000FF">page_high_index</a> defaults to zero indicating an iframe of one page 

<p>
developer tools indicate if iframe storage is insufficient and needs correction by raising <a style="color:#0000FF">page_high_index</a>



<a      name="_iframe"/>
<h4>8.4: $iframe</h4>

<a style="color:#0000FF">iframe</a> constructs one loadable or fixed subroutine iframe one or more pages in size

<pre	style="font-size:12pt;color:#0000FF">

	[vector_name* $vector offset]
	[vector_name* $vector offset]

		$iframe[,page_high_index]

</pre>

<p>
$iframe frames integrated in dynamically loadable application groups and are not callable from outside the loadable iframe group

<a	name="_library"/>
<h4>8.5: Independent Library Iframes</h4>
Independent libraries (libraries not specific to individual applications) at fixed and known addresses are suitable for construction <a href="#_without">without any framing by macro</a>

<p>
Independent libraries may be constructed in 4k-pages using up to 64 vectors and 64 far returns in each page


<a      name="_without"/>
<h4>8.6: Without any Framing by Macro</h4>
<pre	style="font-size:12pt;color:#0000FF">

	vector_name* $vector offset
	[vector_name* $vector offset]
	[vector_name* $vector offset]

		$list	0
		$do	64-$,	fret	0
		$list

	offset	.
		.
		fret	0

</pre>

<a	name="_app4kp"/>
<h4>8.7: Simple 4K Application Iframes</h4>
A complete and efficient application system image can be constructed without any instruction framing macros if
<ul	type="square">

	<li>instruction frames are one page of 4096 words</li>
	<ul	type="square">
		<li>4K application iframes may contain multiple applications</li>
		<li>4K application iframes may be joined together with <a href="rta.html#call">call</a> <a href="rta.html#fret">fret</a> and <a href="rta.html#go">go</a> instructions to construct large applications</li>
	</ul>
	<li>instruction frames are at fixed storage locations</li>

	<li>library calls are programmatic because they always are</li>

	<li>application startups are</li>
	<ul	type="square"> 
		<li>programmatic, or</li>
		<li>have lookup by name programmed by the integrator, or</li>
		<li>use framing macros <a href="#_catalog">catalog</a> for one application or <a href="#_application">$application</a> for application group iframes</li>
	</ul>
</ul>
Vector values are exported. They are encoded information and not address labels

<p>
Application <a style="color:#0000FF">2simple</a> is constructed without framing macros
<pre	style="font-size:12pt;color:#0000FF">

$ cat 2simple.msm
	$list		0
	$path		../
	$include	def/rta.def
	$include	def/vector.def
	$include	language/stack.def
	$include	stream/stream.def
	$path
	$include	../image.app/imports.def
	$list	

$(3:03000/$3)
$(0:0/$0)
simpl*	$vector	simple
	$list	0
	$do	64-$,	fret	0
	$list
simple	$base_d	$zenith(3)-03000 1024
	c	(seg$load)	0,,xi	(mydata:d),,long
	printf	$3("that ought to be simple enough 4u":10:0),,xi
	fret	0
	$do	$<256,$(0:256)

</pre>
The directory must contain a text file loadfs
<pre	style="font-size:12pt;color:#0000FF">

$ cat loadfs
volume embedded
file mydata lsegment

</pre>
2simple is then built like this
<pre	style="font-size:12pt;color:#0000FF">

$ amake 2simple
$ slab 2simple 2simple.rom 4096
$ cat ../up2here.apps/sysimage.rom 2simple.rom &gt; ./sysimage.rom		# for example

</pre>
Then the integrator must 
<ul	type="square">

	<li>keep track at what page address the application is catenated</li>
	<li>use that Start Page Index * 64 as the application launch vector value [<i>PAGE</i>:000000<sub>2</sub>]</a></li>
	<li>have a way if required of looking up the application by name</li>
	<li>parameter needed for the launch service call <a href="#_app_launch">SPAWN$</a> are { vector, priority, static data size, -B1_frames }</li>

</ul>

<a	name="_app4kq">
<h4>8.8: Simplified Application Iframes</h4>

Application <a style="color:#0000FF">simple</a> is less work for the integrator than application <a style="color:#0000FF">2simple</a> because
<ul	 type="square">

	<li>lookup and vector information is checked to correspond with load location derived from catenation</li>
	<li>data sizes are carried forward automatically into launch parameters</li>
	<li>the <a href="#nvram">application [group]</a> contains a directory of launch name[s] and parameters</li>
	<li>the containing storage block is <a href="#nvram">listed at system start</a> for application lookup and launch</li>

</ul>
<pre	style="font-size:12pt;color:#0000FF">

$ cat simple.msm 
	$list		0
	$path		../
	$include	def/rta.def
	$include	def/vector.def
	$include	language/stack.def
	$include	stream/stream.def
	$include	def.app/iframes.def
	$include	language/catalog.def
	$path
	$include	../image.app/imports.def
	$list	

__BASE*	$equ	<a style="color:#FF0000">APPLICATION(4)</a>/*12

$(3:03000/$3)
$(0:0/$0)
simpl*	$vector	simple

	<a style="color:#FF0000">catalog</a>

simple	$base_d	$zenith(3)-03000 1024
	c	(seg$load)	0,,xi	(mydata:d),,long
	printf	$3("that ought to be simple enough 4u":10:0),,xi
	fret	0
	$do	$<256,$(0:256)

</pre>
__BASE is exported

<p>
<a style="color:#0000ff">iframes.def</a> is introduced to explain <a style="color:#FF0000">APPLICATION(4)</a>

<p>
<a style="color:#0000ff">catalog.def<a> is introduced to explain <a style="color:#FF0000">catalog</a>

<p>
Two more lines in file loadfs assure a name lookup <a style="color:#0000ff">simple</a>
<pre	style="font-size:12pt;color:#0000FF">

$ cat loadfs
volume embedded
file mydata lsegment
tree application_templates
link simple launch_gate G

</pre>
Storage block <a style="color:#FF0000">APPLICATION(4)</a> is identified to the kernel as containing applications for lookup and launch

<p>
A file <a style="color:#0000ff">amass</a> in the directory checks the location of <a style="color:#FF0000">APPLICATION(4)</a> and does the catenation
<pre	style="font-size:12pt;color:#0000FF">

$ cat amass
insert simple ../up2here.apps/sysimage.rom

</pre>
Application <a style="color:#0000FF">simple</a> is simpler. Build is just one command

<pre	style="font-size:12pt;color:#0000FF">

	$ amake simple

</pre>
The result of doing that is <a style="color:#0000FF">simple.app/sysimage.rom</a>

<p>
If simple is the last in the chain then
<pre	style="font-size:12pt;color:#0000FF">

$ cd rta/rta.run
$ export RTA_IMAGE=../target.rta/simple.app/sysimage.rom

</pre>
Otherwise the chain modules after <a style="color:#0000FF">simple</a> must be serially reinserted starting with with the module with <a style="color:#0000FF">amass</a> file command
<pre	style="font-size:12pt;color:#0000FF">

insert this_module ../simple.app/sysimage.rom

</pre>
<a href="#nvram">def.app/nvframes.rom</a> must be constructed for the application number of application <a style="color:#0000FF">simple</a> and built into File System Device 1

<p>
Application <a style="color:#0000FF">simple</a> is fixed in the system image and available after restart
<pre	style="font-size:12pt;color:#0000FF">

$ telnet 172.29.7.7
RTA1 smaragd7 OS shared console
r simple
00001f 
that ought to be simple enough 4u

</pre>

Macro <a style="color:#FF0000">catalog</a> can be used to launch large and loadable single applications

<p>
Application framing  macros <a href="#_catalog">catalog</a> <a href="#_application">$application</a> automatically measure data section size and necessary heaps and stacks

<a	name="_app_launch">
<h4>8.9: Application Launch</h4>
Application launch call is <a href="kernel.html#spawn_ii">SPAWN$</a>
<pre	style="font-size:12pt;color:#0000FF">

	ql	(vector, PRIORITY, STATIC_SIZE, -B1_FRAMES:q)
	ii	SPAWN$

</pre>
Process primary thread identifier is returned in application register a

<p>
System call to <a href="kernel.html#tag_ii">TAG$</a> attaches a displayable name to thread [register a]
<pre	style="font-size:12pt;color:#0000FF">

	lb	$3("name":0),,xi	. leftside word zero means this thread 
	ii	TAG$

</pre>
A thread calling TAG$ with zero in register a names itself


<a      name="literal_tables"/>
<h3>9: Literal Tables</h3>

Literals are data constants generated by reference

<p>
In RTA1 literals may be big numbers, callable vector names, strings or structures
<pre	style="font-size:12pt;color:#0000FF">

	c	(__sscanf)	$3("%s %d":0),,xi	string,,xi	number,,xi

</pre>
Literals are recognised

<ul	type="square">

	<li>by being in parentheses without operators attached front or back</li>

	<li>by being in parentheses with a label of type <a href="">literal pool tag</a> on the front</li>

</ul>
Literal pool tags are declared on program section headers
<pre	style="font-size:12pt;color:#0000FF">

__STATIC	$equ	3
$(__STATIC:03000/$3)		. literal pool tag in static data section is $3

</pre>
There is a default program section for literals and it is $(0), the iframe. An assembly directive <a href="http://timmilescox.github.io/masmx/masmx.html#lit">$lit</a> may change the default and may also tag the default literal pool
<pre	style="font-size:12pt;color:#0000FF">

"$4"	$lit	4

</pre>
Literals may be indirection constants for very large addresses which don't fit inside an instruction
<pre	style="font-size:12pt;color:#0000FF">

	tz	<a style="color:#000000">*</a>(_IO_WINDOW*/18++131072<a style="color:#000000">s</a>)	. force the literal to single word with suffix <a style="color:#000000">s</a>

</pre>
The indirection operator <a style="color:#0000FF">*</a> is allowed on the front of a literal

<p>
Variables and constants in the first 8192 locations of address space may be indirection pointers. These locations are
<ul	type="square">

	<li>256 registers: addresses [000000..0000FF]</li>
	<li>words 256..4095 of the actual iframe: addresses [000100..000FFF]</li>
	<li>all 4096 words if the actual B1 frame: addresses [001000..001FFF]</li>

</ul>
Integer constants add a word of signs if the highest bit is not a sign. So an address literal pointing to the high half of address space needs to be suffixed <a style="color:#0000FF">s</a> to prevent a prefix of 24 zero bits

<p>
Literals can be any data which can't be an immediate operand because of its size
<pre	style="font-size:12pt;color:#0000FF">

	qpush	(1.5)		. that generates 4 words
	d	(3000000)	. that's within 1 word but larger than &plusmn;32767

</pre>
Literals can go in any program section where data can be generated but most of them go in iframe $(0, 4) or static $(3)

<p>
Literals are placed in static if another iframe references them. That other iframe cannot address anything in this iframe
<pre	style="font-size:12pt;color:#0000FF">

	c	(__sscanf)	<a style="color:#FF0000">$3("%s %d":0),,xi</a>	string,,xi	number,,xi

</pre>
By default literals are in the current iframe. Many iframe literals are call vectors to other iframes and must be constants or variables because the operand of instructions go and call is a constant or variable
<pre	style="font-size:12pt;color:#0000FF">


	c	<a style="color:#FF0000">(__sscanf)</a>	$3("%s %d":0),,xi	string,,xi	number,,xi
	.
	$do	$<256),$(0:256)

</pre>
Literals in the iframe must be in words 256..4095 of the iframe. Lower operand adresses than 256 are registers. Operand adresses 4096+ are not in the iframe. Only instructions can be obtained from addresses 4096+ of the iframe

<p>
The construct <a style="color:#0000FF">$do  $<256),$(0:256)</a> at iframe end forces location counter to 256 if it has not reached 256, so that the automatic literal table is in memory address space

<p>
If instructions + literals > 4096, literals need to be placed in front of instructions, not after

<p>
Macro <a style="color:#0000FF">$lits4</a> places the default literal table in a new section $(4) starting at address 256 

<p>
Macro <a style="color:#0000FF">$check4</a> at the end of the instruction section checks if the default literal table is inside the number of words allowed on the <a style="color:#0000FF">$lits4</a> line. The default is 20 words. Fewer or more words are reserved with an argument to <a style="color:#0000FF">$lits4</a>

<pre	style="font-size:12pt;color:#0000FF">

$(0::0/$0)

        $application,1  startup

        $lits4	[words]
startup
	.
	.
        $check4
	

</pre>

If multiple applications are linked in one iframe all their default literal pools must be collected within iframe locations 256..4096, either before instruction code or after it if instructions + literals < 4097

<p>
All <a href="#group">relocatable applications</a> included must be assembled with automatic literals in a separate relocatable section, here $(4), from instruction code in $(0)

<pre    style="font-size:12pt;color:#0000FF">

$(1:01000)              . B1 frame still absolute
$(3:03000)              . static variable section absolute as ever
        $lit    4
$(4:*1)
$(0:*1/$0)              . relocatable instruction code section
first*                  . exported start address
        $base_d         $zenith(3)-003000       1024
        c               (seg$load)      0,,xi   (data_1st:d),,long
        .
        .
        fret    0       . or ii EXIT$


</pre>

<p>
In this <a href=="#_group_link">linking assembly</a> three small applications have instructions in program section $(0) and literals in $(4)

<pre	style="font-size:12pt;color:#0000FF">


$(0:0)
        <a style="color:#FF0000">$application,1</a>             0:first 0:second 0:third

        $include,$binary        first.rel       $(0)
        $include,$binary        second.rel      $(0)
        $include,$binary        third.rel       $(0)

        $do     $<256,$(0:256)
        $include,$binary        first.rel       $(4)
        $include,$binary        second.rel      $(4)
        $include,$binary        third.rel       $(4)

</pre>
For an applications group iframe > 4096 words it is necessary to place iframe literal pools before the instructions

<pre	style="font-size:12pt;color:#0000FF">

$(0:0)
        <a style="color:#FF0000">$application,1</a>             0:first 0:second 0:third

	$do	$<256,$(0:256)
        $include,$binary        first.rel       $(4)
        $include,$binary        second.rel      $(4)
        $include,$binary        third.rel       $(4)
	$do	$>4096,		$flag	default literal tables larger than possible

        $include,$binary        first.rel       $(0)
        $include,$binary        second.rel      $(0)
        $include,$binary        third.rel       $(0)

</pre>

<a	name="load_app"/>
<h3>Appendix A: load Application</h3>

load Application loads applications to executable space from filestore and optionally starts a process instance of the application

<p>
load is itself an application and has a command interface

<p>
load is started from <a href="connect.html=connect#telnet">telnet</a> or from a <a href="#auto">script</a>

<p>
load is started from telnet with the console command <a href="connect.html=connect#telnet">r</a>
<pre	style="font-size:12pt;color:#0000FF">

	r load [ first command ]
	.
	.	commands
	.
	@eof

</pre>

load is started by name from a line of <a href="#auto">script</a> text
<pre	style="font-size:12pt;color:#0000FF">

	load [ first command ]
	.
	.	commands
	.
	@eof

</pre>
Commands to load are
<pre	style="font-size:12pt;color:#0000FF">

	a path name		/directory[/directories...]/file[* { + | application } ]

				path name with no *suffix	load, execute the 1st application in the file
				path name*+			load
				path/file*application		load, execute the <a href="scripts.html#group">named application within the file</a>

								in all cases the file remains loaded

	name of a loaded file	filename			execute the 1st application in the loaded file
				filename*application		execute the named application
				filename*-			unload


	built-in commands	@?				list loaded files

				@run <a href="#auto">script_path</a>		start a script from a new thread

				@eof				exit load, all binaries unload

</pre>
All loaded files are in the memory estate of load and are removed from memory when load exits

<p>
This has the effect that the loaded files are only executable from the calling instance of load application

<p>
This permits prototyping and testing

<p>
However all RTA1 applications are shared-code reentrant

<p>
It is projected to assign the loaded files optionally to kernel vectors, making the loaded applications common for system runtime

<p>
load is only from <a href="kernel.html#fsda">file system Device 1</a>, which is not online updatable

<p>
Applications may be loaded and started programmatically using

<ul	type="none">
	<li><a href="kernel.html#fs_loadgo">kernel routines</a></li>
	<ul	type="none">
		<li><a href ="kernel.html#iframe_load">fspath</a></li>
		<li><a href ="kernel.html#iframe_load">iframe_load</al></li>
		<li><a href="kernel.html#qstart">qstart</a></li>
	</ul>
	<li>and <a href="kernel.html#ii">system calls</a></li>
	<ul	type="none">
		<li><a href="kernel.html#spawn_ii">SPAWN$</a></li>
		<li><a href="kernel.html#thread_state_ii">THREAD$STATE</a></li>
	</ul>
</ul>

<a	name="iframe_examples"/>
<h3>Appendix B: iframe Examples</h3>

<ul	type="square">
	<li><a href="array.html">array and 1off</a> are a load group of SIMD demonstrations</li>
	<li><a href="#source">hello.msm</a> is a simple loadable application</li>
	<li><a href="iframe.html">gate.msm</a> is a large loadable application consisting multiple iframes</li>
	<li><a href="#_app4kq">simple.msm</a> is a simple ROM application</li>
	<li>rta/target.rta/rom1.app/[fixed1 fixed2].msm and apps.msm are a group of ROM applications</li>
</ul>

<a	name="auto"/>
<h3>Appendix C: Scripts and Automatic Start</h3>

Kernel routine <a style="color:#FF0000">run_start</a> runs applications serially from a script at absolute path in <a href="kernel.html#fsda">file system Device 1</a>
<pre	style="font-size:12pt;color:#0000FF">

	c	(run_start)	$3("/directory[/directory...]/script":0),,xi

</pre>

Scripts may be nested to a depth of three

<p>
A nested script path in the text has the syntax <a style="color:#0000FF">/directory[/directory...]/script</a>

<p>
Text lines are otherwise application command lines followed optionally by lines of stdin

<p>
The first stdin line available to an application is its own command line which may have argument fields

<p>
stdin text may be commands to applications like shells

<p>
script execution is sequential. Each application ends before more script text is read. This allows applications to read script lines as stdin
<pre	style="font-size:12pt;color:#0000FF">

load /production/multiple*applications1	# run load application: command to load + run /production/multiple*applications1
inputs to applications1
.					# end command of application1
multiple*applications2			# run another part of the application group now loaded
multiple*applications3			# and another part
@eof					# end command of load application, loaded apps get unloaded
read_the_post				# another application
/another/script				# a nested script

</pre>
Although <a style="color:#FF0000">run_start</a> processes strictly sequentially, a caller may process multiple scripts simultaneously from separate threads

<p>
A script <a style="color:#0000FF">/initial/script</a> is run automatically at system start if it is present in <a href="kernel.html#fsda">file system Device 1</a>

<p>
Scripts are not always started interactively and therefore terminal output for input is not assumed

<p>
stdout from script-activated applications is a UDP broadcast displayed in a shell running platform utility <a style="color:#FF0000">oconsole</a>
<pre	style="font-size:12pt;color:#0000FF">

	sudo oconsole

</pre>

Multiple platforms anywhere in the local net may run <a style="color:#FF0000">oconsole</a>

<p>
stdout of background processes can only be broadcast if broadcast address 255.255.255.255 has an interface route in $HOME/.rta_net, for example
<pre	style="font-size:12pt;color:#0000FF">

	export RTA_WIFI=172.29.7.72/12@0.0.0.0/0*192.168.1.254@192.168.0.0/16@172.16.0.0/12<a style="color:#FF0000">@255.255.255.255/32</a>

</pre>

If an emulator platform doesn't appear to receive its own broadcast run the <a href="connect.html#run">network trunk process</a> with -o option. If RTA1 has a script /initial/script then -o should be opted on runL before the emulator is started
<pre	style="font-size:12pt;color:#0000FF">

	./runL -o		# forward background console output to platform loopback before RTA1 runs

</pre>
or else
<pre	style="font-size:12pt;color:#0000FF">

	./runL			
	-o			# start forwarding background console output to platform loopback

</pre>

<pre	style="font-size:10pt;background-color:#FFFFFF00">
<div	style="border-radius:5px;background-color:#FF0000;color:#FFFFFF;width:75pt;height:100pt;top:25pt;right:375pt;position:absolute">    NVRAM
_____________
 application
        code
_____________

 initial data<a style="color:#000000">------------</a>
 load strings

</div>

<div	style="border-radius:5px;background-color:#00FF00;width:75pt;height:100pt;top:25pt;right:225pt;position:absolute">     RAM
_____________




----->
</div>

</a>

<a      href="#application_group">
<div	style="border-radius:5px;color:#FFFFFF;background-color:#0000FF;
	width:75pt;height:75pt;top:25pt;right:125pt;position:absolute">


   fixed and
    loadable
applications
</div>
</a>

	<a	href="program.html#overview" style="font-size:17pt;top:200;right:125pt;position:absolute">to app development overview page</a>

<a      href="masmx7r3.html">
<div	style="border-radius:5px;color:#FFFFFF;background-color:#0000FF;width:75pt;height:75pt;top:25pt;right:25pt;position:absolute">
        meta
   assembler

      binary
   utilities

</div>
</a>

<div	style="border-radius:5px;background-color:#FF0000;color:FFFFFF;
	width:225pt;height:100pt;top:200pt;right:225pt;position:absolute">    NVRAM
____________________________________________________________________________________________
	            fixed   more fixed
      kernel applications applications
	   +	      		    
    embedded  app lookups  app lookups
 app servers ------------------------>
             initial data initial data
</div>

<div	style="border-radius:5px;background-color:#00FF00;
	width:75pt;height:100pt;top:200pt;right:150pt;position:absolute">     RAM
_____________
     loadable
 applications


 application
        data
</div>
<div	style="background-color:FFFFFF;width:1pt;height:166pt;top:200pt;right:300pt;position:absolute">
</div>

<div	style="background-color:FFFFFF;width:1pt;height:166pt;top:200pt;right:375pt;position:absolute">
</div>


<a      href="language.html">
<div	style="border-radius:5px;color:#FFFFFF;background-color:#0000FF;
	width:75pt;height:75pt;top:125pt;right:25pt;position:absolute">
   functions

        call
    sequence
      macros

</div>
</a>

<a      href="#build">
<div	style="border-radius:5px;color:#FFFFFF;background-color:#0000FF;
	width:75pt;height:75pt;top:225pt;right:25pt;position:absolute">


 application
       build
     scripts

</div>
</a>

<a      href="kernel.html">
<div    style="border-radius:5px;color:#FFFFFF;background-color:#0000FF;
        width:75pt;height:75pt;top:325pt;right:25pt;position:absolute">


 
  Kernel API

</div>
</a>

<a      href="index.html">
<div    style="border-radius:5px;color:#FFFFFF;background-color:#0000FF;
        width:75pt;height:75pt;top:325pt;right:125pt;position:absolute">



  INTRO PAGE


</div>
</a>
</pre>
</div>
