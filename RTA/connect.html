<html>
<div	style="font-size:15pt">

<center>

<h1>Running and Talking to the Emulated RTA1<br>
and constructing the emulated machine for your host system</h1>

<i>
Copyright Tim Cox, 2012<br>
This document is part of the RTA1 Processor Programmable Architecture Specification<br>
The RTA1 Architecture is freeware licensed with the GNU General Public Licence Version 3<br>
The same licence encompasses all accompanying software and documentation <br>
The full licence text is included with these materials<br>
See also the licensing notice at the foot of this document
</i>

</center>

<ol>
	<li><a href="#rungo">Running and Building Emulated RTA1</a></li>
	<ol>
		<li><a href="#readies">Ready Emulation Images</a></li>
		<li><a href="#running">Running RTA1</a></li>
		<ol>
			<li><a href="#runnet">Starting a Real Network Service for Emulated RTA1</a></li>
			<li><a href="#runrta">Starting the Emulated RTA1 Machine</a></li>
		</ol>
		<li><a href="#osserv">portal/osserv Networking</a></li>
		<li><a href="#address plan">Network Address Plan</a></li>
		<li><a href="#zeroconf">Autoconf and Multihomed Routes</a></li>
		<li><a href="#windows">Network Considerations with Windows 10</a></li>
		<li><a href="#locostwifi">Performance Considerations with Low-Cost Home Wifi</a></li>
		<li><a href="#loopback">Special Considerations Networking from Emulator Platform to Emulated Machine</a></li>
		<li><a href="#repair">Checksum Repair using OSX Software Loopback</a></li>
		<li><a href="#build">How to build the Emulated Machine</a></li>
			<ol>
			<li><a href="#buildnet">Building a Network Service</a></li>
			<li><a href="#buildrta">Building the RTA1 Emulator</a></li>
			<li><a href="#tiptoe">Emulated RTA1 Memory Sizes</a></li>
			</ol>
		<li><a href="#operate">Operating the Emulator</a></li>
		</ol>
	<li><a href="#ipfw">Appendix A: netifx Datagram Divert Service</a></li>
	<ol>
		<li><a href="#datagram service">Earlier Datagram Service over IPFW</a></li>
		<li><a href="#netifx">Building netifx</a></li>
	</ol>
	<li><a href="#licence">adhesion to FSF GNU General Public License</a></li>
</ol>
	

<a	name="rungo"/a>
<h2>Running and Building Emulated RTA1</h2>

<a	name="readies"/a>
<h3>Ready Emulation Images</h3>

<p>
The binary path for RTA1 emulation and binary utilities is $RTA_BINARY,
by default <b>/Users/YOU/rta/binary.rta/osx.x86</b>

<p>
If you have OSX PowerPC, your shell profile needs to change <b>$RTA_BINARY</b>
<pre>

	export	RTA_BINARY=<b>/Users/YOU/rta/binary.rta/osx.ppc</b>

</pre>
If you have a different platform from OSX you need to <a href="#build">build</a>
 the emulator binary tiptoe and the network service binary osserv.<br>
All other binary utilities and build tools are already
available on 32-bit Linux x86 and on Win32


<a	name="running".>
<h3>Running RTA1</h3>

<a	name="runnet"/>
<h3>Starting a Real Network Service for Emulated RTA1</h3>

An emulator host process is run from a shell to provide network connectivity
<pre>

	cd	<a href="#osserv">rta/portal</a>
	./runL	[ ipfw ]

</pre>
rta/portal/runL is a script which configures networks and runs binary osserv.<br>
Argument ipfw is only needed if the emulator platform is OSX and not recent enough to have<br>
Packet Filter based firewall <b>pfctl</b>. The platform must then be old enough to have <b>ipfw</b>
firewall

<a	name="runrta"/>
<h3>Starting the Emulated RTA1 Machine</h3>

Emulated RTA1 is run from another shell
<pre>

	cd	<a href="#tiptoe">rta/rta.run</a>
	./run	minimal rand7
	g

</pre>
if no breakpoints are needed, command <b>g</b> leaves single step and emulated
RTA1 is running

<p>
For single step and debug commands see <a href="#operate">Operation</a>.
For choosing emulated machine memory capacity and constructing variants see
<a href="#tiptoe">Memory Sizes</a>

<p>
rta/rta.run/run is a script which executes the emulator binary <b>tiptoe</b>.<br>
tiptoe loads in turn an RTA1 target system image, identified in this example as
<pre>

	rta/target.rta/rta.gen/minimal.rom

</pre>
Target system images in RTA1 code are generated in directory space
<a href="#target">rta/target.rta/rta.gen</a><br>

<p>
second argument rand7 is a file system image constructed with RTA1 offline binary utilities

<p>
Loadable filestore image rand7 contains web hosting pages and currently takes 1 bank of filestore.<br>
24-bit computer words in filestore images are packed into 3 bytes each of emulator host storage

<p>
Each 262144-word filestore bank takes 768K bytes of emulator host memory. That is the total amount required for<br>
filestore image rand7. The addition of more online documentation is expected to reach two filestore banks altogether

<p>
rta/portal/runL sets the external network environment. A third shell is usually
opened for network connectivity over the emulator host software loopback interface
<pre>

	cd rta/client
	./prun

</pre>
rta/client/prun installs connectivity between the emulator platform and emulated RTA1,
then sets default addresses which PC client program
 <a href="#fp">fp</a> uses to operate the RTA1 96/192-bit floating point server

<p>
There are some <a href="#loopback">special addressing considerations</a> for running
client applications including  browsers, fp, netSNMP, telnet, and echo protocol to RTA1
over the software loopback interface of the emulator host. Traffic for RTA1 arriving
from the software loopback interface of an OSX platform also needs
<a href="#repair">checksum repair</a> which osserv applies with option -z 

<a	name="osserv"/>
<h3>portal/osserv Networking</h3>

<p>
osserv shares network traffic with RTA1 through shared memory

<p>
The shared buffer appears to emulated RTA1 as a device array, one of 63
peripheral memories in RTA1 architecture

<p>
The interface process uses Berkely Packet Filter (BPF) kernel calls
to receive and send.<br>The materials for running this interface process
are in directory <b>rta/portal</b>

<p>
An earlier network access method for RTA1 used IPFW Divert Socket,
but that is not available on any recent personal computer.<br>
OSX computers old enough to have <b>ipfw</b> firewall may also use the
newer and more featured portal/osserv with the argument <b>ipfw</b>
<pre>

	cd	rta/portal
	./runL	ipfw

</pre>
Platforms with Packet Filter based firewall omit the <b>ipfw</b> argument

<p>
portal/osserv is a Packet Filter based frame service which runs on most
platforms of any age whatever firewall interface they have.<br>
However script portal/runL adds one firewall rule and needs to know
which firewall interface to operate

<p>
Platform Firewall differences for OSX are per distribution OSX 10.<a style="color:0000FF">X</a>.Y<br>
and all 10.X.Y distributions are reported to bash shell as 10.0

<p>
The earlier datagram divert service <b>netifx</b> is implemented entirely via <b>ipfw</b>

<p>
Materials for running IPFW Divert are still delivered in directory
<b>rta/netifx</b> and run on Mac PowerPC and x86 up to Snow Leopard,<br>
see <a href="#ipfw">Appendix A</a>. However BPF-based <b>portal</b> also
runs on these slightly venerable Apple platforms, and additionally is specific<br>
for new Apple platforms and intended for other platforms including Linux

<p>
Apple Computer did not have PCAP fully working on older platforms when it
withdrew IPFW from newer platforms. so BPF-based <b>portal/osserv</b> has
been devised for any platforms. This has the accidental advantage that
<b>portal</b> constructs its own filter rules for BPF, and produces a far
more efficient filter program than the PCAP "compiler"

<p>
Packet filtering does not remove any incoming frames from the emulator platform kernel,<br>
but the kernel only gets datagrams for which it has protocol addresses configured on its interfaces

<p>
With <b>osserv/portal</b> the practice of aliasing emulator platform
interfaces with addresses for emulated RTA1 is phased out.<br>
Subseqently it is mostly unnecessary to  drop frames after they are copied
via BPF for RTA1

<p>
No firewalls encountered so far have dropped any frames before BPF filter
programs had them

<p>
The actions of <b>portal/osserv</b> are
	<ol>
	<li>script portal/runL sets a firewall rule to prevent
	local http traffic for RTA1 from reaching the kernel</li>

	<br>
	<li>binary osserv binds real-interface:net-address[/mask][:port]
	combinations to RTA1 according to command line arguments</li>

        <br>
	<li>osserv ascertains interface types and determines physical
	address, address size and whether ARP is used</li>

        <br>
	<li>osserv writes a macro-assembly source file and build
	script for the filter program of each interface and starts
	a process to assemble filter pseudo-instructions, in reality
	64-bit binary-encoded rules. osserv awaits the completion
	of each filter program build process</li>

        <br>
	<li>osserv specifies filter programs, notification timing
	and non-block action to BPF</li>

        <br>
	<li>osserv initialises the buffer shared with emulated RTA1
	and uses it to transmit network configuration PDUs to RTA1</li>

        <br>
	<li>RTA1 receives configuration tuples as its first traffic</li>

        <br>
	<li>osserv submits received traffic to RTA1 and transmits traffic
	from RTA1</b>
	</ol>

<div    style="color:0000FF">

	<a	name="address plan"/>
	<h3>Network Address Plan</h3>
	Address configuration is structured in a way intended to help
	a rapid and clear choice of network media

	<p>
	The process scripts which launch interfaces for emulated RTA1
	specify network addresses per interface to binary osserv.<br>
	These process scripts are rta/portal/runL and rta/portal/rerunL.
	rerunL omits repeated insertion of firewall rules

	<p>
	The developer needs to carry out some equivalent configuration
	at PCs intended to communicate over LAN with emulated RTA1

        <p>
	Any network addresses can be used. The following address plan
	is used by default in start-up scripts runL and rerunL

        <p>
	A different address plan  would need to be reflected in the
	default routing table assembled into the RTA1 target image<br>
	in assembly language file rta/target.rta/t77.4/routes.msm

        <p>
	Target image routing table will later be constructed dynamically
	on RTA1 target image start, as the network addresses already are

        <p>
	Blocks of network addresses in the default plan are these

        <p>
	RTA1 on wired Ethernet uses some of the addresses
	<pre>
		172.29.7.8/26 to 172.29.7.62/26

	</pre>
	and RTA1 on WiFi uses some of the addresses
	<pre>

		172.29.7.66/24 to 172.29.7.253/24

	</pre>
	Emulated RTA1s on the local network are assiged addresses
	from the low end of these ranges,<br>
	and addresses at the high end
	of these ranges are notionally for PCs talking to RTA1s
		
        <p>
        To be in the same wired ethernet subnet as RTA a PC has
	typically an address around 172.29.7.60/26

        <p>
        This causes traffic for RTA1s which have addresses from
	172.29.7.8/26 to go via wire

        <p>
	No LAN addresses used by emulated RTA1s are any longer
	alias addresses of the emulator host's interfaces.<br>
	The emulated RTA1 is instead using ARP for real

        <p>
	PC programs bind this address to communicate over emulator
	host loopback with emulated RTA1
	<pre>

		172.29.7.6/32

	</pre>
	<b>172.29.7.6</b> remains an alias of emulator host software loopback

	<p>
	PC programs on the emulator host platform address emulated RTA1 as
	<pre>

		172.29.7.7/32

	</pre>
	<b>172.29.7.7</b> is no longer an alias of emulator platform loopback.</b>
	Emulator host routes to <b>172.29.7.7</b> via gateway <b>127.0.0.1</b>

        <p>
	To be in the same WiFi subnet as RTA a PC has typically an
	address around 172.29.7.230/24

        <p>
        This causes traffic for emulated RTAs which have adresses
	from 172.29.7.66/24 to go via WiFi

        <p>
        RTA1 has a new routing table entry
	<pre>

		172.19.7.0	255.255.255.192

	</pre>
        which goes to the wired interface and is classed as local

        <p>
	The existing route
	<pre>

		172.19.7.0	255.240.0.0

	</pre>
	routes traffic to WiFi. Routes with wider masks are of course searched first

        <p>
	RTA1 is now doing ARP for real and could do ZeroConf

        <p>

	There are some special considerations about placing
	<a href="#windows">Windows</a> PCs in RTA subnets and<br>
	the alternative of routing from PC over emulator host may be preferable

	<p>
	POSIX style computers may equally be routed instead of subnetworked
	to the emulated RTA1.<br>
	Shell commands for restating a route are for example
	<pre>

        sudo route -nv delete -host 172.29.7.9
        sudo route -nv add -host 172.29.7.9 192.168.1.3

	</pre>

</div>


<a	name="zeroconf"/>
<h3>Autoconf and Multihomed Routes</h3>

        routes in the route table of RTA1 target image
        are typed homed (bound to an interface) or
        not homed

	<p>
        routes not homed may replicate remote network addresses
        in separate attached networks

	<p>
        routing picks a next hop for datagrams, and if the route
        is homed IP uses the indicated outgoing interface

	<p>
        if the route is not homed the outgoing interface is chosen
        according to datagram source network address, which should
        not be duplicated in any way on one host

	<p>
	RTA1 IPv4 can consequently exchange datagrams with remote sockets
	which MAY replicate addresses on separate attached networks

	<p>
	ZeroConf is a procedure which may negotiate identical addresses
	within separate attached networks, but is not the only method
	of so doing. Manual configuration and DHCP might do the same
	so long as the networks remain separate and are directly attached

	<p>
	Addresses which potentially replicate in different attached
	networks are not routable. Routes which could reach replicated
	addresses are known to RTA1 IPv4 because their interface
	attribute in the routing table has the wildcard value ANYNET

	<p>
        This allows a single routing table entry to route to any
        autoconf addresses which have been encountered

	<p>
	Routes of this kind only apply to locally attached networks
	and are always direct. The next-hop is the the destination
	
	<p>
        ARP caches each protocol address separately for each attached
	network where it appears

	<p>
	ARP resolution requires a hit on protocol address plus interface index


<a	name="windows"/>
<h3>Network Considerations with Windows 10</h3>
<pre>

	The earlier method of routing to the emulator host	
	as gateway to RTA1 is still a good technique for
	talking from Windows 10 PCs to RTA1

	netsh cannot alias an interface into a subnet
	without breaking that interface's DHCP configuration.
	This lames the PC's internet access

	any of the following solutions will assure service

		netsh can manually configure an interface with multiple
		addresses, allowing inclusion in a subnet where RTA1 is
		found, and simultaneously access to the internet

		routes can be installed on windows PCs adressing emulator
		host interfaces as gateways, without attempting to configure
		PCs with addresses in RTA1's subnets

		one physical network can be used between PCs and RTA1,
		for example wired Ethernet, leaving automatically configured
		DHCP to another network, for example WiFi

	Opening the administrator command prompt is enough authority to
	operate netsh and route

	Manual addition of an address to an interface on Windows 10
	is like this

                netsh interface ipv4 add address name="WiFi" 172.29.7.x/24

	However if the interface was DHCP up to this point, the DHCP binding
	is lost and the add is effectively a set

	The less destructive method of naming the emulator host as gateway
	is like this

                route add -p 172.29.6.y mask 255.255.255.255 192.168.x.x

	The last address on the line is gateway, and it should be the
	emulator host's known address on this interface 

        You need to do this anyway if you want to talk to RTA1 from another network

        This configuration restriction (inability to add an extra address
        to the DHCP-configured interface) is confined to Windows. Linux and
        Darwin (Apple OSX) do not have this restriction


</pre>
<a	name="locostwifi"/>
<h3>Performance Considerations with Low-Cost Home Wifi</h3>

        Some performance restrictions have been encountered
        using low-cost home WiFi to transmit data in quantity
        between RTA1 and other locally networked hosts

	<p>
        Excellent network performance has been regained by
	transmitting over wired Ethernet instead

	<P>
        The WiFi products associated with problems appear to treat
        intranet traffic as upload and drop hundreds of presumably
        over-budget segments. At any rate packet loss is large.

	<P>
        RTA1 uses an aggressive TCP resend policy to maintain
        performance. Aggressive resends are switched on via telnet
	<pre>

                telnet -s 172.29.7.6 172.29.7.7
                aggress

	</pre>
        this command is a flipflop so repeating it turns aggressive
        resends off again

	<p>
        This is not considered best practice but an emergency method

	<p>
        A performant network is present in the form of wired Ethernet
        wherever WiFi is present


<a	name="loopback"/>
<h3>Special Considerations Networking from Emulator Platform to Emulated Machine</h3>

Emulated RTA1 has by default an address 172.29.7.7<br>
The emulator host routes to 172.29.7.7 via gateway 127.0.0.1

<p>
Any IP traffic from the emulator host to the
emulated RTA1 must to be forced to come from an<br>
address other than 127.0.0.1, because RTA1 has a
loopback named 127.0.0.1

<p>
Platform script <b>rta/client/prun</b> adds an address 172.29.7.6
to emulator host loopback and sends the echo request
<pre>

	ping -c 6 -S 172.29.7.6 172.29.7.7

</pre>
telnet can also be guided on the command line
<pre>
<div    style="color:#0000FF">


	$ telnet -s 172.29.7.6 172.29.7.7</div><div    style="color:#FF0000">
	Trying 172.29.7.7...
	Connected to 172.29.7.7.
	Escape character is '^]'.
	RTA1 smaragd7 OS shared console
	key h for command list</div><div    style="color:#0000FF">
	h</div><div    style="color:#FF0000">
	commands are	t	h	bsh&
			stay

</div>
</pre>
The floating point interactor <b>client/fp</b> calls the
floating server on RTA1. <b>fp</b> is commanded with
argument 2 to come from somewhere different from the
destination
<pre>

	fp 172.29.7.7 172.29.7.6

</pre>

script <b>client/prun</b> also writes default target and source
addresses for <b>fp</b>

<p>
If you want different default addresses for <b>fp</b> change
<b>prun</b>. For no default addresses, change them to
<pre>

	echo	fp-server	0.0.0.0  >config.fp
	echo	fp-client	0.0.0.0 >>config.fp

</pre>
<p>
There is some point in having this floating server in the
emulated machine! The PC hasn't one micron particle in a
light year of RTA1's number range. Not by another million
and a quarter decimal places! The PC is obliged to send the largest
numbers in ASCII because it can't otherwise represent them
<pre>
<div	style="color:#0000FF">


        $ fp 172.29.7.7
        remote application socket 3 bind state 0 F 2 NB 0 udconnect state 0

        246913578024691357802e600004 / 2000000000000000000000000e-600000
        send state 65
        recv state 34/35 +1.23456789012345678901e+1200000
        

</div>
<div	style="color:#FF0000">

	$ fp -U
	remote application socket 3 bind state 0 F 2 NB 0 udconnect state 0

	3.666666999999333333666666999999333333666666e+1000000 / 3e-250000
	send state 66
	recv state 55/35 +1.222222333333111111222222333333111111222222e+1250000

</div>
</pre>
netsnmp manager has a configuration file to say where it's
coming from
<pre>

	/Users/YOU/.snmp/snmp.conf 
	 clientaddr	172.29.7.6

</pre>
Then you can interact from the emulator host
<pre>
<div    style="color:#FF0000">

	$ snmpwalk -v 1 -c public -Ir -Os 172.29.7.7 tcp
	.
	tcpMaxConn = INTEGER: 7500000
	tcpActiveOpens = Counter32: 0
	tcpPassiveOpens = Counter32: 1
	tcpAttemptFails = Counter32: 0
	tcpEstabResets = Counter32: 0
	tcpCurrEstab = Gauge32: 1
	tcpInSegs = Counter32: 7
	tcpOutSegs = Counter32: 6
	tcpRetransSegs = Counter32: 0
	tcpConnTable.172.29.7.7.23.172.29.7.6.51171.1 = INTEGER: 5
	tcpConnTable.172.29.7.7.23.172.29.7.6.51171.2 = IpAddress: 172.29.7.7
	tcpConnTable.172.29.7.7.23.172.29.7.6.51171.3 = INTEGER: 23
	tcpConnTable.172.29.7.7.23.172.29.7.6.51171.4 = IpAddress: 172.29.7.6
	tcpConnTable.172.29.7.7.23.172.29.7.6.51171.5 = INTEGER: 51171
	tcpInErrs = Counter32: 0
	tcpOutRsts = Counter32: 0
</div>

<div    style="color:#0000FF">
	$ snmpwalk -v 1 -c public -Ir -Os 172.29.7.7 system
	sysDescr = STRING: RTA1 running OS smaragd7
	sysObjectID = OID: zeroDotZero.0
	sysUpTime = Timeticks: (4294946715) 497 days, 2:24:27.15
	sysContact = STRING: TimMilesCox@gmx.ch
	sysName = STRING: RTA1
	sysLocation = STRING: worldwide

</div>
</pre>
To browse the RTA1 from the emulator host, direct the browser to 172.29.7.6<br>
and the BPF filter in portal/osserv will receive traffic to 172.29.7.6:80

<p>
Responses come to 172.29.7.6 which is you
<pre>

	http://172.29.7.6

</pre>
This is a remaining case where a firewall rule must prevent traffic for
loopback address 172.29.7.6:80 from reaching the kernel

<a	name="repair"/>
<h3>Checksum Repair using OSX Software Loopback</h3>

<p>
If you are running on OSX and talking to emulated RTA1 from the
same computer it's running on, you need the -z option for osserv

<p>
This is because OSX puts wrong checksums on its own loopback
interface and osserv must correct them before passing traffic to
RTA1


<a	name="build"/>
<h2>How to build the Emulated Machine</h2>

You need to export an environment variable telling
the build scripts what directory to construct with
your new binaries, for example

<pre>

	export RTA_BINARY=../binary.rta/linux.x86

</pre>
It is recommended to include this step in your shell profile
and to add $RTA_BINARY to $PATH, because $RTA_BINARY is
referenced as the location of emulator binary, network service
binaries and binary utilities used in the construction of
target system images and target file system images

<p>
In Windows the equivalent environment variable name is %RTA_BINARY%

<a	name="buildnet"/>
<h3>Building a Network Service</h3>

Binary osserv is supplied in
<pre>

	rta/binary.rta/osx.x86

	rta/binary.rta/osx.ppc

</pre>
If it is necessary to build or recover osserv or any of its callout parts
<pre>

	physal

	bpf_slab

	portal.o

</pre>
then enter directory portal and run script <b>./make</B> or for a big-endian target <b>./make.ppc</b>
<pre>

	cd rta/portal
	./make[.ppc]

</pre>


<a	name="buildrta">
<h3>Building the RTA1 Emulator</h3>

cd to <b>rta.run</b>. That's where you run the emulator.
The script <b>tipgen</b> constructs the emulator framework
around the instruction set emulations
<pre>

	cd rta/rta.run
	./tipgen

</pre>

The emulator platform is x86 unless you say it is PowerPC
<pre>

	cd rta/rta.run
	./tipgen powerpc

</pre>
Default path x86 inlines some 80x86 machine code which will not assemble
and is not needed on a PowerPC platform. The only emulator platforms
developed so far are OSX PowerPC and OSX x86. Projects are in progress
for emulator platforms on Linux and Windows 10


<a      name="tiptoe"/>
<h3>Emulated RTA1 Memory Sizes</h3>

The emulator image is <b>$RTA_BINARY/tiptoe[<i>x</i>]</b> where the optional <i><b>x</b></i>
is emulated machine executable space in banks of 262144 24-bit words

<p>
RTA_BINARY contains alternative binaries tiptoe1 tiptoe2 tiptoe8 tiptoe32 tiptoe64. These images emulate RTA hardware with respectively 1, 2, 8, 32, or 64 RTA1 system memory banks of 262144 words. Each 24-bit RTA computer word is modelled in a 32-bit emulator host word for optimal efficiency, so each RTA1 bank takes a megabyte of emulator host memory

<p>
Working from PWD <b>rta.run/</b>, script <b>./run</b> executes the RTA1 emulation <b>tiptoe</b> which loads
an RTA1 code image for execution and optionally a file system. To run a larger or smaller RTA1
precede <b>./run</b> with <b>export RTA_MBANKS=<i>banks</i></b>, for example
<pre>

	export	RTA_MBANKS=4
	./run	minimal rand7

</pre>

An emulation tiptoe0 containing only half a bank (131072 24-bit words) is also supplied and runs everything
in the RTA1 code image <b>minimal.rom</b>, which are the smaragd7 kernel and network stack plus http server,
snmp v 1 agent, telnet daemon, and floating-point server

<p>
However <b>tiptoe0</b> will not run much more target software than that.

<p>
To run more applications in the target *.rom image or to calibrate the performance of larger or
smaller RTA1s under heavy network traffic, export RTA_MBANKS { 1 | 2 | 4 | 8 | 32 | 64 }

<p>
The RTA1 maximum 65536 banks is 16 gigawords but the emulation is a 32-bit program

<p>
To construct an emulated machine with a different number of banks than the seven ready-made<br>
sizes, export the required value and construct the machine from PWD <b>rta.run</b>, for example
<pre>

	export	RTA_MBANKS=12
	./tipgen		# construct the emulated machine tiptoe12
				# then for example
	./run	minimal	rand7	# have tiptoe12 execute system image minimal.rom
				# and load file system image rand7	

</pre>
To construct an emulated machine smaller than 131072 RTA1 words, generate tiptoe0<br>
with macro PAGES_IN_MEMORY in engine.rta/emulate.h changed from 32 to the required number<p>
of 4096-word pages
<pre>

#define	PAGES_IN_MEMORY	<i>pages</i>

</pre>
The prototype smaragd7 kernel is not suitable for a machine significantly smaller than<br>
131072 words and not many daemons daemons and threads would run. A machine of only a few<br>
pages of 4096 words would be intended for a different style of system image

<p>
RTA1 emulation tiptoe1 takes a megabyte to run on the emulator host, a comparable memory size to an MS-DOS system of 1982. tiptoe64 takes 64 megabytes on the emulator host

<p>
The default emulated machine is tiptoe2, which emulates an RTA1 with 524288 words of system memory

<p>
If a larger or smaller emulated machine is required, either copy tiptoe[1|2|8|32|64] to $RTA_BINARY/tiptoe or change which binary is executed in script rta/rta.run/run

<p>
Prototype OS smaragd7 should be resilient and performant however large the demands on however small network buffer pools. Comparisons where online users are multiple may be run with larger or smaller emulated machines

</pre>
<a      name="operate"/>
<h2>Operating the Emulator</h2>

This is how RTA1 emulator looks when you run it. Network service
portal/osserv (or netifx) must run first
<pre>
<div    style="color:#0000FF">


	$ ./run srom rand7
	emulator ../binary.rta/osx.x86/tiptoe
	rom image 28672 target words read
	netbank 65536
	netbase 0x1c021000
	loading file system image ../fsimages/rand7
	4278 granules loaded
	async thread ID 0xb0081000
	[000000:00003f]000000	sr	0000
	800000 00000040
	[000000:000040]5500fc	lx,xi	00fc
	[000000:000041]10008f	sx	008f
	[000000:000042]10008e	sx	008e
	[000000:000043]04007c	inA	007c
	[000000:000044]200087	sa	0087
	[000000:000045]680084	lb	0084
	80: 000000 000000 000000 000000 000000 000000 000000 000000
	88: 000000 000000 000000 000000 000000 000000 000000 000000
	90: 000000 000000 000000 000000 000000 000000 000000 000000
	[000000]-&gt; 000000 000000 000000 000000 000000 000000 000000
	    000000 000000 000000 000000 000000 000000 000000 000000
	&gt;

</div>
</pre>
The first line of the display is the instruction located in
memory before the one where we are. It looks as if we have
executed
<pre>

	sr	0000

</pre>

But that's a zero word and we jumped over it from location
0 to location 64

<p>
The second line per frame is the PSR and program counter. The
high-order flag of the PSR shows we are in interrupt code at
system start

<p>
The next six instructions in line are shown, then 24 registers

<p>
We're at system start, so these are the first 24 of the 128
interrupt registers starting at address 128

<p>
If we single-step two instructions more, a value gets into the
interrupt stack pointer! Now we can see the the last four
interrupt registers at addresses 252..255
<pre>
<div    style="color:#0000FF">

	&gt;
	[000000:000041]10008f	sx	008f
	800000 00000042
	[000000:000042]10008e	sx	008e
	[000000:000043]04007c	inA	007c
	[000000:000044]200087	sa	0087
	[000000:000045]680084	lb	0084
	[000000:000046]dd0001	anb,xi	0001
	[000000:000047]de0049	jnzb	0049
	80: 000000 000000 0000fc 000000 000000 000000 000000 000000
	88: 000000 000000 000000 000000 000000 000000 000000 0000fc
	90: 000000 000000 000000 000000 000000 000000 000000 000000
	[0000fc]-&gt; 000000 000000 000000 000000 000000 000000 000000
   	 000000 000000 000000 000000 000000 000000 000000 000000
	&gt;g
	:

</div>
</pre>
<h3>A few emulator interactive commands</h3>

The emulator starts in single step and you can key
<pre>

	g

</pre>
or set a breakpoint at the same time
<pre>

	g[page:offset]

</pre>

The prompt changes from > to :

<p>
Reaching the breakpoint will get back to single step.
So will the asynchronous command
<pre>

	s

</pre>
The prompt symbol then changes back to >

<p>
Line feed will execute and advance a single instruction

<p>
A go command or a display command can be entered

<p>
The go command leaves single-step and may change the breakpoint

<p>
<b>g</b> <i>address></i> will set the new breakpoint and run to it<br>
The [page:] and address are in hex
<pre>

        g6:3    # go until bank 24K word 3

        g16a    # go until 16a of the current bank

</pre>

Breakpoint addresses are entered in hex. All single step display is in hex

<p>
Display commands in single step show memory, registers or relocation registers


<p>
<b>m</b> <i>hexaddress</i> displays a line of system memory<br>

<p>
The address for <b>m</b> is either, for example
<pre>

	m8400	# in the current address space

	mc:010	# absolute 4K page and offset

</pre>

Memory display addresses are entered in hex. All single step display is in hex<br>
Each line each line return displays eight more storage words<br>
Key <b>.</b> to end the memory display


<p>
<b>r</b> <i>register</i> displays registers.<br>
<pre>

	r 0	# walk the application registers

	r 128	# walk the interrupt registers

	r <i>decvalue</i> # walk for example the stack
		# sp is [<i>hexvalue</i>]-&gt; in paused state
		# 23 internal stack locations already shown
		# note application or interrupt context
		 
</pre>
Absolute register address is entered in decimal. All single step display is in hex<br>

<p>
Each line return displays eight more registers.<br>
Key <b>.</b> to end the register display

<p>
<b>b</b> displays the relocation register values

<p>
<b>.</b> exits the emulator

<a	name="ipfw"/>
<h2>Appendix A: netifx Datagram Divert Service</h2>
<a	name="datagram service"/>
<h3>Earlier Datagram Service over IPFW</h3>

netifx datagram service over ipfw is mostly confined to Apple OSX up to
Snow Leopard or slightly later

<pre>

	cd rta/netifx

	./runL

</pre>
runL script sets up firewall divert rules which catch traffic addressed to
the RTA1 from outside, then runs a program netifx

<p>
runL calls first ifconfig then ipfw to associate network addresses for RTA1
with the emulator platform interfaces and then calls ipfw to divert traffic
for these addresses to netifx firewall divert socket and to relay output

<p>
172.29.7.7 is the divert address of RTA1 on the emulator
host software loopback

<p>
ifconfig attaches by default address 172.29.7.8 to wired Ethernet for diversion
to RTA1 and 172.29.7.66 to WiFi. The two LAN addresses need varying in 
scripts runL and reRunl if there are more emulated RTA1s on the network

<p>
<pre>

        sudu ifconfig lo0 inet 172.29.7.7/32 alias
        sudo ifconfig en0 inet 172.29.7.8/32 alias
        sudo ifconfig en1 inet 172.29.7.66/32 alias

</pre>
ipfw adds a firewall rule to divert traffic to the netifx
process connecting emulated RTA1 to the physical interface
<pre>

        sudo ipfw add divert 4608 ip from any to 172.29.7.7 in
        sudo ipfw add divert 4608 ip from any to 172.29.7.8 in
        sudo ipfw add divert 4608 ip from any to 172.29.7.66 in
</pre>

<p>
netifx owns the firewall divert socket which catches traffic meant for
RTA1 and places it in a large ring of shared memory buffers which looks
to the emulated RTA1 like one of its architectural device arrays

<p>
netifx forwards RTA1's outbound network traffic from that buffer
to real networks

<p>
You can stop netifx by keying PERIOD and ENTER twice
<pre>

	.
	stop the interface? key . again>.

</pre>
You need to restart netifx before restarting the emulated RTA1
if you have stopped that

<p>
There is a script
<pre>

	./rerunL

</pre>
which runs netifx without repeating the firewall rules. It does no harm
however to duplicate the firewall rules

<p>
If you are running on OSX and talking to emulated RTA1 from the
same computer it's running on, you need the -z option for netifx

<p>
This is because OSX puts wrong checksums on its own loopback
interface and netifx must correct them before passing traffic to
RTA1

<p>
In detail the wrong checksums are addresses + protocol + PDUsize
without doing any more

<p>
Other netifx options are about how much trace you like to see
in the shell where netifx is running

<p>
The actions of <b>netifx</b> are
        <ol>
        <li>script netifx/runL sets firewall rules to
        drop RTA1 incoming traffic from the kernel</li>

        <br>
        <li>binary netifx binds real-interface:net-address[/mask][:port]
        combinations to RTA1 according to command line arguments</li>

        <br>
        <li>netifx initialises the buffer shared with emulated RTA1
        and uses it to transmit network configuration PDUs to RTA1</li>

        <br>
        <li>RTA1 receives configuration tuples as its first traffic</li>

        <br>
        <li>ifconfig is separately called on the emulator host to add
        RTA1 network addresses to emulator host interfaces</li>

        <br>
        <li>netifx submits received traffic to RTA1 and transmits traffic
        from RTA1</b>
        </ol>



<a	name="netifx"/>
<h3>Building netifx</h3>

<pre>

        cd rta/netifx
        ./make  [powerpc|sparc]

</pre>

This is not cross-compilation This is native compilation on and for
the emulator host with some code path differences for platform endian.
An argument of either <b>powerpc</b> or <b>sparc</b> indicates big endian
<pre>

        ./make          #       build on any little-endian emulator host

        ./make  powerpc #       build on any big-endian emulator host

        ./make  sparc   #       build on any big-endian emulator host

</pre>


<a	name="licence"/>
<i>
<pre>
_______________________________________________________________________________________


LICENCE NOTE

    Copyright Tim Cox, 2012
    TimMilesCox@gmx.ch

    This document is part of the RTA1 Processor Programmable Architecture.

    RTA1 is a free processor architecture specification. It is licensed
    under the GNU General Public Licence Version 3

    The executable emulation of RTA1 is free software.

    Instruction code for the target RTA1 architecture is free software
    if it is delivered with this software

    Software programs delivered with this software to connect the
    emulated RTA1 with real network interfaces in the emulator host
    are free software

    Scripts and programs delivered with this software for running
    on other computers and interacting with the RTA1 are free software

    Scripts and utility programs for constructing RTA1 target
    executable software are free software

    You can redistribute it and/or modify RTA1
    under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    RTA1 is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with RTA1.  If not, see &lt;http://www.gnu.org/licenses/&gt;.



</pre>
</i>


</div>
</html>
