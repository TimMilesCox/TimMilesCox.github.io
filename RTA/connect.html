<html>
<div	style="font-size:15pt">

<center>

<h1>Running and Talking to the Emulated RTA1<br>
and constructing the emulated machine for your host system</h1>

<i>
Copyright Tim Cox, 2012<br>
This document is part of the RTA1 Processor Programmable Architecture Specification<br>
The RTA1 Architecture is freeware licensed with the GNU General Public Licence Version 3<br>
The same licence encompasses all accompanying software and documentation <br>
The full licence text is included with these materials<br>
See also the licensing notice at the foot of this document
<br>
<br>
This acronym MIPS in this document means millions of instructions per second

</i>

</center>

<ol>
	<li><a href="#rungo">Running and Building Emulated RTA1</a></li>
	<ol>
		<li><a href="#readies">Ready Emulation Images</a></li>
		<li><a href="#running">Running RTA1</a></li>
		<ol>
			<li><a href="#runnet">Starting a Real Network Service for Emulated RTA1</a></li>
			<li><a href="#runrta">Starting the Emulated RTA1 Machine</a></li>
		</ol>
		<li><a href="#osserv">portal/osserv Networking</a></li>
		<li><a href="#address plan">Network Address Plan</a></li>
		<li><a href="#zeroconf">Autoconf and Multihomed Routes</a></li>
		<li><a href="#windows">Network Considerations with Windows 10</a></li>
		<li><a href="#loopback">Special Considerations Networking from Emulator Platform to Emulated Machine</a></li>
		<li><a href="#repair">Checksum Repair using OSX Software Loopback</a></li>
		<li><a href="#build">How to build the Emulated Machine</a></li>
			<ol>
			<li><a href="#buildnet">Building a Network Service</a></li>
			<li><a href="#buildrta">Building the RTA1 Emulator</a></li>
			<li><a href="#tiptoe">Emulated RTA1 Memory Sizes</a></li>
			</ol>
		<li><a href="#operate">Operating the Emulator</a></li>
		</ol>
	<li><a href="#work">Appendix A: Developer Notes for Projected RTA1 Products</a></li>
	<ol>
		<li><a href="#locy">A Low-Cycle-Rate Low-Power High-Effect Architecture</a></li>
		<li><a href="#free">Freedom of Action and Progress by Agreement</a></li>
                <li><a href="#hard">Hard-Cased Value-Added Low-Cost Single-Board Computer</a></li>
                <li><a href="#platformc">Obtaining a Hard-Edged Compiler for Emulators</a></li>
                <li><a href="#targetc">Compiler to front Existing RTA1 Target Macro Assembly</a></li>
                <li><a href="#large">A Large Model via Soft Core</a></li>
                <li><a href="#morems">More Emulations</a></li>
                <li><a href="#metric">Emulated MIPS Performance Metric</a></li>
		<li><a href="#target">Constructing RTA1 Target Images and Applications</a></li>
	</ol>
	<li><a href="#ipfw">Appendix B: netifx Datagram Divert Service</a></li>
	<ol>
		<li><a href="#datagram service">Earlier Datagram Service over IPFW</a></li>
		<li><a href="#netifx">Building netifx</a></li>
	</ol>
	<li><a href="#licence">adhesion to FSF GNU General Public License</a></li>
</ol>
	

<a	name="rungo"/a>
<h2>Running and Building Emulated RTA1</h2>

<a	name="readies"/a>
<h3>Ready Emulation Images</h3>

<p>
The binary path for RTA1 emulation and binary utilities is $RTA_BINARY,
by default <b>/Users/YOU/rta/binary.rta/osx.x86</b>

<p>
If you have OSX PowerPC, your shell profile needs to change <b>$RTA_BINARY</b>
<pre>

	export	RTA_BINARY=<b>/Users/YOU/rta/binary.rta/osx.ppc</b>

</pre>
If you have a different platform from OSX you need to <a href="#build">build</a>
 the emulator binary tiptoe and the network service binary osserv.<br>
All other binary utilities and build tools are already
available on 32-bit Linux x86 and on Win32


<a	name="running".>
<h3>Running RTA1</h3>

<a	name="runnet"/>
<h3>Starting a Real Network Service for Emulated RTA1</h3>

An emulator host process is run from a shell to provide network connectivity
<pre>

	cd	<a href="#osserv">rta/portal</a>
	./runL	[ ipfw ]

</pre>
rta/portal/runL is a script which configures networks and runs binary osserv.<br>
Argument ipfw is only needed if the emulator platform is OSX and not recent enough to have<br>
Packet Filter based firewall <b>pfctl</b>. The platform must then be old enough to have <b>ipfw</b>
firewall

<a	name="runrta"/>
<h3>Starting the Emulated RTA1 Machine</h3>

Emulated RTA1 is run from another shell
<pre>

	emulated machine size is picked, default two banks, or default in user profile

	export	TCP_MBANKS={2|0|1|4|8|32|64|other}

	<a	style="color:00FF00">OSX Intel</a>
	cd	<a href="#tiptoe">rta/tgen</a>
	./r[c]

	./r runs RTA1 instruction emulation tipt written in x86 Assembly Language
	./rc runs RTA1 instruction emulation tipc written in gcc 

	tipt{2|0|1|4|8|32|64} and tipc{2|0|1|4|8|32|64} stay in a hard loop
	of emulated RTA1 instruction processing when not entering powersave,
	instrumentation or debug

	<a	style="color:00FF00">OSX PowerPC</a>
	cd	<a href="#tiptoe">rta/rta.run</a>
	./run	minimal rand7
	g

	both tgen/r[c] and rta.run/run are available on OSX Intel platforms

	only rta.run/run is available on OSX PowerPC platforms and runs
	emulator binary tiptoe{2|0|1|4|8|32|64}

	gcc-written instruction emulation is the functional yardstick for
	planned instruction emulations

		in platform machine code (assembler)
		or in C with a harder compiler

	for Windows10 and Linux SBC hosted RTA1 emulations

</pre>
if no breakpoints are needed, command <b>g</b> leaves single step and emulated
RTA1 is running

<p>
For single step and debug commands see <a href="#operate">Operation</a>.
For choosing emulated machine memory capacity and constructing variants see
<a href="#tiptoe">Memory Sizes</a>

<p>
emulator binary <b>tipt{2|0|1|4|8|32|64}</b> or tipc{...} or tiptoe{...}.<br>
loads an RTA1 target system image, by default the supplied system image
<pre>

	rta/target.rta/rta.gen/minimal.rom

</pre>
Target system images in RTA1 code are generated in directory space
<a href="#target">rta/target.rta/rta.gen</a><br>

<p>
second argument rand7 is a file system image constructed with RTA1 offline binary utilities

<p>
Loadable filestore image rand7 contains web hosting pages and currently takes 1 bank of filestore.<br>
24-bit computer words in filestore images are packed into 3 bytes each of emulator host storage

<p>
Standard application protocols and a floating pount client program communicate network hosts with
emulated RTA1 with over real networks. These application protocols include http, snmp, and telnet

<p>
A third shell is opened to run PC programs communicating over platform loopback with emulated RTA1
and to set and test the routing to make that possible
<pre>

	cd rta/client
	./prun

</pre>
rta/client/prun installs connectivity between the emulator platform and emulated RTA1,
then sets default addresses which PC client program
 <a href="#fp">fp</a> uses to operate the <a href="#fp192">RTA1 96/192-bit floating point server</a>

<p>
There are some <a href="#loopback">special addressing considerations</a> for running
client applications including  browsers, fp, netSNMP, telnet, and echo protocol to RTA1
over the software loopback interface of the emulator host. Traffic for RTA1 arriving
from the software loopback interface of an OSX platform also needs
<a href="#repair">checksum repair</a> which osserv applies with option -z 

<a	name="osserv"/>
<h3>portal/osserv Networking</h3>

<p>
osserv shares network traffic with RTA1 through shared memory

<p>
The shared buffer appears to emulated RTA1 as a device array, one of 63
peripheral memories in RTA1 architecture

<p>
The interface process uses Berkely Packet Filter (BPF) kernel calls
to receive and send.<br>The materials for running this interface process
are in directory <b>rta/portal</b>

<p>
BPF serves a separate filter program for each interface
<pre>

	osserv / RTA1 Network Interfaces Initialisation
	_______________________________________________

	_________________
	|	osserv	|
	|_______________|
	|writes macro	|
	|assembly source|
	|from arguments	|
	|_______________|	_________________
	|launches masmx	|	|   masmx.7R3A	|
	|process script	|	|_______________|
	|for each I/F	|------>|assembles BPF	|
	|_______________|	|filter program |
	|initialises	|<------|_______________|	
	|buffer shared	|					_________________
	|with RTA1	|					|	RTA1	|
	|_______________|					|_______________|
	|sends interface|					| awaits traffic|
	|configuration	|					|---------------|
	|PDUs to RTA1	|-------------------------------------->|configures	|
	|_______________|					|network I/Fs	|
	|assigns filter	|					|_______________|
	|programs to BPF|
	|_______________|



	Live Example WiFi or Ethernet Packet Filter Program in Dump Format
	__________________________________________________________________

	Little-Endian Emulator Platform
	_______________________________


	[:280000000c000000]	. examine 16 bits at frame offset octet 12 = protocol discriminator
	[:1500040006080000]	. ARP protocol field reverse byte order, if so jump to YES
	[:1500000200080000]	. IP protocol field reverse byte order, if not jump to NO
	[:200000001e000000]	. examine 32 bits at frame offset octet 30 = IP destination
	[:1500010042071dac]	. acceptable destination in reverse byte order? Jump to YES
	[:0600000000000000]	. return NO = drop
	[:06000000ffff0000]	. return YES = BPF assign this frame to osserv

	masmx.7r3a Macro Assembly can do any amount of variation on this minimal path



	Running after Initialisation
	____________________________

	________________					_________________
	|osserv receives|					| RTA1 IP stack	|
------->|IP/ARP from BPF|-------------------------------------->| receives	|
	|_______________|					|_______________|
	|osserv	xmits on|					| RTA1 IP stack	|
<-------|network via BPF|<--------------------------------------| transmits	|
	|_______________|					|_______________|

	
</pre>
<p>
An earlier network access method for RTA1 used IPFW Divert Socket,
but that is not available on any recent personal computer.<br>
OSX computers old enough to have <b>ipfw</b> firewall may also use the
newer and more featured portal/osserv with the argument <b>ipfw</b>
<pre>

	cd	rta/portal
	./runL	ipfw

</pre>
Platforms with Packet Filter based firewall omit the <b>ipfw</b> argument

<p>
portal/osserv is a Packet Filter based frame service which runs on most
platforms of any age whatever firewall interface they have.<br>
However script portal/runL adds one firewall rule and needs to know
which firewall interface to operate

<p>
Platform Firewall differences for OSX are per distribution OSX 10.<a style="color:0000FF">X</a>.Y<br>
and all 10.X.Y distributions are reported to bash shell as 10.0

<p>
The earlier datagram divert service <b>netifx</b> is implemented entirely via <b>ipfw</b>

<p>
Materials for running IPFW Divert are still delivered in directory
<b>rta/netifx</b> and run on Mac PowerPC and x86 up to Snow Leopard,<br>
see <a href="#ipfw">Appendix B</a>. However BPF-based <b>portal</b> also
runs on these slightly venerable Apple platforms, and additionally is specific<br>
for new Apple platforms and intended for other platforms including Linux

<p>
Apple Computer did not have PCAP fully working on older platforms when it
withdrew IPFW from newer platforms. so BPF-based <b>portal/osserv</b> has
been devised for any platforms. This has the accidental advantage that
<b>portal</b> constructs its own filter rules for BPF, and produces a far
more efficient filter program than the PCAP "compiler"

<p>
Packet filtering does not remove any incoming frames from the emulator platform kernel,<br>
but the kernel only gets datagrams for which it has protocol addresses configured on its interfaces

<p>
With <b>osserv/portal</b> the practice of aliasing emulator platform
interfaces with addresses for emulated RTA1 is phased out.<br>
Subseqently it is mostly unnecessary to  drop frames after they are copied
via BPF for RTA1

<p>
No firewalls encountered so far have dropped any frames before BPF filter
programs had them

<p>
The actions of <b>portal/osserv</b> are
	<ol>
	<li>script portal/runL sets a firewall rule to prevent
	local http traffic for RTA1 from reaching the kernel</li>

	<br>
	<li>binary osserv binds real-interface:net-address[/mask][:port]
	combinations to RTA1 according to command line arguments</li>

        <br>
	<li>osserv ascertains interface types and determines physical
	address, address size and whether ARP is used</li>

        <br>
	<li>osserv writes a macro-assembly source file and build
	script for the filter program of each interface and starts
	a process to assemble filter pseudo-instructions, in reality
	64-bit binary-encoded rules. osserv awaits the completion
	of each filter program build process</li>

        <br>
	<li>osserv specifies filter programs, notification timing
	and non-block action to BPF</li>

        <br>
	<li>osserv initialises the buffer shared with emulated RTA1
	and uses it to transmit network configuration PDUs to RTA1</li>

        <br>
	<li>RTA1 receives configuration tuples as its first traffic</li>

        <br>
	<li>osserv submits received traffic to RTA1 and transmits traffic
	from RTA1</b>
	</ol>

<div    style="color:0000FF">

	<a	name="address plan"/>
	<h3>Network Address Plan</h3>
	Address configuration is structured in a way intended to help
	a rapid and clear choice of network media

	<p>
	The process scripts which launch interfaces for emulated RTA1
	specify network addresses per interface to binary osserv.<br>
	These process scripts are rta/portal/runL and rta/portal/rerunL.
	rerunL omits repeated insertion of firewall rules

	<p>
	The developer needs to carry out some equivalent configuration
	at PCs intended to communicate over LAN with emulated RTA1

        <p>
	Any network addresses can be used. The following address plan
	is used by default in start-up scripts runL and rerunL

        <p>
	A different address plan  would need to be reflected in the
	default routing table assembled into the RTA1 target image<br>
	in assembly language file rta/target.rta/t77.4/routes.msm

        <p>
	Target image routing table will later be constructed dynamically
	on RTA1 target image start, as the network addresses already are

        <p>
	Blocks of network addresses in the default plan are these

        <p>
	RTA1 on wired Ethernet uses some of the addresses
	<pre>
		172.29.7.8/26 to 172.29.7.62/26

	</pre>
	and RTA1 on WiFi uses some of the addresses
	<pre>

		172.29.7.66/24 to 172.29.7.253/24

	</pre>
	Emulated RTA1s on the local network are assiged addresses
	from the low end of these ranges,<br>
	and addresses at the high end
	of these ranges are notionally for PCs talking to RTA1s
		
        <p>
        To be in the same wired ethernet subnet as RTA a PC has
	typically an address around 172.29.7.60/26

        <p>
        This causes traffic for RTA1s which have addresses from
	172.29.7.8/26 to go via wire

        <p>
	No LAN addresses used by emulated RTA1s are any longer
	alias addresses of the emulator host's interfaces.<br>
	The emulated RTA1 is instead using ARP for real

        <p>
	PC programs bind this address to communicate over emulator
	host loopback with emulated RTA1
	<pre>

		172.29.7.6/32

	</pre>
	<b>172.29.7.6</b> remains an alias of emulator host software loopback

	<p>
	PC programs on the emulator host platform address emulated RTA1 as
	<pre>

		172.29.7.7/32

	</pre>
	<b>172.29.7.7</b> is no longer an alias of emulator platform loopback.</b>
	Emulator host routes to <b>172.29.7.7</b> via gateway <b>127.0.0.1</b>

        <p>
	To be in the same WiFi subnet as RTA a PC has typically an
	address around 172.29.7.230/24

        <p>
        This causes traffic for emulated RTAs which have adresses
	from 172.29.7.66/24 to go via WiFi

        <p>
        RTA1 has a new routing table entry
	<pre>

		172.19.7.0	255.255.255.192

	</pre>
        which goes to the wired interface and is classed as local

        <p>
	The existing route
	<pre>

		172.19.7.0	255.240.0.0

	</pre>
	routes traffic to WiFi. Routes with wider masks are of course searched first

        <p>
	RTA1 is now doing ARP for real and could do ZeroConf

        <p>

	There are some special considerations about placing
	<a href="#windows">Windows</a> PCs in RTA subnets and<br>
	the alternative of routing from PC over emulator host may be preferable

	<p>
	POSIX style computers may equally be routed instead of subnetworked
	to the emulated RTA1.<br>
	Shell commands for restating a route are for example
	<pre>

        sudo route -nv delete -host 172.29.7.9
        sudo route -nv add -host 172.29.7.9 192.168.1.3

	</pre>

</div>


<a	name="zeroconf"/>
<h3>Autoconf and Multihomed Routes</h3>

        routes in the route table of RTA1 target image
        are typed homed (bound to an interface) or
        not homed

	<p>
        routes not homed may replicate remote network addresses
        in separate attached networks

	<p>
        routing picks a next hop for datagrams, and if the route
        is homed IP uses the indicated outgoing interface

	<p>
        if the route is not homed the outgoing interface is chosen
        according to datagram source network address, which should
        not be duplicated in any way on one host

	<p>
	RTA1 IPv4 can consequently exchange datagrams with remote sockets
	which MAY replicate addresses on separate attached networks

	<p>
	ZeroConf is a procedure which may negotiate identical addresses
	within separate attached networks, but is not the only method
	of so doing. Manual configuration and DHCP might do the same
	so long as the networks remain separate and are directly attached

	<p>
	Addresses which potentially replicate in different attached
	networks are not routable. Routes which could reach replicated
	addresses are known to RTA1 IPv4 because their interface
	attribute in the routing table has the wildcard value ANYNET

	<p>
        This allows a single routing table entry to route to an autoconf
        address which however many attached networks replicate that address

	<p>
	Routes of this kind only apply to locally attached networks
	and are always direct. The next-hop is the the destination
	
	<p>
        ARP caches each protocol address separately for each attached
	network where it appears

	<p>
	ARP resolution requires a hit on protocol address plus interface index


<a	name="windows"/>
<h3>Network Considerations with Windows 10</h3>
<pre>

	The earlier method of routing to the emulator host	
	as gateway to RTA1 is still a good technique for
	talking from Windows 10 PCs to RTA1

	netsh cannot alias an interface into a subnet
	without breaking that interface's DHCP configuration.
	This lames the PC's internet access

	any of the following solutions will assure service

		netsh can manually configure an interface with multiple
		addresses, allowing inclusion in a subnet where RTA1 is
		found, and simultaneously access to the internet

		routes can be installed on windows PCs adressing emulator
		host interfaces as gateways, without attempting to configure
		PCs with addresses in RTA1's subnets

		one physical network can be used between PCs and RTA1,
		for example wired Ethernet, leaving automatically configured
		DHCP to another network, for example WiFi

	Opening the administrator command prompt is enough authority to
	operate netsh and route

	Manual addition of an address to an interface on Windows 10
	is like this

                netsh interface ipv4 add address name="WiFi" 172.29.7.x/24

	However if the interface was DHCP up to this point, the DHCP binding
	is lost and the add is effectively a set

	The less destructive method of naming the emulator host as gateway
	is like this

                route add -p 172.29.6.y mask 255.255.255.255 192.168.x.x

	The last address on the line is gateway, and it should be the
	emulator host's known address on this interface 

        You need to do this anyway if you want to talk to RTA1 from another network

        This configuration restriction (inability to add an extra address
        to the DHCP-configured interface) is confined to Windows. Linux and
        Darwin (Apple OSX) do not have this restriction


</pre>
<a	name="loopback"/>
<h3>Special Considerations Networking from Emulator Platform to Emulated Machine</h3>

Emulated RTA1 has by default an address 172.29.7.7<br>
The emulator host routes to 172.29.7.7 via gateway 127.0.0.1

<p>
Any IP traffic from the emulator host to the
emulated RTA1 must to be forced to come from an<br>
address other than 127.0.0.1, because RTA1 has a
loopback named 127.0.0.1

<p>
Platform script <b>rta/client/prun</b> adds an address 172.29.7.6
to emulator host loopback and sends the echo request
<pre>

	ping -c 6 -S 172.29.7.6 172.29.7.7

</pre>
telnet can also be guided on the command line
<pre>
<div    style="color:#0000FF">


	$ telnet -s 172.29.7.6 172.29.7.7</div><div    style="color:#FF0000">
	Trying 172.29.7.7...
	Connected to 172.29.7.7.
	Escape character is '^]'.
	RTA1 smaragd7 OS shared console
	key h for command list</div><div    style="color:#0000FF">
	h</div><div    style="color:#FF0000">
	commands are	t	h	bsh&
			stay

</div>
</pre>
<a	name="fp"/>
<h3>Floating Point</h3>
The floating point interactor <b>client/fp</b> calls the
floating server on RTA1. <b>fp</b> on emulator platform loopback
is commanded with argument 2 to come from somewhere different
from the destination
<pre>

	fp 172.29.7.7 172.29.7.6

</pre>

script <b>client/prun</b> also writes default target and source
addresses for <b>fp</b>

<p>
If you want different default addresses for <b>fp</b> change
<b>prun</b>. For no default addresses, change them to
<pre>

	echo	fp-server	0.0.0.0  >config.fp
	echo	fp-client	0.0.0.0 >>config.fp

</pre>
<p>
There is some point in having this floating server in the
emulated machine! The PC hasn't one micron particle in a
light year of RTA1's number range. Not by another million
and a quarter decimal places! The PC is obliged to send the largest
numbers in ASCII because it can't otherwise represent them
<pre>
<div	style="color:#0000FF">


        $ fp 172.29.7.7
        remote application socket 3 bind state 0 F 2 NB 0 udconnect state 0

        246913578024691357802e600004 / 2000000000000000000000000e-600000
        send state 65
        recv state 34/35 +1.23456789012345678901e+1200000
        

</div>
</pre>
directory rta/client has a test script and list of checked results for 96-bit floating point

<p>
Flags -QR resend on timeout and confine printing to result values
<pre>

rta/client>

	fp -QR < fpscript.txt > 4th.txt
	diff ../fp_bench.mk/scripted.txt 4th.txt

</pre>
<a	name="fp192"/>
<h3>192-bit Floating Point</h3>
<p>
fp with option -U calls RTA1 192-bit floating server instead of RTA1 96-bit floating server
<pre>
<div	style="color:#FF0000">

	$ fp -U
	remote application socket 3 bind state 0 F 2 NB 0 udconnect state 0

	3.666666999999333333666666999999333333666666e+1000000 / 3e-250000
	send state 66
	recv state 55/35 +1.222222333333111111222222333333111111222222e+1250000

</div>
</pre>
192-bit floating point has a test script and list of checked results in directory rta/client
<pre>

rta/client>

	fp -QRU < 192.txt > 7th.txt
	diff provisio.txt 7th.txt

</pre>

<a	name="netsnmp"/>
<h3>netsnmp</h3>
netsnmp manager has a configuration file to say where it's
coming from
<pre>

	/Users/YOU/.snmp/snmp.conf 
	 clientaddr	172.29.7.6

</pre>
Then you can interact from the emulator host, but do not configure clientaddr
doing netsnmp from a separate host
<pre>
<div    style="color:#FF0000">

	$ snmpwalk -v 1 -c public -Ir -Os 172.29.7.7 tcp
	.
	tcpMaxConn = INTEGER: 7500000
	tcpActiveOpens = Counter32: 0
	tcpPassiveOpens = Counter32: 1
	tcpAttemptFails = Counter32: 0
	tcpEstabResets = Counter32: 0
	tcpCurrEstab = Gauge32: 1
	tcpInSegs = Counter32: 7
	tcpOutSegs = Counter32: 6
	tcpRetransSegs = Counter32: 0
	tcpConnTable.172.29.7.7.23.172.29.7.6.51171.1 = INTEGER: 5
	tcpConnTable.172.29.7.7.23.172.29.7.6.51171.2 = IpAddress: 172.29.7.7
	tcpConnTable.172.29.7.7.23.172.29.7.6.51171.3 = INTEGER: 23
	tcpConnTable.172.29.7.7.23.172.29.7.6.51171.4 = IpAddress: 172.29.7.6
	tcpConnTable.172.29.7.7.23.172.29.7.6.51171.5 = INTEGER: 51171
	tcpInErrs = Counter32: 0
	tcpOutRsts = Counter32: 0
</div>

<div    style="color:#0000FF">
	$ snmpwalk -v 1 -c public -Ir -Os 172.29.7.7 system
	sysDescr = STRING: RTA1 running OS smaragd7
	sysObjectID = OID: zeroDotZero.0
	sysUpTime = Timeticks: (4294946715) 497 days, 2:24:27.15
	sysContact = STRING: TimMilesCox@gmx.ch
	sysName = STRING: RTA1
	sysLocation = STRING: worldwide

</div>
</pre>
To browse the RTA1 from the emulator host, direct the browser to 172.29.7.6<br>
and the BPF filter in portal/osserv will receive traffic to 172.29.7.6:80

<p>
Responses come to 172.29.7.6 which is you
<pre>

	http://172.29.7.6

</pre>
This is a remaining case where a firewall rule must prevent traffic for
loopback address 172.29.7.6:80 from reaching the kernel

<a	name="repair"/>
<h3>Checksum Repair using OSX Software Loopback</h3>

<p>
If you are running on OSX and talking to emulated RTA1 from the
same computer it's running on, you need the -z option for osserv

<p>
This is because OSX puts wrong checksums on its own loopback
interface and osserv must correct them before passing traffic to
RTA1


<a	name="build"/>
<h2>How to build the Emulated Machine</h2>

You need to export an environment variable telling
the build scripts what directory to construct with
your new binaries, for example

<pre>

	export RTA_BINARY=../binary.rta/linux.x86

</pre>
It is recommended to include this step in your shell profile
and to add $RTA_BINARY to $PATH, because $RTA_BINARY is
referenced as the location of emulator binary, network service
binaries and binary utilities used in the construction of
target system images and target file system images

<p>
In Windows the equivalent environment variable name is %RTA_BINARY%

<a	name="buildnet"/>
<h3>Building a Network Service</h3>

Binary osserv is supplied in
<pre>

	rta/binary.rta/osx.x86

	rta/binary.rta/osx.ppc

</pre>
If it is necessary to build or recover osserv or any of its callout parts
<pre>

	physal

	bpf_slab

	portal.o

</pre>
then enter directory portal and run script <b>./make</B> or for a big-endian target <b>./make.ppc</b>
<pre>

	cd rta/portal
	./make[.ppc]

</pre>


<a	name="buildrta">
<h3>Building the RTA1 Emulator</h3>

Choose the emulated machine size in banks of 262144 24-bit words
<pre>

	export	RTA_MBANKS=0	# factually half a bank or 131072 words
				# image for testing resiliency on tight resources
				# half the memory of an 8086 PC of year 1983

				# or

	export	RTA_MBANKS=16	# for example

</pre>
<h3>High Speed Emulation on x86</h3>

cd to rta/tgen to generate an emulated RTA1 machine running a hard
loop of emulated instructions<br>except when entering powersave, debug
or instrumentation. Run Script <b>tgen</b> or <b>tgenc</b>

<pre>

	cd rta/tgen

	./tgen			# emulated instructions coded in x86 Assembler
	./tgenc			# emulated instructions coded in gcc for any little-endian platform
	./tgenc x86		# emulated instructions in gcc with x86 inlines for accelerated operand access
	./tgenc x86 -DMETRIC	# with MIPS performance metric
	./tgenc any -DMETRIC	# all-gcc, no inline assembler, any little-endian platform

	./tgen x86 -DMETRIC	# instruction emulations in x86 Assembler, with MIPS performance metric

</pre>

This construction is also intended for PowerPC but is not currently
available in OSX PowerPC platforms.<br>The earlier prototype emulation
is equally available on OSX PowerPC and Intel


<h3>Prototype Emulation on PowerPC and x86</h3>


cd to <b>rta.run</b>. 
Script <b>tipgen</b> constructs the emulator framework
around the instruction set emulations
<pre>

	cd rta/rta.run
	./tipgen

</pre>

The emulator platform is x86 unless you say it is PowerPC
<pre>

	cd rta/rta.run
	./tipgen powerpc

</pre>
Default path x86 inlines some 80x86 machine code which 
is not needed on a PowerPC platform.<br>The only emulator platforms
developed so far are OSX PowerPC and OSX x86.<br>Projects are in progress
for emulator platforms on Linux and Windows 10


<a      name="tiptoe"/>
<h3>Emulated RTA1 Memory Sizes</h3>

The emulator image is
<pre>

	$RTA_BINARY/tipt[<i>X</i>]	x86 machine code (Assembler) instruction emulation 
	$RTA_BINARY/tipc[<i>X</i>]	gcc instruction emulation in multi-platform harness

				tiptX and tipcX are constructed to stay in a hard
				loop of emulated RTA1 instruction processing
				when not entering powersave, instrumentation or debug

	$RTA_BINARY/tiptoe[<i>X</i>]	prototype emulation running on OSX PowerPC and any target 


</pre>
where  <i><b>X</b></i>
is emulated machine executable space in banks of 262144 24-bit words

<p>
RTA_BINARY contains alternative binaries tipt1 tipt2 tipt4 tipt8 tiptoe32 tipt64. These images emulate RTA hardware with respectively 1, 2, 4, 8, 32, or 64 RTA1 system memory banks of 262144 words. Each 24-bit RTA computer word is modelled in a 32-bit emulator host word for optimal efficiency, so each RTA1 bank takes a megabyte of emulator host memory

<p>
Script <b>tgen/r</b> or <b>tgen/rc</b> or  <b>rta.run/run</b> executes the RTA1 emulation <b>tiptoe</b> which loads
an RTA1 code image for execution and optionally a file system. To run a larger or smaller RTA1
precede <b>./run</b> with <b>export RTA_MBANKS=<i>banks</i></b>, for example
<pre>

rta/tgen>

	export RTA_MBANKS=8
	./r


rta/rta.run>

	export	RTA_MBANKS=4
	./run	minimal rand7

</pre>

Supplied emulations tipt0 tipc0 tiptoe0 with only half a bank (131072 24-bit words) run
smaragd7 kernel and network stack plus http server, snmp, telnet daemon, and floating-point server

<p>
tipt0 /tipc0 /tiptoe0 are run to verify the resiliency of RTA1 target
kernel smaragd7 with tight resources


<p>
The RTA1 maximum 65536 banks is 16 gigawords but the emulation is a 32-bit program

<p>
To build a larger RTA1 emulation than a 64 banks, for example
<pre>

rta/tgen>

	export	RTA_MBANKS=1024		# generate a 256 MWord emulated RTA1 machine
	./tgen[c]			# build the assembler or the gcc emulation
	./r[c]				# run the assembler or the gcc emulation

</pre>
The default emulated machine has two banks and emulates an RTA1 with 524288 words of system memory


</pre>
<a      name="operate"/>
<h2>Operating the Emulator</h2>

This is how RTA1 emulator looks when you run it. Network service
portal/osserv (or netifx) must run first
<pre>
<div    style="color:#0000FF">


	$ ./run srom rand7
	emulator ../binary.rta/osx.x86/tiptoe
	rom image 28672 target words read
	netbank 65536
	netbase 0x1c021000
	loading file system image ../fsimages/rand7
	4278 granules loaded
	async thread ID 0xb0081000
	[000000:00003f]000000	sr	0000
	800000 00000040
	[000000:000040]5500fc	lx,xi	00fc
	[000000:000041]10008f	sx	008f
	[000000:000042]10008e	sx	008e
	[000000:000043]04007c	inA	007c
	[000000:000044]200087	sa	0087
	[000000:000045]680084	lb	0084
	80: 000000 000000 000000 000000 000000 000000 000000 000000
	88: 000000 000000 000000 000000 000000 000000 000000 000000
	90: 000000 000000 000000 000000 000000 000000 000000 000000
	[000000]-&gt; 000000 000000 000000 000000 000000 000000 000000
	    000000 000000 000000 000000 000000 000000 000000 000000
	&gt;

</div>
</pre>
The first line of the display is the instruction located in
memory before the one where we are. It looks as if we have
executed
<pre>

	sr	0000

</pre>

But that's a zero word and we jumped over it from location
0 to location 64

<p>
The second line per frame is the PSR and program counter. The
high-order flag of the PSR shows we are in interrupt code at
system start

<p>
The next six instructions in line are shown, then 24 registers

<p>
We're at system start, so these are the first 24 of the 128
interrupt registers starting at address 128

<p>
If we single-step two instructions more, a value gets into the
interrupt stack pointer! Now we can see the the last four
interrupt registers at addresses 252..255
<pre>
<div    style="color:#0000FF">

	&gt;
	[000000:000041]10008f	sx	008f
	800000 00000042
	[000000:000042]10008e	sx	008e
	[000000:000043]04007c	inA	007c
	[000000:000044]200087	sa	0087
	[000000:000045]680084	lb	0084
	[000000:000046]dd0001	anb,xi	0001
	[000000:000047]de0049	jnzb	0049
	80: 000000 000000 0000fc 000000 000000 000000 000000 000000
	88: 000000 000000 000000 000000 000000 000000 000000 0000fc
	90: 000000 000000 000000 000000 000000 000000 000000 000000
	[0000fc]-&gt; 000000 000000 000000 000000 000000 000000 000000
   	 000000 000000 000000 000000 000000 000000 000000 000000
	&gt;g
	:

</div>
</pre>
<h3>A few emulator interactive commands</h3>

The emulator starts in single step and you can key
<pre>

	g

</pre>
or set a breakpoint at the same time
<pre>

	g[page:offset]

</pre>

The prompt changes from > to :

<p>
Reaching the breakpoint will get back to single step.
So will the asynchronous command
<pre>

	s

</pre>
The prompt symbol then changes back to >

<p>
Line feed will execute and advance a single instruction

<p>
A go command or a display command can be entered

<p>
The go command leaves single-step and may change the breakpoint

<p>
<b>g</b> <i>address></i> will set the new breakpoint and run to it<br>
The [page:] and address are in hex
<pre>

        g6:3    # go until bank 24K word 3

        g16a    # go until 16a of the current bank

</pre>

Breakpoint addresses are entered in hex. All single step display is in hex

<p>
Display commands in single step show memory, registers or relocation registers


<p>
<b>m</b> <i>hexaddress</i> displays a line of system memory<br>

<p>
The address for <b>m</b> is either, for example
<pre>

	m8400	# in the current address space

	mc:010	# absolute 4K page and offset

</pre>

Memory display addresses are entered in hex. All single step display is in hex<br>
Each line each line return displays eight more storage words<br>
Key <b>.</b> to end the memory display


<p>
<b>r</b> <i>register</i> displays registers.<br>
<pre>

	r 0	# walk the application registers

	r 128	# walk the interrupt registers

	r <i>decvalue</i> # walk for example the stack
		# sp is [<i>hexvalue</i>]-&gt; in paused state
		# 23 internal stack locations already shown
		# note application or interrupt context
		 
</pre>
Absolute register address is entered in decimal. All single step display is in hex<br>

<p>
Each line return displays eight more registers.<br>
Key <b>.</b> to end the register display

<p>
<b>b</b> displays the relocation register values

<p>
<b>.</b> exits the emulator

<a	name="work"/>
<a      name="locy"/>
<h2>Appendix A: Developer Notes for Projected RTA1 Products</h2>

<h3>A Low-Cycle-Rate Low-Power High-Effect Architecture</h3>

The author of RTA1 project believes RTA1 is a worthwhile idea.<br>
RTA1 now running in emulation is achieving more MIPS than<br>
a "real" or semiconductor one is intended to have in its smallest<br>
versions. It takes few instruction executions to do work and the<br>
performance of network application protocols HTTP host, SNMP agent,<br>
floating point UDP server, is more than respectable

<p>
The instruction set is not many and all instructions are simple.<br>
High efficiency from a small and simple instruction set means

<ul>	<li>Any logical mind can program and read machine code</li>
	<li>The machine can be clocked slow using little energy and yet perform</li>
</ul>
additionally
<ul>
	<li>The architecture is big enough for large arithmetic and manipulates large operands</li>
	<li>RTA1 has an advantage over possibly every other machine:<br>
	floating point representing &plusmn;1262611 decimal places and 43 decimal digits</li>
</ul>
These things are proved in emulation, which is not a low-power affair at all.<br>
The target of a semiconductor RTA1 package is distant, but some immediate projects<br>
planned here in outline can bring the target nearer

<a      name="free"/>
<h3>Freedom of Action and Progress by Agreement</h3>

There are no chiefs in freeware. The author has made RTA1 freeware.<br>
Any work done in collaboration is done by agreement. The following ideas<br>
are wishes of RTA1 project's initial author. I requested your attention<br>
to the project. Your ideas are welcome. I hope my ideas are welcome too.<br>
Knowledge which I don't myself have will be needed to carry some of these ideas through


<a      name="hard"/>
<h3>Hard-Cased Value-Added Low-Cost Single-Board Computer</h3>

One practical RTA1 profiling product is the all-freeware emulations which are already<br>
dowloadable for any PC that runs OSX, from PowerPC thru High Sierra. Emulations on Linux<br>
and Windows 10 are projects discussed at <a href="#morems">More Emulations</a>

<p>
Emulations guesting on a $15 Linux SBC are seen as route to marketing a value-added<br>
product which with imaginative packaging will arouse the imagination of many persons.<br>
These emulations are intended to be some steps away from plain software emulation in<br>
the PC loadables

<p>
Like the PC loadables, the hard-packaged emulations are intended to be processes of<br>
the POSIX emulator host. They shall share the host's powersave as now. RTA1 I/O calls<br>
host usleep() for up to 97% of elapsed time. A difference is the hard loop of emulated<br>
instructions should not be timesliced. It timeslices itself when it has no work. Avoiding<br>
an emulator host timeslice will make performance metrication reliable where it may presently<br>
be influenced by lucky or unlucky synchronisation

<p>
The Linux host has as now a direct debug console to the executing RTA1, as well as<br>
shared-memory network access over Telnet, HTTP, SNMP and UDP floating server

<p>
PC emulations emulate in software RTA1's view of bus behaviour. This adds overhead<br>
even to the simplest instructions. It is sought to speed up these bus accesses<br>
with some electronic engineering, maybe by installing some different memory at fixed addresses.<br>
The ambitious solution would be a bus that knows RTA1's address translation pointers and<br>
associated attributes, because the overhead lies largely not in accessing different memories<br>
in different ways, but in deciding which method to apply, access by access. RTA1 is not a<br>
flat-address idea

<p>
Address space is 24 bits and address quantum is a 24-bit word, in keeping with aims of<br>
compactness and rightsizing for objects like pixels and UTF-32 characters. A field of the<br>
effective address tags one of 71 <a href="http://TimMilesCox.github.io/RTA/rta.html">memory block pointers</a>
on a teraword space

<p>
This large space is in 64 device arrays of up to 16 gigawords. Each device array may be of a type

<ul>	<li>executable memory. Emulator models an RTA word in a 32-bit platform word</li><br>

	<li>filestore: strictly an octet array:<br>
	RTA1 accesses a 24-bit word quantum@ octet[word_index*2+word_index]</li><br>

	<li>shared memory network buffer in 16-bit words:<br>
	RTA1 accesses a byte pair as a word quantum and zero-extends on read</li>

</ul>
RTA1 storage byte order is big-endian. Emulations on X86 adjust on read and write

<p>
Currently emulations are either in GCC for any platform or in x86 assembly language

<p>
A small-scale emulation on x86 and a large emulation on 64-bit PowerPC are projected,<br>
both guested on low-cost Linux SBCs. Emulated RTA instructions need fewer platform instructions<br>
on PowerPC than on x86



<a      name="platformc"/>
<h3>Obtaining a Hard-Edged Compiler for Emulators</h3>

It is considered necessary to source an ANSI-C compiler generating efficient code for PowerPC and X86.<br>
The existing gcc emulation is the functional yardstick and runs on PowerPC and X86. However<br>
gcc generates over three times too many platform instructions

<a      name="targetc"/>
<h3>Compiler to front Existing RTA1 target Macro Assembly</h3>

It should eventually be necessary to port a number of applications to RTA1 which are not required to be realtime<br>
in performance and are written in C. These include for example shells. RTA1 already has assembly<br>
macro language intended to support C language, and the
<a href="http://timmilescox.github.io/masmx/masmx.html">masmx7r3A Meta Assembler</a> has<br>
<a href="http://timmilescox.github.io/RTA/masmx7r3.html#algors">algorithm plotters</a>
supporting programmatic runtime expressions.

<p>
See also <a href ="#target">Constructing RTA1 Target Images and Applications</a>

<p>
This is a project of compiler creation


<a      name="large"/>
<h3>A Large Model via Soft Core</h3>

FPGA unit costs may or may not be too high for very small RTA1 implementations.<br>
Prototype kernel smaragd7 can run with IP stack, Telnet Server, SNMP Agent, HTTP server<br>
and UDP fLoating point server in half as much memory as a DOS PC of 1982

<p>
But FPGA may be an excellent way of prototyping and even producing a multicore RTA1 with
a 192-bit bus rather like some video RAM buses

<a	name="morems"/>
<h3>More Emulations</h3>

First some notes on the shipped emulations for OSX Intel and OSX PowerPC

<p>
Emulations compiled or assembled on very old OSX (Snow Leopard and gcc 4.2.1) are the fastest<br>
performing on all OSX Intel and run on all OSX Intel. They are
<pre>

	rta/tgen/r	# runs emulators called tipt written in x86 assembler and built with tgen/tgen
	rta/tgen/rc	# runs emulators called tipc written in gcc and built with tgen/tgenc 
</pre>
Emulations built on High Sierra with LLVM and clang are much slower

<p>
A static link to join x86 assembler-written emulator instruction loop to gcc-written emulator<br>
front-end has not yet been achieved with LLVM and clang. Not one that runs anyway. Something<br>
connected with a dislike of static links at Apple Computer. There is an enthusiasm for PIC there<br>

<p>
Anything written all in c with no inline assembler and no called assembler either can build with<br>
LLVM and clang. However old tools build a quicker emulator as long as they remain available on<br>
some build platform. Instrumentation shows a third more emulated MIPS for builds on Snow Leopard<br>
executing on High Sierra than for High Sierra builds running on High Sierra

<p>
There is some possibility that the MIPS performance metric is distorted in PC emulations, because
elapsed time other than emulated powersave is measured. The instruction execution thread may be timesliced
when it is supposedly active.


<a	name="metric"/>
<h3>Emulated MIPS Performance Metric</h4>

The acronym MIPS means millions of emulated instructions per second

<p>
Instrumentation is optional. Of the 21 emulator images shipped for OSX Intel, three are built with instrumentation
<ul>

	<li>tipt0 is constructed with x86 assembler-written hard-loop execution thread</li>
	<li>tipc0 is all gcc with no assembler inlines</li>
	<li>tipc1 is gcc with assembler inlines to accelerate operand access</li>

</ul>
The digit at the end of the binary name is the number of executable space banks the image has.<br>
A bank is 262144 RTA1 words. No banks means half a bank. Scripts tgen/r and tgen/rc run tiptX or tipcX<br>
according to the value of $RTA_MBANKS. Shipped emulators have [ 0 | 1 | 2 | 4 | 8 | 32 | 64 ] banks

<p>
To run for example tipc1

<pre>

	export	RTA_MBANKS=1	# this selects tipt1 or tipc1 or tiptoe1 depending what script you run
	./rc			# script rc: tipc$RTA_MBANKS must be started without -s flag
				# and single-step command s must not be entered
				# waiting for keyboard distorts the MIPs metric millions downward 
	i			# key i and return for MIPS metric on the fly

</pre>

$RTA_MBANKS also sets the executable space size for <a href="#buildrta">emulator builds</a>
<pre>
	tgenc	any_little_endian -DMETRIC
</pre>
A buils with -DMETRIC argument constructs an instrumented binary for any size you select

<p>
But executable space does not effect MIP rate at all,  and anything built on High Sierra/LLVM/clang<b>
instruments itself as slower than the shipped emulators

That highlights the importance of sourcing a fast-code-generating ANSI-c multi-architecture compiler<br>
for OSX and Linux:<br>especially for Linux, because Linux SBCs are the projected host for for<br>
a value-added market product

<p>
OSX PowerPC runs an earlier emulator
<pre>

	rta/rta.run/run minimal rand7	# runs emulators called tiptoe written in gcc	
					# and built with rta/rta.run/tipgen
					# minimal is target system image target.rta/rta.gen/minimal.rom
					# rand7 is a file system image containing these web pages

</pre>

<p>
Next emulation should be Linux if anyone likes to play IPTables to get the firewall rules right<br>
A separate <a href="#osserv">network interfacing process</a> shares buffers with the emulator process.

<p>
Emulator build on Linux aso needs a better compiler than gcc

<p>
A Windows 10 compilation of the emulator runs, but there is no satisfactory way of filtering<br>
network traffic into RTA1's shared buffer. Win10Pcap isn't sufficiently documented to use, and<br>
does not support LoopBack interface. It would be good to obtain a fix removing all restrictions<br>
from IP Raw Socket Protocol. Very few problems are encountered programming with Visual Studio CL<br>
in command prompt


<a	name="target"/>
<h3>Constructing RTA1 Target Images and Applications</h3>

This section is about programming RTA1

<p>
Currently RTA1 target images are a kernel and a small number of application server protocols,<br>
http, telnet, snmp, UDP 96-bit floating point server and UDP 192-bit floating point server

<p>
These servers start at system start. This corresponds with the embedded systems background of RTA1 project

<p>
All these servers are either threads or subroutines of the system's only automatic process, internet protocol

<p>
Servers over TCP are necessarily a different thread or a different process from IP initial thread.<br>
TCP Servers may wait for segment buffers and IP initial thread cannot wait for itself

<p>
A few UDP servers are still stacked into IP initial thread as this was earlier considered more efficient<br>
than context switching. All new development of application protocol servers is in new threads, so that newly<br>
developed routines do not stop IP if they accidentally trigger a contingency and get switched to the inactive<br>
list for analysis

<p>
Servers to be run as a thread of IP may be named in a file rta/target.rta/t77.4/athreads.msm

<p>
These servers start their own thread as this example stub function shows.<br>
The name added to athreads.msm is http_server, which IP calls exactly once on startup
<pre>
  :                            50 $(0::A_PROTOS_BANK1)
00:005000 B601A4              +51 telnet*       $vector telnet_i
00:005001 B6025E              +52 http_server*  $vector http_serve



  :                            75 $(0)
  :                            76 http_serve
  :                            77
  :                            78
  :                            79
00:00525E 4F0F88              +80       ql      (http_thread,,,:q)
00:00525F 750047              +81       ii      THREAD$
00:005260 3D0000              +82       fret    0
  :                            83
  :                            84 http_thread
  :                            85
  :                            86


</pre>
Non-primary threads are in the data space of IP and do not need to initialise any part of that.<br>
Primary threads load the initial data of all included threads

<p>
The sequence for constructing the default prototype image is
<pre>

	cd	rta/target.rta/rta.gen
	micro -d		# d option lists with absolute adresses

</pre>
Text file mlist.txt can then be checked

<p>
New processes link in a way which includes their instructions at their targeted address in the system image<br>
and stores initial data in a ROM-resident (executable-space-resident) file system. There is no file system lookup<br>
because the data file location is available at link

<p>
Applications initialise by basing the supplied data memory in their address space and calling the<br>
file driver for resident file systems to load
<a href="http://TimMilesCox.github.io/RTA/masmx7r3.html#appload">data segment load strings</a>.
This is a single call for all<br>
segments placed in the application's load file at link

<p>
So all applications are shared-code

<p>
Newly under development is a lookup table for starting applications on interactive demand

<p>
The interface will be telnet, which does not as could be expected assign incoming connections<br>
to a new process and a shell

<p>
telnet is currently a stub allowing a few simple console commands. A new command will start<br>
applications which have a lookup template as a new process and assign the incoming connection to the process

<p>
The lookup table entry or template will be generated by a macro call at application build

<p>
Applications of this kind are expected to include shells. These may not be the very first terminal-startable<br>
applications because they certainly need a c compiler

<p>
Development of this application start interface will be accompanied by a simple sample application

<p>
Manuals for development include
<ul>
	<li><a href="http://TimMilesCox.github.io/RTA/rta.html">rta</a></li>
	<li><a href="http://TimMilesCox.github.io/RTA/masmx7r3.html">masmx for RTA1</a></li>
        <li><a href="http://TimMilesCox.github.io/RTA/language.html">language and call sequences</a></li>
        <li><a href="http://TimMilesCox.github.io/RTA/smaragd7.html">smaragd7 kernel</a></li>
        <li><a href="http://TimMilesCox.github.io/masmx/masmx.html">masmx reference</a></li>
</ul>

<a	name="ipfw"/>
<h2>Appendix B: netifx Datagram Divert Service</h2>
<a	name="datagram service"/>
<h3>Earlier Datagram Service over IPFW</h3>

netifx datagram service over ipfw is mostly confined to Apple OSX up to
Snow Leopard or slightly later

<pre>

	cd rta/netifx

	./runL

</pre>
runL script sets up firewall divert rules which catch traffic addressed to
the RTA1 from outside, then runs a program netifx

<p>
runL calls first ifconfig then ipfw to associate network addresses for RTA1
with the emulator platform interfaces and then calls ipfw to divert traffic
for these addresses to netifx firewall divert socket and to relay output

<p>
172.29.7.7 is the divert address of RTA1 on the emulator
host software loopback

<p>
ifconfig attaches by default address 172.29.7.8 to wired Ethernet for diversion
to RTA1 and 172.29.7.66 to WiFi. The two LAN addresses need varying in 
scripts runL and reRunl if there are more emulated RTA1s on the network

<p>
<pre>

        sudu ifconfig lo0 inet 172.29.7.7/32 alias
        sudo ifconfig en0 inet 172.29.7.8/32 alias
        sudo ifconfig en1 inet 172.29.7.66/32 alias

</pre>
ipfw adds a firewall rule to divert traffic to the netifx
process connecting emulated RTA1 to the physical interface
<pre>

        sudo ipfw add divert 4608 ip from any to 172.29.7.7 in
        sudo ipfw add divert 4608 ip from any to 172.29.7.8 in
        sudo ipfw add divert 4608 ip from any to 172.29.7.66 in
</pre>

<p>
netifx owns the firewall divert socket which catches traffic meant for
RTA1 and places it in a large ring of shared memory buffers which looks
to the emulated RTA1 like one of its architectural device arrays

<p>
netifx forwards RTA1's outbound network traffic from that buffer
to real networks

<p>
You can stop netifx by keying PERIOD and ENTER twice
<pre>

	.
	stop the interface? key . again>.

</pre>
You need to restart netifx before restarting the emulated RTA1
if you have stopped that

<p>
There is a script
<pre>

	./rerunL

</pre>
which runs netifx without repeating the firewall rules. It does no harm
however to duplicate the firewall rules

<p>
If you are running on OSX and talking to emulated RTA1 from the
same computer it's running on, you need the -z option for netifx

<p>
This is because OSX puts wrong checksums on its own loopback
interface and netifx must correct them before passing traffic to
RTA1

<p>
In detail the wrong checksums are addresses + protocol + PDUsize
without doing any more

<p>
Other netifx options are about how much trace you like to see
in the shell where netifx is running

<p>
The actions of <b>netifx</b> are
        <ol>
        <li>script netifx/runL sets firewall rules to
        drop RTA1 incoming traffic from the kernel</li>

        <br>
        <li>binary netifx binds real-interface:net-address[/mask][:port]
        combinations to RTA1 according to command line arguments</li>

        <br>
        <li>netifx initialises the buffer shared with emulated RTA1
        and uses it to transmit network configuration PDUs to RTA1</li>

        <br>
        <li>RTA1 receives configuration tuples as its first traffic</li>

        <br>
        <li>ifconfig is separately called on the emulator host to add
        RTA1 network addresses to emulator host interfaces</li>

        <br>
        <li>netifx submits received traffic to RTA1 and transmits traffic
        from RTA1</b>
        </ol>



<a	name="netifx"/>
<h3>Building netifx</h3>

<pre>

        cd rta/netifx
        ./make  [powerpc|sparc]

</pre>

This is not cross-compilation This is native compilation on and for
the emulator host with some code path differences for platform endian.
An argument of either <b>powerpc</b> or <b>sparc</b> indicates big endian
<pre>

        ./make          #       build on any little-endian emulator host

        ./make  powerpc #       build on any big-endian emulator host

        ./make  sparc   #       build on any big-endian emulator host

</pre>


<a	name="licence"/>
<i>
<pre>
_______________________________________________________________________________________


LICENCE NOTE

    Copyright Tim Cox, 2012
    TimMilesCox@gmx.ch

    This document is part of the RTA1 Processor Programmable Architecture.

    RTA1 is a free processor architecture specification. It is licensed
    under the GNU General Public Licence Version 3

    The executable emulation of RTA1 is free software.

    Instruction code for the target RTA1 architecture is free software
    if it is delivered with this software

    Software programs delivered with this software to connect the
    emulated RTA1 with real network interfaces in the emulator host
    are free software

    Scripts and programs delivered with this software for running
    on other computers and interacting with the RTA1 are free software

    Scripts and utility programs for constructing RTA1 target
    executable software are free software

    You can redistribute it and/or modify RTA1
    under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    RTA1 is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with RTA1.  If not, see &lt;http://www.gnu.org/licenses/&gt;.



</pre>
</i>


</div>
</html>
