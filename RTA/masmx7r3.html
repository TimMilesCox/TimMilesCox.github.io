<html>

<div>

<center>
<h1>masmx.7r3 for RTA1</h1>

<i>
Copyright Tim Cox, 2014
<p>
This document is part of the RTA1 Processor Programmable Architecture Specification<br>
RTA1 is a free computer programmable architecture licensed under the GNU General Public Licence Version 3<br>

The same licence encompasses all software and documentation delivered with RTA1 Specification

<br>
The masmx.7r3 meta-assembler is free software separately licensed with the GNU General Public Licence Version 3

<br>
The full text of GNU General Public Licence Version 3 is included with these materials<br>
See also the licensing notice at the foot of this document

</i>
</center>

<h2>Larger Document Link</h2>

This is a summary for programming RTA1

<p>
To see everything masmx does,
refer to <a href="http://timmilescox.github.io/masmx">
masmx documentation and download</a>

<p>

For RTA1 assembly examples,        
Complete source code and assembly listing of the smaragd7 kernel and of some application protocols are in the repository RTA1

<p>
RTA1 instructions are listed by functional group in this manual,
and the storage geometry of application programs is described

<p>
To see in full RTA architecture and instruction set specification,
refer to <a href="http://timmilescox.github.io/RTA/rta">
RTA Processor Programmable Architecture Specification</a>

<p>
Or online to your emulated machine <b>http://172.29.7.7:8080</b> and hit the architecture specification button <b>rta</b>

<p>
This manual discusses some topics beyond writing assembly language code for RTA1. Kernel calls to support
data segment loading are described, plus linking and code formatting utilities

<h2>Settings for RTA1</h2>

masmx is a target-independent meta-assembler. masmx default
settings are already the correct ones for RTA1 data formats.
For RTA1 registers and instructions
<pre>

	$include	freeware/RTA1/rta/def/rta.def

</pre>
or like this
<pre>

	$path		freeware/RTA1/rta	. if that's where you have it
	$include	def/rta.def
	$path					. back to your directory

</pre>

<p>
masmx already has these default settings. They are correct for RTA1
<pre>

        $word                   24
        $address_quantum        24
        $awidth                 24:48
        $floating_point         96
        $characteristic         24
        $characteristic,48      12
        $byte                   8

</pre>


<b>$awidth</b> has two steps because the effective address is
24 bits but the executable space is larger. masmx can construct
code and data in all the executable space using the giant address

<p>
masmx default byte size is 8 bits and data code is ASCII.
<b>$byte</b> and the data code can be changed during
an assembly

<p>
masmx syntax element defaults are also
correct for RTA1
<pre>

	$lterm			'.'	. comments follow PERIOD SPACE
	$sterm			':'	. substrings are lexical:divisions
	$cont_char		';'	. line continuation sentinel

</pre>

<h2>Assembly Language</h2>

The line of assembly language code has an arbitrary number of fields

<pre>

label	command		argument1[,argument1_subfield2,...]]	[argumentN[,argumentN_subfiel2,...]]	[. comment ]

</pre>
Lines may be continued
<pre>

label	command		 argument1[,argument1_subfield2,...]	;
			[argument2[,argument1_subfield2,...]]	;
			[argumentN[,argumentN_subfield2,...]] 

</pre>
<h3>Labels</h3>
A label starts in column 1 and ends in whitespace. A label may contain letters, digits, $_?!@: and
starts with a letter or _?!@

<p>
A reference containing substring character : may reference a simple label or a structured location

<p>
A label may be in "" and then it starts with anything and contains anything

<p>
Without case-sensitive option -k all labels and references are translated to uppercase

<p>
$ in column one is a program section control called a location counter with syntax
<b>$(number[:attributes])</b> See section <b>Application Memory, Location Counters</b>

<p>
A label starting with $ is declared in quotes but usually referenced without quotes

<p>
A label may have an arbitrary number of subscripts
<pre>

<i>label(5,7,600)</i>

</pre>
Each subscripted instance is a different label

<p>
A label <i>label_stem(4,1,20)</i> is the count of

<pre>
	<i>
	label_stem(4,1,20,5)<br>
	label_stem(4,1,20,20)<br>
	...</i>

</pre>

Each subscript may be expressed algorithmically as <i>label_name(name*function+counter)</i>

<p>
A subscripted label reference which does not exist has the value of zero because it
counts an empty set

<p>
Macros generate and use labels which are discarded at the end of the macro expansion.
Labels only remain for the calling level of assembly if they are promoted with trailing
asterisk
<pre>

$ masmx -lnxk visible visible
MASMX 7r3
3/visible.msm
  :                            1 macro1*	$proc
  :                            2 	macro2
  :                            3 visible* $equ	invisible
  :                            4 	$end
  :                            5 
  :                            6 macro2* $proc
  :                            7 macro3* $proc
  :                            8 manifest****
  :                            9 private***
  :                            10 unseen
  :                            11 invisible**
  :                            12 	$end
  :                            13 	macro3
  :                            14 	$end
  :                            15 
  :                            16 $(14:0E000)
  :                            17 	macro1
  :                            18 	$end
macro1=:P1:0:000000
macro2=:P1:0:000001
manifest+=$0E:00E000
private=$0E:00E000
visible=00E000
visible.msm=0<000003
:$(0E):00E000:00E000 
visible.msm: object code 47 bytes: 0 errors: 0 undefined labels
Tim-Coxs-MacBook:~ timcox$ cat visible.txo

+manifest:$0E:00E000
:$0E*000000:00E000:00E000
$

</pre>
<p>
One asterisk is added to promote a label one  macro level. An asterisk at the main
assembly level externalises the label


<h3>Command Field</h3>

The command field is the first field to follow any whitespace. It may contain 

	<blockquote>
	nothing. Then there are no arguments either<br><br>
	a number constant or a character string constant<br><br>
	a space-isolated unary sign governing a number constant<br><br>
	an assembler directive<br><br>
	a bitfield structure name of the <b>$form</b> type<br><br>
	the name of a macro of the <b>$proc</b> type producing data or instruction code
	</blockquote>

Assembler coding is predominantly writing instructions. The essential line has in 
the command field the <b>$proc</b> macro name of an instruction. The <b>$proc</b>
mostly invokes a <b>$form</b> bitfield layout for the instruction. Here is a simplified
view of an instruction defininition in <b>rta.def</b>
<pre>

isimple $form	5,3,16

p	$proc
lret*	$name	6
fret*	$name	7
	isimple	p(0, 0), 5, p(1, 1)
	$end

</pre>
Here is a corresponding line of application code
<pre>

	lret	1	. return and skip 1 instruction

</pre>

see also sections <b>$form</b> and <b>$proc</b>

<h2>Data Constants</h2>
<h3>Expressions and Numbers</h3>

Operators by rank are

	<blockquote>
	()<br>
	=<br>
	^=<br>
	><br>
	<<br>
	--<br>
	++<br>
	/*<br>
	*/<br>
	*/-<br>
	**<br>
	*+ *-<br>
	+ -<br>
	* / // ///<br>
	&plusmn; ^unary<br>
	</blockquote>


Operators in the same rank have left-to-right precedence as they are
encountered in the expression

<p>
Operators of higher rank are evaluated first and operated last. An expression
generates an integer until a decimal exponent operator *+ *- is actioned

<p>
The operators are 
<pre>

	_________________________________________
	|	=	|	equal		|	= 1 ^= 0
	|_______________|_______________________|
	|	^=	|	unequal		|	^= 1 = 0
	|_______________|_______________________|
	|	>	|	greater		|	> 1 = 0 < 0
	|_______________|_______________________|
	|	<	|	less		|	< 1 = 0 > 0
	|_______________|_______________________|
	|	--	|	XOR		|
	|_______________|_______________________|
	|	++	|	OR		|
	|_______________|_______________________|
	|	/*	|	shift right	|
	|_______________|_______________________|
	|	*/	|	shift left	|
	|_______________|_______________________|
	|	*/-	| right	shift algebraic	|
	|_______________|_______________________|
	|	**	|	AND		|
	|_______________|_______________________|
	|	*+	|      +decimal exponent|
	|_______________|_______________________|
	|	*-	|      -decimal exponent|
	|_______________|_______________________|
	|	+	|	PLUS		|
	|_______________|_______________________|
	|	-	|	MINUS		|
	|_______________|_______________________|
	|	*	|	MULTIPLY	|
	|_______________|_______________________|
	|	/	|	DIVIDE		|
	|_______________|_______________________|
	|	//	|	covered quotient|
	|_______________|_______________________|
	|	///	|	remainder	|
	|_______________|_______________________|

</pre>
<p>
Number constants have the default masmx syntax. Leading 0 means hex

<p>
masmx.7r3 has two changes from masmx7r2 in number handling

<p>
It is no longer invariably necessary to precede a number constant
with a unary sign. An unsigned number starting with a digit in the
command field is now recognised as a positive number constant

<pre>

$ masmx -ln
MASMX 7r3
0/-INPUT>>

	99
	1.5*+2
        $end
  :                            1 
00:000000 000063              +2  99
00:000001 400008960000000000000000
                              +3  1.5*+2
  :                            4  $end
:$(00):000000:000005 


</pre>

<p>
A unary symbol in the command field continues to mean a number
constant, but with a new difference

<p>
In masmx.7r3 a unary symbol appended to the front of the
constant expression only exerts polarity on the first token

<pre>

$ masmx -ln
MASMX 7r3
0/-INPUT>>
	-2-2
	^0f0f++3
	-5-10*-1 
	$end
00:000000 FFFFFC              +1  -2-2
00:000001 FFF0F3              +2  ^0f0f++3
00:000002 BFFFFE3FFFFFFFFFFFFFFFFF
                              +3  -5-10*-1 
  :                            4  $end
:$(00):000000:000006 

</pre>

<p>
Unary ^ is 1s complement

<p>
As with earlier masmx distribitions, a unary symbol
separated by whitespace from the number expression
exerts polarity on the resolved total expression
that follows

<pre>

$ masmx -ln
MASMX 7r3
0/-INPUT>>
	-	2-2
	-	50+50:d
	+	3072-1:t
	+	0ffffffcccccc++0ffffffEEEEEE*/48:q
        -       100000*/96:p

        +       1.75*+1200000
	$end
00:000000 000000              +1  - 2-2
00:000001 FFFFFFFFFF9C        +2  - 50+50:d
00:000003 000000000000000BFF  +3  + 3072-1:t
00:000006 FFFFFFEEEEEEFFFFFFCCCCCC
                              +4  + 0ffffffcccccc++0ffffffEEEEEE*/48:q
00:00000A FE7960000000000000000000000000
                              +5         -       100000*/96:p
  :                            6 
00:00000F 7CD38BB7B396D7AA20B6E083
                              +7         +       1.75*+1200000
  :                            8  $end
:$(00):000000:000013 


</pre>
<p>
Fixed point numbers are autosized. masmx adds an extra word of signs
where the high order bit of the magnitude is not a sign.
Specific size can be suffixed
<pre>

$ masmx -ln
MASMX 7r2
0/-INPUT>>
	+	255*/16
	+	255*/16:s
	$end
00:000000 000000FF0000        +1  + 255*/16
00:000002 FF0000              +2  + 255*/16:s
  :                            3  $end
:$(00):000000:000003 


</pre>
The size suffixes are :s (one word) :d (two words) :t (three words)
:q (four words) :p (five words) :h (six words) :o (eight words)

<p>
:d and :l are synonymous. The size suffix does not always need a colon
but it is never wrong to type the colon. The size suffix can equally be
upper or lower case, whether the assembly is case-sensitive or not

<p>
Symbols in single quotes produce the number values assigned in the
current data code juxtaposed according to current byte size. It's a
right justified string up to maximum number size, and may be operated
in expressions
<pre>

$ masmx -ln
MASMX 7r3
0/-INPUT>>
	+	'abcd'
	$data_code	97:65	. generate 'A' when the source has 'a'
	+	'abcd'++128	. logical OR bit 7 on
	$ascii			. switch back to plain ASCII
	$byte	12		. make the byte size a halfword
	+	'abcd'
	$end
00:000000 000061626364        +1  + 'abcd'
  :                            2  $data_code 97:65	. generate 'A' when the source has 'a'
00:000002 0000416263E4        +3  + 'abcd'++128		. logical OR bit 7 on
  :                            4  $ascii		. switch back to plain ASCII
  :                            5  $byte 12		. make the byte size a halfword
00:000004 061062063064        +6  + 'abcd'
  :                            7  $end
:$(00):000000:000006 

</pre>

<p>
Tokens in an expression may be labels

<p>
<b>$equ</b> labels are fixed in value. <b>$set</b> labels can be
set again to a new value
<pre>

fast	$equ	1.75	. can't be changed within this subassembly
loose	$set	99	. can be changed as much as you like

</pre>
Not all operations are allowed on labels which are relocatable
storage addresses
<pre>

$(3:*1)			. relocatable program section

buffer	$res	20	. buffer can be in &plusmn; expressions
			. and shift right expressions

</pre>
Labels in expressions may also be masmx internal function names
or the names of macros of the $func type

<p>
These examples show function expressions in instruction operands
instead of constants
<pre>

	jc	$+2	. current location counter + 2

f	$func
upto10*	$name
	$do	f(1, 1)>10,	$return	10
	$return	f(1, 1)
	$end


	lr, xi	upto10(ACTUAL_PARAMETER)		
	

</pre>
The optional tag of <b>$do</b> directive is a value incrementing
from 1
<pre>

$ masmx -ln
MASMX 7r3
0/-INPUT>>
mantissa	$equ	175
exponent	$do	3,	+mantissa*+exponent-3
		$end
  :                            1 mantissa $equ 175
00:000000 400001E00000000000000000
                              +2 exponent $do 3, +mantissa*+exponent-3
00:000004 4000058C0000000000000000
                              +2 
00:000008 400008AF0000000000000000
                              +2 
  :                            3   $end
:$(00):000000:00000C 

</pre>
<p>
A decimal point or the exponent operators <b>*+ *-</b> make a number
floating-point

<p>
Integers are twos-complement negative and floating numbers are 1s-complement negative
<pre>

	$ masmx -ln
MASMX 7r3
0/-INPUT>>
	-       6
	-	0.5
	$end
00:000000 FFFFFA              +1  - 6
00:000001 BFFFFF7FFFFFFFFFFFFFFFFF
                              +2  - 0.5
  :                            3  $end
:$(00):000000:000005 


</pre>
The floating mantissa is a simple fraction.
Its integral part is derived by hauling the mantissa
upwards through the fractional point the number of
positions by which the exponent exceeds the midpoint
value <b>0400000</b>
<pre>

	$ masmx -ln
MASMX 7r3
0/-INPUT>>
	+	1.5
	$end
00:000000 400001C00000000000000000
                              +1  + 1.5
  :                            2  $end
:$(00):000000:000004 


</pre>
Floating point numbers do not autosize.
They are four words
<pre>


		$ masmx -ln
MASMX 7r3
0/-INPUT>>
	+	1.75*+1250000
	+	1.75*-1250000
	$end
00:000000 7F5C5BF331AD4B6FFBBCAAB2
                              +1  + 1.75*+1250000
00:000004 00A3A7CE52225BC80EDFF592
                              +2  + 1.75*-1250000
  :                            3  $end
:$(00):000000:000008 


</pre>
<p>
The two-word suffix may be used to assemble a 48-bit
compressed floating constant which RTA1 can
expand to four words at the internal stack top with the
<b>floating push and expand</b> instruction <b>fpx</b>

<p>
RTA1 computes 96-bit floating-point but the <b>floating pop and pack</b>
instruction <b>fpp</b> can store the number in a 48-bit
floating format if that has enough range for its value
<pre>

	$ masmx -ln
MASMX 7r3
0/-INPUT>>

	$list		0
	$include	freeware/RTA1/rta/def/rta.def
	$list

$(0:64)

	fpx		(4.096:d*+200)		. this instruction loads the internal stack from storage
	fa		0, sp			. use the expanded number

	qs		0, sp
	fpp		compressed_storage	. compress the 4-word result
						. this instruction pops the internal stack to storage	
	$do		$<256,$(0:256)

$(3:03000)
compressed_storage $res	2
	$end
  :                            1 
  :                            429  $list
  :                            430 
  :                            431 $(0:64)
  :                            432 
00:000040 5F0100              +433  fpx  (4.096:d*+200)
00:000041 67F000              +434  fa  0, sp   . use the expanded number
  :                            435 
00:000042 47F000              +436  qs  0, sp
00:000043 573000              +437  fpp  compressed_storage . compress the 4-word result
  :                            438  
  :                            439  $do  $<256,$(0:256)
  :                            440 
  :                            441 $(3:03000)
  :                            442 compressed_storage $res 2
  :                            443  $end
00:000100+69BAB3C2FDDF
:$(00):000040:000102 :$(03):003000:003002 


</pre>

48-bit compressed floating format has only 11 exponent bits, so its range difference
from 96-bit compute-format is a larger difference that a difference in mantissa
precision
<pre>

	47 46        36 35                                      0
	__________________________________________________________
	|s|xxxxx xxxxxx|mmmmmm mmmmmm mmmmmm mmmmmm mmmmmm mmmmmm|
	|_|____________|_________________________________________|________________________________________________________
	|s|xxxxx xxxxxx xxxxxx xxxxxx|mmmmmm mmmmmm mmmmmm mmmmmm mmmmmm mmmmmm mmmmmm mmmmmm mmmmmm mmmmmm mmmmmm mmmmmm|
	|_|__________________________|___________________________________________________________________________________|
	95 94                      72 71                                                                                0

</pre>

<p>
RTA1 two- and four-word burst reads and writes are at any word address

<p>
It's foreseen that for network transfer native RTA1 96-bit and 48-bit numbers be
translated dynamically to and from XDR formats

<p>
However XDR and non-RTA1 machines can only represent a microscopic
part of RTA1 floating range. The exchange format for large numbers is
ASCII edit string




<h3>Literals</h3>

The last floating-point assembly example also shows an automatic literal.
The two-word floating operand of the <b>fpx</b> instruction is assembled
at address 256, beyond the addresses of the RTA1 registers

<p>
A literal is a constant declared as an operand and
assembled at the end of a designated section

<p>
Literals look like immediate operands but are storage
constants of any size. The instruction contains their
address, not their value

<p>
An automatic literal is an operand starting and ending
with parenthesis. Automatic literals are  enabled with
assembly flag -a in <b>rta.def</b>
<pre>

	$set_option	"a"
	
</pre>
By default automatic literals are assembled at the end
of program section $(0)

<p>
The <b>$lit</b> directive may place automatic literals 
at the end of another program section
<pre>

[tag]	$lit	55

</pre>
A literal which is not automatic  has a literal pool
tag before the opening parenthesis
<pre>

$ masmx -lnz
MASMX 7r2
0/-INPUT>>

        $list   0
        $include        freeware/RTA1/rta/def/rta.def
        $list

$(3:03000/$literals3)
$(0:64)

	lx, xi		$literals3("this way to the gastronomy hall")

	$end
  :                            1 
  :                            428         $list
  :                            429 
  :                            430 $(3:03000/$literals3)
  :                            431 $(0:64)
  :                            432 
00:000040 553000              +433  lx, xi  $literals3("this way to the gastronomy hall")
  :                            434 
  :                            435  $end
03:003000+746869732077617920746F207468652067617374726F6E6F
6D792068616C6C0000
:$(00):000040:000041 :$(03):003000:00300B 

</pre>

<h3>More about Strings</h3>

The last literal example was a string. Bytes are any size you
say they are, default 8-bits, padded with either zero or space to integral words
<pre>

$ masmx strings -ln
MASMX 7r2
3/strings.msm
*EOF*
  :                            1 	$set_option	"z"
00:000000 737472696E67        +2 	"string"
  :                            3 	$byte	12
00:000002 07307407206906E067  +4 	"string"
  :                            5 	$byte	16
00:000005 0073007400720069006E0067
                              +6 	"string"
  :                            7 	$byte	24
00:000009 00007300007400007200006900006E000067
                              +8 	"string"
  :                            9 	$byte	6
00:00000F CF4CA9BA7000        +10 	"string"
  :                            11 	$byte	7
Note: strings.msm Line 12: trailing zero bits in last data word of string
00:000011 E7D3969DD9C0        +12 	"string"
  :                            13 	$byte	8
00:000013 737472696E67        +14 	"string"
  :                            15 
*EOF*
:$(00):000000:000015 

</pre>
Padding to word fill is zero with option <b>-c</b> or <b>-z</b> and space
with neither or both <b>-cz</b>

<p>
In <b>masmx.7r3</b> the masmx-internal label <b>$bits</b> contains
the number of bits containing the characters in the string after the
string is assembled. The number of characters in the string can be
calculated instead of counted by hand

<pre>

$ masmx -lnz
MASMX 7r3
0/-INPUT>>
	"abcd"
	+	$bits
	+	$bits/$byte
	$end
00:000000 616263640000        +1  "abcd"
00:000002 000020              +2  + $bits
00:000003 000004              +3  + $bits/$byte
  :                            4  $end
:$(00):000000:000004 

</pre>


<p>
Changed data code and byte size are effective for "strings" just as for
number +'strings'
<pre>

$ masmx -ln
MASMX 7r3
0/-INPUT>>
	"789abc"
	$data_code	97:65,66,67
	"789abc"
	$byte	12
	"789abc"
	$ascii
	"789abc"
	$byte	8
	"789abc"
	$end
00:000000 373839616263        +1  "789abc"
  :                            2  $data_code 97:65,66,67
00:000002 373839414243        +3  "789abc"
  :                            4  $byte 12
00:000004 037038039041042043  +5  "789abc"
  :                            6  $ascii
00:000007 037038039061062063  +7  "789abc"
  :                            8  $byte 8
00:00000A 373839616263        +9  "789abc"
  :                            10  $end
:$(00):000000:00000C 


</pre>

<h3>$form Bit-Field Structures</h3>

Directive <b>$form</b> types bit-field structures up to eight words long.
The structures are an integral number of words in size
<pre>

long_virtual_address	$form			1, 1, 16, 6, 6, 18

			long_virtual_address	0, 1, BANK_32768, DEVICE_2, BASE_WINDOW_44, 03000A

</pre>

<h3>Equal-Size Bit Fields</h3>

A number constant divided by commas means the containing word or words is of equal sized fields. The total size is one word regardless of value truncation, unless an override suffix is typed
<pre>

		$ masmx -ln
MASMX 7r3
0/-INPUT>>

RED48		$equ		48
GREEN72		$equ		72
BLUE240		$equ		240

	+	RED48, GREEN72, BLUE240
	+	0FFFC, 08003, 07001:d    

	+	15, 14, 12, 0, 5, 10
	+	7, 4, 3, 6,  6, 3, 2, 5
	$end
  :                            1 
  :                            2 RED48		$equ		48
  :                            3 GREEN72	$equ		72
  :                            4 BLUE240	$equ		240
  :                            5 
00:000000 3048F0              +6 	+	RED48, GREEN72, BLUE240
00:000001 FFFC80037001        +7 	+	0FFFC, 08003, 07001:d    
  :                            8 
00:000003 FEC05A              +9 	+	15, 14, 12, 0, 5, 10
00:000004 F1ECD5              +10 	+	7, 4, 3, 6,  6, 3, 2, 5
  :                            11 	$end
:$(00):000000:000005 


</pre>
<h2>Instructions and Operands</h2>

Instructions are listed here in functional groups

<p>
Instructions are explained in code order in the RTA1 programmable architecture
specification

<p>
Instructions may imply scalar registers or the internal stack as left-side operand, and
have an address for a second input


<h3>Register / Memory Operand Continuum</h3>
<p>
The right-side operand may be in storage or a register. Some
instructions take an immediate operand

<p>
Registers are in the memory address space

<h3>Programmable Register Model</h3>
Application and interrupt space each have scalar registers and a register array called the internal stack

<p>
The size of each internal stack is 104 words intended for stringently realtime programming methods. For
programming techniques which require extensive stacks, macro libraries are supplied to reuse internal
stack space in a renewable way
<pre>

			The Application Registers						  The Interrupt Registers
			_________________________						  _______________________


		 23			       0					 23			       0
		_________________________________					_________________________________
	0	|		r		|	repeat counter	 	128	|		r_x		|
		|_______________________________|					|_______________________________|
	1	|		k		|	mask register		129	|		k_x		|
		|_______________________________|					|_______________________________|
	2	|		x		|	index register		130	|		x_x		|
		|_______________________________|					|_______________________________|
	3	|		y		|	index register		131	|		y_x		|
		|_______________________________|					|_______________________________|
	4	|		a		|  arithmetic + index register	132	|		a_x		|
		|_______________________________|					|_______________________________|
	5	|		b		|  arithmetic + index register	133	|		b_x		|
		|_______________________________|					|_______________________________|
	6	|	mantissa2		|	arithmetic register	134	|	mantissa2_x		|
		|_______________________________|					|_______________________________|
	7	|	mantissa3		|	arithmetic register	135	|	mantissa3_x		|
		|_______________________________|					|_______________________________|
	8	|		aA		|	arithmetic register	136	|		aA_x		|
		|_______________________________|					|_______________________________|
	9	|		bA		|	arithmetic register	137	|		bA_x		|
		|_______________________________|					|_______________________________|
	10	|	mantissa2A		|	arithmetic register	138	|	mantissa2A_x		|
		|_______________________________|					|_______________________________|
	11	|	mantissa3A		|	arithmetic register	139	|	mantissa3A_x		|
		|_______________________________|					|_______________________________|
	12	|	    	 p		|	bitstream pointer write	140	|		p_x		|
		|_______________________________|					|_______________________________|
	13	|	   	 q		|	bitstream pointer read	141	|		q_x		|
		|_______________________________|					|_______________________________|
	14	|	  	 fp		|	index register		142	|		fp_x		|
		|_______________________________|					|_______________________________|
	15	|	  	 sp		|	index register		143	|		sp_x		|
		|_______________________________|					|_______________________________|
	16	|				|	scratch			144	|	REALTIME$_CLOCK		|
		|_______________________________|					|_______________________________|
	17	|				|	scratch			145	|	PRIORITY$		|
		|_______________________________|					|_______________________________|
	18	|				|	scratch			146	|	DAYCLOCK$U		|
		|_______________________________|					|_______________________________|
	19	|				|	scratch			147	|	DAYCLOCK$		|
		|_______________________________|					|_______________________________|
	20	|	   RDATAC		|	bitstream counter read	148	|	X_RDATAC		|
		|_______________________________|					|_______________________________|
	21	|	    RDATA		|	bitstream data read	149	|	 X_RDATA		|
		|_______________________________|					|_______________________________|
	22	|	   WDATAC		|	bitstream counter write	150	|	X_WDATAC		|
		|_______________________________|					|_______________________________|
	23	|	    WDATA		|	bitstream data write	151	|	 X_WDATA		|
		|_______________________________|					|_______________________________|
	24	| maximum internal stack top	|				152	|				|
		|_______________________________|					|_______________________________|
	25	|				|				153	|				|
		|_______________________________|					|_______________________________|
	26	|				|				154	|				|
		|_______________________________|					|_______________________________|
	27	|				|				155	|				|




		|_______________________________|					|_______________________________|
	124	|				|				252	|				|
		|_______________________________|					|_______________________________|
	125	|				|				253	|				|
		|_______________________________|					|_______________________________|
	126	|				|				254	|				|
		|_______________________________|					|_______________________________|
	127	|				|	first pushed word	255	|				|
		|_______________________________|	on internal stack		|_______________________________|


</pre>

<h3>Instruction Layout</h3>
 
<p>
Instructions have an operand type indicator <b>jjj</b>, an instruction code 
<b>ffff</b> and a 16-bit address field

<p>
Six jjj values are different operand types for 32 single-integer instructions
and two jjj values select two mores lists of instructions

<p>
If the jjj field is 5, the operand is 16-bit sign extended immediate
<pre>


				  23      18    15                            0
				_________________________________________________
				| fffff | 101 | &plusmn;16-bit sign extended immediate	|
				|_______|_jjj_|_________________________________|


				ax, xi		-20000
				push		600,,xi


</pre>
Otherwise, if bit 15 is zero, the operand address is a direct address 15 bits in size
<pre>

				  23      18    15  14                        0
				_________________________________________________
				| fffff | jjj | 0 | 15-bit direct address----->	|
				|_______|_____|___|_____________________________|



		$(3:03000)
		instance	$do	20000,keyvalue(instance)	+	KEYVALUE*instance**07FFFFF

		$(0)
				dl	keyvalue(19999)
				xor	keyvalue(19997)
				xorB	keyvalue(19998)



</pre>
If instruction bit 15 is one, the instruction has a 3 bit indirection-bank/index-register selector <b>xxx</b>
and a 12-bit displacement field
<pre>

				  23      18    15  14    11                  0
				_________________________________________________
				| fffff | jjj | 1 | xxx | 12-bit displacement->	|
				|_______|_____|___|_____|_______________________|


</pre>
If xxx is zero or one, the address is indirect. Its pointer is in the first 8192 words
in the address space. These are
<blockquote>

	the 256 registers<br>
	words 256..4095 of the current instruction bank B0<br><br>

	the 4096 words of the current private stack bank B1 (or the TCB if PSR flag see$1 is on)

</blockquote>
<pre>
		$(1:01000)
		redirection	$res	1
				
		$(0)
				lr	*redirection
				ql	*(ADDRESS_7_MEGAWORD)	. big indirect address
								. in 24-bit literal constant
				tp	*11

</pre>

If xxx is 2..7 then index register [x y a b fp sp] is added to to the unsigned
12-bit displacement to form the effective address
<pre>

		  23                                          0			  23                                          0
		_________________________________________________		_________________________________________________
		|		effective address		|<----- + ------|		[ x y a b fp sp ]		|
		|_______________________________________________|		|_______________________________________________|
				 	^			^
					|			|
					|	    +		|
					|			|
		  23      18    15  14    11                  0
		_________________________________________________
		| fffff | jjj | 1 | xxx | 12-bit displacement->	|
		|_______|_____|___|_____|_______________________|



				la	64, b, i
				ly	descriptor:dgram, fp




</pre>

<h3>Single Integer Instructions</h3>
32 instructions carry out load / store / arithmetic / boolean operations on a single
integer. These 32 instructions have as their right-side operand another register, a storage word,
part of a storage word (half or third), the effective address as an immediate value, or a
sign-extended immediate value in the range -32768..+32767

<p>
Integer instructions access a word and either third-words or halfwords.
jjj = zero = operand is the storage word at ea
<pre>


				z	buffer+4
				pop	buffer+5[,,w0]	. w0 is the default
							. and need not be typed


</pre>
<p>
PSR designator <b>half$w</b> is zero if the program accesses third-words
and one if the program accesses halfwords. Bytes are sign-extended to 24
bits on read and unused fields are unchanged on byte write. Bytes are not
read from registers or written to registers. A register is a 24-bit integer,
including the internal stack register array 
<pre>

		half$w = 0							half$w = 1
		__________							__________

		  23                                          0
		_________________________________________________
   jjj = 001	|	t1	|////unused/////|////unused/////|
		|_______________|____unchanged__|____unchanged__|


				xorB, t1	indicators



		  23                                          0			  23                                          0
		_________________________________________________		_________________________________________________
   jjj = 010	|////unused/////|	t2	|////unused/////|		|	    h1		|///unused//unchanged///|
		|____unchanged__|_______________|____unchanged__|		|_______________________|_______________________|


				ana		*margin,,t2					xor		crypto,b,h1




		  23                                          0			  23                                          0
		_________________________________________________		_________________________________________________
   jjj = 011	|////unused/////|////unused/////|	t3	|		|///unused//unchanged///|	    h2		|
		|____unchanged__|____unchanged__|_______________|		|_______________________|_______________________|

				
				mf		table, x, t3					ay, h2		interval



</pre>
jjj = 100 = the operand is the effective address used as an immediate
<pre>

				lb, i		4, a
				lr		2,b,i			

</pre>
jjj = 101 = the immediate operand is the 16 bits of the address fields
sign extended to 24 bits
<pre>


				ax, xi		-8


</pre>
The $equf directive can represent all the subfield attributes of an operand with one name
<pre>

		header_byte	$equf		directory, y, t1
		HARD_LINK	$equf		'H',,xi

				la		header_byte
				aa, xi		-HARD_LINK	. compare
</pre>

<h3>Single Integer Store Instructions</h3>

The store and the test integer instructions do not take immediate operands.
The ,,i and ,,xi options of instructions sr sk sx sy sa sb z pop tz tp
are assigned to I/O and control instructions which take only an immediate
operand

The integer store instructions do not update <b>carry$</b>

<pre>

	_________________________________________________________________________________________________________
	|	mnemonic|   fffff.jjj	|			|		jjj				|	
	|_______________|_______________|_______________________|_______________________________________________|
	|	sr	|   00000.0jj	|  store repeat counter	| [w0] ++ [t1 t2 t3] -- [h1 h2]			|
	|_______________|_______________|_______________________|_______________________________________________|
	|	sk	|   00001.0jj	|  store mask register	| [w0] ++ [t1 t2 t3] -- [h1 h2]			|
	|_______________|_______________|_______________________|_______________________________________________|
	|	sx	|   00010.0jj	|  store x		| [w0] ++ [t1 t2 t3] -- [h1 h2]			|
	|_______________|_______________|_______________________|_______________________________________________|
	|	sy	|   00011.0jj	|  store y		| [w0] ++ [t1 t2 t3] -- [h1 h2]			|
	|_______________|_______________|_______________________|_______________________________________________|
	|	sa	|   00100.0jj	|  store a		| [w0] ++ [t1 t2 t3] -- [h1 h2]			|
	|_______________|_______________|_______________________|_______________________________________________|
	|	sb	|   00101.0jj	|  store b		| [w0] ++ [t1 t2 t3] -- [h1 h2]			|
	|_______________|_______________|_______________________|_______________________________________________|
	|	z	|   00110.0jj	|  zero			| [w0] ++ [t1 t2 t3] -- [h1 h2]			|
	|_______________|_______________|_______________________|_______________________________________________|
	|	pop	|   00111.0jj	|  pop internal stack	| [w0] ++ [t1 t2 t3] -- [h1 h2]			|
	|_______________|_______________|_______________________|_______________________________________________|


	Assembly Language Examples
	__________________________


</pre>

<h3>Single Integer Load Instructions</h3>

The integer load instructions do not update <b>carry$</b>

<pre>



        _________________________________________________________________________________________________________
        |       mnemonic|   fffff.jjj   |                       |               jjj                             |
	|_______________|_______________|_______________________|_______________________________________________|
	|	lr	|   01000.jjj	|  load repeat counter	| [w0] ++ [t1 t2 t3] -- [h1 h2]	++ [i xi]	|
	|_______________|_______________|_______________________|_______________________________________________|
	|	lk	|   01001.jjj	|  load mask register	| [w0] ++ [t1 t2 t3] -- [h1 h2]	++ [i xi]	|
	|_______________|_______________|_______________________|_______________________________________________|
	|	lx	|   01010.jjj	|  load x		| [w0] ++ [t1 t2 t3] -- [h1 h2]	++ [i xi]	|
	|_______________|_______________|_______________________|_______________________________________________|
	|	ly	|   01011.jjj	|  load y		| [w0] ++ [t1 t2 t3] -- [h1 h2]	++ [i xi]	|
	|_______________|_______________|_______________________|_______________________________________________|
	|	la	|   01100.jjj	|  load a		| [w0] ++ [t1 t2 t3] -- [h1 h2]	++ [i xi]	|
	|_______________|_______________|_______________________|_______________________________________________|
	|	lb	|   01101.jjj	|  load b		| [w0] ++ [t1 t2 t3] -- [h1 h2]	++ [i xi]	|
	|_______________|_______________|_______________________|_______________________________________________|
	|	push	|   11111.jjj	|  push internal stack	| [w0] ++ [t1 t2 t3] -- [h1 h2]	++ [i xi]	|
	|_______________|_______________|_______________________|_______________________________________________|



	Assembly Language Examples
	__________________________


</pre>
push decrements the internal stack pointer and loads one register in the internal
stack with the operand value. If application sp is outside the range 25..128
before the operation the guard interrupt intervenes


<h3>Test Instructions</h3>

The integer test instructions do not update <b>carry$</b>

<p>
The operand is tested for zero or for bit 23=0. If so, the next instruction is skipped. Storage half-and
third-words are sign-extended

<pre>

        _________________________________________________________________________________________________________
        |       mnemonic|   fffff.jjj   |                       |               jjj                             |
        |_______________|_______________|_______________________|_______________________________________________|
	|	tz	|   01110.0jj	|  test zero skip	| [w0] ++ [t1 t2 t3] -- [h1 h2]			|
	|_______________|_______________|_______________________|_______________________________________________|
	|	tp	|   01111.0jj	|  test positive skip	| [w0] ++ [t1 t2 t3] -- [h1 h2]			|
	|_______________|_______________|_______________________|_______________________________________________|


	Assembly Language Examples
	__________________________

  :                            430 $(3:03000)
  :                            431 left		$res	1
  :                            432 right	$res	1
  :                            433 
  :                            434 $(0:64)
  :                            435 examine<div	style="color:red">
00:000040 783000              +436 	tp	left 
00:000041 B60046              +437 	j	left_is_negative
00:000042 703001              +438 	tz	right
00:000043 B60046              +439 	j	right_is_nonzero</div>
  :                            440 
00:000044 650000              +441	la, xi	0 
00:000045 350000              +442 	lret 0
  :                            443 
  :                            444 left_is_negative
  :                            445 right_is_nonzero
00:000046 65FFFF              +446 	la, xi	-1
00:000047 350000              +447 	lret	0


</pre>

<h3>Index Register Add  Instructions</h3>

The index register add instructions do not update <b>carry$</b>

<pre>


        _________________________________________________________________________________________________________
        |       mnemonic|   fffff.jjj   |                       |               jjj                             |
        |_______________|_______________|_______________________|_______________________________________________|
        |       ax      |   10000.jjj   |  x += operand		| [w0] ++ [t1 t2 t3] -- [h1 h2] ++ [i xi]       |
        |_______________|_______________|_______________________|_______________________________________________|
        |       ay      |   10001.jjj   |  y += operand		| [w0] ++ [t1 t2 t3] -- [h1 h2] ++ [i xi]       |
        |_______________|_______________|_______________________|_______________________________________________|


	Assembly Language Examples
	__________________________


</pre>

<h3>Boolean Algebra Instructions</h3>

The boolean algebra instructions do not update <b>carry$</b>

<pre>


        _________________________________________________________________________________________________________
        |       mnemonic|   fffff.jjj   |                       |               jjj                             |
        |_______________|_______________|_______________________|_______________________________________________|
        |       or      |   10010.jjj   |  a OR operand ->a	| [w0] ++ [t1 t2 t3] -- [h1 h2] ++ [i xi]       |
        |_______________|_______________|_______________________|_______________________________________________|
        |       orB     |   10011.jjj   |  b OR operand ->b     | [w0] ++ [t1 t2 t3] -- [h1 h2] ++ [i xi]       |
        |_______________|_______________|_______________________|_______________________________________________|
        |       and     |   10100.jjj   |  a AND operand ->a	| [w0] ++ [t1 t2 t3] -- [h1 h2] ++ [i xi]       |
        |_______________|_______________|_______________________|_______________________________________________|
        |       andB    |   10101.jjj   |  a AND operand ->b	| [w0] ++ [t1 t2 t3] -- [h1 h2] ++ [i xi]       |
        |_______________|_______________|_______________________|_______________________________________________|
        |       xor     |   10110.jjj   |  a XOR operand ->a	| [w0] ++ [t1 t2 t3] -- [h1 h2] ++ [i xi]       |
        |_______________|_______________|_______________________|_______________________________________________|
        |       xorB    |   10111.jjj   |  b XOR operand ->b	| [w0] ++ [t1 t2 t3] -- [h1 h2] ++ [i xi]       |
        |_______________|_______________|_______________________|_______________________________________________|


	Assembly Language Examples
	__________________________


</pre>

<h3>Single Integer Add Instructions</h3>

<p>
The single integer add instructions add the operand or its 2s complement
to arithmetic register a or b

<p>
carry from bit 23 of the addition is stored in <b>carry$</b>.
Carry is not inverted after negative adds. They write carry as the positive add
of the 2s complement would write carry

<pre>

        _________________________________________________________________________________________________________________
        |       mnemonic|   fffff.jjj   |				|               jjj                             |
        |_______________|_______________|_______________________________|_______________________________________________|
        |       aa      |   11000.jjj   |  a += operand			| [w0] ++ [t1 t2 t3] -- [h1 h2] ++ [i xi]       |
        |_______________|_______________|_______________________________|_______________________________________________|
        |       ab      |   11001.jjj   |  b += operand			| [w0] ++ [t1 t2 t3] -- [h1 h2] ++ [i xi]       |
        |_______________|_______________|_______________________________|_______________________________________________|
        |       ana     |   11010.jjj   |  a += 2s complement of operand| [w0] ++ [t1 t2 t3] -- [h1 h2] ++ [i xi]       |
        |_______________|_______________|_______________________________|_______________________________________________|
        |       anb     |   11011.jjj   |  b += 2s complement of operand| [w0] ++ [t1 t2 t3] -- [h1 h2] ++ [i xi]       |
        |_______________|_______________|_______________________________|_______________________________________________|



	Assembly Language Examples
	__________________________


</pre>

<h3>Multiply</h3>

The integer multiply instruction multiplies arithmetic register b algebraically 
by the operand and stores the 48-bit product in arithmetic registers a:b
<p>

<b>carry$</b> is not updated

<pre>


        _________________________________________________________________________________________________________
        |       mnemonic|   fffff.jjj   |                       |               jjj                             |
        |_______________|_______________|_______________________|_______________________________________________|
        |       m	|   11100.jjj   |  a:b = b * operand	| [w0] ++ [t1 t2 t3] -- [h1 h2] ++ [i xi]       |
        |_______________|_______________|_______________________|_______________________________________________|


	Assembly Language Examples
	__________________________


</pre>

<h3>Multiply Fractional</h3>

Multiply Fractional instruction multiplies arithmetic register b by the
operand and stores the 48-bit product in arithmetic registers a:b

<p>
The multiplier is treated as signed and the multiplicand is treated
as unsigned

<p>
Multiply Fractional is used to render binary fractions integrally
for editing and conversion, and may also be used serially to multiply
integer multiplicands more than one word in length

<p>
<b>carry$</b> is not updated

<pre>


        _________________________________________________________________________________________________________
        |       mnemonic|   fffff.jjj   |                       |               jjj                             |
        |_______________|_______________|_______________________|_______________________________________________|
        |       mf	|   11101.jjj   |  a:b = b * operand	| [w0] ++ [t1 t2 t3] -- [h1 h2] ++ [i xi]       |
        |_______________|_______________|_______________________|_______________________________________________|



	Assembly Language Examples
	__________________________



</pre>

<h3>Divide</h3>

The integer divide instruction algebraically divides the 48-bit
dividend in arithmetic registers a:b by the 24-bit divisor. The
remainder is stored in b. The low order 24 bits of the quotient
are stored in a. The high-order 24 bits of the quotient are
stored in register 6 mantissa2

<p>
<b>carry$</b> is not updated

<pre>


        _________________________________________________________________________________________________________________
        |       mnemonic|   fffff.jjj   |				|               jjj                             |
        |_______________|_______________|_______________________________|_______________________________________________|
        |       d	|   11110.jjj   |	a:b /= operand		| [w0] ++ [t1 t2 t3] -- [h1 h2] ++ [i xi]       |
        |_______________|_______________|_______________________________|_______________________________________________|
					|   a = qotient 23:0		|
					|_______________________________|
					|   b = remainder		|
					|_______________________________|
					|   mantissa2 = quotient 47:24	|
					|_______________________________|



		 47                                      23                                    0
		_________________________________________________________________________________
		|arithmetic register a = dividend 47..24|arithmetic register b = dividend 23..0	|
	before	|_______________________________________|_______________________________________|
	______



		 23                                    0 23                                    0 47                                   24
		_________________________________________________________________________________________________________________________
		| arithmetic register a = quotient 23..0|arithmetic register b = remainder 23..0|arithmetic register 6 = quotient 47..24|
	after	|_______________________________________|_______________________________________|_______________________________________|
	____




	Assembly Language Examples
	__________________________


</pre>



<h3>Large Load and Store Instructions</h3>
<pre>

        _________________________________________________________________________________________________________
        |       mnemonic|   fffff.jjj   |                       |               action                          |
        |_______________|_______________|_______________________|_______________________________________________|
        |       ds      |   11000.111   |  double store		| a:b -> 2 words @ ea				|
        |_______________|_______________|_______________________|_______________________________________________|
        |       dl      |   11001.111   |  double load		| 2 words @ ea -> a:b				|
        |_______________|_______________|_______________________|_______________________________________________|
        |       dpush   |   01011.111   |  double push		| sp -= 2, 2 words @ ea added to internal stack	|
        |_______________|_______________|_______________________|_______________________________________________|
        |       qs      |   01000.111   |  quadruple store      | a:b:mantissa2:mantissa3 -> 4 words @ ea	|
        |_______________|_______________|_______________________|_______________________________________________|
        |       ql      |   01001.111   |  quadruple load	| 4 words @ ea -> a:b:mantissa2:mantissa3       |
        |_______________|_______________|_______________________|_______________________________________________|
        |       qpop	|   10000.111   |  quadruple pop	| 4 words @ internal stack top -> 4 words @ ea  |
        |_______________|_______________|_______________________|_______________________________________sp_+=_4_|
        |       qpush   |   10001.111   |  quadruple push	| sp -= 4, 4 words @ ea added to internal stack |
        |_______________|_______________|_______________________|_______________________________________________|


	Assembly Language Examples
	__________________________

</pre>

<h3>Large Integer Arithmetic Instructions</h3>

<pre>

        _________________________________________________________________________________________________________
        |       mnemonic|   fffff.jjj   |                       |               action                          |
        |_______________|_______________|_______________________|_______________________________________________|
        |       da      |   11010.111   |  double add		| a:b += 2 words @ ea, carry from MS bit of add	|       
        |_______________|_______________|_______________________|_______________________________________________|
        |       dan	|   11011.111   |  double add negative	| a:b += 2s complement of 2 words @ ea, 	|
        |_______________|_______________|_______________________|______________________carry_from_MS_bit_of_add_|
        |       sc      |   10110.111   |  store carry          | PSR AND 1 -> word @ ea			|
        |_______________|_______________|_______________________|_______________________________________________|
        |       mlb	|   10111.111   |  masked load b	| b AND NOT k OR word @ ea AND k -> b		|
        |_______________|_______________|_______________________|_______________________________________________|
        |       mta     |   10101.111   |  masked test equal	| skip if a AND k = word @ ea AND k		|
        |_______________|_______________|_______________________|_______________________________________________|
        |       lsc     |   10100.111   |  load shift & count	| 1 word @ ea -> a, rotate left [sign bits]	|
        |_______________|_______________|_______________________|_______________________________count in b______|
        |       dlsc    |   11100.111   |double load shift&count| 2 words @ ea -> a:b, rotate left [sign bits]	|
        |_______________|_______________|_______________________|__________________________count_in_mantissa2___|
        |       ex	|   10010.111   |  execute		| execute the instruction @ ea			|
        |_______________|_______________|_______________________|_______________________________________________|


	Assembly Language Examples
	__________________________


</pre>


<h3>Floating Arithmetic Instructions</h3>

<p>
Floating numbers used in the four arithmetic function instructions have the 96-bit format
<pre>



	|sign
	| |mid-pointed exponent       
        |s|m|			      fractional mantissa
        __________________________________________________________________________________________________________________
        |s|xxxxx xxxxxx xxxxxx xxxxxx|mmmmmm mmmmmm mmmmmm mmmmmm mmmmmm mmmmmm mmmmmm mmmmmm mmmmmm mmmmmm mmmmmm mmmmmm|
        |_|__________________________|___________________________________________________________________________________|
        95 94                      72 71                                                                                0


</pre>
Sign = 1 indicates that all 96 bits of the number are  inverted in 1s complement. It is not an indication of negative polarity
zoned on a positively expressed magnitude 

<p>
Floating Add Negative instruction <b>fan</b> is the addition of the 1s complement

<p>
The mantissa is a simple fraction without any integral field either represented or unrepresented. The integral value
is derived by hauling the mantissa leftward through the binary point the number of positions by which the exponent
exceeds its midpoint value of <b>0400000</b>

<p>
Exponent <b>0400000</b> indicates that the normalised magnitude is &ge;0.5 and &lt;1.0

<p>
The lowest or most microscopic exponent is <b>000000</b> The highest or most astronomic exponent is <b>07FFFFF</b>

<p>
Exponentiation range is the equivalent of around &plusmn;1262611 decimal places

<p>
A number is normalised if the normalising bit in position 71 is of opposite polarity to the sign

<p>
Positive and negative zero are the two numbers with normalising bit the same value as the sign.
All unnormalised numbers are computed as zero

<p>
Floating arithmetic instructions do not update <b>carry$</b>
<pre>

        _________________________________________________________________________________________________________
        |       mnemonic|   fffff.jjj   |                       |               action                          |
        |_______________|_______________|_______________________|_______________________________________________|
        |       fpp     |   01010.111   |  floating pop & pack	| 4 word fp number @ sp -> 2 word fp number @ ea|       
        |_______________|_______________|_______________________|_______________________________internal_sp_+= 4|
        |       fpx     |   01011.111   | floating push & expand| internal sp -= 4, 2 words @ ea -> 4 words @ sp|
        |_______________|_______________|_______________________|_______________________________________________|
        |       fa      |   01100.111   |  floating add		| a:b:mantissa2:mantissa3 += 4 words @ ea	|
        |_______________|_______________|_______________________|_______________________________________________|
        |       fan     |   01101.111   |  floating add negative| a:b:mantissa2:mantissa3 += 4 words @ ea XOR 1s|
        |_______________|_______________|_______________________|_______________________________________________|
        |       fm	|   01110.111   |  floating multiply	| a:b:mantissa2:mantissa3 *= 4 words @ ea	|
        |_______________|_______________|_______________________|_______________________________________________|
        |       fd	|   01111.111   |  floating divide	| a:b:mantissa2:mantissa3 /= 4 words @ ea	|
        |_______________|_______________|_______________________|_______________________________________________|


	Assembly Language Examples
	__________________________


</pre>

<p>
Floating Pop and Pack instruction <b>fpp</b> can compress numbers not requiring
mantissa precision larger than 36 bits or exponentiation outside the equivalent
of around &plusmn;305 decimal places from 96 bits at the internal stack top to
this 48-bit stored format

<pre>

        47 46        36 35                                      0
        __________________________________________________________
        |s|xxxxx xxxxxx|mmmmmm mmmmmm mmmmmm mmmmmm mmmmmm mmmmmm|
        |_|____________|_________________________________________|

</pre>
Floating Push and Expand instruction <b>fpx</b> loads and expands compressed floating numbers to 96-bit compute format
at the internal stack top


<h3>Storage Modify Instructions</h3>

Test and Set is only executed with any purpose on a storage location for inter-processor arbitration

<p>
The other seven modify instructions can be executed on a register or on storage. Execution on storage
causes a memory read followed by memory write. Execution on a register is at register-access speed
 
<pre>

        _________________________________________________________________________________________________________
        |       mnemonic|   fffff.jjj   |                       |               action                          |
        |_______________|_______________|_______________________|_______________________________________________|
        |       ts      |   00000.111   |  test and set		| set bit 23 of word @ ea, skip if b23 was zero	|
        |_______________|_______________|_______________________|_______________________________________________|
        |       n	|   00001.111   |  negate		| word @ ea XOR= all 1s				|
        |_______________|_______________|_______________________|_______________________________________________|
        |       inc	|   00010.111   |  increment		| word @ ea += 0000 0000 0000 0000 0000 0001	|
        |_______________|_______________|_______________________|______________________carry$_is_not_updated____|
        |       dec	|   00011.111   |  decrement		| word @ ea += 1111 1111 1111 1111 1111 1111	|
        |_______________|_______________|_______________________|______________________carry$_is_not_updated____|
        |       sim	|   00100.111   |  switch interrupt mask| switch interrupt mask with word @ea, b23:3 = 0|
        |_______________|_______________|_______________________|_______________________________________________|
        |       popA    |   00101.111   |  pop and add to store	| word @ ea += word at internal stack top, sp++	|
        |_______________|_______________|_______________________|_____________________________carry$_is_updated_|
        |       src	|   00110.111   |shift right thru carry	| R.rotate word @ ea in 25-bit ring with carry	|
        |_______________|_______________|_______________________|_______________________________________________|
        |       slc	|   00111.111	| shift left thru carry	| L.rotate word @ ea in 25-bit ring with carry	|
        |_______________|_______________|_______________________|_______________________________________________|


	Assembly Language Examples
	__________________________


		push, xi	MAXIMUM_INTERRUPT_MASK	. internal stack = register location<div style="color:FF0000">
		sim		0, sp
		ts		lock_word		. this has to be in memory</div>
		j		$-1			. try again

		.
		.

		z		lock_word		. free the resource<div style="color:FF0000">
		sim		0, sp			. restore the interrupt mask
		inc		sp			. restore the internal stack</div>

</pre>


<h3>Shift Instructions</h3>

Shift instructions use the effective address as the shift count.
An effective address may be indexed or indirect

<p>
Double shifts shift the value in arithmetic registers a and b as
a single 48-bit register

<p>
Shift instructions do not update <bcarry$</b>
<pre>

        _________________________________________________________________________________________________________________
        |       mnemonic|   fffff.jjj   |                       |               action                          	|
        |_______________|_______________|_______________________|_______________________________________________________|
        |       sar	|   00000.110   |  shift a right	|  shift a [ea] bits right, zero fill vacated positions	|
        |_______________|_______________|_______________________|_______________________________________________________|
        |       sbr	|   00001.110   |  shift b right	|  shift b [ea] bits right, zero fill vacated positions	|
        |_______________|_______________|_______________________|_______________________________________________________|
        |       dsr	|   00010.110   |  double shift right	|shift a:b [ea] bits right, zero fill vacated positions	|
        |_______________|_______________|_______________________|_______________________________________________________|
        |       sal	|   00100.110   |  shift a left		|  shift a [ea] bits left, zero fill vacated positions	|
        |_______________|_______________|_______________________|_______________________________________________________|
        |       sbl	|   00101.110   |  shift b left		|  shift b [ea] bits left, zero fill vacated positions	|
        |_______________|_______________|_______________________|_______________________________________________________|
        |       dsl	|   00110.110   |  double shift left	|shift a:b [ea] bits left, zero fill vacated positions	|
        |_______________|_______________|_______________________|_______________________________________________________|
        |       rar	|   01000.110   |  rotate a right	|rotate a [ea] bits right, LS bit values to MS positions|
        |_______________|_______________|_______________________|_______________________________________________________|
        |       rbr	|   01001.110   |  rotate b right	|rotate b [ea] bits right, LS bit values to MS positions|
        |_______________|_______________|_______________________|_______________________________________________________|
        |       drr	|   01010.110   |  double rotate right	|rotate a:b [ea] bits right,LS bitvalues to MS positions|
        |_______________|_______________|_______________________|_______________________________________________________|
        |       ral	|   01100.110   |  rotate a left	| rotate a [ea] bits left, MS bit values to LS positions|
        |_______________|_______________|_______________________|_______________________________________________________|
        |       rbl	|   01101.110   |  rotate b left	| rotate b [ea] bits left, MS bit values to LS positions|
        |_______________|_______________|_______________________|_______________________________________________________|
        |       drl	|   01110.110   |  double rotate left	|rotate a:b [ea] bits left, MS bitvalues to LS positions|
        |_______________|_______________|_______________________|_______________________________________________________|
        |       saa	|   10000.110   |  shift a algebraic	|  shift a [ea] bits right, sign fill vacated positions	|
        |_______________|_______________|_______________________|_______________________________________________________|
        |       sba	|   10001.110   |  shift b algebraic	|  shift b [ea] bits right, sign fill vacated positions	|
        |_______________|_______________|_______________________|_______________________________________________________|
        |       dsa	|   10010.110   | double shift algebraic|shift a:b [ea] bits right, sign fill vacated positions |
        |_______________|_______________|_______________________|_______________________________________________________|


	Assembly Language Examples
	__________________________


</pre>

<h3>Bit Stream Instructions</h3>

Read Staging Register instruction <b>rsr</b> shifts immediate bit count <b>xi</b> bits left from staging register RDATA
to arithmetic register a. Register RDATAC is decremented by shift count <b>xi</b>. If RDATAC reaches zero during the
transfer RDATA is reloaded from memory pointed by register *q++ and RDATAC is restarted at 24 bits. If PSR flag
<b>b$stream16r</b> = 1 the restart count in RDATAC is 16 and RDATA is shifted left 8 bit positions on reload. If PSR
flag <b>b$streamZR</b> = 1 arithmetic register a is cleared before the transfer

<p>

Write Staging Register instruction <b>wsr</b> shifts immediate bit count <b>xi</b> bits left from arithmetic register a
to staging register WDATA. Register WDATAC is incremented by shift count <b>xi</b>. If WDATAC reaches 24 during the
transfer WDATA is stored at memory pointed by register *p++ and WDATAC is restarted at zero. if PSR flag <b>b$stream16w</b>
= 1 data is stored and WDATAC restarted when WDATAC reaches 16

<pre>

        _________________________________________________________________________________________________________________
        |       mnemonic|   fffff.jjj   |                       |               action                                  |
        |_______________|_______________|_______________________|_______________________________________________________|
        |       rsr	|   10010.101   | read staging register	| shift [xi &le; 24] bits a<-RDATA [reload RDATA]		|
        |_______________|_______________|_______________________|_______________________________________________________|
        |       wsr	|   00011.101   |write staging register	| shift [xi &le; 24] bits WDATA<-a [store WDATA]		|
        |_______________|_______________|_______________________|_______________________________________________________|


	Assembly Language Examples
	__________________________


</pre>

<h3>Jump Instructions</h3>

Jump instructions transfer execution to the location designated by the effective address in current address window B0

<p>
The effective address may be indexed or indirect

<p>
Absolute program counter is updated with B0 + effective address

<pre>

        _________________________________________________________________________________________________________________
        |       mnemonic|   fffff.jjj   |                       |               action                                  |
        |_______________|_______________|_______________________|_______________________________________________________|
        |       j	|   10110.110   |  jump			|  continue execution @ ea in B0			|
        |_______________|_______________|_______________________|_______________________________________________________|
        |       jdr     |   00011.110   |  jump decrement r	|  add -1 to r, jump if r &ne; -1, carry is not updated	|
        |_______________|_______________|_______________________|_______________________________________________________|
        |       jnc	|   01011.110   |  jump no carry	|  jump if carry$ of PSR = zero				|
        |_______________|_______________|_______________________|_______________________________________________________|
        |       jc	|   01111.110   |  jump carry		|  jump if carry$ of PSR = one				|
        |_______________|_______________|_______________________|_______________________________________________________|
        |       jza	|   11000.110   |  jump zero a		|  jump if arithmetic register a = zero			|
        |_______________|_______________|_______________________|_______________________________________________________|
        |       jzb     |   11001.110   |  jump zero b		|  jump if arithmetic register b = zero			|
        |_______________|_______________|_______________________|_______________________________________________________|
        |       jnza	|   11010.110   |  jump nonzero a	|  jump if arithmetic register a = nonzero		|
        |_______________|_______________|_______________________|_______________________________________________________|
        |       jnzb	|   11011.110   |  jump nonzero b	|  jump if arithmetic register b = nonzero		|
        |_______________|_______________|_______________________|_______________________________________________________|
        |       jpa	|   10100.110   |  jump positive a	|  jump if arithmetic register a high-order bit = zero	|
        |_______________|_______________|_______________________|_______________________________________________________|
        |       jpb	|   10101.110   |  jump positive b	|  jump if arithmetic register b high-order bit = zero	|
        |_______________|_______________|_______________________|_______________________________________________________|
        |       jna	|   11100.110   |  jump negative a	|  jump if arithmetic register a high-order bit = one	|
        |_______________|_______________|_______________________|_______________________________________________________|
        |       jnb	|   11101.110   |  jump negative b	|  jump if arithmetic register b high-order bit = zero	|
        |_______________|_______________|_______________________|_______________________________________________________|
        |       jao	|   10011.110   |  jump a odd		|  jump if arithmetic register a low-order bit = one	|
        |_______________|_______________|_______________________|_______________________________________________________|
        |       jpo	|   10111.110   |  jump parity odd	|  jump if a AND mask register k has odd parity		|
        |_______________|_______________|_______________________|_______________________________________________________|
        |       jxge	|   11110.110   |jump x greater or equal|  jump if index register x &ge; repeat counter r		|
        |_______________|_______________|_______________________|_______________________________________________________|
        |       jyge	|   11111.110   |jump y greater or equal|  jump if index register y &ge; repeat counter r		|
        |_______________|_______________|_______________________|_______________________________________________________|
        |       jdz	|   01111.100   |  jump double zero	|  jump if 48-bit integer in registers a and b = zero	|
        |_______________|_______________|_______________________|_______________________________________________________|
        |       lcal    |   00111.110   |  local call           |  push absolute PC - B0 on internal stack, jump to ea  |
        |_______________|_______________|_______________________|_______________________________________________________|


	Assembly Language Examples
	__________________________


</pre>


<h3>Call Returns, Bank Jumps and Interrupts</h3>

<pre>

        _________________________________________________________________________________________________________________________
        |       mnemonic|   fffff.jjj   |                       |  action				symbol B0* = B0 * 4096	|
        |_______________|_______________|_______________________|_______________________________________________________________|
        |       lret	|   00110.101   |  local return		|  word @ internal stack top + xi + B0* -> PC, sp++		|
        |_______________|_______________|_______________________|_______________________________________________________________|
        |       go	|   11110.111   |  go to another bank	|  word @ ea bank pointer part->B0*->PC += vector part		|
        |_______________|_______________|_______________________|_______________________________________________________________|
        |       call	|   11111.111   |  call another bank	|  push PC-B0*, push B0, word @ ea bank part-> B0* -> PC+=vector|
        |_______________|_______________|_______________________|_______________________________________________________________|
        |       fret	|   00111.101   |  far bank return	|  pop B0* -> PC += pop offset from internal stack += xi	|
        |_______________|_______________|_______________________|_______________________________________________________________|

								________________________________________________________________
								| ii and ir operate the interrupt stack. sp_x = register 143	|
	________________________________________________________|_______________________________________________________________|
        |       ii	|   11110.101   |  internal interrupt	| push 0.PSR.B0.PC-B0*, xi 23:6 ->B0* -> PC += xi 5:0, PSR b23=1|
        |_______________|_______________|_______________________|_______________________________________________________________|
        |       ir	|   11111.101   |  interrupt return	| sp_x++, pop PSR.B0* -> PC += pop offset += xi			|
        |_______________|_______________|_______________________|_______________________________________________________________|


	Assembly Language Examples
	__________________________

  :                            430 $(3:03000)
  :                            431 left		$res	1
  :                            432 right	$res	1
  :                            433 
  :                            434 $(0:64)
  :                            435 examine<div	style="color:red">
00:000040 783000              +436 	tp	left 
00:000041 350000              +437 	lret	0
00:000042 703001              +438 	tz	right
00:000043 350000              +439 	lret	0
00:000044 350001              +440 	lret	1</div>



</pre>
<h3>Control and I/O Instructions</h3>


<pre>

        _________________________________________________________________________________________________________________
        |       mnemonic|   fffff.jjj   |                       |               action                                  |
        |_______________|_______________|_______________________|_______________________________________________________|
        |       on	|   00000.101   |   on PSR flags	|  PSR flags 15..0 OR= mask value xi			|
        |_______________|_______________|_______________________|_______________________________________________________|
        |       off	|   00001.101   |  off PSR flags	|  PSR flags 15..0 AND= NOT mask value xi		|
	|_______________|_______________|_______________________|_______________________________________________________|
	|       inA	|   00000.100   |  I/O port ea in to a 	|							|
        |_______________|_______________|_______________________|_______________________________________________________|
        |       inB	|   00001.100   |  I/O port ea in to b 	|  							|
        |_______________|_______________|_______________________|_______________________________________________________|
        |       outA	|   00010.100   |  out a to I/O port ea	|  							|
        |_______________|_______________|_______________________|_______________________________________________________|
	|	outB	|   00011.100	|  out a to I/O port ea |  							|
        |_______________|_______________|_______________________|_______________________________________________________|
        |       reload	|   00100.100   |  reload base registers|  2 * bank index @ *a *(a+1) -> io ports [ea, ea + 1]	|
        |_______________|_______________|_______________________|_______________________________________________________|
        | emulator_cool	|   00101.100   |			|  usleep the emulator thread ea microseconds		|
        |_______________|_______________|_______________________|_______________________________________________________|
        |	sabr	|   00110.100   |  store a base register|bank pointer[a]->io port[ea=2..63],index[a]->TCB+64+ea	|
        |_______________|_______________|_______________________|_______________________________________________________|


	Assembly Language Examples
	__________________________

</pre>

<h2>Application Memory, Location Counters and Dynamic Data Segment Load</h2>

<h3>Location Counters</h3>

Location counters correspond to program sections. masmx has 72 location counters.
Their RTA1 usage convention with smaragd7 kernel is
<pre>


	_________________________________________________________________________________________________________________
        |       location counter|       address window			|		purpose / address range		|
        |_______________________|_______________________________________|_______________________________________________|
        |       $(0)            |       instruction bank B0             |[ispace]000000..007FFF/[dspace]000100..000FFF	|
        |_______________________|_______________________________________|_______________________________________________|
        |       $(1:01000)	|       private stack bank B1		|	     data memory space 001000..001FFF	|
        |_______________________|_______________________________________|_______________________________________________|
        |       $(2)            |       vector bank B2			|	     data memory space 002000..002FFF	|	    
        |_______________________|_______________________________________|_______________________________________________|
        |       $(3:03000)	|       data windows  B3..B31		|	application data space 003000..01FFFF	|
        |_______________________|_______________________________________|___________________________or 0C0000..7FFFFF___|
        |			|       data windows B32..B47		|	application context kernel interface	|
        |_______________________|_______________________________________|_______________________________________________|
        |			|       data windows B48..B63           |		kernel				|
        |_______________________|_______________________________________|_______________________________________________|
        |       $(66::,x)	|       pointer in index register x	|
        |_______________________|_______________________________________|
        |       $(67::,y)	|       pointer in index register y	|
        |_______________________|_______________________________________|
        |       $(68::,a)	|       pointer in arithmetic register a|
        |_______________________|_______________________________________|
        |       $(69::,b)	|       pointer in arithmetic register b|
        |_______________________|_______________________________________|
        |       $(70::,fp)	|       frame at external stack pointer |
        |_______________________|_______________________________________|
        |       $(71::,sp)      |       frame at internal stack pointer |
        |_______________________|_______________________________________|


</pre>
$(0) contains instruction code in bank B0 and a few constants which are locally visible only


<h3>Loadable vs ROM Systems and Absolute Code vs Relocatable Code</h3>

<p>
Absolute code assembly is examined here. Relocatable code is described in
Appendix A: masmx Linking for RTA1

<p>
Absolute code has no oustanding linkage requests and above all has fixed
locations internally. Relocatable code is code awaiting resolution of
references and above all awaiting final location of program internal
sections. Linking is examined at Appendix A: masmx Linking for RTA1

<p>
Simplest absolute assemblies have a B0 bank starting at program-visible address zero
<pre>

$(0)
name1	$vector	entry1
name2	$vector entry2
	$do	8-$,	fret	0	. unused vectors

entry1
	.
	.

</pre>

<p>
This is simple in a system where applications are loaded dynamically. The
kernel assigns load space and determines hardware physical locations

<p>
Load address absolute zero is not available for applications in a ROM image.

To remain assembling absolutely, B0 load address can preassigned at image
construction with a breakpoint address in the location counter line

<p>
The program visible addresses still start at zero
<pre>

$(0::B0_LOAD_ADDRESS)


</pre>
<p>
If the application contains several instruction banks, $(0) declares all of them at
different load addresses. Their program-visible addresses are all based at address zero
<pre>


$(0::0)

$(0::16384)

$(0::24576)


</pre>
Each new load address makes a new B0.
Each new B0 has its own literal table. In a ROM application, the
breakpoint addresses are the absolute load addresses. In a loadable
application, the breakpoint addresses are relative to the RAM region
where the code is loaded

<p>
When multiple instruction banks are assembled together in this way,
they may be different source files with conceptually different
data sections.

<p>
A single instruction bank may be functionally
several programs. When one bank contains data or instructions
for a number of sources collected in one absolute assembly,
one file must be a wrapper for the others, because the program
sections which do not breakpoint are only started once
<pre>

$(3:03000)	. done once in the wrapper

$(3)		. at the start of program1 data

$(3)		. at the start of program2 data

</pre>


The principle extends to instruction banks containing multiple
programs
<pre>

$(0::WHEREVER_IT_LOADS)		. in wrapper.msm
entry1*	$vector	program1
entry2*	$vector	program2
	$do	8-$,	fret	0
$(3:03000)

	$include program1
<div	style="color:0000FF">
$(3)				. in program1.msm
data1		0.0
$(0)
program1
	fa	data1
	qs	data1
	fret	0
</div>

	$include program2
<div	style="color:0000FF">
$(3)				. in program2.msm
data2		5*-4040
$(0)
program2
	fm	data2
	qs	data2
	fret	0
</div>

$(0)				. in wrapper.msm
	$do	$<256,$(0:256)	. make sure the literal table is visible
	$do	$zenith>4095,	$flag	placement of B0 constants must be rearranged

</pre>


<h3>Data Sections $(1) and $(3)</h3>

<p>
$(1) contains private data in bank B1 starting at program-visible address 4096
<pre>

$(1:01000)

</pre>

smaragd7 kernel assigns at least one 4096-word B1 bank at thread start, but does not 
place any values in it. The application may assemble B1 at a read-only load-address
in the ROM system image, and copy the initial values on startup.

<p>
$(2) contains the vector bank. smaragd7 constructs the 4096-word vector-bank on
process launch at program-visible address 8192 = 02000 hex, based as bank B2

<p>
$(2) is declared by including vector.def. It is common to the whole process and
contains elements which are shared between all threads. These include all handle
descriptors and pointers to all initial banks and entry points of this process.

<p>
$(3) is assigned by the kernel to contain the program data in address windows
B3..B31

<p>
However at process start B3 is not based and the program's RAM initial data is not loaded

<p>
A typical ROM application memory configuration is
<pre>

	$include	def/rta.def
	$include	def/vector.def		. this defines the vector bank
						. in address window 02000

$(0::INSTRUCTIONS_LOAD_ADDRESS)
$(1:01000)					. private RAM
	+	variables
$(3:03000)					. application RAM
	+	data

$(0)
callname* $vector get_going
	$do	64-$,	fret	0

get_going
	$base_d	MY_APPLICATION_DATA_SIZE	. this macro reads VECTOR_D
						. from the vector bank,
						. bases enough windows to hold
						. the application data in B3..B31
						. points external stack pointer fp
						. to the high end of that

	c	(seg$load)	CORE_FS,,xi	;	. this call copies initialised
				(my_data_segments:d),,long  . variables to process RAM space

	.
	.

	fret	0



</pre>


<p>
Process RAM bank addresses are not known until the kernel stores their pointer
in the vector bank. Dynamically loaded programs also find their B0 physical
position[s] in the vector bank

<h3>seg$load Realtime RAM Initialisation</h3>
<p>
smaragd7 kernel can unpack program RAM initial values from
ROM-resident (or RAM-resident) file systems which are linked
into the application image or the total system image

<p>
A sequence of link operations and file system image operations
separate the program writeable parts into a dynamic load segment

<p>
Core file-system image construction exports a link label for each
dynamic load segment. An application instance references this
label to request initialization of its writeable data part
<pre>

	$base_d MY_APPLICATION_DATA_SIZE	. base the memory space

	c	(seg$load)	BANK_INDEX_OF_CORE_FS_START,,xi	;
				(my_ram_loadup_filename:d),,long	

</pre>
There is no directory search in the core file system. The link
label of the file has effectively completed a file open at
assembly time. <b>seg$load</b> starts unpacking load strings in
realtime. All the target windows must be based

<p>
The external label identifying the file is submitted as a 48-bit
value because it is a position in core file system possibly more
than 16 megawords from the file system start

<p>
There are core-resident file system images in case no filestore
peripherals are present

<p>
Simple applications may instead initialise a few scalars without
any organised segment load, or copy a block from ROM to RAM using
a breakpointed load address, for example
<pre>

B0_LOAD_ADDRESS $equ    30*4096

$(0::B0_LOAD_ADDRESS)

$(3:03000:B0_LOAD_ADDRESS+3072)
one     +       99
two     +       100
three   "abc"

.	the application initialises by copying initial data from 0C00 to 03000

</pre>



But in most cases the <b>seg$load</b> service has these distinct advantages

<blockquote>

	<b>seg$load</b> loads all the RAM sections of the application in one call<br><br>

	<b>seg$load</b> does not write locations which have don't-care values<br><br>

	RAM images in ROM / core file systems do not buffer don't-care values<br><br>

	<b>seg$load</b> is not limited in the size of RAM image it loads<br><br>

	Each core-resident file system may contain the the RAM images of many programs<br><br>

	There may be many core-resident file systems<br><br>

	It is simpler to call <b>seg$load</b> than to code an initialisation in every program<br><br>

	<b>seg$load</b> avoids appointing a copy-from ROM region in the space of each program

</blockquote>

The steps for placing RAM assembly-time variable values in ROM or core resident
file systems are described in the linking and utilities section of this manual. 


<h3>Base + Displacement Sections, Void Sections and Structure by Pointer</h3>

A section may have base + displacement addressing, and it may either a reference
where data cannot be generated or an actual data structure or list of structures

<p>
Base + displacement sections are widely used in conjunction with structured data

<h3>Void Sections and Structure by Pointer</h3>

A program section may have no initial addresses but instead a base register. They are
a template of the sort which is variously called a dsect and a pointer. The syntax is
for example
<pre>

$(66::,x)
label	$res	4
label2	structure

$(70::,fp)
descriptor acw

</pre>
Zero address followed by zero breakpoint allows the location counter number to be used
for many different void sections. Without the second colon you could only use counter 66 or
counter 70 once in an assembly. These locator/base register assignements are convention only
<pre>

$(66::,x)
$(67::,y)
$(68::,a)
$(69::,b)
$(70::,fp)
$(71::,sp)

</pre>

The indentifiers inside these sections are base + displacement tuples of the sort which
masmx calls $equf labels. In the example called descriptor
<pre>

	la	descriptor

</pre>
is the same as
<pre>

	la	descriptor, fp

</pre>
The base register assigned at the section head can be overriden on reference
<pre>

	la	descriptor, b

</pre>

Void sections are frequently used in conjuction with structured data
<pre>

$(70::,fp)
descriptor      acw

$(67::,y)
dgram           datagram

$(0)

        ly      descriptor:dgram
        dl      dgram:ipsource



	lx	descriptor:next
	lr	descriptor:bytes, x

</pre>


No data is generated inside void sections, even if data is declared. That allows
macros which otherwise generate data to be coded

<h3>Structured Data</h3>

Structured data combines <b>$tree</b> and <b>$root</b> directives with <b>$proc</b>
macros to construct hierarchical names for structured data, for example
<pre>

p       $proc
ber_template* $name
*       $tree
ojet    $res    1       . pointer to the managed object. or type tag
bytes   $res    1       . # bytes in the data edited for BER
data    $res    1       . 2-word integer or # words of string storage
                        . or byte offset in input buffer (30.encapsulation)
storage $res    1       . pointer to aligned storage scanned on string input
                        . or pointer to string in MIB object on string output
                        . or pointer to input buffer location (30.encapsulation)
oidl    $res    1       . oid bytes in storage
oid     $res    1       . external oid string in storage
        $root
        $end

$(3:03000)
fixed	ber_template

$(67::,y)
parameter ber_template

$(0)
	ql	fixed:ojet
	qs	parameter:ojet
	dl	fixed:iodl
	ds	parameter:oidl
	z	0, b

</pre>


Name structures may be nested to a depth eight levels
<pre>

$ freeware/masmx/masmx.7r3/masmx spiko -lnx
MASMX 7r3
3/spiko.msm
*EOF*
  :                            1 start*	$tree
  :                            2 onedown	$tree
  :                            3 twodown	$tree
  :                            4 spoon	$res	4
  :                            5 	$root
  :                            6 	$root
  :                            7 again	$tree
  :                            8 and_again $tree
  :                            9 fiddle	$res	4
  :                            10 	$root
  :                            11 	$root
  :                            12 	$root
  :                            13 
*EOF*
START+=$00:000000
START:ONEDOWN+=$00:000000
START:ONEDOWN:TWODOWN+=$00:000000
START:ONEDOWN:TWODOWN:SPOON+=$00:000000
START:AGAIN+=$00:000004
START:AGAIN:AND_AGAIN+=$00:000004
START:AGAIN:AND_AGAIN:FIDDLE+=$00:000004
spiko.msm=0<000003
:$(00):000000:000008 

</pre>

<b>$branch</b> directive is used in place of <b>$tree</b> to overlay
name structures at the same storage address

<pre>

$ masmx spiko -lnx
MASMX 7r3
3/spiko.msm
*EOF*
  :                            1 spiko*	$branch
00:000000 FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF9C
                              +2 hexaword -100:h
  :                            3 	$root
  :                            4 start*	$branch
  :                            5 onedown	$tree
  :                            6 twodown	$tree
  :                            7 spoon	$res	4
  :                            8 	$root
  :                            9 	$root
  :                            10 again	$tree
  :                            11 and_again $tree
  :                            12 fiddle	$res	4
  :                            13 	$root
  :                            14 	$root
  :                            15 	$root
  :                            16 
*EOF*
SPIKO+=$00:000000
SPIKO:HEXAWORD+=$00:000000
START+=$00:000000
START:ONEDOWN+=$00:000000
START:ONEDOWN:TWODOWN+=$00:000000
START:ONEDOWN:TWODOWN:SPOON+=$00:000000
START:AGAIN+=$00:000004
START:AGAIN:AND_AGAIN+=$00:000004
START:AGAIN:AND_AGAIN:FIDDLE+=$00:000004
spiko.msm=0<000003
:$(00):000000:000008 

</pre>

<h3>Data-generating Sections with Base_Displacement View</h3>

Data-generating sections may also be constructed for
base + displacement addressing if their location is
beyond the operand direct address range 32768 words and within
available ranges of the effective address space 16777216 words

<p>
To assemble structures 16 Megawords and beyond see the next section
<b>Assembling Structures Larger than the Address Space</b>

<pre>

$ masmx -kln oreilly oreilly
MASMX 7r3
3/oreilly.msm
*EOF*
  :                            1: 	$include	freeware/RTA1/rta/def/rta.def
  :                            2 
  :                            3 TABLE1	$equ	79*1024
  :                            4 
  :                            5 $(20:TABLE1,x)
14:000000 400001C00000000000000000
                              +6 one	+	1.5
14:000004 400001D00000000000000000
                              +7 two	+	1.625
14:000008 400001E00000000000000000
                              +8 three	+	1.75
14:00000C 400001F00000000000000000
                              +9 "O'Reilly" +	1.875
  :                            10 
  :                            11 $(0:64)
00:000040 500045              +12 	lx	(TABLE1)
00:000041 4FA000              +13 	ql	one
00:000042 67A004              +14 	fa	two
00:000043 6FA008              +15 	fan	three
00:000044 47A00C              +16 	qs	"O'Reilly"
  :                            17 
  :                            18 
*EOF*
00:000045+013C00
:$(00):000040:000046 :$(14):013C00:013C10 
oreilly.msm: object code 228 bytes: 0 errors: 0 undefined labels
$
$ cat oreilly.txo

$14:013C00
400001C00000000000000000 400001D00000000000000000
400001E00000000000000000 400001F00000000000000000
$00:000040
500045 4FA000 67A004 6FA008 47A00C
$00:000045
013C00

:$00*000000:000040:000046
:$14*000000:013C00:013C10


</pre>



<h3>Assembling Structures Larger than the Address Space</h3>
<p>

Arrays too large for the static data space and  many times larger than the 16-Megaword
address space may be assembled, up the the limit of available memory

<p>
Any array may be assembled instead of constructed at run time. There are cases where
this is desirable and where it is preferred that the application need not understand
the shaping of data, but rather that the data drive the behaviour of the application

<p>
An array which extends beyond the address space into a larger executable space is called
in masmx terms giant addressing

<p>
Giant address space has a width greater than effective address space, notionally
256 terawords expressed in 48 bits, but physically constrained to the executable
space of RTA1 architecture, 16 gigawords expressed in 34 bits.

<p>
A giant address offset is introduced to the location counter as a breakpoint address
with leading *asterisk

<pre>

$(54::*00000A000000)

</pre>

The address breakpoint is incremented as repeat structures assemble. In the
example case following, the array root location of zero does not look giant
by most standards. The application will obtain storage from the kernel and
pass the load address to the segment load routine <b>array$seg$load</b>. See
Appendix A: masmx Linking for RTA1 

<p>
The structure may be assembled with the application or independently. In any
case it uses separate location counters from the rest of the assembly, for
separate load-formatting. This follows the need of ROM based systems to
submit data segments to a run-time segment loader

<pre>

$ masmx array2 -ln
MASMX 7r3
3/array2.msm
*EOF*
  :                            1: 	$include	freeware/RTA1/rta/def/rta.def
  :                            2 
  :                            3 ARRAY_INDEX     $set    0
  :                            4 SIZE            $equ    6
  :                            5 BASE		$equ	48
  :                            6 
  :                            7 p               $proc
  :                            8 my_structure*   $name
  :                            9 *               $tree
  :                            10 next_pointer    +       p(1, 1):d
  :                            11                 $res    4
  :                            12                 $root
  :                            13                 $end
  :                            14 
  :                            15 f               $func
  :                            16 long_pointer*   $name
  :                            17                 $return 1*/46++f(1, 1)**-262144*/12++BASE*/18++f(1, 1)**262143
  :                            18                 $end
  :                            19 
  :                            20 p               $proc
  :                            21 array1_element* $name
  :                            22                 $do     repeat=4,       $list   0
  :                            23 $(54::*ARRAY_INDEX)
  :                            24 FORWARD         $set    ARRAY_INDEX+SIZE
  :                            25 tempsymbol	my_structure	long_pointer(FORWARD)
  :                            26 ARRAY_INDEX*    $set    $a
  :                            27                 $end
  :                            28 
  :                            29 array_part(1)
36:000000000000:400000C00006  +30 repeat          $do     6000000000,	array1_element
36:000000000006:400000C0000C  +30 
36:00000000000C:400000C00012  +30 
  :                            31                 $list
  :                            32 



</pre>

An array up to six or seven megawords may all be in the address space at once

<p>
Otherwise a pair of address windows provide a moving cursor in the array

<p>

Pointers in a structure of many large system memory banks take two words
and have a format
<pre>

	  46  bank identifier 30      24     18       word offset      0
	_________________________________________________________________
	|0 1|bbbb bbbb bbbb bbbb|000 000|window| www www www www www www|
	|___|___________________|_______|______|________________________|
	 47  45			 29	 23	 17

</pre>
Pointers like this may be assembled in the data structure as cross-reference
and chain links. The field <b>window</b> must agree with with the address
space window where sabr instruction will base the leading edge of the target
element. See function macro <b>long_pointer()</b> above

<p>
In the giant structure example above, this pointer is not quite complete
at assembly time, because the start location of the array is not known. So
the start bank identity is added to bits 45:30 of the pointer before the
containing bank is based
<pre>



  :                            33 $(68::,b)
  :                            34 structure       my_structure
  :                            35 
  :                            36 $(0)
00:000000 CFD000              +37                 dl              structure:next_pointer
[+0000]0f
00:000001 C00000              +38                 aa              array_start_bank_index
00:000002 340030              +39                 sabr            BASE
  :                            40 
00:000003 64C040              +41                 la, i           64, a           . base two adjacent banks
00:000004 340031              +42                 sabr            BASE+1          . if the structure is not power 2 size
  :                            43 
  :                            44 
*EOF*
:$(00):000000:000005 :$(36):000000:000006 :$(44):000000:000006 
 

</pre>
<p>
It is also possible to put labels on each element of an assembled array,
although this is not advised if there are millions of elements, because
software handling tables and arrays references very few labels
<pre>


?	$do	12000,float(?)	structure	float(?+1)	. next pointer, last instance = zero


</pre>

<h2>9: $do Iteration</h2>

<h2>10: $proc and $func Macros</h2>

<b>$proc</b> directive heads an inline macro. <b>$end</b> directives ends all macros
and also ends the assembly. End of input also ends the assembly

<p>
Macros reference actual parameters as a function of their <b>$proc</b>
or <b>$func</b> label

<p>
For this reason macros tend to cryptic titles with separate
call names assigned a latent value with <b>$name</b> directive

<p>
Macro labels  are only visible if they are promoted with asterisk* Names
which are not promoted are reusable in the calling assembly. Many macros
may have the same <b>$proc</b> label, making paraform language easy to write
<pre>

$ masmx -ln
MASMX 7r3
0/-INPUT>>
p	$proc
dem1*	$name	33
dem2*	$name	99

	+	p(0, 0), p(1, 1), p(1, 3), p(2, 1:1)*p(2, 1:2):d
	$end

	dem1	0aaa,,-12 25:4
	dem2	0bbb,,12        3:3
	$end
  :                            1 p $proc
  :                            2 dem1* $name 33
  :                            3 dem2* $name 99
  :                            4 
  :                            5  + p(0, 0), p(1, 1), p(1, 3), p(2, 1:1)*p(2, 1:2):d
  :                            6  $end
  :                            7 
00:000000 021AAAFF4064        +8  dem1	0aaa,,-12	25:4
00:000002 063BBB00C009        +9  dem2	0bbb,,12	3:3
  :                            10  $end
:$(00):000000:000004 

</pre>

It is visible that <b>$proc</b> macros interpret actual parameters as <b>field,subfield:substring field...</b>

<p>
The call name is p(0, 0) and has a latent value

<p>
Forward references are possible in two-pass <b>$proc</b> macros, flagged with *
<pre>

maybe*	$proc	*
	tp	estimation
	j	maybe_not
?	$do	maybe(),	lcal	maybe(?, 1)
maybe_not
	$end

</pre>

<i>proc_name</i>() is the count of actual argument fields after the callname

<p>
<i>proc_name</i>(&mu;) is the count of subfields in field &mu;

<p>
<i>proc_name</i>(&mu;,&nu;:) is the count of substrings in subfield &mu;,&nu;

<p>
However if <i>proc_name</i>() is an argument calling another macro,
all the actual parameters are passed

<p>
If <i>proc_name</i>(&mu;) is an argument calling another macro, all the subfields of field &mu;
are passed

<pre>

$ masmx sort_out -ln
MASMX 7r3
3/sort_out.msm
*EOF*
  :                            1 
  :                            2 p	$proc
  :                            3 sort_out* $name
  :                            4 index	$equ	p()+1
  :                            5 ?	$do	p(),	+	p(1, 2), p(index-?, 1)
  :                            6 	$end
  :                            7 
  :                            8 p	$proc
  :                            9 backslang* $name
  :                            10 ?	$do	p(),	+	p(?, 1), p(?, 3), p(?, 2)
  :                            11 	$end
  :                            12 
  :                            13 p       $proc
  :                            14 yaname* $name		101
  :                            15         sort_out        p()
  :                            16         backslang       p(3) p(2) p(1)
  :                            17 	$end
  :                            18 
00:000000 028007              +19 	yaname,40	1, 2, 3	   4, 5, 6     7, 8, 9
00:000001 028004              +19 
00:000002 028001              +19 
00:000003 028065              +19 
00:000004 070908              +19 
00:000005 040605              +19 
00:000006 010302              +19 
  :                            20 
*EOF*
:$(00):000000:000007 

</pre>

When all the parameters are passed to a new macro with argument <i>proc_name</i>(),
field zero (the call name) is the new field one. The number of fields is one greater

<p>
<i>proc_name</i>(&mu;,*&nu;) is a unary asterisk on subfield &mu;,&nu;

<p>
<i>proc_name</i>(&mu;,&nu;:*&sigma;) is a unary asterisk on subfield &mu;,&nu;:&sigma;

<p>
Five more features of macro processing are shown here

<p>
Macros may contain macros, so only the outer macro can call the inner macro

<p>
<b>$proc</b> macros may be flagged with a location counter to assemble in a target
program section. Any 2-pass asterisk comes before the section flag and separate, as
<pre>

macro_name	$proc	*	$(TARGET_LOCATOR)

</pre>
Macros can construct a label combining a parameter with other symbols. The parameter
part of the label in in quotes

<p>
Macros can assign a new value to the label on the call line. It is referenced
with an asterisk in column 1

<p>
Macros generate and use labels which are discarded at the end of the macro expansion.
Labels only remain for the calling level of assembly if they are promoted with trailing
asterisk

<p>
One asterisk is added to promote a label one  macro level. An asterisk at the main
assembly level externalises the label


<pre>
	
$ masmx indicate indicate -ln
MASMX 7r3
3/indicate.msm
*EOF*
  :                            1: 	$include	freeware/RTA1/rta/def/rta.def
  :                            2 
  :                            3 react*  $proc
  :                            4 indicate* $proc	$(1)
  :                            5 *	+	0
  :                            6 	$end
  :                            7 "react(1, 1)" indicate
  :                            8 	tz 	*react(1, 1)
  :                            9 	lcal	*react(1, 1)
  :                            10 	$end
  :                            11 
  :                            12 $(1:01000)
  :                            13 $(0:64)
  :                            14 
01:001000 000000              +15 	react	quick
00:000040 709000              +15 
00:000041 3E9000              +15 
01:001001 000000              +16 	react	right
00:000042 709001              +16 
00:000043 3E9001              +16 
  :                            17 
*EOF*
:$(00):000040:000044 :$(01):001000:001002 
indicate.msm: object code 138 bytes: 0 errors: 0 undefined labels
$ cat indicate.txo

$01:001000
000000
$00:000040
709000 3E9000
$01:001001
000000
$00:000042
709001 3E9001
:$00*000000:000040:000044
:$01*000000:001000:001002


</pre>
Function macros are not inline commands. They appear in expressions and generate a value.

<p>
<b>$func</b> directive heads a function macro and  <b>$end></b>end it. Function macros have
a <b>$return</b> directive which returns a 192-bit value



<h2>Appendix A: masmx Linking for RTA1</h2>

<h3>A.1 masmx Output File Formats</h3>

masmx outputs text encoded binary files. They have the default suffix
<b>.txo</b> and they can be viewed in a text editor or a shell

<pre>

$ masmx absolute absolute -lnk
MASMX 7r3
3/absolute.msm
*EOF*
  :                            1: 	$include	freeware/RTA1/rta/def/rta.def
  :                            2: 	$include	freeware/RTA1/rta/language/stack.def
  :                            3 
  :                            4 TARGET_ADDRESS* $equ	16384
  :                            5 
  :                            6 $(3:03000)
03:003000 00000A              +7 tally	10
  :                            8 $(0)
00:000000 B60040              +9 tally_up* x$vector tallyu  TARGET_ADDRESS
  :                            10 $(0:64)
00:000040 C03000              +11 tallyu	aa	tally
[+0000]0f
00:000041 C00000              +12 	aa	extra
00:000042 203000              +13 	sa	tally
[+0001]0f
00:000043 3E0000              +14 	lcal	extract
00:000044 3D0000              +15 	fret	0
*EOF*
:$(00):000000:000045 :$(03):003000:003001 
absolute.msm: object code 230 bytes: 0 errors: 2 undefined labels
$
$ cat absolute.txo

$03:003000
00000A
$00:000000
B60040
$00:000040
C03000 [0000]0F:C00000 203000 [0001]0F:3E0000 3D0000
+tally_up:$00:000100
-extra:[0000]
-extract:[0001]
:$00*000000:000000:000045
:$03*000000:003000:003001

</pre>

absolute.msm has an integer 10 at address 003000 in data, and an
instruction bank at absolute 16384 with a jump to its location 64.
At locations 64 are two add instructions, a store instruction, a
local call, and a far return instruction

<p>
The load addresses of the code are not the program-visible addresses
of the code. There is a breakpointed load address TARGET_ADDRESS,
which indicates part of a ROM system image. A dynamically loaded
instruction section would get a load address from the kernel

<p>
A vector label <b>tally_up</b> with the value 16384/4096*64++0 is exported

<p>
But the code can't find two things called <b>extra</b> and <b>extract</b>.
absolute.txo contains linker requests

<p>
If you want to combine multiple sources in the same program sections,
this is simpler to do by assembling the sources together as absolute code
than by linking in RTA1. Linking relocatables to make one instruction
section is intricate

<pre>

$ masmx absolute absolute -lnk
MASMX 7r3
3/absolute.msm
*EOF*
  :                            1: 	$include	freeware/RTA1/rta/def/rta.def
  :                            2: 	$include	freeware/RTA1/rta/language/stack.def
  :                            3 
  :                            4 TARGET_ADDRESS	$equ	16384
  :                            5 
  :                            6 $(3:03000)
03:003000 00000A              +7 tally	10
  :                            8 $(0)
00:000000 B60040              +9 tally_up* x$vector tallyu  TARGET_ADDRESS
  :                            10 $(0:64)
00:000040 C03000              +11 tallyu	aa	tally
00:000041 C03001              +12 	aa	extra
00:000042 203000              +13 	sa	tally
00:000043 3E0045              +14 	lcal	extract
00:000044 3D0000              +15 	fret	0
  :                            16 
  :                            17 	$list	2
  :                            18: 	$include	absolu2
  :                            1 $(3)
03:003001 FFFFF6              +2 extra	-10
  :                            3 $(0)
  :                            4 extract
00:000045 460001              +5 	rar	1
00:000046 B00100              +6 	xor	(0a5a5a5:s)
00:000047 203001              +7 	sa	extra
00:000048 350000              +8 	lret	0
  :                            9 
  :                            19 $(0)
  :                            20 	$do	$<256,$(0:256)
  :                            21 	$do	$zenith>4095,	$flag	B0 constant space must be reassigned
  :                            22 
*EOF*
00:000100+A5A5A5
:$(00):000000:000101 :$(03):003000:003002 
absolute.msm: object code 269 bytes: 0 errors: 0 undefined labels
$
$ cat absolute.txo

$03:003000
00000A
$00:000000
B60040
$00:000040
C03000 C03001 203000 3E0045 3D0000
$03:003001
FFFFF6
$00:000045
460001 B00100 203001 350000
$00:000100
A5A5A5

+tally_up:$00:000100
:$00*000000:000000:000101
:$03*000000:003000:003002


</pre>

Multiple instruction banks can also be assembled at once,
if they share each data section as a linear space. They
can be one file or a number of files

<pre>

$(3:03000)
$(1:01000)

	$include	application_part1
<div	style="color:0000FF">
$(1)
	private	data
$(3)
	program data
$(0::08000)
part1_routine1* $vector	p1r1
part1_routine2* $vector p1r2
	$do	64-$,	fret	0
p1r1	
	fret	0
p1r2
	fret	0
	$do	$<256,$(0:256)
</div>

        $include        application_part2
<div    style="color:0000FF">
$(1)
        private data
$(3)
        program data
$(0::09000)
part2_routine1* $vector p2r1
part2_routine2* $vector p2r2
        $do     64-$,   fret    0
p2r1    
        fret    0
p2r2
        fret    0
        $do     $<256,$(0:256)
</div>

        $include        application_part3
<div    style="color:0000FF">
$(1)
        private data
$(3)
        program data
$(0::0A000)
part3_routine1* $vector p3r1
part3_routine2* $vector p3r2
        $do     64-$,   fret    0
p3r1    
        fret    0
p3r2
        fret    0
        $do     $<256,$(0:256)
</div>

</pre>

These source files can alternatively be assembled singly and linked.
If they are not intended to share either private data frame $(1) or
application data space $(3) then separate assembly and linking is
necessary

<h3>A.2 masmx Linking</h3>

masmx linking is an assembly which reads masmx output files in text
encoded binary format. It is necessary to have a target-specific
procedure macro <b>$map</b> in the assembly to manipulate the input
binary code

<p>
Here the foregoing large assembly will be replaced with three assemblies
of single source files followed by an assembly which links the parts

<p>
Each part has a separate $(1) private data section but program data section
$(3) has been combined in the link after being assembled as relocatable

<p>
$(3:*1) marks data section $(3) as relocatable. *1 is a relocation alignment
factor of 1 word

<p>
Information is forwarded to the link in the text encoded binaries

	<blockquote>
	the third line in application_part1.txo encodes the relocation alignment
	factor = 1. The information is also in the last summary line at the end<br><br>

	A relocation clause requests the link-updated relocation base of the
	data segment $(3) to be added to the 15-bit address field of the 2nd-last
	instruction. The relocation request is also visible above line 18 of
	the assembly listing. Assembly option -n lists relocation requests
	</blockquote>

<p>
Option -b in a linking assembly collates the program sections. The sections
otherwise need to be manipulated by filtering the file includes

<pre>

$ masmx -lnkZ application_part1 application_part1
MASMX 7r3
3/application_part1.msm
*EOF*
  :                            1 	$path		freeware/RTA1/rta
  :                            2: 	$include	def/rta.def
  :                            3: 	$include	language/stack.def
  :                            4 	$path
  :                            5 
  :                            6 $(1:01000)
01:001000 4000049B3333333333333334
                              +7 ratio1	9.7
  :                            8 $(3:*1)
03:000000 000000              +9 buffer1	$res	4
03:000001 000000              +9 
03:000002 000000              +9 
03:000003 000000              +9 
  :                            10 $(0::08000)
00:000000 B60040              +11 part1_routine1* $vector	p1r1
00:000001 B60042              +12 part1_routine2* $vector p1r2
  :                            15 	$list
00:000040 771000              +16 p1r1	fm	ratio1
00:000041 3D0000              +17 	fret	0
(+03)0f
00:000042 470000              +18 p1r2	qs	buffer1
00:000043 3D0000              +19 	fret	0
  :                            20 	$do	$<256,$(0:256)
  :                            21 
*EOF*
:$(00):000000:000100 :$(01):001000:001004 :$(03):000000:000004 
application_part1.msm: object code 713 bytes: 0 errors: 0 undefined labels
$
$ cat application_part1.txo

$01:001000
4000049B3333333333333334
$03:*000001
$03:000000
000000 000000 000000 000000
$00:008000
B60040 B60042 3D0000 3D0000 3D0000 3D0000 3D0000 3D0000
3D0000 3D0000 3D0000 3D0000 3D0000 3D0000 3D0000 3D0000
******
3D0000 3D0000 3D0000 3D0000 3D0000 3D0000 3D0000 3D0000
771000 3D0000 (03)0F:470000 3D0000
+part1_routine1:$00:000200
+part1_routine2:$00:000201
:$00*000000:000000:000100
:$01*000000:001000:001004
:$03*000001:000000:000004
$
$ masmx -wkZ application_part2 application_part2
$ masmx -wkZ application_part3 application_part3
$
$ masmx -lnkb
MASMX 7r3
0/-INPUT>>
	$list	0
		$include freeware/RTA1/rta/def/map1.def
	$list
$(3:03000)
        $include,$binary	application_part1
application_part1.txo:$(0) 256 words decimal from hexadecimal 000000 to 000100
application_part1.txo:$(1) 4 words decimal from hexadecimal 001000 to 001004
application_part1.txo:$(3) 4 words decimal from hexadecimal 003000 to 003004
        $include,$binary	application_part2
application_part2.txo:$(0) 256 words decimal from hexadecimal 000000 to 000100
application_part2.txo:$(1) 4 words decimal from hexadecimal 001000 to 001004
application_part2.txo:$(3) 4 words decimal from hexadecimal 003004 to 003008
        $include,$binary        application_part3       
application_part3.txo:$(0) 256 words decimal from hexadecimal 000000 to 000100
application_part3.txo:$(1) 4 words decimal from hexadecimal 001000 to 001004
application_part3.txo:$(3) 4 words decimal from hexadecimal 003008 to 00300C
	$store			total_application
	$end
  :                            97  $list
  :                            98 $(3:03000)
  :                            99:         $include,$binary application_part1
  :                            100:         $include,$binary application_part2
  :                            101:         $include,$binary application_part3
  :                            102  $store   total_application
  :                            103  $end
:$(00):000000:00A044 :$(01):001000:001004 :$(03):003000:00300C 
-INPUT>>: object code 1926 bytes: 0 errors: 0 undefined labels
Tim-Coxs-MacBook:~ timcox$ cat total_application.txo

$01:001000
4000049B3333333333333334
$03:003000
000000 000000 000000 000000
$00:008000
B60040 B60042 3D0000 3D0000 3D0000 3D0000 3D0000 3D0000
3D0000 3D0000 3D0000 3D0000 3D0000 3D0000 3D0000 3D0000
******
3D0000 3D0000 3D0000 3D0000 3D0000 3D0000 3D0000 3D0000
771000 3D0000 473000 3D0000
$01:001000
4000038CCCCCCCCCCCCCCCCD
$03:003004
000000 000000 000000 000000
$00:009000
B60040 B60042 3D0000 3D0000 3D0000 3D0000 3D0000 3D0000
3D0000 3D0000 3D0000 3D0000 3D0000 3D0000 3D0000 3D0000
******
3D0000 3D0000 3D0000 3D0000 3D0000 3D0000 3D0000 3D0000
7F1000 3D0000 473004 3D0000
$01:001000
400002ECCCCCCCCCCCCCCCCD
$03:003008
000000 000000 000000 000000
$00:00A000
B60040 B60042 3D0000 3D0000 3D0000 3D0000 3D0000 3D0000
3D0000 3D0000 3D0000 3D0000 3D0000 3D0000 3D0000 3D0000
******
3D0000 3D0000 3D0000 3D0000 3D0000 3D0000 3D0000 3D0000
771000 3D0000 473008 3D0000
+part1_routine1:$00:000200
+part1_routine2:$00:000201
+part2_routine1:$00:000240
+part2_routine2:$00:000241
+part3_routine1:$00:000280
+part3_routine2:$00:000281
:$00*000000:000000:00A044
:$01*000000:001000:001004
:$03*000000:003000:00300C


</pre>

The load addresses of the instruction sections are 008000 009000 and 00A000

<p>
The exported vector labels show entry points at the first two words of each bank.
The bank start addresses are at 4K-word boundaries and the bank identity is the
bank start address / 4096. The vector value is the bank identity * 64 plus offset
[0..63]
<pre>

	008000/*6++0	=	000200
	008000/*6++1	=	000201
	009000/*6++0	=	000240
	009000/*6++1	=	000241
	00A000/*6++0	=	000280
	00A000/*6++1	=	000281

</pre>
A ROM system cannot write data sections in ROM. They are separated with
another link for inclusion in a read-only file system in ROM. Segments in
this file system are unpacked to RAM at runtime

<p>
This is shown at its simplest with the earlier example of multiple source files
assembled as absolute and sharing all data segments. No sections are relocatable,
but masmx linking features are used to extract the data sections for different
load treatment from the instruction sections
<pre>

$ masmx application application -lnk
MASMX 7r3
3/application.msm
*EOF*
  :                            1 	$path		freeware/RTA1/rta
  :                            2: 	$include	def/rta.def
  :                            3: 	$include	def/vector.def
  :                            4: 	$include	language/stack.def
  :                            5 	$path
  :                            6 
  :                            7 $(1:01000)
  :                            8 $(3:03000)
  :                            9 
  :                            10: 	$include	application_part1
  :                            11: 	$include	application_part2
00:000100+[0000]30:000000000000
00:000102+[0002]18:000000
  :                            12: 	$include	application_part3
  :                            13 
*EOF*
:$(00):000000:000100 :$(01):001000:00100C :$(02):002000:003000 :$(03):003000:00300C 
application.msm: object code 2031 bytes: 0 errors: 3 undefined labels
$
$ masmx -lnkb
MASMX 7r3
0/-INPUT>>
	$list	0
	$include	freeware/RTA1/rta/def/map1.def
	$list
	$include,$binary	application	$(0)
application.txo:$(0) 256 words decimal from hexadecimal 000000 to 000100
	$store			app_code
	$end
  :                            97  $list
  :                            98:  $include,$binary application $(0)
  :                            99  $store   app_code
  :                            100  $end
:$(00):000000:00A044 
-INPUT>>: object code 1844 bytes: 0 errors: 3 undefined labels
$
$ masmx -lnkb
MASMX 7r3
0/-INPUT>>
	$list	0
	$include	freeware/RTA1/rta/def/map1.def
	$list
	$include,$binary	application	$(1,3)
application.txo:$(1) 12 words decimal from hexadecimal 001000 to 00100C
application.txo:$(3) 12 words decimal from hexadecimal 003000 to 00300C
	$store			app_data
	$end
  :                            97  $list
  :                            98:  $include,$binary application $(1,3)
  :                            99  $store   app_data
  :                            100  $end
:$(01):001000:00100C :$(03):003000:00300C 
-INPUT>>: object code 160 bytes: 0 errors: 0 undefined labels


</pre>
A file system image containing data segments is constructed before
the system image is linked. The sequence of steps corresponding to
the example are now
<pre>

$ lstring -b	app_data.txo	app_data

$ 4kformat -x	fs_image_99.txo
volume		rom_99
tree		segment_loads
file		app_data	app_data
file		next_file
.
.

</pre>
The periods exit the tree (directory) and finally the file system construction.
Option -x on utility 4kformat produces the file system image as a text-encoded
binary which is included in a final link of the ROM image. This includes the kernel and all the
applications

<pre>

$ masmx -lnkb

	$include		freeware/RTA1/rta/def/map1.def

	$include,$binary	kernel
	$include,$binary	application_A
	$include,$binary	application_B

	$include,$binary	app_code	. this application

FS_97*	$equ			03C		. 4K page ID # 60, for example
FS_99*	$equ			03F		. 4K page ID # 63

$(32::FS_97*4096)
	$include,$binary	fs_image_97

$(32::FS_99*4096)
	$include,$binary	fs_image_99

	store			sysimage

</pre>


<b>$include,$void</b> acquires the names of external software without
including its code
<pre>

$ masmx -lnkb

        $include                freeware/RTA1/rta/def/map1.def

        $include,$void		kernel
        $include,$binary        app_code        . this application

</pre>
Utility lstring writes the generated image in a load tuples format

<p>
slab utility reads a load tuples file and writes a ROM image

<p>
At process start, macro <b>$base_d</b> bases storage assigned by the kernel.
Then routine <b>seg$load</b> loads the segments in file <b>app_data</b>
<pre>

initial $base_d PROGRAM_DATA
        c       (seg$load)      FS_99,,xi               ;
                                (app_data:d),,long


</pre>


<h3>A.3 lstring Load String Utility</h3>

lstring reads the text-encoded-binary output of masmx and
constructs a load string image for loaders

<p>
The command line is
<pre>

        lstring -b input[.txo] output

</pre>

-b option selects the binary format which slab loads to
ROM image. Otherwise you get S-Records for quantum-24

<p>
The input and output files are named in full. masmx output
files have the default extension .txo

<p>
Here is a part of a system image output from lstring with
-b option
<pre>


        $ ../util.rta/fds24 srom
        00000000: 000001 49ffbe 000000 000000  "   I        "
        00000004: b60040 00000b d9fa7c 000000  "  @     |   "
        00000008: 000040 5500fc 10008f 10008e  "  @U        "
        0000000c: 04007c 200087 680084 dd0001  "  |   h     "
        00000010: de0049 3e004a f70100 350000  "  I> J   5  "
        00000014: 000001 fffebe 000000 000100  "            "
        00000018: 000040 000077 45324d 000000  "  @  wE2M   ".

        $

</pre>
There is a four word descriptor before each load string:
word-count, checksum, 48-bit address

<p>
The address may be relative to the start of executable space
in the case of a ROM image, or to a dynamic load address

<p>
A loader loading at a run-time-determined address would
need to plug a vector bank with the program's own entry
points and bank addresses

<p>
This fds24 readout is the start of the RTA1 smaragd7 system image

<p>
The first 4-word descriptor describes one word of code at absolute zero.
It's a jump instruction to absolute address 64

<p>
11 instructions at location 64 initialise the interrupt stack pointer
and read memory configuration from an I/O port. That assists decisions
on loadable vs ROM system image, and where data RAM starts. Then a GO
instruction jumps inter-bank. Its indirect operand is a constant at
address 256 (operand addresses < 256 are registers). The constant has
the value 64. That means go to the first location of the bank at absolute
address 4096



<h3>A.4 slab ROM Image Utility</h3>

slab utility builds a ROM image on a file. A typical command line is
<pre>


        ../util.rta/slab srom srom.rom 28 -k

</pre>

This fds24 readout of the slab output file srom.rom displays 4 words at
location zero, twelve words from location 64 and four words at
location 256. They show a jump to location 64, where the interrupt
internal stack pointer is written with the value 252. Some I/O
is probed to detect the startup environment, then a GO instruction
jumps inter-bank via its constant operand, a word at 256 containing
the value 64. This is the vector value of the first location of the
bank at absolute address 4096

<pre>

        $ ../util.rta/fds24 srom.rom
        00000000: b60040 000000 000000 000000  "  @         "64
        00000040: 5500fc 10008f 10008e 04007c  "U          |"
        00000044: 200087 680084 dd0001 de0049  "   h       I"
        00000048: 3e004a f70100 350000 000000  "> J   5     "256
        00000100: 000040 000000 000000 000000  "  @         ".

        $

</pre>
If any load strings point outside the area described at
argument 3 of slab, slab won't finish the job

<p>
slab -h prints complete command line syntax

<pre>

$ slab -h

slab [-options] input[.bxl] output[.rom] [target-rom-words]

default ROM size is 1024 RTA1 words
target-rom-words is leading-zero for hex else decimal

slab ifile ofile -p          #  4096 RTA1 words
slab ifile ofile -b          #  262144 RTA1 words
slab ifile ofile -m          #  1048576 RTA1 words

slab ifile ofile number      #  number of RTA1 words
slab ifile ofile number -k   #  number * 1024 RTA1 words
slab ifile ofile number -p   #  number * 4096 RTA1 words
slab ifile ofile number -b   #  number * 262144 RTA1 words
slab ifile ofile number -m   #  number * 1048576 RTA1 words
options -v verbose -w very verbose
$

</pre>


<h3>A.4 Core Resident File Systems used in Software RAM Segment Load</h3>

The input binary_image_filename is a load strings output from the
following utility steps. First all the RAM-destined part of an
assembly is separated in a linking assembly. Then the utility
lstring is executed with option -b to output binary load strings

<pre>

        $ masmx -kln


                $include        freeware/RTA1/rta/def/map1.def
                $include,$binary        my_application  $(1,3)

                                        . that includes writable parts


                $store  my_ram_part
                $end


        $ lstring -b my_ram_part.txo binary_input_filename

</pre>

The core file system image can be constructed after all segments
for inclusion have been built
<pre>

        $ 4kformat -x fsystem5.txo
        volume  fsystem5
        tree    seg$load
        file    my_ram_values binary_input_filename
	.
	.

</pre>
The two periods are required. They are not a hint at further text. The first period
returns from directory seg$load to volume root directory fsystem8. The second
period exits 4kformat utility

<p>
The inclusion of fsystem5.txo in the final image has the pattern
<pre>

        $ masmx         -kln

                $include        freeware/RTA1/rta/def/map1.def
                $include,$binary        everything_else

FS5_START_BANK_INDEX $equ       NEXT_ADDRESS//4096      . a 4K bank index

                $include,$binary        fsystem5
                $store                  totalimage

</pre>

Finally when a process instance of my_application is launched, after
the storage banks for process data are based, the function seg$load can
be called with the indentify of the core file system start bank and the
label of the file containing the RAM segment
<pre>

        $base_d MY_APPLICATION_DATA_SIZE        . base the memory space

	c	(seg$load)	FS5_START_BANK_INDEX,,xi
				(my_ram_values:d),,long

</pre>
There are two more variants of <b>seg$load</b>

<p>
<b>recursive$seg$load</b> is used in the recursive subprogramming model.
This technique replicates the unpacking of program data to an external stack
frame when a thread calls the program recursively. This is for calling programs
as if they were functions with new copies of a data segment of any size and
complexity. External stack pointer <b>fp</b> must contain the new segment
address before <b>recursive$seg$load</b>
<pre>

	c	(recursive$seg$load)	BANK_INDEX_OF_CORE_FS_START,,xi	;
					(my_dynamic_segment_filename:d),,long

</pre>
block structured programs use the xframe() part of <b>$head_near/far</b>
macro to load dynamic values in the external stack at a functional rather
than a program level

<p>
The third variant of <b>seg$load</b> is <b>array$seg$load</b>. This loads
multi-bank arrays with assembly-time initial values. The target windows
are dynamically overlaid and cannot be based before the call. The third
argument is zero if the array is assembled with absolute load addresses
and is a bank index if storage for the array has been obtained dynamically
with system calls <b>ii BANK$</b> or <b>ii ARRAY$</b>
<pre>

	la, xi	30000*262144
	ii	ARRAY$
	jza	sorry

	c	(array$seg$load)	BANK_INDEX_OF_CORE_FS_START,,xi			;
					(my_assembled_array_segment_filename:d),,long	;
					a		
 
</pre>

<h2>Appendix Y: masmx Directive and Function Names</h2>

masmx prints its internal names if options + and x are both typed. -y sorts
the label table. -k is case-sensitive, otherwise all names are uppercase


<pre>

		$ masmx -x+yk
MASMX 7r3
0/-INPUT>>
	$end

assembly list			explanation
_____________			___________

				label category	syntax column 1
				______________	_______________

$=:F:000000			function		+	$			. location counter $ or $(number)
$a=:F:000011			function		+	$a			. absolute $a current address or $a(value)
$ascii=:D:000015		directive		$ascii				. generate direct ASCII:ASCII data code as input
$awidth=:D:00002B		directive		$awidth	ea_bits[:executable_space]	. set target address size, default 24:48
$b=:F:000010			function		+	$b			. start address of section $b or $b(number)
$bank_index=:F:000012		function		+	$bank_index		. current breakpoint address of program section

$binary=0000FA						$include,$binary filename	. add *.txo text encoded binary file to linking assembly
						label	$set,$binary	text_encoded_superword_paraform . capture binary code in a label, linking assembly
 
$blank=:D:00004E		directive	label[*] $blank				. assign export level to label not yet declared
$branch=:D:00003F		directive	label	$branch				. address structure overlaid in memory. See $tree and $root
$byte=:D:00001A			directive		$byte	bits			. width of data character in "" and +'', default 8
				and function		+	$byte
$characteristic=:D:000035	directive		$characteristic[,number_size_bits] characteristic_bits
											. size of sign+exponent field in floating number, defaults:
							$characteristic		24	. default floating number size 96 bits, 24-bit characteristic
							$characteristic,48	12	. compressed floating number size 48 bits, 12-bit characteristic

$cont_char=:D:000030		directive		$cont_char	value			. line continuation character default ';'
$data_code=:D:000014		directive	 	$data_code [input:generated,generated... input:..] . switch to alternate data code [assign parts of it]
$directive=00007E				name	$equ,$directive	$blank_for_example	. additional name for a masmx directive
$do=:D:000004			directive	[tag]	$do	count,[label(tag)] command arguments . iterate a line of code
$else=:D:000007			directive		$else				. conditional assembly
$elseif=:D:000008		directive		$elseif	condition		. conditional assembly
$end=:D:000003			directive		$end				. end of subassembly (macro) or end of assembly 
$endif=:D:000009		directive		$endif				. conditional assembly
$equ=:D:000010			directive	label	$equ	value
$equf=:D:000043			directive	label	$equf	value,value,..		. equate a name to a tuple of values
$exit=:D:00000E			directive		$exit	stop the assembly with this message
$flag=:D:000033			directive		$flag	mark the assembly in error with this message
$flagf=:D:00000A		directive		$flag	mark the first pass assembly in error with this message
$floating_point=:D:000034	directive		$floating_point	floating_number_default_bit_size	. default 96
$form=:D:00003B			directive	name	$form	bits,bits,..		. bitfields structure template 
$func=:D:00000D			directive	name	$func	[*]			. function macro head [* second pass only]
$function=00007D				name	$equ,$function	$_for_example	. additional name for a masmx function
$hex=:D:000042			directive		$hex				. leading 0 means hex input print hex output, default
$if=:D:000006			directive		$if	condition		. conditional assembly
$include=:D:00000C		directive		$include			. include source code, see also $binary and $void
$info=:D:000044			directive		$info			. instruct the linking assembly, see also $range_check $range_check1 $offset
$linewidth=:D:00002A		directive		$linewidth	columns		. set maximum line width in output text encoded binary file
$list=:D:00001C			directive		$list	[nondefault]		. set file inclusion nest level for -l list. Just $list returns to default 
$lit=:D:00007B			directive	[tag]	$lit	location_counter	 . set which program section contains automatic literals
$load=:D:00004C			directive		$load,$bits	label		. output link adjusted binary acquired at $set,$binary
$long_absolute=0000DC				name	$pushrel,$long_absolute label_value . acquire a large label value to add to a relocatable code field
$lterm=:D:00002C		directive		$lterm	comment_character 	. default is period space, other values do not need following space
$n=:F:000001			function		+	$n			. the name value in macro call, equal to perform value macroname(0, 0)
$name=:D:000002			directive	name[*]	$name	value			. binds a macro call name to a value. Otherwise similar to $set
$net=:F:00000B			function		+	$net(value)		. local part of relocatable value = unrelocatable value. Allows all algebra
$nop=:D:00003C			directive		$nop	do nothing except optionally serve as a comment line without knowing what $lterm is
$note=:D:00003A			directive		$note	print this non-error remark
$notef=:D:00000B		directive		$notef	print this non-error remark on the first assembly pass
$o=:F:000009			function		+	$o(value_of_option_letter)	. 1 if opted, otherwise zero
$octal=:D:000041		directive		$octal				. leading 0 means octal input print octal output, otherwise default hex
$offset=000001						$info,$offset	new_value	. update a tuple containing a relocatable address value in a link assembly
$path=:D:00001D			directive		$path	[../../][/token..]	. path prepend for $include. Cancels with just $path
$plist=:D:00001E		directive		$plist	value			. set macro expansion depth for -pqr listing. Just $plist returns to default

$proc=:D:000001			directive	label[*] $proc	[*] [$(number)]		. head of a command macro
											. label must be exported if macro text exports no labelled* $name label
											. argument * is 2-pass macro on second assembly pass
											. $(number) assembles in program section $(number)

$pushrel=:D:00004D		directive	label	$pushrel text_encoded_binary_superword_subfield		. in a linking assembly
											. capture one relocation tuple from *.txo data superword into a $equf label
$quantum=:D:000029		directive		$quantum	bitsize		. the addressable memory unit of the target architecture. Default = $word
$quote=:D:000036		directive		$quote		value		. set the string delimiter, default "
$r=:F:000006			function		+		$r		. program section (location counter]: $r of here, $r(name) of something 
$range_check=000002		directive		$info,$range_check	value	. on final relocation check value is in range of target field
$range_check1=000003		directive		$info,$range_check1	value	. check value in range of target field each time this relocation tuple is scanned
$rel=:F:00000A			function		+		$rel		. relocation alignment, zero = absolute : $rel current section or $rel(number)
$res=:D:000022			directive	[label]	$res		quanta		. declare a buffer. option -Z initial zero
$return=:D:00001B		directive		$return		expression	. leave a $func macro and return the expressed value to the assembly above
$root=:D:000047			directive		$root				. end of structured name space started with $tree or $branch
$set=:D:000011			directive	label	$set		expression	. temporary equate, actioned on all assembly passes, may be $set again to a new value
$set_option=:D:000045		directive		$set_option	"flaGS"		. set assembly options. See Appendix Z: Command Line
$snap=:D:000028a		directive		$snap[,1]	[2]		. list label table fixed or [2] dynamic part. Subfunction 1 = 1st pass	
$sterm=:D:00002D		directive		$sterm		value		. change the substring character, default ':'
$store=:D:00004F		directive		$store		path		. default assembly output file name. Suffix .txo if no '.' in path last token
$suffix=:D:00003D		directive		$suffix		[1|2]		. integer notation suffixes h o|q b d (default). 1|2 : default for leading 0 = h|d
$t=:F:000008			function		+	$t(name_or_paraform)	. category of label
 
$text=:D:000053			directive		$text	,this,that,
							$text	\these,those\any\	. translate source text on read

$trace=:D:000039		directive		$trace[,1]	expression	. display a value
$tree=:D:000046			directive	name	$tree				. structured name space, see also $branch, $root
$twos_complement=:D:00002F	directive		$twos_complement	1|0	. default 1 = 2s complement, 0 = negative integers are 1s complement
$void=0000F8						$include,$void file		. add names but not code from *.txo text encoded binary file to link assembly
											. see $binary
$word=:D:000019			directive		$word	bits
				and function	bytes_w	$equ	$word/$byte             . $word is size denominator of generated code and default integer size

$xqt_fp=:D:000050		directive		$xqt_fp	floating_tokens+operators . inline runtime expression algorithm via target-specific instruction macros
$xqt_i=:D:000051		directive		$xqt_i	integer_tokens+operators . inline runtime expression algorithm via target-specific instruction macros

$zenith=:F:000FC8		function		$if	$zenith>LIMIT
							$if	$zenith(section)>LIMIT	. unrelocated high address of section including literal pool
-INPUT>>=0<000000

-INPUT>>: object code 0 bytes: 0 errors: 0 undefined labels

</pre>

<h2>Appendix Z: masmx Command Line Options</h2>

<pre>

</pre>

_____________________________________________________________________
<pre>
<i>

    LICENCE NOTICE


    Copyright Tim Cox, 2012
    TimMilesCox@gmx.ch

    This document is part of the RTA1 processor programmable
    architecture.

    RTA1 is a free processor architecture specification.
    It is licensed under the GNU General Public Licence Version 3

    The executable emulation of RTA1 is free software.

    Instruction code for the target RTA1 architecture is free software
    if it is delivered with this software

    Software programs delivered with this software to connect the
    emulated RTA1 with real network interfaces in the emulator host
    are free software

    Scripts and programs delivered with this software for running
    on other computers and interacting with the RTA1 are free software

    The masmx target-independent meta-asembler delivered here
    is free software whether it is used for constructing RTA1 code
    or any other code. masmx is a separate free program by the
    same author and included with this software to save searching for it

    Scripts and utility programs for constructing RTA1 target
    executable software are free software

    You can redistribute it and/or modify RTA1
    under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    RTA1 is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with RTA1.  If not, see &lt;http://www.gnu.org/licenses/&gt;.

</i>
</pre>


</div>
</html>
