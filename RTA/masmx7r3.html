<html>

<div	style="font-size:14pt">

<center>
<h1>masmx.7r3A for RTA1</h1>
<h1><a href="#binary_utilities">and Binary Utilities<a/></h1>

<i>
Copyright Tim Cox, 2014
<p>
This document is part of the RTA1 Processor Programmable Architecture Specification<br>
RTA1 is a free computer programmable architecture licensed under the GNU General Public Licence Version 3<br>

The same licence encompasses all software and documentation delivered with RTA1 Specification

<br>
The masmx.7r3 meta-assembler is free software separately licensed with the GNU General Public Licence Version 3

<br>
The full text of GNU General Public Licence Version 3 is included with these materials<br>
See also the licensing notice at the foot of this document

</i>
</center>
	<ol>
	<li><a href="#organisation">Organisation of Manuals about Programming RTA1</a></li>
		<ol>
		<li><a href="#architecture">RTA1 Architecture and Application Structure</a></li>
		<li><a href="#masmx">masmx Download and Reference Manual</a></li>
		</ol>
	<li><a href="#masmx_settings">masmx Settings for RTA1</a></li>
	<li><a href="#language">Assembly Language</a></li>
		<ol>
		<li><a href="#labels">Labels</a></li>
		<li><a href="#commands">Command and Arguments Fields</a></li>
		</ol>
	<li><a href="#constants">Data Constants</a></li>
		<ol>
		<li><a href="#expressions">Expressions and Numbers</a></li>
			<ol>
			<li><a href="#operator">Operators</a></li>
			<li><a href="#numbers">Integers and Floating Point</a></li>
			<li><a href="#fp96data">Floating Point</a></li>
			<li><a href="#fp48data">Floating Storage Compression</a></li>
			<li><a href="#fp192data">192-Bit Floating Point</a></li>
			</ol>
		<li><a href="#literals">Literals</a></li>
			<ol>
			<li><a href="#automatic_literals">Automatic Literals</a></li>
			<li><a href="#tagged_literals">Tagged Literals</a></li>
			</ol>
		<li><a href="#strings">Character Strings</a></li>
		<li><a href="#comma_fields">Number Constants with Equal-Size Bit Fields</a></li>
		</ol>
	<li><a href="#form">$form</a> Bit-Field Templates</a></li>
	<li><a href="#instructions">Instructions and Operands</a></li>
		<ol>
		<li><a href="#operands">Register / Memory Operand Continuum</a></li>
		<li><a href="#registers">Programmable Register Model</a></li>
			<ol>
			<li><a href="#nar">Two Non-Addressable Registers</a></li>
			<li><a href="#ioar">Architectural Space Mapped via I/O</a></li>
			<li><a href="#register_stack">The Register Stack</a></li>
			</ol>
		<li><a href="#instruction_form">Instruction Layout</a></li>
		<li><a href="#integer_instructions">Single Integer Instructions</a></li>
		<li><a href="#sisi">Single Integer Store Instructions</a></li>
		<li><a href="#sili">Single Integer Load Instructions</a></li>
		<li><a href="#ti">Test Instructions</a></a></li>
		<li><a href="#xai">Index Register Add Instructions</a></li>
		<li><a href="#booli">Boolean Algebra Instructions</a></li>
		<li><a href="#siai">Single Integer Add Instructions</a></li>
		<li><a href="#mi">Multiply</a></li>
		<li><a href="#mf">Multiply Fractional</a></li>
		<li><a href="#di">Divide</a></li>
		<li><a href="#llsi">Large Load and Store Instructions</a></li>
		<li><a href="#liai">Large Integer Arithmetic Instructions</a></li>
		<li><a href="#fpai">Floating Arithmetic Instructions</a></li>
			<ol>
			<li><a href="#fp96i">The 96-Bit Floating Point Model</a></li>
			<li><a href="#fp192i">192-Bit Floating Arithmetic</a></li>
			</ol>
		<li><a href="#smi">Storage Modify Instructions</a></li>
		<li><a href="#si">Shift Instructions</a></li>
		<li><a href="#bsi">Bit Stream Instructions</a></li>
		<li><a href="#ji">Jump Instructions</a></li>
		<li><a href="#nar">Non-Addressable Registers</a></li>
		<li><a href="#crii">Call / Return, Iframe Jump, Internal Interrupt / Return</a></li>
		<li><a href="#crio">Control and I/O Instructions</a></li>
		</ol>
	<li><a href="#locators">Application Memory and Location Counters</a></li>
	<li><a href="#do">$do</a> Iteration</li>
	<li><a href="#proc">$proc</a> and <a href="#func">$func</a> Macros</li>
		<ol>
		<li><a href="#proc">$proc</a>: Command and Instruction Macros</li>
		<li><a href="#func">$func</a>: Macros to generate Assembly-Time Values</li>
		</ol>
	<li>Runtime Algorithmic Expressions: <a href="#algors">$xqt_i</a> and <a href="#algors">$xqt_fp</a></li>
	<li><a href="#structure">Structures</a></li>
		<ol>
		<li><a href="#structure">Structures for Data and Instruction Code</a></li>
		<li><a href="#bit_structures">Bit Structures</a></li>
		</ol>
	<li><a href="#directives">masmx directives and internal functions</a></li>
	</ol>

	<blockquote>
	<a href="#linking">Appendix A: Linking</a><br>
	<a href="#file_formats">Appendix B: File Formats</a><br>
		<blockquote>
		<a href="#txo">Text Encoded Binary (.txo) Format</a><br>
		<a href="#load_string">Load String Format</a><br>
		<a href="#txo">rom Format</a><br>
		</blockquote>
	<a href="#command_line">Appendix X: masmx Command Line</a><br>
	<a href="#binary_utilities">Appendix Y: Binary Utilities</a><br>
		<blockquote>
		<a href="#lstring">lstring</a><br>
		<a href="#slab">slab</a><br>
		<a href="#fsformat">fsformat</a><br>
		<a href="#4kformat">4kformat</a><br>
		<a href="#1gformat">1gformat</a><br>
		<a href="#fds24">fds24</a><br>
		</blockquote>
	<a href="#licence">Appendix Z: Licence Note</a><br>
	</blockquote>


<a	name="organisation"/>
<h2>1: Organisation of Manuals about Programming RTA1</h2>

<a      name="architecture"/>
<h3>1.1: RTA1 Architecture and Application Structure</h3>
This manual summarises RTA1 register model and instructions by functional group

<p>
Architecture and instructions are completely described in <a href="rta.html">
RTA1 Processor Programmable Architecture Specification</a>

<p>
See also <a href="language.html#application_structure">Application Structure</a>,
<a href="app.html">Fixed Application Structure</a>
and <a href="iframe.html">Loadable Application Structure</a>

<a      name="masmx"/>
<h3>1.2: masmx Download and Reference Manual</h3>

Refer to <a href="http://timmilescox.github.io/masmx">
masmx documentation and download</a> for more information about masmx

<a      name="masmx_settings"/>
<h2>2: masmx Settings for RTA1</h2>

masmx is a target-independent meta-assembler

<p>
masmx default settings are correct for RTA1:

<pre	style="font-size:12pt;color:#0000FF">

        $word                   24		. unit of generated code + bits size single integer
        $quantum		24		. addressable storage location bits size
        $awidth                 24:48		. address space : executable space
        $floating_point         96		. default size of floating constant
        $characteristic         24		. sign + scale field of floating number
        $characteristic,48      12		. sign + scale field of compressed floating number
        $byte                   8

</pre>

<p>
RTA1 instructions and registers are added with an include file rta.def
and often more include files about I/O, macros and structures
<pre>

	$path		rta/target.rta/
	$include	def/rta.def
	$include	def/vector.def
	$include	def/ii.def
	$include	def.sys/io.def
	$include	language/stack.def
	$include	t77.4/ip.def
	$path			. back to PWD for the developer's own include files
	$include	...

</pre>

<p>
Source input text is ASCII

<p>
Text strings may include ASCII extensions like UTF-8

<p>
The default generated code of strings is ASCII as input, but may instead be completely different data code in rule-based translation

<p>
See
<a href="#expressions"> 4.1: Expressions and Numbers</a> and
<a href="#strings"> 4.3: Character Strings</a>

<p>
Language elements not in quotes or apostrophes are from ASCII code points 0..127.


<p>
masmx default syntax elements are used for RTA1

<pre	style="font-size:12pt;color:#0000FF">

	$lterm			'.'	. comments follow PERIOD SPACE
	$sterm			':'	. substring:divider and structure:join is colon :
	$cont_char		';'	. line continuation is semicolon ;
	$quote			'"'	. "quoted" is a string in current bytes and data code
					. +"quoted" forces the token to be a label reference. See . <a href="#labr">+"label_reference"<a>

					. ' apostrophe may bound a right justified token [&plusmn;]'abc'
					. up to 192 bits in current bytes and data code. See <a href="#qnu">+'values'</a> 


</pre>

<a	name="language"/>
<h2>3: Assembly Language</h2>

The line of assembly language code has an arbitrary number of fields

<pre	style="font-size:12pt;color:#0000FF">

[label]	[command]		[argument1[,argument1_subfield2,...]]	[argumentN[,argumentN_subfield2,...]]	[. comment ]

</pre>
Lines may be continued
<pre	style="font-size:12pt;color:#0000FF">

[label]	[command]	[argument1[,argument1_subfield2,...]]	;
			[argument2[,argument1_subfield2,...]]	;
			[argumentN[,argumentN_subfield2,...]] 

</pre>
<a      name="labels"/>
<h3>3.1: Labels</h3>

A label starts in column 1 and ends in whitespace. A label may contain letters, digits, $_?!@: and
starts with a letter or _?!@

<p>
Substring divider : may be a character in a label or a join in a structure

<p>
A label may be in "" and then it starts with anything and contains anything

<p>
Without case-sensitive option -k all labels and references are translated to uppercase

<p>
$ in column one is a program section control called a location counter with syntax
<b>$(number[:attributes])</b> See <a href="#locators">7: Application Memory and Location Counters</a>

<p>
A label starting with $ is declared in quotes and may be referenced without quotes

<p>
A label may have an arbitrary number of subscripts
<pre	style="font-size:12pt;color:#0000FF">

<i>label(5,7,600)</i>

</pre>

<p>
Reference to a subscripted label which does not exist
counts instances of labels identical except for one more
subscript

<p>
A label <i>label_stem(<b>4,1,20</b>)</i> is the count of labels
<i>label_stem(<b>4,1,20</b>,&xi;)</i>

<pre	style="font-size:12pt;color:#0000FF">
	<i>
	label_stem(<b>4,1,20</b>,5)<br>
	label_stem(<b>4,1,20</b>,20)<br>
	...</i>

</pre>

If no instances exist either the reference has the value of zero because it
counts an empty set

<p>
There is no requirement for label subscripts to fill a number space
continuously or evenly

<p>
Subscripted labels need not be in ascending order or any order, but may be
generated by loop control
<pre	style="font-size:12pt;color:#0000FF">

MANY	$set	65536

index	$do	MANY,a_name(MANY+1-index)	+	99*index

</pre>
Subscript expressions are normalised to decimal strings when the label is stored

<p>
For example, the first two repeats of $do above generate
<pre	style="font-size:12pt;color:#0000FF">

a_name(65536)	+	99*1
a_name(65535)	+	99*2

</pre>
and the last three generate
<pre	style="font-size:12pt;color:#0000FF">

a_name(3)	+	99*65534
a_name(2)	+	99*65535
a_name(1)	+	99*65536


</pre>
Labels inside macros only exist during macro assembly unless they are promoted

<p>
Labels in macros are promoted one macro level per trailing asterisk

<pre	style="font-size:12pt;color:#0000FF">

$ masmx -lnxk visible visible
MASMX 7r3
3/visible.msm
  :                            1 macro1*	$proc
  :                            2 	macro2
  :                            3 visible* $equ	invisible
  :                            4 	$end
  :                            5 
  :                            6 macro2* $proc
  :                            7 macro3* $proc
  :                            8 manifest****
  :                            9 private***
  :                            10 unseen
  :                            11 invisible**
  :                            12 	$end
  :                            13 	macro3
  :                            14 	$end
  :                            15 
  :                            16 $(14:0E000)
  :                            17 	macro1
  :                            18 	$end
macro1=:P1:0:000000
macro2=:P1:0:000001
manifest+=$0E:00E000
private=$0E:00E000
visible=00E000
visible.msm=0<000003
:$(0E):00E000:00E000 
visible.msm: object code 47 bytes: 0 errors: 0 undefined labels
$
$ cat visible.txo

+manifest:$0E:00E000
:$0E*000000:00E000:00E000
$

</pre>

The name "manifest" has been exported here in the <a href="#txo">output file</a>

<p>
An asterisk at the main assembly level externalises the label

<p>
Directive $set is a temporary equate

<p>
$set labels can be restated without restriction

<p>
A $set label at main assembly which is not exported may be restated with surplus asterisks but is not consequently exported

<p>
This assembly does not export any names

<pre	style="font-size:12pt;color:#0000FF">

$ masmx attestor -lnx
MASMX 7r3
3/attestor.msm
*EOF*
  :                            1 "$$local"	$set	1
  :                            2 
  :                            3 outward*	$proc
  :                            4 "$$local"******	$set	2
  :                            5 		$end
  :                            6 
  :                            7 		outward
  :                            8  
*EOF*
$$LOCAL=000002
OUTWARD=:P1:0:000000
attestor.msm=0<000003

attestor.msm: object code 0 bytes: 0 errors: 0 undefined labels
$ cat temp.txo
$

</pre>
The <a href="#file_formats">text-encoded binary</a> file temp.txo contains no exported names and no other information because no code is assembled

<a	name="commands"/>
<h3>3.2: Command and Arguments Fields</h3>

The command field is the first field to follow any whitespace. It may contain 

	<blockquote>
	nothing. Then there are no arguments either<br><br>
	a number constant or a character string constant<br><br>
	an assembler directive command<br><br>
	the macro name of an instruction or data structure
	</blockquote>

Assembly language coding is largely instruction code

<p>
Most source lines have the macro name of an instruction in the command position

<p>
Other commands can be about data structures or commands to the assembler like $include or $equ

<p>
Instruction names are macros because a meta-assembler knows no instructions until they are described in macro language

<p>
Most instruction macros centre on a directive command $form, which describes the instruction in bit fields


<pre	style="font-size:12pt;color:#0000FF">

isimple $form	5,3,16

p	$proc
lret*	$name	6
fret*	$name	7
	isimple	p(0, 0), 5, p(1, 1)
	$end

</pre>
Here is a corresponding line of application code
<pre	style="font-size:12pt;color:#0000FF">

	lret	1	. return and skip 1 instruction


.	the values in the generated instruction are
.	_____________________________________
.	| 00110 | 101 | 0000 0000 0000 0001 |
.	|_______|_____|_____________________|

</pre>

see also sections <b>$form</b> and <b>$proc</b>

<a	name="constants"/>
<h2>4: Data Constants</h2>
<a	name="expressions"/>
<h3>4.1: Expressions and Numbers</h3>
<a	name="operator"/>
<h4>4.1.1: Operators</h4>

Operators by rank are

	<blockquote>
	()<br>
	=<br>
	^=<br>
	><br>
	<<br>
	--<br>
	++<br>
	/*<br>
	*/<br>
	*/-<br>
	**<br>
	*+ *-<br>
	+ -<br>
	* / // ///<br>
	&plusmn; ^unary<br>
	</blockquote>


Operators in the same rank have left-to-right precedence as they are
encountered in the expression

<p>
Operators of higher rank are evaluated first and operated last. An expression
generates an integer until a decimal exponent operator *+ *- is actioned or a
decimal point is encountered

<p>
The operators are 
<pre	style="font-size:12pt;color:#0000FF">

	_________________________________________
	|	=	|	equal		|	= 1 ^= 0
	|_______________|_______________________|
	|	^=	|	unequal		|	^= 1 = 0
	|_______________|_______________________|
	|	>	|	greater		|	> 1 = 0 < 0
	|_______________|_______________________|
	|	<	|	less		|	< 1 = 0 > 0
	|_______________|_______________________|
	|	--	|	XOR		|
	|_______________|_______________________|
	|	++	|	OR		|
	|_______________|_______________________|
	|	/*	|	shift right	|
	|_______________|_______________________|
	|	*/	|	shift left	|
	|_______________|_______________________|
	|	*/-	| right	shift algebraic	|
	|_______________|_______________________|
	|	**	|	AND		|
	|_______________|_______________________|
	|	*+	|      +decimal exponent|
	|_______________|_______________________|
	|	*-	|      -decimal exponent|
	|_______________|_______________________|
	|	+	|	PLUS		|
	|_______________|_______________________|
	|	-	|	MINUS		|
	|_______________|_______________________|
	|	*	|	MULTIPLY	|
	|_______________|_______________________|
	|	/	|	DIVIDE		|
	|_______________|_______________________|
	|	//	|	covered quotient|
	|_______________|_______________________|
	|	///	|	remainder	|
	|_______________|_______________________|


Only	+	PLUS
	-	MINUS
	**	AND
	/*	SHIFT RIGHT
	*/-	SHIFT RIGHT ALGEBRAIC may be applied to relocatable tokens


	+ PLUS - MINUS may operate without restriction on mixed relocatable and absolute tokens	

	The token left of ** <a style="color:FFFFFF;background-color:000000">AND</a> may be relocatable, not the mask. Linker range check is suppressed

	/* SHIFT RIGHT */- SHIFT RIGHT ALGEBRAIC shift the final relocated value

	/* SHIFT RIGHT shifts the relocated value logically right and range-checks unsigned

	shift left operator */ with negative shift count is SHIFT RIGHT ALGEBRAIC.
	Range check at link is signed. The target field contains at least one sign bit.
	The relocated value is shifted right algebraically


$ masmx relarith -lnk
MASMX 7r3
3/relarith.msm
*EOF*
  :                            1 ABSOLUTE	$equ	-4096
  :                            2 MINUS8		$equ	-8
  :                            3 $(5:*1)
  :                            4 relocatable	$res	1
  :                            5 $(6:06000)
  :                            6 
(+05:000000/*10)18+
06:006000 000000              +7 	+	relocatable*/-16	. signed range check after relocation
  :                            8 					. shift right algebraic 16 positions
  :                            9 
(+05)18+
06:006001 000000              +10 	+	relocatable*/-0		. signed range check after relocation
  :                            11 					. shift no positions
  :                            12 
(+05:000000/*10)18+
06:006002 000000              +13 	+	relocatable*/(-16)	. signed range check after relocation
  :                            14 					. shift right algebraic 16 positions
  :                            15 
06:006003 FFFFF0              +16 	+	ABSOLUTE*/MINUS8	. shift right algebraic at assembly time
06:006004 FFFFF0              +17 	+	ABSOLUTE*/-8		. shift right algebraic at assembly time
06:006005 00FFF0              +18 	+	0FFF000/*8		. shift right logical at assembly time	
  :                            19 
(+05:000000/*08)18
06:006006 000000              +20 	+	relocatable/*8		. unsigned range check after relocation
  :                            21 					. shift right logical 8 positions
  :                            22 
(+05:000000/*0c)18+
[+0000:000000/*0c]18+
06:006007 000000              +23 	+	relocatable+EXTERNAL*/-12 . signed range check after relocation
  :                            24 					. shift right algebraic 12 positions
  :                            25 
(+05:000000/*08)18+
06:006008 000000              +26 	+	relocatable*/MINUS8	. signed range check after relocation
  :                            27 					. shift right algebraic 8 positions
  :                            28 
*EOF*
:$(05):000000:000001 :$(06):006000:006009 


</pre>

<a	name="numbers"/>
<h4>4.1.2: Integers and Floating Point</h4>
<p>
Integer and floating constants can be up to eight words in size

<p>
RTA1 computes <a href="rta.html#fp">floating numbers</a> of four or eight words

<p>
Number constants have the default masmx syntax. Leading 0 means hex unless the number string has a decimal point for example 0.5

<p>
A unary sign in the command field indicates a number constant
but is not always necessary
<pre	style="font-size:12pt;color:#0000FF">

	+	<i>expression</i>
	<i>-expression</i>

</pre>

<a	name="qnu"/>
An unsigned number starting with a digit or a single quote (apostrophe)
in the command field is recognised as a positive number constant

<pre	style="font-size:12pt;color:#0000FF">

$ masmx -ln
MASMX 7r3
0/-INPUT>>

        99
        1.5*+2
	'abcd'
	$end
  :                            1 
00:000000 000063              +2 	 99
00:000001 400008960000000000000000
                              +3 	1.5*+2
00:000005 000061626364        +4 	'abcd'
  :                            5 	$end
:$(00):000000:000007 


</pre>


<p>
In masmx.7r3 a unary symbol appended to the front of the
constant expression only exerts polarity on the first token

<pre	style="font-size:12pt;color:#0000FF">

$ masmx -ln
MASMX 7r3
0/-INPUT>>
	-2-2
	^0f0f++3
	-5-10*-1 
	$end
00:000000 FFFFFC              +1 	 -2-2
00:000001 FFF0F3              +2 	^0f0f++3
00:000002 BFFFFE3FFFFFFFFFFFFFFFFF
                              +3 	-5-10*-1 
  :                            4 	$end
:$(00):000000:000006 

</pre>

<p>
Unary ^ is 1s complement

<p>
A unary symbol in the command field separated by whitespace
from the following constant expression exerts polarity on the
total expression which follows

<pre	style="font-size:12pt;color:#0000FF">

$ masmx -ln
MASMX 7r3
0/-INPUT>>
	-	2-2
	-	50+50:d
	+	3072-1:t
	+	0ffffffcccccc++0ffffffEEEEEE*/48:q
        -       100000*/96:p

        +       1.75*+1200000
	$end
00:000000 000000              +1 	-	2-2
00:000001 FFFFFFFFFF9C        +2 	-	50+50:d
00:000003 000000000000000BFF  +3 	+	3072-1:t
00:000006 FFFFFFEEEEEEFFFFFFCCCCCC
                              +4 	+	0ffffffcccccc++0ffffffEEEEEE*/48:q
00:00000A FE7960000000000000000000000000
                              +5 	-	100000*/96:p
  :                            6 
00:00000F 7CD38BB7B396D7AA20B6E083
                              +7 	+	1.75*+1200000
  :                            8 	$end
:$(00):000000:000013 


</pre>
<p>
Fixed point numbers are autosized. masmx adds an extra word of signs
where the high order bit of the magnitude is not a sign.
Size can be forced with a suffix
<pre	style="font-size:12pt;color:#0000FF">

$ masmx -ln
MASMX 7r2
0/-INPUT>>
	+	255*/16
	+	255*/16:s
	$end
00:000000 000000FF0000        +1 	+	255*/16
00:000002 FF0000              +2 	+	255*/16:s
  :                            3 	$end
:$(00):000000:000003 


</pre>
The size suffixes are
<pre	style="font-size:12pt;color:#0000FF">

	:s	:S			one word
	:d	:D	:l	:L	two words
	:t	:T			three words
	:q	:Q			four words
	:p	:P			five words
	:h	:H			six words
	:z	:Z			seven words
	:o	:O			eight words

</pre>

<p>
Size suffix does not always need a colon
but it is never wrong to type the colon. Parentheses can also separate the suffix from labels and hex symbols

<p>
Upper and lowercase suffix are interchangeable


<p>
Symbols in single quotes generate the data code value in fields of byte size right justified

<pre	style="font-size:12pt;color:#0000FF">

$ masmx -ln
MASMX 7r3
0/-INPUT>>
	+	'abcd'
	$data_code	97:65	. generate 'A' when the source has 'a'
	'abcd'++128		. logical OR bit 7 on
	$ascii			. switch back to plain ASCII
	$byte	12		. make the byte size a halfword
	'abcd'
	$end
00:000000 000061626364        +1 	+	'abcd'
  :                            2 	$data_code	97:65	. generate 'A' when the source has 'a'
00:000002 0000416263E4        +3 	'abcd'++128		. logical OR bit 7 on
  :                            4 	$ascii			. switch back to plain ASCII
  :                            5 	$byte 	12		. make the byte size a halfword
00:000004 061062063064        +6 	'abcd'
  :                            7 	$end
:$(00):000000:000006 

</pre>

<p>
Tokens in an expression may be labels

<p>
<b>$equ</b> labels are fixed in value. <b>$set</b> labels can be
set again to a new value
<pre	style="font-size:12pt;color:#0000FF">

fast	$equ	1.75	. can't be changed within this subassembly
loose	$set	99	. can be changed as much as you like

</pre>
Not all operations are allowed on labels which are relocatable
storage addresses
<pre	style="font-size:12pt;color:#0000FF">

$(3:*1)			. relocatable program section

buffer	$res	20	. buffer can be in &plusmn; expressions
			. and shift right expressions

</pre>
Labels in expressions may also be masmx internal function names
or the names of macros of the $func type

<p>
These examples show function expressions in instruction operands
instead of constants
<pre	style="font-size:12pt;color:#0000FF">

	jc	$+2	. current location counter + 2

f	$func
upto10*	$name
	$do	f(1, 1)>10,	$return	10
	$return	f(1, 1)
	$end


	lr, xi	upto10(ACTUAL_PARAMETER)		
	

</pre>
The optional tag of <b>$do</b> directive is a value incrementing
from 1
<pre	style="font-size:12pt;color:#0000FF">

$ masmx -ln
MASMX 7r3
0/-INPUT>>
mantissa	$equ	175
exponent	$do	3,	+mantissa*+exponent-3
		$end
  :                            1 mantissa	$equ	175
00:000000 400001E00000000000000000
                              +2 exponent	$do	3,	+mantissa*+exponent-3
00:000004 4000058C0000000000000000
                              +2 
00:000008 400008AF0000000000000000
                              +2 
  :                            3  		$end
:$(00):000000:00000C 

</pre>

<p>

Integers are twos-complement negative and floating numbers are 1s-complement negative

<pre    style="font-size:12pt;color:#0000FF">

        $ masmx -ln
MASMX 7r3
0/-INPUT>>
        -       6
        -       0.5
        $end
00:000000 FFFFFA              +1        -       6
00:000001 BFFFFF7FFFFFFFFFFFFFFFFF
                              +2        -       0.5
  :                            3        $end
:$(00):000000:000005


</pre>

<a	name="fp96data"/>
<h4>4.1.3 Floating Point</h4>

<p>
Floating constants are typed as decimal string with decimal point and optional e&plusmn;<br> 
or as decimal fractions with exponent operator *+ or *-<br>
or as integer expressions with tokens in any notation and exponent operator *+ or *-
<pre    style="font-size:12pt;color:#0000FF">

$ masmx -lnke
MASMX 7r3A Build 8
0/-INPUT>>
		1.23456789012345678901e1250000
EXPONENT 	$equ    1250000-20
	06B14E9F812F366C35*+EXPONENT
	$end
00:000000  7F5C5B AB90C2 6474BB A03580
                              +1   1.23456789012345678901e1250000
  :                            2 EXPONENT  $equ    1250000-20
00:000004  7F5C5B AB90C2 6474BB A03580
                              +3  06B14E9F812F366C35*+EXPONENT
  :                            4  $end
:$(00):000000:000008 


</pre>

e can be E or E+

<p>
The floating mantissa is a simple fraction.<br>
Its integral part is derived by hauling the mantissa
upwards through the fractional point<br>by the number of
positions with which the exponent exceeds the midpoint
value <b>0400000</b>
<pre	style="font-size:12pt;color:#0000FF">

	$ masmx -ln
MASMX 7r3
0/-INPUT>>
	+	1.5
	$end
00:000000 400001C00000000000000000
                              +1 	+	1.5
  :                            2 	$end
:$(00):000000:000004 


</pre>
Floating point numbers do not autosize.
They are four words unless a size override is typed

<p>
An RTA1 floating operand is four words

<p>
An eight word floating constant is generated with the macro major_minor for use with <a href="#fp192data">192-bit floating library</a>

<p>
A two-word floating constant is target of <a href="rta.html#fpx">fpx</a> instruction which promotes the number to four words in the internal stack top

<p>
See also <a href = "#fp192i">192-Bit Floating Point</a>
and <a href="#fp48data">Floating Storage Compression</a>
<pre	style="font-size:12pt;color:#0000FF">


$ masmx -ln
MASMX 7r3
0/-INPUT>>
        $list		0
	$include	../def/rta.def
	$list
$(3:03000)
left	1.75*+1250000
right	1.75*-1250000
$(0:64)
left_plus_right
	ql	left
	fa	right


  :                            451 		$list
  :                            452 $(3:03000)
03:003000 7F5C5BF331AD4B6FFBBCAAB2
                              +453 left		1.75*+1250000
03:003004 00A3A7CE52225BC80EDFF592
                              +454 right	1.75*-1250000
  :                            455 $(0:64)
  :                            456 left_plus_right
00:000040 4F3000              +457 		ql	left
00:000041 673004              +458 		fa	right


</pre>
<a	name="fp48data"/>
<h4>4.1.4: Floating Storage Compression</h4>
<p>
The two-word suffix may be used to assemble a 48-bit
compressed floating constant which RTA1 can
expand to four words at the internal stack top with the
<b>floating push and expand</b> instruction <a href="rta.html#fpx">fpx</a>

<p>
RTA1 computes 96-bit floating-point but the <a href="rta.html#fpp">floating pop and pack</a>
instruction <b>fpp</b> can store the number in a 48-bit
floating format if that has enough range for its value
<pre	style="font-size:12pt;color:#0000FF">

	$ masmx -ln
MASMX 7r3
0/-INPUT>>

	$list		0
	$include	freeware/RTA1/rta/def/rta.def
	$list

$(0:64)

	fpx		(4.096:d*+200)		. load and expand the 2-word input
	fa		0, sp			. use the expanded number

	qs		0, sp
	fpp		compressed_storage	. store and compress the result
						. from 4 words to 2
	$do		$<256,$(0:256)

$(3:03000)
compressed_storage $res	2
	$end
  :                            1 
  :                            429 	$list
  :                            430 
  :                            431 $(0:64)
  :                            432 
00:000040 5F0100              +433 	fpx	(4.096:d*+200)		. load and expand the 2-word input
00:000041 67F000              +434 	fa	 0, sp			. use the expanded number
  :                            435 
00:000042 47F000              +436 	qs	 0, sp
00:000043 573000              +437 	fpp	compressed_storage	. store and compress the result
  :                            438  					. from 4 words to 2
  :                            439 	$do	$<256,$(0:256)
  :                            440 
  :                            441 $(3:03000)
  :                            442 compressed_storage $res 2
  :                            443 	$end
00:000100+69BAB3C2FDDF
:$(00):000040:000102 :$(03):003000:003002 


</pre>

48-bit compressed floating format has 11 exponent bits equivalent to decimal exponent range approximately &plusmn;307
<pre>


	47 46     36 35                                        0
	_________________________________________________________
	|s|   11    |		mantissa 36 bits		|
	|_|_________|___________________________________________|

</pre>
96-bit compute format has 23 exponent bits equivalent to decimal exponent range approximately &plusmn;1262611
<pre>

	_________________________________________________________________________________________________
	|s|	    23		|			   mantissa 72 bits				|
	|_|_____________________|_______________________________________________________________________|
	95 94                 72 71                                                                    0

</pre>

<p>
<a	name="fp192data"/>
<h4>4.1.5: 192-Bit Floating Point</h4>

<p>

192-bit floating constants are generated with macro major_minor

<pre	style="font-size:12pt;color:#0000FF">

	$path		rta/target.rta
	$include	lib/144.def
	$path


value3	major_minor	1.222222333333111111222222333333111111222222*+1250000


</pre>
major_minor macro constructs two teamed 96-bit floating numbers for 192-bit arithmetic
with effective mantissa 144 bits

<p>
No length override is given to major_minor macro

<p>
These library calls compute 192-bit floating values:
<pre	style="font-size:12pt;color:#0000FF">


	$include	language/stack.def
									. 1st operand loadup:
									. address of operand in internal stack

	c	(fp192lib_load)			<i>source</i>,,i	. registers a b 6 7 8 9 10 11 are loaded
	c	(fp192lib_load_negative)	<i>source</i>,,i	. registers a b 6 7 8 9 10 11 are loaded

									. 4-functions arithmetic:
									. 1st operand in registers [ a..11 ]
									. address of 2nd operand in stack
									. result in registers [ a..11 ]

	c	(fp192lib_add)			<i>addend</i>,,i	. 1st addend in registers [ a..11 ]
	c	(fp192lib_add_negative)		<i>subtrahend</i>,,i	. minuend is in registers [ a..11 ]
	c	(fp192lib_multiply)		<i>multiplier</i>,,i	. multiplicand in registers [ a..11 ]
	c	(fp192lib_divide)		<i>divisor</i>,,i	. dividend is in registers [ a..11 ]

						. pushed address needs to be ,,i if it is base + displacement
						. as function parameters & dynamic variables are: displacement, sp
						. pushed address may be address,,xi if direct addressed like static

	c	(reciprocal192)			<i>value</i>,,float192	. 8-word argument in the stack
									. reciprocal delivered in [ a..11 ]

	c	(fp192lib_mfa)	<i>multiplicand</i>,,i	<i>multiplier</i>,,i	. 2 addresses in stack
								. product is written -> multiplicand

</pre>

<a	name="literals"/>
<h3>4.2: Literals</h3>

<a	name="automatic_literals"/>
<h3>4.2.1: Automatic Literals</h3>

Automatic literals are enabled with assembly flag -a

<p>
This two-word compressed floating constant is an automatic literal because it is in parentheses

<pre	style="font-size:12pt;color:#0000FF">


00:000040 5F0100              +433      fpx     (4.096:d*+200)          . load and expand the 2-word input
  :                            438                                      . from 4 words to 2
  :                            439      $do     $<256,$(0:256)		. force literal table to address 256+
  :                            440
  :                            443      $end
00:000100+69BAB3C2FDDF
:$(00):000040:000102 :$(03):003000:003002



</pre>

<p>
A literal is a constant declared as an operand and
assembled at the end of a designated section

<p>
Literals look like immediate operands but are storage
constants of any size. The instruction contains their
address, not their value
<pre	style="font-size:12pt;color:#0000FF">

$ masmx -lnz
MASMX 7r3
0/-INPUT>>
	$list	0
	$include	freeware/RTA1/rta/def/rta.def
	$list
$(31:01F000)
	$list	0
?	$do	1024,number(?)	1.75*+?-1
	$list
$(3:03000)
$(0:64)
	lx	(number(512))
	lk	(127*/16)
	dl      (1.65*+1200000)
	$lit	3
	ly, xi	("the result is %f":10)
	$do	$<256,$(0:256)
        $end
  :                            428 	$list
  :                            429 $(31:01F000)
  :                            432 	$list
  :                            433 $(3:03000)
  :                            434 $(0:64)
00:000040 500100              +435 	lx	(number(512))
00:000041 480101              +436 	lk	(127*/16)
00:000042 CF0102              +437 	dl	(1.65*+1200000)
  :                            438 	$lit	3
00:000043 5D3000              +439 	ly, xi	("the result is %f":10)
  :                            440 	$do $<256,$(0:256)
  :                            441 	$end
00:000100+01F7FC
00:000101+7F0000
00:000102+7CD38BAD344C64F0DD0432C5
03:003000+74686520726573756C742069732025660A00
:$(00):000040:000106 :$(03):003000:003006 :$(1F):01F000:020000 

</pre>
By default automatic literals are assembled at the end of program section $(0)

<p>
The <b>$lit</b> directive may place automatic literals 
at the end of another program section
<pre	style="font-size:12pt;color:#0000FF">

[tag]	$lit	55

</pre>
If <b>$lit</b> directive has no argument, automatic literals are placed
at the end of the program section containing the <b>$lit</b> directive

<p>
A literal may contain a macro generating data or code
<pre	style="font-size:12pt;color:#0000FF">

$ masmx lstruct -lnk
MASMX 7r3
3/lstruct.msm
*EOF*
  :                            1 	$path		freeware/RTA1/rta
  :                            2: 	$include	def/rta.def
  :                            3: 	$include	t77.4/ip.def
  :                            4 	$path
  :                            5 
  :                            6 $(3:03000/$3)
  :                            7 buffer	$res		2048
  :                            8 $(0:64)
00:000040 970100              +9 	ex		(dl		$3($net_socket	127.0.0.1:8080))
  :                            10 	$do		$<256,$(0:256)
  :                            11 
*EOF*
00:000100+CF3800
03:003800+7F0000011F90
:$(00):000040:000101 :$(03):003000:003802 


</pre>

<a	name="tagged_literals"/>
<h3>4.2.2: Tagged Literals</h3>

A literal which is not automatic  has a literal pool
tag before the opening parenthesis
<pre	style="font-size:12pt;color:#0000FF">

$ masmx -lnz
MASMX 7r2
0/-INPUT>>

        $list   0
        $include        freeware/RTA1/rta/def/rta.def
        $list

$(3:03000/$literals3)
$(0:64)

	lx, xi		$literals3("this way to the gastronomy hall")

	$end
  :                            1 
  :                            428         $list
  :                            429 
  :                            430 $(3:03000/$literals3)
  :                            431 $(0:64)
  :                            432 
00:000040 553000              +433  lx, xi  $literals3("this way to the gastronomy hall")
  :                            434 
  :                            435  $end
03:003000+746869732077617920746F207468652067617374726F6E6F
6D792068616C6C0000
:$(00):000040:000041 :$(03):003000:00300B 

</pre>

<a	name="strings"/>
<h3>4.3: Character Strings</h3>

Strings generate the containing number of data words. The default byte size
is 8 bits and the default data code is ASCII
<pre	style="font-size:12pt;color:#0000FF">

$ masmx strings -ln
MASMX 7r2
3/strings.msm
*EOF*
  :                            1 	$set_option	"z"
00:000000 737472696E67        +2 	"string"
  :                            3 	$byte	12
00:000002 07307407206906E067  +4 	"string"
  :                            5 	$byte	16
00:000005 0073007400720069006E0067
                              +6 	"string"
  :                            7 	$byte	24
00:000009 00007300007400007200006900006E000067
                              +8 	"string"
  :                            9 	$byte	6
00:00000F CF4CA9BA7000        +10 	"string"
  :                            11 	$byte	7
Note: strings.msm Line 12: trailing zero bits in last data word of string
00:000011 E7D3969DD9C0        +12 	"string"
  :                            13 	$byte	8
00:000013 737472696E67        +14 	"string"
  :                            15 
*EOF*
:$(00):000000:000015 

</pre>
Padding to word fill is zero with option <b>-z</b> otherwise space

<p>
Strings may contain ASCII extensions like UTF-8 
<pre	style="font-size:12pt;color:#0000FF">

$ masmx -lnke
MASMX 7r3A Build 8
0/-INPUT>>
	"canoë"
	$end
00:000000  63616E 6FC3AB        +1  "canoë"
  :                            2  $end

</pre>
The last symbol in <a style="color:#0000FF">canoë</a> occupies more memory than the others

<p>
Nondisplay byte values can be placed in strings (see also <a href="http://timmilescox.github.io/masmx/masmx.html#cstring">-c option</a>)
<pre	style="font-size:12pt;color:#0000FF">

$ masmx -ln
MASMX 7r3
0/-INPUT>>
LF	$equ	10
edit	"the result is %f":LF:0
	$end
  :                            1 LF	$equ	10
00:000000 74686520726573756C742069732025660A00
                              +2 edit	"the result is %f":LF:0
  :                            3 	$end
:$(00):000000:000006 

</pre>
<p>
In <b>masmx.7r3</b> the masmx-internal label <b>$bits</b> contains
the number of bits containing the characters in the string after the
string is assembled

<p>
The number of characters in the string can be captured

<pre	style="font-size:12pt;color:#0000FF">

$ masmx -lnz
MASMX 7r3
0/-INPUT>>
	"abcd"
	+	$bits
	+	$bits/$byte
	$end
00:000000 616263640000        +1 	"abcd"
00:000002 000020              +2 	+	$bits
00:000003 000004              +3 	+	$bits/$byte
  :                            4 	$end
:$(00):000000:000004 

</pre>


<p>
Changed data code and byte size are effective for "strings" and for
number +'strings'
<pre	style="font-size:12pt;color:#0000FF">

$ masmx -ln
MASMX 7r3
0/-INPUT>>
	"789abc"
	$data_code	97:65,66,67
	"789abc"
	$byte	12
	"789abc"
	$ascii
	"789abc"
	$byte	8
	"789abc"
	$end
00:000000 373839616263        +1 	"789abc"
  :                            2 	$data_code	97:65,66,67
00:000002 373839414243        +3 	"789abc"
  :                            4 	$byte 12
00:000004 037038039041042043  +5 	"789abc"
  :                            6 	$ascii
00:000007 037038039061062063  +7 	"789abc"
  :                            8 	$byte 8
00:00000A 373839616263        +9 	"789abc"
  :                            10 	$end
:$(00):000000:00000C 


</pre>

<a	name="comma_fields"/>
<h3>4.4: Number Constants with Equal-Size Bit Fields</h3>

A number constant divided by commas means the containing word or words is of equal sized fields. The total size is one word regardless of value truncation, unless an override suffix is typed
<pre	style="font-size:12pt;color:#0000FF">

		$ masmx -ln
MASMX 7r3
0/-INPUT>>

RED48		$equ		48
GREEN72		$equ		72
BLUE240		$equ		240

	+	RED48, GREEN72, BLUE240
	+	0FFFC, 08003, 07001:d    

	+	15, 14, 12, 0, 5, 10
	+	7, 4, 3, 6,  6, 3, 2, 5
	$end
  :                            1 
  :                            2 RED48		$equ		48
  :                            3 GREEN72	$equ		72
  :                            4 BLUE240	$equ		240
  :                            5 
00:000000 3048F0              +6 	+	RED48, GREEN72, BLUE240
00:000001 FFFC80037001        +7 	+	0FFFC, 08003, 07001:d    
  :                            8 
00:000003 FEC05A              +9 	+	15, 14, 12, 0, 5, 10
00:000004 F1ECD5              +10 	+	7, 4, 3, 6,  6, 3, 2, 5
  :                            11 	$end
:$(00):000000:000005 


</pre>


<a	name="form"/>
<h2>5: $form Bit-Field Templates</h2>


Directive <a href="http://timmilescox.github.io/masmx/masmx.html#form">$form</a>
types an instruction or descriptor bit-field layout

The layout size is from one to eight words

<pre	style="font-size:12pt;color:#0000FF">

gate    $form		6, 18, 2, 22

	gate		7, ENTRY1, 2, START_PAGE_INDEX

</pre>

<a	name="instructions"/>
<h2>6: Instructions and Operands</h2>

Instructions are listed here in functional groups

<p>
Instructions are explained more in
<a href="rta.html#iset"> RTA1 Programmable Processor Architecture Specification 3.3: Instruction Set</a>

<p>
Most instructions imply an arithmetic operand in scalar registers or the internal stack.
All instructions derive an input or output from an effective address

<a	name="operands"/>
<h3>6.1: Register / Memory Operand Continuum</h3>
<p>
The address-side operand may be in storage or a register and may be an immediate value 

<p>
Data registers are in memory address space

<a	name="registers"/>
<h3>6.2: Programmable Register Model</h3>

<a	name="nar"/>
<h4>6.2.1: Two Non-Addressable Registers</h4>

There are two <a href="rta.html#nonar">non-addressable registers</a>, the 48-bit absolute program counter and the 24-bit processor state register

<p>
Absolute program counter is never stored

<p>
PC - B0 * 4096 is pushed on calls and interrupts. Iframe Name is then pushed on far calls and interrupts

<p>
On interrupt returns and far returns popped Iframe Name:Start Page Index -> B0 * 4096 is added to popped offset
and transferred to absolute program counter


<p>
PSR is stored and loaded at interrupt and interrupt return. Its flag assignments are
<pre	style="font-size:12pt;color:#0000FF">

		23             18   16     14           8   7   6   5   4   3         0
		_________________________________________________________________________
		| I | 0 0 0 0 | i i i | 0 | see$          | H | R | R | W | F | 0 0 | C |
		|   |         |       |   | 1 2 3 4 5 6 7 |   | Z |16 |16 | P |     |   |
		|___|_________|_______|___|_______________|___|___|___|___|_R_|_____|___|


		I = 0 = current state is application: registers are 0..127
		    1 =                    interrupt: registers are 128..255

		iii	interrupt mask

		see$1 = 0 = data window 01000..01FFF  = private stack window B1
		 	1 =				Thread Control Block

		see$2 = 0 = data window 02000..02FFF  = application vector list
			1 =				kernel vector list

		see$3
		see$4
		see$5
		see$6
		see$7	select kernel data windows instead of application windows B3..B7

		half$w = 0 = read / write thirdwords
			 1 = read / write halfwords

		b$streamZR = 0 = do not clear a at start of rsr instruction
			     1 = clear a at start of rsr instruction

		b$stream16r = 0 = use 24 bits of data words in Bitstream Read Channel
			      1 = use 16 bits

		b$stream16w = 0 = use 24 bits of data words in Bitstream Write Channel
			      1 = use 16 bits

		Flag 3 fp$r is used for teaming pairs of floating numbers to calculate 192-bit values
		When fp$r is asserted floating instructions store a minor result in registers 8..11

		carry$ = carry from high-order position of integer adds and integer negative adds


</pre>

<a	name="crii"/>

<a	name="ioar"/>
<h4>6.2.2: Architectural Space Mapped via I/O</h4>
<p>
Storage relocation pointers and limits are addressable by being mapped as I/O ports

<a	name="register_stack"/>
<h4>6.2.3: The Register Stack</h4>

The register stack is in program memory space

<p>
Applications and interrupts each have 128 registers in the 256-word internal stack

<p>
Application and interrupt spaces each have scalar arithmetic, pointer and special registers in their region of the internal stack

<p>
The part available for stack operations is in each case 104 registers

<p>
Macro libraries are supplied to reuse internal stack space for demanding behaviour like recursion

<p>
Target realtime behaviour contains parameters and local variables entirely
in the internal stack. This is achieved for kernel, IP stack and supplied applications

<pre	style="font-size:12pt;color:#0000FF">

			The Application Registers						  The Interrupt Registers
			_________________________						  _______________________


		 23			       0					 23			       0
		_________________________________					_________________________________
	0	|		r		|	repeat counter	 	128	|		r_x		|
		|_______________________________|					|_______________________________|
	1	|		k		|	mask register		129	|		k_x		|
		|_______________________________|					|_______________________________|
	2	|		x		|	index register		130	|		x_x		|
		|_______________________________|					|_______________________________|
	3	|		y		|	index register		131	|		y_x		|
		|_______________________________|					|_______________________________|
	4	|		a		|  arithmetic + index register	132	|		a_x		|
		|_______________________________|					|_______________________________|
	5	|		b		|  arithmetic + index register	133	|		b_x		|
		|_______________________________|					|_______________________________|
	6	|	mantissa2		|	arithmetic register	134	|	mantissa2_x		|
		|_______________________________|					|_______________________________|
	7	|	mantissa3		|	arithmetic register	135	|	mantissa3_x		|
		|_______________________________|					|_______________________________|
	8	|		aA		|	arithmetic register	136	|		aA_x		|
		|_______________________________|					|_______________________________|
	9	|		bA		|	arithmetic register	137	|		bA_x		|
		|_______________________________|					|_______________________________|
	10	|	mantissa2A		|	arithmetic register	138	|	mantissa2A_x		|
		|_______________________________|					|_______________________________|
	11	|	mantissa3A		|	arithmetic register	139	|	mantissa3A_x		|
		|_______________________________|					|_______________________________|
	12	|	    	 p		|	bitstream pointer write	140	|		p_x		|
		|_______________________________|					|_______________________________|
	13	|	   	 q		|	bitstream pointer read	141	|		q_x		|
		|_______________________________|					|_______________________________|
	14	|	  	 fp		|	index register		142	|		fp_x		|
		|_______________________________|					|_______________________________|
	15	|	  	 sp		|	index register		143	|		sp_x		|
		|_______________________________|					|_______________________________|
	16	|		d$save		|	scratch			144	|				|
		|_______________________________|					|_______________________________|
	17	|		d$save1		|	scratch			145	|				|
		|_______________________________|					|_______________________________|
	18	|		d$save2		|	scratch			146	|				|
		|_______________________________|					|_______________________________|
	19	|		d$save3		|     < scratch | fp rounding > 147	|	fp$guard		|
		|_______________________________|					|_______________________________|
	20	|	   RDATAC		|	bitstream counter read	148	|	REALTIME$_CLOCK		|
		|_______________________________|					|_______________________________|
	21	|	    RDATA		|	bitstream data read	149	|	PRIORITY$		|
		|_______________________________|					|_______________________________|
	22	|	   WDATAC		|	bitstream counter write	150	|	DAYCLOCK$U		|
		|_______________________________|					|_______________________________|
	23	|	    WDATA		|	bitstream data write	151	|	DAYCLOCK$ 		|
		|_______________________________|					|_______________________________|
	24	| maximum internal stack top	|				152	|				|
		|_______________________________|					|_______________________________|
	25	|				|				153	|				|
		|_______________________________|					|_______________________________|
	26	|				|				154	|				|
		|_______________________________|					|_______________________________|
	27	|				|				155	|				|




		|_______________________________|					|_______________________________|
	124	|				|				252	|				|
		|_______________________________|					|_______________________________|
	125	|				|				253	|				|
		|_______________________________|					|_______________________________|
	126	|				|				254	|				|
		|_______________________________|					|_______________________________|
	127	|				|	first pushed word	255	|				|
		|_______________________________|	on internal stack		|_______________________________|


</pre>

Bitstream channel buffer and counter registers only exist once at locations 20..23.
It is not envisaged that ISRs manipulate streams of bits, but if they do they must
first push <b>RDATAC RDATA / WDATAC WDATA</b>, because applications program those registers

<p>
If ISRs program bitstreams, interrupt registers <b>p_x</b> and <b>q_x</b> are used as bitstream
storage pointers, and ISRs need not save user registers <b>p</b> and <b>q</b>

<a	name="instruction_form"/>
<h3>6.3: Instruction Layout</h3>

<p>
Instructions have an operand type indicator <b>jjj</b>, an instruction code 
<b>fffff</b> and a 16-bit address field

<p>
Six jjj values are different operand types for 32 single-integer instructions
and two jjj values select two mores lists of instructions

<p>
If the jjj field is 5, the operand is 16-bit sign extended immediate
<pre	style="font-size:12pt;color:#0000FF">


				  23      18    15                            0
				_________________________________________________
				| fffff | 101 | &plusmn;16-bit sign extended immediate	|
				|_______|_jjj_|_________________________________|


				ax, xi		-20000
				push		600,,xi


</pre>
Otherwise, if bit 15 is zero, the operand address is a direct address 15 bits in size
<pre	style="font-size:12pt;color:#0000FF">

				  23      18    15  14                        0
				_________________________________________________
				| fffff | jjj | 0 | 15-bit direct address----->	|
				|_______|_____|___|_____________________________|



		$(3:03000)
		instance	$do	20000,keyvalue(instance)	+	KEYVALUE*instance**07FFFFF

		$(0)
				dl	keyvalue(19999)
				xor	keyvalue(19997)
				xorB	keyvalue(19998)



</pre>
If instruction bit 15 is one, the instruction has a 3 bit indirection-window/index-register selector <b>xxx</b>
and a 12-bit displacement field
<pre	style="font-size:12pt;color:#0000FF">

				  23      18    15  14    11                  0
				_________________________________________________
				| fffff | jjj | 1 | xxx | 12-bit displacement->	|
				|_______|_____|___|_____|_______________________|


</pre>
If xxx is zero or one, the address is indirect. Its pointer is in the first 8192 words
in the address space. These are
<blockquote>

	the 256 registers<br>
	words 256..4095 of the current instruction frame B0<br><br>

	the 4096 words of the current private stack frame B1 (or the thread control block if PSR flag see$1 is on)

</blockquote>
<pre	style="font-size:12pt;color:#0000FF">
		$(1:01000)
		redirection	$res	1
				
		$(0)
				lr	*redirection
				ql	*(ADDRESS_7_MEGAWORD)	. big indirect address
								. in 24-bit literal constant
				tp	*11

</pre>

If xxx is 2..7 then index register [x y a b fp sp] is added to to the unsigned
12-bit displacement to form the effective address
<pre	style="font-size:12pt;color:#0000FF">

		  23                                          0			  23                                          0
		_________________________________________________		_________________________________________________
		|		effective address		|<----- + ------|		[ x y a b fp sp ]		|
		|_______________________________________________|		|_______________________________________________|
				 	^			^
					|			|
					|	    +		|
					|			|
		  23      18    15  14    11                  0
		_________________________________________________
		| fffff | jjj | 1 | xxx | 12-bit displacement->	|
		|_______|_____|___|_____|_______________________|



				la	64, b, i
				ly	descriptor:dgram, fp




</pre>

<a	name="integer_instructions"/>
<h3>6.4: Single Integer Instructions</h3>
32 instructions carry out load / store / arithmetic / boolean operations on a single
integer. These 32 instructions have as their right-side operand another register, a storage word,
part of a storage word (half or third), the effective address as an immediate value, or a
sign-extended immediate value in the range -32768..+32767

<p>
Integer instructions access a word and either third-words or halfwords.
jjj = zero = operand is the storage word at ea
<pre	style="font-size:12pt;color:#0000FF">


				z	buffer+4
				pop	buffer+5[,,w0]	. w0 is the default
							. and need not be typed


</pre>
<p>
PSR designator <b>half$w</b> is zero if the program accesses third-words
and one if the program accesses halfwords. Bytes are sign-extended to 24
bits on read and unused fields are unchanged on byte write. Bytes are not
read from registers or written to registers. All registers including the
internal stack are read and written as one or two or four 24-bit words 

<pre	style="font-size:12pt;color:#0000FF">

		half$w = 0							half$w = 1
		__________							__________

		  23                                          0
		_________________________________________________
   jjj = 001	|	t1	|////unused/////|////unused/////|
		|_______________|____unchanged__|____unchanged__|


				xorB, t1	indicators



		  23                                          0			  23                                          0
		_________________________________________________		_________________________________________________
   jjj = 010	|////unused/////|	t2	|////unused/////|		|	    h1		|///unused//unchanged///|
		|____unchanged__|_______________|____unchanged__|		|_______________________|_______________________|


				ana		*margin,,t2					xor		crypto,b,h1




		  23                                          0			  23                                          0
		_________________________________________________		_________________________________________________
   jjj = 011	|////unused/////|////unused/////|	t3	|		|///unused//unchanged///|	    h2		|
		|____unchanged__|____unchanged__|_______________|		|_______________________|_______________________|

				
				mf		table, x, t3					ay, h2		interval



</pre>
jjj = 100 = the operand is the effective address used as an immediate
<pre	style="font-size:12pt;color:#0000FF">

				lb, i		4, a
				lr		2,b,i			

</pre>
jjj = 101 = the immediate operand is the 16 bits of the address fields
sign extended to 24 bits
<pre	style="font-size:12pt;color:#0000FF">


				ax, xi		-8


</pre>
<b>$equf</b> directive can represent all the subfield attributes of an operand
with one name
<pre	style="font-size:12pt;color:#0000FF">

		header_byte	$equf		directory, y, t1
		HARD_LINK	$equf		'H',,xi

				la		header_byte
				aa, xi		-HARD_LINK	. compare
</pre>

<a	name="sisi"/>
<h3>6.5: Single Integer Store Instructions</h3>

The store and the test integer instructions do not take immediate operands.
The ,,i and ,,xi options of instructions sr sk sx sy sa sb z pop tz tp
are assigned to I/O and control instructions which take only an immediate
operand

The integer store instructions do not update <b>carry$</b>

<pre	style="font-size:12pt;color:#0000FF">

	_________________________________________________________________________________________________________
	|	mnemonic|   fffff.jjj	|			|		jjj				|	
	|_______________|_______________|_______________________|_______________________________________________|
	|	<a href="rta.html#sr">sr</a>	|   00000.0jj	|  store repeat counter	| [w0] ++ [t1 t2 t3] -- [h1 h2]			|
	|_______________|_______________|_______________________|_______________________________________________|
	|	<a href="rta.html#sk">sk</a>	|   00001.0jj	|  store mask register	| [w0] ++ [t1 t2 t3] -- [h1 h2]			|
	|_______________|_______________|_______________________|_______________________________________________|
	|	<a href="rta.html#sx">sx</a>	|   00010.0jj	|  store x		| [w0] ++ [t1 t2 t3] -- [h1 h2]			|
	|_______________|_______________|_______________________|_______________________________________________|
	|	<a href="rta.html#sy">sy</a>	|   00011.0jj	|  store y		| [w0] ++ [t1 t2 t3] -- [h1 h2]			|
	|_______________|_______________|_______________________|_______________________________________________|
	|	<a href="rta.html#sa">sa</a>	|   00100.0jj	|  store a		| [w0] ++ [t1 t2 t3] -- [h1 h2]			|
	|_______________|_______________|_______________________|_______________________________________________|
	|	<a href="rta.html#sb">sb</a>	|   00101.0jj	|  store b		| [w0] ++ [t1 t2 t3] -- [h1 h2]			|
	|_______________|_______________|_______________________|_______________________________________________|
	|	<a href="rta.html#z">z</a>	|   00110.0jj	|  zero			| [w0] ++ [t1 t2 t3] -- [h1 h2]			|
	|_______________|_______________|_______________________|_______________________________________________|
	|	<a href="rta.html#pop">pop</a>	|   00111.0jj	|  pop internal stack	| [w0] ++ [t1 t2 t3] -- [h1 h2]			|
	|_______________|_______________|_______________________|_______________________________________________|


	Assembly Language Examples
	__________________________

	<div    style="color:FF0000">
	sx		save_pointer
        sb, h2          control_word, y
	sa		total
        z               lock_cell, x
	sr		*(HIGH_ADDRESS)
        <div>
	<div	style="color:0000FF">
	push, t1	before
	push		update<div><div    style="color:FF0000">
	pop		before
	pop, t1		before
	</div>

</pre>

<a	name="sili"/>
<h3>6.6: Single Integer Load Instructions</h3>

The integer load instructions do not update <b>carry$</b>

<pre	style="font-size:12pt;color:#0000FF">



        _________________________________________________________________________________________________________
        |       mnemonic|   fffff.jjj   |                       |               jjj                             |
	|_______________|_______________|_______________________|_______________________________________________|
	|	<a href="rta.html#lr">lr</a>	|   01000.jjj	|  load repeat counter	| [w0] ++ [t1 t2 t3] -- [h1 h2]	++ [i xi]	|
	|_______________|_______________|_______________________|_______________________________________________|
	|	<a href="rta.html#lk">lk</a>	|   01001.jjj	|  load mask register	| [w0] ++ [t1 t2 t3] -- [h1 h2]	++ [i xi]	|
	|_______________|_______________|_______________________|_______________________________________________|
	|	<a href="rta.html#lx">lx</a>	|   01010.jjj	|  load x		| [w0] ++ [t1 t2 t3] -- [h1 h2]	++ [i xi]	|
	|_______________|_______________|_______________________|_______________________________________________|
	|	<a href="rta.html#ly">ly</a>	|   01011.jjj	|  load y		| [w0] ++ [t1 t2 t3] -- [h1 h2]	++ [i xi]	|
	|_______________|_______________|_______________________|_______________________________________________|
	|	<a href="rta.html#la">la</a>	|   01100.jjj	|  load a		| [w0] ++ [t1 t2 t3] -- [h1 h2]	++ [i xi]	|
	|_______________|_______________|_______________________|_______________________________________________|
	|	<a href="rta.html#lb">lb</a>	|   01101.jjj	|  load b		| [w0] ++ [t1 t2 t3] -- [h1 h2]	++ [i xi]	|
	|_______________|_______________|_______________________|_______________________________________________|
	|	<a href="rta.html#push">push</a>	|   11111.jjj	|  push internal stack	| [w0] ++ [t1 t2 t3] -- [h1 h2]	++ [i xi]	|
	|_______________|_______________|_______________________|_______________________________________________|



	Assembly Language Examples
	__________________________

	<div    style="color:FF0000">
	lr	HOW_MANY,,xi
	lk	(0FFC000s)

	ly	*pointer_array_cursor
	la	8, y
	lb, i	6, a

	push, t1        before
        push            update
	</div>


</pre>
push decrements the internal stack pointer and loads one register in the internal
stack with the operand value. If application sp is outside the range 25..128
before the operation the guard interrupt intervenes


<a	name="ti"/>
<h3>6.7: Test Instructions</h3>

The integer test instructions do not update <b>carry$</b>

<p>
The operand is tested for zero or for bit 23=0. If so, the next instruction is skipped. Storage half-and
third-words are sign-extended

<pre	style="font-size:12pt;color:#0000FF">

        _________________________________________________________________________________________________________
        |       mnemonic|   fffff.jjj   |                       |               jjj                             |
        |_______________|_______________|_______________________|_______________________________________________|
	|	<a href="rta.html#tz">tz</a>	|   01110.0jj	|  test zero skip	| [w0] ++ [t1 t2 t3] -- [h1 h2]			|
	|_______________|_______________|_______________________|_______________________________________________|
	|	<a href="rta.html#tp">tp</a>	|   01111.0jj	|  test positive skip	| [w0] ++ [t1 t2 t3] -- [h1 h2]			|
	|_______________|_______________|_______________________|_______________________________________________|


	Assembly Language Examples
	__________________________

  :                            430 $(3:03000)
  :                            431 left		$res	1
  :                            432 right	$res	1
  :                            433 
  :                            434 $(0:64)
  :                            435 examine<div	style="color:red">
00:000040 783000              +436 	tp	left 
00:000041 B60046              +437 	j	left_is_negative
00:000042 703001              +438 	tz	right
00:000043 B60046              +439 	j	right_is_nonzero</div>
  :                            440 
00:000044 650000              +441	la, xi	0 
00:000045 350000              +442 	lret 0
  :                            443 
  :                            444 left_is_negative
  :                            445 right_is_nonzero
00:000046 65FFFF              +446 	la, xi	-1
00:000047 350000              +447 	lret	0


</pre>

<a	name="xai"/>
<h3>6.8: Index Register Add  Instructions</h3>

The index register add instructions do not update <b>carry$</b>

<pre	style="font-size:12pt;color:#0000FF">


        _________________________________________________________________________________________________________
        |       mnemonic|   fffff.jjj   |                       |               jjj                             |
        |_______________|_______________|_______________________|_______________________________________________|
        |       <a href="rta.html#ax">ax</a>      |   10000.jjj   |  x += operand		| [w0] ++ [t1 t2 t3] -- [h1 h2] ++ [i xi]       |
        |_______________|_______________|_______________________|_______________________________________________|
        |       <a href="rta.html#ay">ay</a>      |   10001.jjj   |  y += operand		| [w0] ++ [t1 t2 t3] -- [h1 h2] ++ [i xi]       |
        |_______________|_______________|_______________________|_______________________________________________|


	Assembly Language Examples
	__________________________

	<div  style="color:FF0000">
	ax, xi	-30000
	ay	increment
	</div>
</pre>

<a	name="booli"/>
<h3>6.9: Boolean Algebra Instructions</h3>

The boolean algebra instructions do not update <b>carry$</b>

<pre	style="font-size:12pt;color:#0000FF">


        _________________________________________________________________________________________________________
        |       mnemonic|   fffff.jjj   |                       |               jjj                             |
        |_______________|_______________|_______________________|_______________________________________________|
        |       <a href="rta.html#or">or</a>      |   10010.jjj   |  a OR operand ->a	| [w0] ++ [t1 t2 t3] -- [h1 h2] ++ [i xi]       |
        |_______________|_______________|_______________________|_______________________________________________|
        |       <a href="rta.html#orB">orB</a>     |   10011.jjj   |  b OR operand ->b     | [w0] ++ [t1 t2 t3] -- [h1 h2] ++ [i xi]       |
        |_______________|_______________|_______________________|_______________________________________________|
        |       <a href="rta.html#and">and</a>     |   10100.jjj   |  a AND operand ->a	| [w0] ++ [t1 t2 t3] -- [h1 h2] ++ [i xi]       |
        |_______________|_______________|_______________________|_______________________________________________|
        |       <a href="rta.html#andB">andB</a>    |   10101.jjj   |  a AND operand ->b	| [w0] ++ [t1 t2 t3] -- [h1 h2] ++ [i xi]       |
        |_______________|_______________|_______________________|_______________________________________________|
        |       <a href="rta.html#xor">xor</a>     |   10110.jjj   |  a XOR operand ->a	| [w0] ++ [t1 t2 t3] -- [h1 h2] ++ [i xi]       |
        |_______________|_______________|_______________________|_______________________________________________|
        |       <a href="rta.html#xorB">xorB</a>    |   10111.jjj   |  b XOR operand ->b	| [w0] ++ [t1 t2 t3] -- [h1 h2] ++ [i xi]       |
        |_______________|_______________|_______________________|_______________________________________________|


	Assembly Language Examples
	__________________________

	<div  style="color:FF0000">

	orB,xi	BASE_32
	or	(0800000s)
	and	mask,,h2

	xor	key, x
	xorB	key+1, x

	</div>

</pre>

<a	name="siai"/>
<h3>6.10: Single Integer Add Instructions</h3>

<p>
The single integer add instructions add the operand or its 2s complement
to arithmetic register a or b

<p>
carry from bit 23 of the addition is stored in <b>carry$</b>.
Carry is not inverted after negative adds. They write carry as the positive add
of the 2s complement would write carry

<pre	style="font-size:12pt;color:#0000FF">

        _________________________________________________________________________________________________________________
        |       mnemonic|   fffff.jjj   |				|               jjj                             |
        |_______________|_______________|_______________________________|_______________________________________________|
        |       <a href="rta.html#aa">aa</a>      |   11000.jjj   |  a += operand			| [w0] ++ [t1 t2 t3] -- [h1 h2] ++ [i xi]       |
        |_______________|_______________|_______________________________|_______________________________________________|
        |       <a href="rta.html#ab">ab</a>      |   11001.jjj   |  b += operand			| [w0] ++ [t1 t2 t3] -- [h1 h2] ++ [i xi]       |
        |_______________|_______________|_______________________________|_______________________________________________|
        |       <a href="rta.html#ana">ana</a>     |   11010.jjj   |  a += 2s complement of operand| [w0] ++ [t1 t2 t3] -- [h1 h2] ++ [i xi]       |
        |_______________|_______________|_______________________________|_______________________________________________|
        |       <a href="rta.html#anb">anb</a>     |   11011.jjj   |  b += 2s complement of operand| [w0] ++ [t1 t2 t3] -- [h1 h2] ++ [i xi]       |
        |_______________|_______________|_______________________________|_______________________________________________|



	Assembly Language Examples
	__________________________

	<div  style="color:FF0000">
	aa	0, b
	ab, xi	-INCREMENT
	ana	6, x
	</div>

</pre>

<a	name="mi"/>
<h3>6.11: Multiply</h3>

The integer multiply instruction multiplies arithmetic register b algebraically 
by the operand and stores the 48-bit product in arithmetic registers a:b
<p>

<b>carry$</b> is not updated

<pre	style="font-size:12pt;color:#0000FF">


        _________________________________________________________________________________________________________
        |       mnemonic|   fffff.jjj   |                       |               jjj                             |
        |_______________|_______________|_______________________|_______________________________________________|
        |       <a href="rta.html#m">m</a>	|   11100.jjj   |  a:b = b * operand	| [w0] ++ [t1 t2 t3] -- [h1 h2] ++ [i xi]       |
        |_______________|_______________|_______________________|_______________________________________________|


	Assembly Language Examples
	__________________________

	<div  style="color:FF0000">
	m	scale, x
	</div>

</pre>

<a	name="mf"/>
<h3>6.12: Multiply Fractional</h3>

Multiply Fractional instruction multiplies arithmetic register b by the
operand and stores the 48-bit product in arithmetic registers a:b

<p>
The multiplier is treated as signed and the multiplicand is treated
as unsigned

<p>
Multiply Fractional is used to render binary fractions integrally
for editing and conversion, and may also be used serially to multiply
integer multiplicands more than one word in length

<p>
<b>carry$</b> is not updated

<pre	style="font-size:12pt;color:#0000FF">


        _________________________________________________________________________________________________________
        |       mnemonic|   fffff.jjj   |                       |               jjj                             |
        |_______________|_______________|_______________________|_______________________________________________|
        |       <a href="rta.html#mf">mf</a>	|   11101.jjj   |  a:b = b * operand	| [w0] ++ [t1 t2 t3] -- [h1 h2] ++ [i xi]       |
        |_______________|_______________|_______________________|_______________________________________________|



	Assembly Language Examples
	__________________________

	<div  style="color:FF0000">
	mf	1000,,xi
	</div>

</pre>

<a	name="di"/>
<h3>6.13: Divide</h3>

The integer divide instruction algebraically divides the 48-bit
dividend in arithmetic registers a:b by the 24-bit divisor. The
remainder is stored in b. The low order 24 bits of the quotient
are stored in a. The high-order 24 bits of the quotient are
stored in register 6 mantissa2

<p>
<b>carry$</b> is not updated

<pre	style="font-size:12pt;color:#0000FF">


        _________________________________________________________________________________________________________________
        |       mnemonic|   fffff.jjj   |				|               jjj                             |
        |_______________|_______________|_______________________________|_______________________________________________|
        |       <a href="rta.html#d">d</a>	|   11110.jjj   |	a:b /= operand		| [w0] ++ [t1 t2 t3] -- [h1 h2] ++ [i xi]       |
        |_______________|_______________|_______________________________|_______________________________________________|
					|   a = qotient 23:0		|
					|_______________________________|
					|   b = remainder		|
					|_______________________________|
					|   mantissa2 = quotient 47:24	|
					|_______________________________|



		 47                   23                       0
		_________________________________________________
		|    dividend 47..24	|    dividend 23..0	|
	before	|_______________________|_______________________|
	______		register a		register b



		 23                    0 23                    0 47                   24
		_________________________________________________________________________
		|      quotient 23..0	|    remainder 23..0	|    quotient 47..24	|
	after	|_______________________|_______________________|_______________________|
	____		register a		register b		register 6




	Assembly Language Examples
	__________________________


	<div  style="color:FF0000">
	d	proportions, y
	d, xi	1000
	</div>

</pre>


<a	name="llsi"/>
<h3>6.14: Large Load and Store Instructions</h3>
<pre	style="font-size:12pt;color:#0000FF">

        _________________________________________________________________________________________________________
        |       mnemonic|   fffff.jjj   |                       |               action                          |
        |_______________|_______________|_______________________|_______________________________________________|
        |       <a href="rta.html#ds">ds</a>      |   11000.111   |  double store		| a:b -> 2 words @ ea				|
        |_______________|_______________|_______________________|_______________________________________________|
        |       <a href="rta.html#dl">dl</a>      |   11001.111   |  double load		| 2 words @ ea -> a:b				|
        |_______________|_______________|_______________________|_______________________________________________|
        |       <a href="rta.html#dpush">dpush</a>   |   01011.111   |  double push		| sp -= 2, 2 words @ ea added to internal stack	|
        |_______________|_______________|_______________________|_______________________________________________|
        |       <a href="rta.html#qs">qs</a>      |   01000.111   |  quadruple store      | a:b:mantissa2:mantissa3 -> 4 words @ ea	|
        |_______________|_______________|_______________________|_______________________________________________|
        |       <a href="rta.html#ql">ql</a>      |   01001.111   |  quadruple load	| 4 words @ ea -> a:b:mantissa2:mantissa3       |
        |_______________|_______________|_______________________|_______________________________________________|
        |       <a href="rta.html#qpop">qpop</a>	|   10000.111   |  quadruple pop	| 4 words @ internal stack top -> 4 words @ ea  |
        |_______________|_______________|_______________________|_______________________________________sp_+=_4_|
        |       <a href="rta.html#qpush">qpush</a>   |   10001.111   |  quadruple push	| sp -= 4, 4 words @ ea added to internal stack |
        |_______________|_______________|_______________________|_______________________________________________|


	Assembly Language Examples
	__________________________


	<div  style="color:FF0000">
	qpush	from, y
	qpop	to, x

	ql	float
	qs	0, sp

	dl	socka
	ds	save
	</div>

</pre>

<a	name="liai"/>
<h3>6.15: Large Integer Arithmetic Instructions</h3>

<pre	style="font-size:12pt;color:#0000FF">

        _________________________________________________________________________________________________________
        |       mnemonic|   fffff.jjj   |                       |               action                          |
        |_______________|_______________|_______________________|_______________________________________________|
        |       <a href="rta.html#da">da</a>      |   11010.111   |  double add		| a:b += 2 words @ ea, carry from MS bit of add	|       
        |_______________|_______________|_______________________|_______________________________________________|
        |       <a href="rta.html#dan">dan</a>	|   11011.111   |  double add negative	| a:b += 2s complement of 2 words @ ea, 	|
        |_______________|_______________|_______________________|______________________carry_from_MS_bit_of_add_|
        |       <a href="rta.html#sc">sc</a>      |   10110.111   |  store carry          | PSR AND 1 -> word @ ea			|
        |_______________|_______________|_______________________|_______________________________________________|
        |       <a href="rta.html#mlb">mlb</a>	|   10111.111   |  masked load b	| b AND NOT k OR word @ ea AND k -> b		|
        |_______________|_______________|_______________________|_______________________________________________|
        |       <a href="rta.html#mta">mta</a>     |   10101.111   |  masked test equal	| skip if a AND k = word @ ea AND k		|
        |_______________|_______________|_______________________|_______________________________________________|
        |       <a href="rta.html#lsc">lsc</a>     |   10100.111   |  load shift & count	| 1 word @ ea -> a, rotate left [sign bits]	|
        |_______________|_______________|_______________________|_______________________________count in b______|
        |       <a href="rta.html#dlsc">dlsc</a>    |   11100.111   |double load shift&count| 2 words @ ea -> a:b, rotate left [sign bits]	|
        |_______________|_______________|_______________________|__________________________count_in_mantissa2___|
        |       <a href="rta.html#ex">ex</a>	|   10010.111   |  execute		| execute the instruction @ ea			|
        |_______________|_______________|_______________________|_______________________________________________|


	Assembly Language Examples
	__________________________

	<div  style="color:FF0000">
	da	INTERVAL
	dan	usecs
	</div><div      style="color:0000FF">
	la	('F'*/16)
	lk	(255*/16s)
	</div><div      style="color:FF0000">
	mta	0, fp
	</div><div	style="color:0000FF">
	j	not_file_descriptor
	lk	(00FFFF)
	</div><div      style="color:FF0000">
	mlb	0, fp

	da	more
	sc	wrapped

	dlsc	integer2

	</div>
</pre>


<a	name="fpai"/>
<h3>6.16: Floating Arithmetic Instructions</h3>

<a	name="fp96i"/>
<h4>6.16.1: The 96-Bit Floating Point Model</h4>

RTA1 floating arithmetic is ones complement

<p>
Floating numbers used in the four arithmetic function instructions are 96 bits or four words

<p>
The midpoint exponent is 23 bits and the all-fraction mantissa is 72 bits

<pre	style="font-size:12pt;color:#0000FF">



        _________________________________________________________________________________________________
        |s|	 exponent	|			      mantissa					|
        |_|_____________________|_______________________________________________________________________|
        95 94                 72 71                                                                    0


</pre>
Sign = 1 indicates that all 96 bits of the number are  inverted in 1s complement

<p>
The mantissa is a simple fraction without any integral field either represented or unrepresented. The integral value
is derived by hauling the mantissa leftward through the binary point the number of positions by which the exponent
exceeds its midpoint value of <b>0400000</b>

<p>
Exponent <b>0400000</b> indicates that the normalised magnitude is &ge;0.5 and &lt;1.0

<p>
The lowest or most microscopic exponent is <b>000000</b> The highest or most astronomic exponent is <b>07FFFFF</b>

<p>
Exponentiation range is the equivalent of around &plusmn;1262611 decimal places

<p>
A number is normalised if the normalising bit in position 71 is of opposite polarity to the sign

<p>
Positive and negative zero are the two numbers with normalising bit the same value as the sign.
All unnormalised numbers are computed as zero

<p>
The rounding guard pattern applied by the current program thread is held in interrupt register 149 (hex 93)
<b>fp$guard</b> and has the default value C00000 hex. It can be changed with the following system call and
the rounding value from before is returned in application register a
<pre	style="font-size:12pt;color:#0000FF">

	la	(<i>NEW_VALUE</i>)
	ii	FP_GUARD$

</pre>
<p>
Floating arithmetic instructions do not update <b>carry$</b>
<pre	style="font-size:12pt;color:#0000FF">

        _________________________________________________________________________________________________________
        |       mnemonic|   fffff.jjj   |                       |               action                          |
        |_______________|_______________|_______________________|_______________________________________________|
        |       <a href="rta.html#fpp">fpp</a>     |   01010.111   |  floating pop & pack	| 4 word fp number @ sp -> 2 word fp number @ ea|       
        |_______________|_______________|_______________________|_______________________________internal_sp_+= 4|
        |       <a href="rta.html#fpx">fpx</a>     |   01011.111   | floating push & expand| internal sp -= 4, 2 words @ ea -> 4 words @ sp|
        |_______________|_______________|_______________________|_______________________________________________|
        |       <a href="rta.html#fa">fa</a>      |   01100.111   |  floating add		| a:b:mantissa2:mantissa3 += 4 words @ ea	|
        |_______________|_______________|_______________________|_______________________________________________|
        |       <a href="rta.html#fan">fan</a>     |   01101.111   |  floating add negative| a:b:mantissa2:mantissa3 += 4 words @ ea XOR 1s|
        |_______________|_______________|_______________________|_______________________________________________|
        |       <a href="rta.html#fm">fm</a>	|   01110.111   |  floating multiply	| a:b:mantissa2:mantissa3 *= 4 words @ ea	|
        |_______________|_______________|_______________________|_______________________________________________|
        |       <a href="rta.html#fd">fd</a>	|   01111.111   |  floating divide	| a:b:mantissa2:mantissa3 /= 4 words @ ea	|
        |_______________|_______________|_______________________|_______________________________________________|


	Assembly Language Examples
	__________________________


$ masmx fp_array.msm -ln
MASMX 7r3
3/fp_array.msm
*EOF*
  :                            1 	$path		../def
  :                            2: 	$include	rta.def
  :                            3 
  :                            4 $(0:64)
  :                            5 
00:000040 770100              +6 ?	$do	6,	fm	(1*-?*3)
00:000041 770104              +6 
00:000042 770108              +6 
00:000043 77010C              +6 
00:000044 770110              +6 
00:000045 770114              +6 
  :                            7 	$do	$<256,$(0:256)
  :                            8 
*EOF*
00:000100+3FFFF783126E978D4FDF3B65
00:000104+3FFFED8637BD05AF6C69B5A7
00:000108+3FFFE389705F4136B4A59732
00:00010c+3FFFD98CBCCC096F5088CBFA
00:000110+3FFFCF901D7CF73AB0ACD910
00:000114+3FFFC59392EE8E921D5D073B
:$(00):000040:000118 


</pre>

<p>
Floating Pop and Pack instruction <href="rta.html#fpp">fpp</a> can compress numbers not requiring
mantissa precision larger than 36 bits or exponentiation outside the equivalent
of around &plusmn;305 decimal places from 96 bits at the internal stack top to
this 48-bit stored format

<pre	style="font-size:12pt;color:#0000FF">

        47 46      36 35                               0
        _________________________________________________
        |s|    11    |		     36			|
        |_|__________|__________________________________|

</pre>
Floating Push and Expand instruction <a href="rta.html#fpx">fpx</a> loads and expands compressed floating numbers to 96-bit compute format
at the internal stack top

<a	name="fp192i"/>
<h4>6.16.2: 192-Bit Floating Arithmetic</h4>

192-bit <a href="rta.html=rta1#fp">floating arithmetic</a> uses the four-function 96-bit floating instructions <a href="rta.html#fa">fa</a>
<a href="rta.html#fan">fan</a> <a href="rta.html#fm">fm</a> <a href="rta.html#fd">fd</a>
described at <a href="#fp96i">6.16.1: The 96-Bit Floating Point Model</a> 

<p>
Two 96-bit floating numbers are teamed to give an effective 144-bit mantissa. 
This is effected when PSR flag <b>fp$r</b> is asserted. 96-bit floating instructions
then store two floating results
 
<p>
The first result is stored in registers a:b:mantissa2:mantissa3 and is not rounded.
The second result is rounded and stored in registers 8:9:10:11, and is nonzero if the total
result does not fit in 96 bits. This minor result or residue is added to the next part
of the sum. The exponent of the minor part is the major exponent minus 72 minus the
normalising count of the minor mantissa
<pre	style="font-size:12pt;color:#0000FF">

	ql	first_addend
	on	fp$r		. switch residue on in PSR
	fa	second_addend	. generate a major and a minor sum
	qs	sum
	off	fp$r		. switch residue off
	ql	first_addend+4
	fa	second_addend+4	. add the second parts
	fa	$residue	. add the minor sum of the first addition
	qs	sum+4

</pre>
PSR flag <b>fp$r</b> and minor result <b>$residue</b> (registers 8..11) are used the same way with all four arithmetic operations
<pre	style="font-size:12pt;color:#0000FF">

	ql	minuend
	on	fp$r		. switch residue on in PSR
	fan	subtrahend	. generate a major and a minor difference
	off	fp$r		. switch residue off
	qs	difference
	ql	minuend+4
	fan	subtrahend+4	. find the difference between the second parts
	fa	$residue	. add the minor difference from the major part
	qs	difference+4


	ql	multiplicand
	on	fp$r		. switch residue on in PSR
	fm	multiplier	. generate a major and a minor product
	off	fp$r		. switch residue off
	qs	product
	ql	multiplicand+4
	fm	multiplier	. multiply the second part
	fa	$residue	. add the minor product of the first multiplication
	qs	product+4


	ql	dividend
	on	fp$r		. switch residue on in PSR
	fd	divisor		. generate a major and a minor quotient
	off	fp$r		. switch residue off
	qs	quotient
	ql	dividend+4
	fd	divisor		. divide the second part
	fa	$residue	. add the minor quiotient from dividing the first part
	qs	quotient+4

</pre>
If a multiplier is larger than 96 bits it is necessary to multiply by its major and
minor parts and then sum the two 192-bit products. Minor result <b>$residue</b> is
required during both multiply passes and the subsequent add of two 192-bit products

<p>
If a divisor is larger than 96 bits, a long multiply by the 192-bit reciprocal of the
divisor is advised. A divisor is longer than 96 bits if the decimal exponent
equivalent is less than zero or more than 31:

<pre	style="font-size:12pt;color:#0000FF">


        $ fp -U
        remote application socket 3 bind state 0 F 2 NB 0 udconnect state 0
        3.666666999999333333666666999999333333666666e1100000 / 3e-150000
        send state 65
        recv state 55/35 +1.222222333333111111222222333333111111222222e+1250000


</pre>


<p>
When a series of operations is iterated on one 192-bit value a large number of times,
any accumulation of rounding effects, and any accumulating discontinuity between major
and minor numbers should be suppressed. This is achieved with an intermittent
super-normalisation of the value. Its major and minor parts are summed with <b>fp$r</b>
asserted. The largest possible part of the total value is consequently stored in the
major part in registers a:b:mantissa2:mantissa3. The resulting zero or nonzero minor
part is stored in registers 8:9:10:11
<pre	style="font-size:12pt;color:#0000FF">

	  ql	minuend		. operation sequence
	  on	fp$r
	  fan	subtrahend
	  qs	difference
	  off	fp$r
	  ql	minuend+4
	  fan	subtrahend+4
	  fa	$residue

	on	fp$r		. super-normalise sequence
	fa	difference
	qs	difference
	off	fp$r
	ql	$residue

	  qs	difference+4	. completion of operation sequence


</pre>
<a	name="major_minor"/>
Procedural macro major_minor in rta/target.rta/lib/144.def generates floating constants in 192-bit format.<br>
These constants are two related and teamed 96-bit floating numbers
<pre	style="font-size:12pt;color:#0000FF">

$ masmx -lnk chaumi
MASMX 7r3A
3/chaumi.msm
*EOF*
  :                            1 	$path		../
  :                            2: 	$include	lib/144.def
  :                            3 	$path
  :                            4 $(3:03000)
03:003000 4000019C71C80B0DD1746C01
                              +5 	major_minor	1.222222333333444444555555666666777777888888
03:003004 3FFFB4CEDE8016BCC48852E0
                              +5 
  :                            6 
*EOF*
:$(03):003000:003008 

</pre>

<a	name="smi"/>
<h3>6.17: Storage Modify Instructions</h3>

Test and Set is only executed with any purpose on a storage location for inter-processor arbitration

<p>
The other seven modify instructions can be executed on a register or on storage. Execution on storage
causes a memory read followed by memory write. Execution on a register is at register-access speed
 
<pre	style="font-size:12pt;color:#0000FF">

        _________________________________________________________________________________________________________
        |       mnemonic|   fffff.jjj   |                       |               action                          |
        |_______________|_______________|_______________________|_______________________________________________|
        |       <a href="rta.html#ts">ts</a>      |   00000.111   |  test and set		| set bit 23 of word @ ea, skip if b23 was zero	|
        |_______________|_______________|_______________________|_______________________________________________|
        |       <a href="rta.html#n">n</a>	|   00001.111   |  negate		| word @ ea XOR= all 1s				|
        |_______________|_______________|_______________________|_______________________________________________|
        |       <a href="rta.html#inc">inc</a>	|   00010.111   |  increment		| word @ ea += 0000 0000 0000 0000 0000 0001	|
        |_______________|_______________|_______________________|______________________carry$_is_not_updated____|
        |       <a href="rta.html#dec">dec</a>	|   00011.111   |  decrement		| word @ ea += 1111 1111 1111 1111 1111 1111	|
        |_______________|_______________|_______________________|______________________carry$_is_not_updated____|
        |       <a href="rta.html#sim">sim</a>	|   00100.111   |  switch interrupt mask| switch interrupt mask with word @ea, b23:3 = 0|
        |_______________|_______________|_______________________|_______________________________________________|
        |       <a href="rta.html#popA">popA</a>    |   00101.111   |  pop and add to store	| word @ ea += word at internal stack top, sp++	|
        |_______________|_______________|_______________________|_____________________________carry$_is_updated_|
        |       <a href="rta.html#src">src</a>	|   00110.111   |shift right thru carry	| R.rotate word @ ea in 25-bit ring with carry	|
        |_______________|_______________|_______________________|_______________________________________________|
        |       <a href="rta.html#slc">slc</a>	|   00111.111	| shift left thru carry	| L.rotate word @ ea in 25-bit ring with carry	|
        |_______________|_______________|_______________________|_______________________________________________|


	Assembly Language Examples
	__________________________


		push, xi	MAXIMUM_INTERRUPT_MASK	. internal stack = register location<div style="color:FF0000">
		sim		0, sp
		ts		lock_word		. this has to be in memory</div>
		j		$-1			. try again

		.
		.

		z		lock_word		. free the resource<div style="color:FF0000">
		sim		0, sp			. restore the interrupt mask
		inc		sp			. restore the internal stack</div>

</pre>

<a	name="si"/>
<h3>6.18: Shift Instructions</h3>

Shift instructions use the effective address as the shift count.
An effective address may be indexed or indirect

<p>
Double shifts shift the value in arithmetic registers a and b as
a single 48-bit register

<p>
Shift instructions do not update <b>carry$</b>
<pre	style="font-size:12pt;color:#0000FF">

        _________________________________________________________________________________________________________________
        |       mnemonic|   fffff.jjj   |                       |               action                          	|
        |_______________|_______________|_______________________|_______________________________________________________|
        |       <a href="rta.html#sar">sar</a>	|   00000.110   |  shift a right	|  shift a [ea] bits right, zero fill vacated positions	|
        |_______________|_______________|_______________________|_______________________________________________________|
        |       <a href="rta.html#sbr">sbr</a>	|   00001.110   |  shift b right	|  shift b [ea] bits right, zero fill vacated positions	|
        |_______________|_______________|_______________________|_______________________________________________________|
        |       <a href="rta.html#dsr">dsr</a>	|   00010.110   |  double shift right	|shift a:b [ea] bits right, zero fill vacated positions	|
        |_______________|_______________|_______________________|_______________________________________________________|
        |       <a href="rta.html#sal">sal</a>	|   00100.110   |  shift a left		|  shift a [ea] bits left, zero fill vacated positions	|
        |_______________|_______________|_______________________|_______________________________________________________|
        |       <a href="rta.html#sbl">sbl</a>	|   00101.110   |  shift b left		|  shift b [ea] bits left, zero fill vacated positions	|
        |_______________|_______________|_______________________|_______________________________________________________|
        |       <a href="rta.html#dsl">dsl</a>	|   00110.110   |  double shift left	|shift a:b [ea] bits left, zero fill vacated positions	|
        |_______________|_______________|_______________________|_______________________________________________________|
        |       <a href="rta.html#rar">rar</a>	|   01000.110   |  rotate a right	|rotate a [ea] bits right, LS bit values to MS positions|
        |_______________|_______________|_______________________|_______________________________________________________|
        |       <a href="rta.html#rbr">rbr</a>	|   01001.110   |  rotate b right	|rotate b [ea] bits right, LS bit values to MS positions|
        |_______________|_______________|_______________________|_______________________________________________________|
        |       <a href="rta.html#drr">drr</a>	|   01010.110   |  double rotate right	|rotate a:b [ea] bits right,LS bitvalues to MS positions|
        |_______________|_______________|_______________________|_______________________________________________________|
        |       <a href="rta.html#ral">ral</a>	|   01100.110   |  rotate a left	| rotate a [ea] bits left, MS bit values to LS positions|
        |_______________|_______________|_______________________|_______________________________________________________|
        |       <a href="rta.html#rbl">rbl</a>	|   01101.110   |  rotate b left	| rotate b [ea] bits left, MS bit values to LS positions|
        |_______________|_______________|_______________________|_______________________________________________________|
        |       <a href="rta.html#drl">drl</a>	|   01110.110   |  double rotate left	|rotate a:b [ea] bits left, MS bitvalues to LS positions|
        |_______________|_______________|_______________________|_______________________________________________________|
        |       <a href="rta.html#saa">saa</a>	|   10000.110   |  shift a algebraic	|  shift a [ea] bits right, sign fill vacated positions	|
        |_______________|_______________|_______________________|_______________________________________________________|
        |       <a href="rta.html#sba">sba</a>	|   10001.110   |  shift b algebraic	|  shift b [ea] bits right, sign fill vacated positions	|
        |_______________|_______________|_______________________|_______________________________________________________|
        |       <a href="rta.html#dsa">dsa</a>	|   10010.110   | double shift algebraic|shift a:b [ea] bits right, sign fill vacated positions |
        |_______________|_______________|_______________________|_______________________________________________________|


	Assembly Language Examples
	__________________________

	<div	style="color:FF0000">
	dsa	48
	sbl	*log
	</div>


</pre>

<a	name="bsi"/>
<h3>6.19: Bit Stream Instructions</h3>

Read Staging Register instruction <b>rsr</b> shifts immediate bit count <b>xi</b> bits left from staging register RDATA
to arithmetic register a. Register RDATAC is decremented by shift count <b>xi</b>. If RDATAC reaches zero during the
transfer RDATA is reloaded from memory pointed by register *q++ and RDATAC is restarted at 24 bits. If PSR flag
<b>b$stream16r</b> = 1 the restart count in RDATAC is 16 and RDATA is shifted left 8 bit positions on reload. If PSR
flag <b>b$streamZR</b> = 1 arithmetic register a is cleared before the transfer

<p>

Write Staging Register instruction <b>wsr</b> shifts immediate bit count <b>xi</b> bits left from arithmetic register a
to staging register WDATA. Register WDATAC is incremented by shift count <b>xi</b>. If WDATAC reaches 24 during the
transfer WDATA is stored at memory pointed by register *p++ and WDATAC is restarted at zero. if PSR flag <b>b$stream16w</b>
= 1 data is stored and WDATAC restarted when WDATAC reaches 16

<pre	style="font-size:12pt;color:#0000FF">

        _________________________________________________________________________________________________________________
        |       mnemonic|   fffff.jjj   |                       |               action                                  |
        |_______________|_______________|_______________________|_______________________________________________________|
        |       <a href="rta.html#rsr">rsr</a>	|   10010.101   | read staging register	| shift [xi &le; 24] bits a<-RDATA [reload RDATA]		|
        |_______________|_______________|_______________________|_______________________________________________________|
        |       <a href="rta.html#wsr">wsr</a>	|   00011.101   |write staging register	| shift [xi &le; 24] bits WDATA<-a [store WDATA]		|
        |_______________|_______________|_______________________|_______________________________________________________|


	Assembly Language Examples
	__________________________

	<div    style="color:FF0000">
	rsr	$byte			. read a field from RDATA
	</div>

	<div    style="color:0000FF">
	sal	$word-$byte		. shift data to high-order positions
	</div><div    style="color:FF0000">
	wsr	$byte
	wsr	$word-$byte		. write latent bits from WDATA
	</div>


</pre>

<a	name="ji"/>
<h3>6.20: Jump Instructions</h3>

Jump instructions transfer execution to effective address within current address window B0

<p>
The effective address may be indexed or indirect

<p>
Absolute program counter is updated with B0 * 4096 + effective address

<pre	style="font-size:12pt;color:#0000FF">

        _________________________________________________________________________________________________________________
        |       mnemonic|   fffff.jjj   |                       |  action			symbol B0* = B0 * 4096	|
        |_______________|_______________|_______________________|_______________________________________________________|
        |       <a href="rta.html#j">j</a>	|   10110.110   |  jump			|  continue execution @ B0* + ea			|
        |_______________|_______________|_______________________|_______________________________________________________|
        |       <a href="rta.html#jdr">jdr</a>     |   00011.110   |  jump decrement r	|  add -1 to r, jump if r &ne; -1, carry is not updated	|
        |_______________|_______________|_______________________|_______________________________________________________|
        |       <a href="rta.html#jnc">jnc</a>	|   01011.110   |  jump no carry	|  jump if carry$ of PSR = zero				|
        |_______________|_______________|_______________________|_______________________________________________________|
        |       <a href="rta.html#jc">jc</a>	|   01111.110   |  jump carry		|  jump if carry$ of PSR = one				|
        |_______________|_______________|_______________________|_______________________________________________________|
        |       <a href="rta.html#jza">jza</a>	|   11000.110   |  jump zero a		|  jump if arithmetic register a = zero			|
        |_______________|_______________|_______________________|_______________________________________________________|
        |       <a href="rta.html#jzb">jzb</a>     |   11001.110   |  jump zero b		|  jump if arithmetic register b = zero			|
        |_______________|_______________|_______________________|_______________________________________________________|
        |       <a href="rta.html#jnza">jnza</a>	|   11010.110   |  jump nonzero a	|  jump if arithmetic register a = nonzero		|
        |_______________|_______________|_______________________|_______________________________________________________|
        |       <a href="rta.html#jnzb">jnzb</a>	|   11011.110   |  jump nonzero b	|  jump if arithmetic register b = nonzero		|
        |_______________|_______________|_______________________|_______________________________________________________|
        |       <a href="rta.html#jpa">jpa</a>	|   10100.110   |  jump positive a	|  jump if arithmetic register a high-order bit = zero	|
        |_______________|_______________|_______________________|_______________________________________________________|
        |       <a href="rta.html#jpb">jpb</a>	|   10101.110   |  jump positive b	|  jump if arithmetic register b high-order bit = zero	|
        |_______________|_______________|_______________________|_______________________________________________________|
        |       <a href="rta.html#jna">jna</a>	|   11100.110   |  jump negative a	|  jump if arithmetic register a high-order bit = one	|
        |_______________|_______________|_______________________|_______________________________________________________|
        |       <a href="rta.html#jnb">jnb</a>	|   11101.110   |  jump negative b	|  jump if arithmetic register b high-order bit = zero	|
        |_______________|_______________|_______________________|_______________________________________________________|
        |       <a href="rta.html#jao">jao</a>	|   10011.110   |  jump a odd		|  jump if arithmetic register a low-order bit = one	|
        |_______________|_______________|_______________________|_______________________________________________________|
        |       <a href="rta.html#jpo">jpo</a>	|   10111.110   |  jump parity odd	|  jump if a AND mask register k has odd parity		|
        |_______________|_______________|_______________________|_______________________________________________________|
        |       <a href="rta.html#jxge">jxge</a>	|   11110.110   |jump x greater or equal|  jump if index register x &ge; repeat counter r		|
        |_______________|_______________|_______________________|_______________________________________________________|
        |       <a href="rta.html#jyge">jyge</a>	|   11111.110   |jump y greater or equal|  jump if index register y &ge; repeat counter r		|
        |_______________|_______________|_______________________|_______________________________________________________|
        |       <a href="rta.html#jdz">jdz</a>	|   01111.100   |  jump double zero	|  jump if 48-bit integer in registers a and b = zero	|
        |_______________|_______________|_______________________|_______________________________________________________|
        |       <a href="rta.html#lcal">lcal</a>    |   00111.110   |  local call           |  push absolute PC - B0* on internal stack, jump to ea	|
        |_______________|_______________|_______________________|_______________________________________________________|


	Assembly Language Examples
	__________________________

	<div    style="color:FF0000">
	j	again?
again!



again?	jdr	again!

	</div><div    style="color:0000FF">
	lr	limit
	</div><div    style="color:FF0000">
	jxge	enough
	lcal	more
	jc	enough
	jnb	enough
	</div>

</pre>

<a	name="crii"/>
<h3>6.21: Call / Return, Iframe Jump, Internal Interrupt / Return</h3>

<pre	style="font-size:12pt;color:#0000FF">

        _________________________________________________________________________________________________________________________
        |       mnemonic|   fffff.jjj   |                       |  action				symbol B0* = B0 * 4096	|
        |_______________|_______________|_______________________|_______________________________________________________________|
	_________________________________________________________________________________________________________________________
        |       <a href="rta.html#lret">lret</a>	|   00110.101   |  local return		|  word @ internal stack top + xi + B0 * 4k -> PC, sp++		|
        |_______________|_______________|_______________________|_______________________________________________________________|



	_________________________________________________________________________________________________________________________
        |       <a href="rta.html#go">go</a>	|   11110.111   |  go to another iframe	|  target iframe page 0  -> B0: * 4k -> PC += vector		|
        |_______________|_______________|_______________________|_______________________________________________________________|


        _________________________________________________________
        |                                                       |
        |       Jump to Iframe                                  |
        |                                                       |
        |       Program Counter minus B0 * 4096                 |
        |       is pushed to internal stack                     |
        |                                                       |
        |       B0 is pushed to Internal Stack                  |
        |                                                       |       indirect operand pointing to gate constant or variable
        |       operand is storage word or register at EA       |
        |                                                       |        23                                                    0
        |                                                       |       _________________________________________________________
        |       if operand bit 23 = 1 --------------------------------> | 1 |               address of gate                     |____
        |       bits 22:0 point to a constant or variable       |       |___|___________________________________________________|    |
        |       containing a 48-bit gate value                  |            22                                                0     |
        |                                                       |                                                                    |
        |       if operand bit 23 = 0                           |                                                                    |
        |                                                       |                                                                    |
        |               bit 22 is reserved                      |                                                                    |
        |                                                       |                                                                    |
        |               bits 21:6 are a 16-bit index of the 1st |                                                                    |
        |               4K page of the target iframe            |       gate to target iframe:offset                                 |
        |                                                       |                                                                    |
        |               bits 5:0 are an entry point vector      |        47          42                                       24     |
        |               to locations 0..63 of the target iframe |       _________________________________________________________    |
        |                                                       |       | page high idx|        target instruction offset       |    |
        |_______________________________________________________|       |______________|________________________________________|<---+
        | 00 |       pointer to 4K-aligned page   |       vector|       | F 0 |                 iframe start page index         |
        |____|21__________________________________|5___________0|       |_____|_________________________________________________|
        |                                                       |              21                                              0
        |                                                       |
	|	        B0 = operand bits 21..6 >> 6            |		B0 = gate bits 21..0 Start Page Index
        |               Page High Index = 0                     |		Page High Index = bits 47..42 of gate
        |               Iframe Name = B0                        |		Iframe Name = B0 OR (Page High Index nonzero) 1 << 23
        |               B64 = B0                                |		B64 = B0 + Page High Index
        |               PC = B0 * 4096 + operand 5..0 offset    |		PC = B0 * 4096 + gate bits 41..24 offset
        |                                                       |
        |                                                       |
        |_______________________________________________________|________________________________________________________________
        |                                                                                                                       |
        |       operand is the  register or storage word at EA                                                                  |
        |_______________________________________________________________________________________________________________________|


	assembler examples	go		target_identifier[, {x|y|a|b|fp|sp}]

				go		*target_identifier_indirectly

				go		(LOCATION/4096*64++VECTOR_0_63)

				go		LITERALS_TAG(0800000++LITERALS_TAG(page_high_index*/18++offset, start_page_index:d)s)

						for large and namically loadable iframes see iframe and gate





	________________________________________________________________________________________________________________________
        |       <a href="rta.html#call">call</a>	|   11111.111   |  call another iframe	|  push offset:Iframe Name. target iframe -> B0 * 4K->PC+=vector|
        |_______________|_______________|_______________________|_______________________________________________________________|


        <a      name="call"/>
        Call                    call                                                            return address -> internal stack
        ____                    ____
                                                                         23                                                    0
        _________________________________________________________       _________________________________________________________
        |                                                       | <a style="color:#00FF00">sp + 1</a>|                       saved offset                    |
        |       Call Iframe                                     |	|_______________________________________________________|
        |                                                       | <a style="color:#00FF00">sp --></a>| F 0 |                 saved Start Page Index          |
        |       Program Counter minus B0 * 4096                 |	|_____|_________________________________________________|
        |       is pushed to internal stack                     |             |21                                              0
        |                                                       |
        |       Iframe Name pushed to Internal Stack            |         0 0 | <- B64 = B0 : Page High Index on return = 0
        |       = B0 -> bits 21:0 Start Page Index              |         1 0 | <- B64 > B0 : Page High Index on return
        |       + iframe size flags -> bits 23:22               |			      = gate bits 47:42 @ iframe + 64
        |                                                       |
        |                                                       |
        |_______________________________________________________|_______________________________________________________________
        |                                                       |
        |                                                       |
        |                                                       |       indirect target operand pointing to gate constant or variable
        |       operand is storage word or register at EA       |
        |                                                       |        23                                                    0
        |                                                       |       _________________________________________________________
        |       if operand bit 23 = 1 --------------------------------> | 1 |               address of gate                     |____
        |       bits 22:0 point to a constant or variable       |       |___|___________________________________________________|    |
        |       containing a 48-bit gate value                  |            22                                                0     |
        |                                                       |                                                                    |
        |       if operand bit 23 = 0                           |                                                                    |
        |                                                       |                                                                    |
        |               bit 22 is reserved                      |                                                                    |
        |                                                       |                                                                    |
        |               bits 21:6 are a 16-bit index of the 1st |                                                                    |
        |               4K page of the target iframe            |       gate to target iframe:offset                                 |
        |                                                       |                                                                    |
        |               bits 5:0 are an entry point vector      |        47          42                                       24     |
        |               to locations 0..63 of the target iframe |       _________________________________________________________    |
        |                                                       |       | page high idx|        target instruction offset       |    |
        |_______________________________________________________|       |______________|________________________________________|<---+
        | 00 |       pointer to 4K-aligned page   |       vector|       | F 0 |                 iframe Start Page Index         |
        |____|21__________________________________|5___________0|       |_____|_________________________________________________|
        |                                                       |              21                                              0
        |                                                       |
        |               B0 = operand bits 21..6 >> 6            |		B0 = gate bits 21..0 Start Page Index
        |               Page High Index = 0                     |		Page High Index = bits 47..42 of gate
        |               Iframe Name = B0                        |		Iframe Name = B0 OR (Page High Index nonzero) 1 << 23
        |               B64 = B0                                |		B64 = B0 + Page High Index
        |               PC = B0 * 4096 + operand 5..0 offset    |		PC = B0 * 4096 + gate bits 41..24 offset
        |                                                       |
        |                                                       |
        |_______________________________________________________|________________________________________________________________
        |                                                                                                                       |
        |       on internal stack overflow / underflow [sp < 26 | sp > 128] before operation guard interrupt 95 is raised       |
        |       operand is the  register or storage word at EA                                                                  |
        |_______________________________________________________________________________________________________________________|


	assembler examples	call		target_identifier[, {x|y|a|b|fp|sp}]

				call		*target_identifier_indirectly

				call		(LOCATION/4096*64++VECTOR_0_63)

				call		LITERALS_TAG(0800000++LITERALS_TAG(page_high_index*/18++offset, start_page_index:d)s)

						for large and namically loadable iframes see iframe and gate






	_________________________________________________________________________________________________________________________
        |       <a href="rta.html#fret">fret</a>	|   00111.101   |  far bank return	|  pop B0: * 4K -> PC += pop offset from internal stack += xi	|
        |_______________|_______________|_______________________|_______________________________________________________________|


                                                                                                            internal stack frame
                                                                         23                                                    0
        _________________________________________________________       _________________________________________________________
        |                                                       | <a style="color:#00FF00">sp + 1</a>|                       offset                          |
        |       Iframe Name is popped from the internal stack   |	|_______________________________________________________|
        |       and bits 21:0 Start Page Index written to B0    | <a style="color:#00FF00">sp --></a>| F 0 |                 iframe Start Page Index         |
        |                                                       |	|_____|_________________________________________________|
        |       return address offset in retrieved instruction  |       |   22|                                                0
        |       frame is popped from the internal stack         |       |     |
        |                                                       |       |
        |       sign extended immediate operand of the return   |       |
        |       instruction is added to iframe relative offset  |       |
        |                                                       |       |
        |       B0 * 4096 is added to iframe relative offset    |       |
        |                                                       |       | 0 0 | Page High Index = 0 : iframe pages 1
        |       the resulting absolute address is transferred   |       |     | B64 = B0
        |       to the program counter                          |       |
        |                                                       |       | 1 0 | gate descriptor @ target iframe + 64
        |       if sp = 128 before fret                         |       |     | Page High Index <- gate descriptor bits 47:42
        |       thread exit interrupt 70 is raised              |       |     | B64 = B0 + Page High Index - 1
        |                                                       |
        |       on internal stack overflow / underflow          |
        |       [sp < 24 | sp > 126 ^ 128] before operation     |
        |       guard interrupt 95 is raised                    |
        |_______________________________________________________|
        |       I/O Port 64 is updated to new highest page for  |
        |       instruction execution = B0 + Page High Index - 1|
        |                                                       |
        |       Page High Index is derived from flag values     |
        |       { 00 | 10 } in bits  23:22 of new Iframe Name   |
        |                                                       |
        |       flags value 00:                                 |
        |       gives Page High Index 0: iframe size 1 page     |       sample gate @ target iframe + 64
        |                                                       |
        |       flags value 10:                                 |        47          42                                       24
        |       Page High Index is read from bits 47:42 of the  |       _________________________________________________________
        |       sample gate at location 64 of target the iframe |       | Page High Idx|        offset 0                        |
        |_______________________________________________________|       |______________|________________________________________|
        |       DISPLACEMENT is 16-bit sign extended immediate  |       | x 0 |                 iframe Start Page Index         |
        |_______________________________________________________|       |_____|_________________________________________________|
                                                                               21                                              0



								_________________________________________________________________
								| ii and ir operate the interrupt stack. sp_x = register 143	|
	________________________________________________________|_______________________________________________________________|
        |       <a href="rta.html#ii">ii</a>	|   11110.101   |  internal interrupt	| push 0.PSR.B0.PC-B0*, xi 23:6 ->B0* -> PC += xi 5:0, PSR b23=1|
        |_______________|_______________|_______________________|_______________________________________________________________|

        <a      name="ii"/>
        Internal Interrupt      ii                                                              interrupt frame -> internal stack
        __________________      __


                                                                         23                                                    0
        _________________________________________________________       _________________________________________________________
        |                                                       | <a style="color:#00FF00">sp + 3</a>|                       saved offset                    |
        |       B0 * 4096 is subtracted from the value of       |	|_______________________________________________________|
        |       the absolute program counter                    | <a style="color:#00FF00">sp + 2</a>| F 0 |                 saved iframe Start Page Index   |
        |                                                       |	|_____|_________________________________________________|
        |       the resulting instruction frame relative value  | <a style="color:#00FF00">sp + 1</a>|   22                  saved PSR                       |
        |       is pushed on the interrupt internal stack       |	|                       ________________________________|
        |                                                       | <a style="color:#00FF00">sp --></a>|                       latent parameter                |
        |       Iframe Name = Start Page Index + size flags     |	|                       ________________________________|
        |       is pushed on the interrupt internal stack       |       |
        |                                                       |       |
        |       PSR is pushed on the interrupt internal stack   |       | 0 0 | B64 = B0 Page High Index on i-return = 0
        |                                                       |       | 1 0 | B64 > B0 Page High Index on i-return
        |       latent parameter 0                              |		      = gate bits 47:42 @ iframe + 64
        |       is pushed on the interrupt internal stack       |
        |-------------------------------------------------------|
        |                                                       |
        |       PSR Flag 23 = 1                                 |
        |                                                       |
        |       the high-order 18 bits of the immediate operand |
        |       designate a VECTOR_BANK                         |
        |                                                       |
        |       the low-order 6 bits if the immediate operand   |
        |       designate a VECTOR_OFFSET                       |
        |                                                       |
        |       B0 = VECTOR_BANK                                |
        |                                                       |
        |       program counter = VECTOR_BANK*4096+VECTOR_OFFSET|
        |_______________________________________________________|
        |       VECTOR_BANK                       |VECTOR_OFFSET|
        |23______________________________________6|5___________0|
        |       VECTOR is 16-bit sign extended immediate        |
        |_______________________________________________________|


        assembler syntax        ii      INTERRUPT_VECTOR

        assembler examples      ii      BANK_1*/6++2
                                ii      BANK_1*/6++11




	_________________________________________________________________________________________________________________________
        |       <a href="rta.html#ir">ir</a>	|   11111.101   |  interrupt return	| sp_x++, pop PSR.B0* -> PC += pop offset += xi			|
        |_______________|_______________|_______________________|_______________________________________________________________|


        <a      name="ir"/>
        Interrupt Return        ir
        ________________        __

                                                                                         interrupt / return internal stack frame

                                                                         23                                                    0
        _________________________________________________________       _________________________________________________________
        |                                                       | <a style="color:#00FF00">sp + 3</a>|                       saved offset                    |
        |                                                       |	|_______________________________________________________|
        |       saved PSR is retrieved from                     | <a style="color:#00FF00">sp + 2</a>| F 0 |                 saved iframe Start Page Index   |
        |       [interrupt internal stack pointer + 1]          |	|_____|_________________________________________________|
        |                                                       | <a style="color:#00FF00">sp + 1</a>|   22|                 saved PSR                       |
        |       saved Iframe Name is retrieved from             |	|                       ________________________________|
        |       [interrupt internal stack pointer + 2]          | <a style="color:#00FF00">sp --></a>|                       latent parameter                |
        |       and bits 21:0 Start Page Index transferred to B0|	|                       ________________________________|
        |                                                       |       |
        |       saved address offset in instruction frame       |       |
        |       is retrieved from                               |       |
        |       [interrupt internal stack pointer + 3]          |       | 0 0 | page high index = 0 : iframe pages 1
        |                                                       |       |     | B64 = B0
        |       the sign extended immediate operand of the ir   |       |
        |       instruction is added to iframe relative address |       | 1 0 | gate descriptor @ target iframe + 64
        |                                                       |       |     | page high index <- gate descriptor bits 47:42
        |       B0 * 4096 is added to iframe relative address   |       |     | B64 = B0 + Page High Index - 1
        |                                                       |
        |       the resulting absolute address is transferred   |
        |       to the program counter                          |
        |                                                       |
        |       interrupt internal stack pointer                |
        |       is incremented by 4                             |
        |_______________________________________________________|
        |       I/O Port 64 is updated to new highest page for  |
        |       instruction execution = B0 + Page High Index - 1|
        |                                                       |
        |       Page High Index is derived from flag values     |
        |       { 00 | 10 } in bits  23:22 of new Iframe Name   |
        |                                                       |
        |       flags value 00:                                 |
        |       gives Page High Index 0: iframe size 1 page     |       sample gate @ target iframe + 64
        |                                                       |
        |       flags value 10:                                 |        47          42                                       24
        |       Page High Index is read from bits 47:42 of the  |       _________________________________________________________
        |       sample gate at location 64 of the target iframe |       | Page High Idx|        offset 0                        |
        |_______________________________________________________|       |______________|________________________________________|
        |       DISPLACEMENT is 16-bit sign extended immediate  |       | x 0 |                 iframe Start Page Index         |
        |_______________________________________________________|       |_____|_________________________________________________|
                                                                               21                                              0


        assembler syntax        ir      SKIP_STEPS

        assembler examples      ir      0
                                ir      -1
                                ir      2



	Assembly Language Examples
	__________________________

  :                            430 $(3:03000)
  :                            431 left		$res	1
  :                            432 right	$res	1
  :                            433 
  :                            434 $(0:64)
  :                            435 examine<div	style="color:red">
00:000040 783000              +436 	tp	left 
00:000041 350000              +437 	lret	0	. return to instruction after lcal
00:000042 703001              +438 	tz	right
00:000043 350000              +439 	lret	0	. return to instruction after lcal
00:000044 350001              +440 	lret	1	. return and skip one instruction</div>


</pre>
Return instructions <a href="rta.html#lret">lret</a> <a href="rta.html#fret">fret</a> <a href="rta.html#ir">ir</a> have a sign extended immediate
operand which is added to the return address on the stack. Nonzero operand causes return
to a location before or after the return address on the stack

	<blockquote>
	<a href="rta.html#lret">lret</a> returns from <a href="rta.html#lcal">lcal</a><br><br>
	<a href="rta.html#fret">fret</a> returns from <a href="rta.html#call">call</a><br><br>
	<a href="rta.html#ir">ir</a> returns from interrupt
	</blockquote>

<p>
<a href="rta.html#lret">lret</a> transfers the word at the stack top + operand xi + B0 * 4096 to the program counter. sp++

<p>
<a href="rta.html#fret">fret</a> transfers to the word at the stack top to B0 then the next word + operand xi
+ B0 * 4096 to the program counter. sp += 2

Internal interrupt instruction <b>ii</b> also has a sign extended immediate operand. The
low-order six bits are a vector value. Bits 21..6 designate the 4K-word start address of
the bank containing the ISR
<pre	style="font-size:12pt;color:#0000FF">

$ masmx -kln
MASMX 7r3
0/-INPUT>>
	$path		freeware/RTA1/rta/def
	$list		0
	$include	rta.def
	$include	ii.def
	$list
$(0:64)
	ql		(routine, PRIORITY, PARAMETER, EXTERNAL_STACKFRAME:q)
	ii		THREAD$
	$do	$<256,$(0:256)
	$end
  :                            1  $path  freeware/RTA1/rta/def
  :                            581  $list
  :                            582 $(0:64)
00:000040 4F0100              +583  ql  (routine, PRIORITY, PARAMETER, EXTERNAL_STACKFRAME:q)<div style="color:FF0000">
00:000041 750047              +584  ii  THREAD$</div>
  :                            585  $do $<256,$(0:256)
  :                            586  $end
00:000100+[0003]18:[0002]18*/18:[0001]18*/30:[0000]18*/48:000000000000000000000000
:$(00):000040:000104 

</pre>

Interrupts construct a four-word stack frame at the interrupt internal stack top

<p>
If the interrupted routine is an application (PSR bit 23 = 0) then interrupt <b>sp</b> is
copied to interrupt <b>fp</b> to mark the interrupted application frame

<pre	style="font-size:12pt;color:#0000FF">

		_________________________________
	0,sp	|	latent parameter	|
		|_______________________________|
	1,sp	|	interrupted PSR		|
		|_______________________________|
	2,sp	|	interrupted iframe name	|
		|_______________________________|
	3,sp	|	interrupted PC minus B0*|
		|_______________________________|

</pre>
<a href="rta.html#ii">ii</a> instruction places a latent parameter value zero in the frame

<p>
<a href="rta.html#ir">ir</a> copies saved PSR to PSR and saved B0 to B0.
B0 * 4094 + interrupted offset + XI is written to the program counter. The frame is removed
from the stack

<p>
Inter-bank jumps <a href="rta.html#go">go</a> and <a href="rta.html#call">call</a> read a single word storiage operand of format 


<pre	style="font-size:12pt;color:#0000FF">

	    21		      6      0
	_______________________________
	|00|  Start Page Index |vector|
	|__|___________________|______|
	      16-bit pointer	6-bit
	      to 4K bank edge	vector

<div    style="color:FF0000">
		OR
</div>

	   22                        0			 47	41		    23			      0
	_______________________________			________________________________________________________
	|1|   	23-bit gate pointer   |---------------> |pagehx|  offset	   |	   iframe name	       |
	|_|___________________________|		   gate	|______|___________________|___________________________|

</pre>

<a href="rta.html#call">call</a> instruction pushes the program-counter minus B0 * 4096 on the internal stack
then pushes B0. <a href="rta.html#go">go</a> and <a href="rta.html#call">call</a> update the program counter
<pre	style="font-size:12pt;color:#0000FF">

	B0 = (operand bit 22) ? operand[21..3] * 8 : operand[21..6] / 64
	PC = B0 * 4096 ++ (operand bit 22) ? operand[2..0] : operand[5..0]


                        _____________________
                        go / call destination
                        _____________________
                                |					 47	41		    23			       0
                                |					_________________________________________________________
                operand b22 = 0 | operand b23 = 1 [operand b22:0]----->	|pagehx|      offset	   |	    iframe name		|
                ________________|________________		   gate	|______|___________________|____________________________|
                |                               |
        ________|________               ________|________
        | iframe name = |               | iframe name = |
        | operand >> 6  |               | gate 23:0	|
        |_______________|               |_______________|
                |                               |
        ________|________               ________|________
        | offset =      |               | offset =      |
        | operand AND 63|               | gate 41:24	|
        |_______________|               |_______________|
                |                               |
	________|________		________|________
	|page high index|		|page high index|
	|	     = 0|		|   = gate 47:42|
	|_______________|		|_______________|
                |_______________________________|
                                |
                        ________|________
			|B0 = iframe name
			|   & 3FFFFF    |
			|_______________|
				|
                        ________|________
                        | PC = B0 */ 12 |
                        | OR offset     |
                        |_______________|



$ masmx ibj -ln
MASMX 7r3
3/ibj.msm
freeware/RTA1/rta/fs/fs.txo:$(0) 477 words decimal from hexadecimal 000000 to 0001DD
*EOF*
  :                            1 
  :                            2: 	$include	freeware/RTA1/rta/def/rta.def
  :                            3 	$include,$void	freeware/RTA1/rta/fs/fs.txo	$(0)
  :                            4 $(0:64)
00:000040 FF0100              +5 	call		(seg$load)
  :                            6 
  :                            7 
  :                            8 	$do		$<256,$(0:256)
  :                            9 
*EOF*
00:000100+000187
:$(00):000040:000101 


</pre>


<a	name="crio"/>
<h3>6.22: Control and I/O Instructions</h3>


<pre	style="font-size:12pt;color:#0000FF">

        _________________________________________________________________________________________________________________
        |       mnemonic|   fffff.jjj   |                       |               action                                  |
        |_______________|_______________|_______________________|_______________________________________________________|
        |       <a href="rta.html#on">on</a>	|   00000.101   |   on PSR flags	|  PSR flags 15..0 OR= mask value xi			|
        |_______________|_______________|_______________________|_______________________________________________________|
        |       <a href="rta.html#off">off</a>	|   00001.101   |  off PSR flags	|  PSR flags 15..0 AND= NOT mask value xi		|
	|_______________|_______________|_______________________|_______________________________________________________|
	|       <a href="rta.html#inA">inA</a>	|   00000.100   |  I/O port ea in to a 	|							|
        |_______________|_______________|_______________________|_______________________________________________________|
        |       <a href="rta.html#inB">inB</a>	|   00001.100   |  I/O port ea in to b 	|  							|
        |_______________|_______________|_______________________|_______________________________________________________|
        |       <a href="rta.html#outA">outA</a>	|   00010.100   |  out a to I/O port ea	|  							|
        |_______________|_______________|_______________________|_______________________________________________________|
	|	<a href="rta.html#outB">outB</a>	|   00011.100	|  out b to I/O port ea |  							|
        |_______________|_______________|_______________________|_______________________________________________________|
        |       <a href="rta.html#reload">reload</a>	|   00100.100   |  reload base registers|  2 * bank index @ *a,*(a+1)->io ports[ea, ea+1]. a+=2	|
        |_______________|_______________|_______________________|_______________________________________________________|
        |	<a href="rta.html#sabr">sabr</a>	|   00110.100   |  store a base register|bank pointer[a]->io port[ea=2..63],index[a]->TCB+64+ea	|
        |_______________|_______________|_______________________|_______________________________________________________|


	Assembly Language Examples
	__________________________

	<div    style="color:FF0000">
	on	b$streamZR
	off	carry$

	inA	PORT_240
	outB	PORT_240
	</div>

	la	transmission:buffer_bank<div	style="color:FF0000">
	sabr	BSOCKB</div>
	<div	style="color:0000FF">
	on	see$1
	la, xi	ABT+2</div><div    style="color:FF0000">
	?	$do	23,	reload	?*2</div>

</pre>
<b>sabr</b> instruction copies the storage block identity to 
Thread Control Block + 64 + ea and writes the absolute value to I/O port[ea]

<p>
bank identity is identical to absolute value when bit 23 of the symbolic
identity is zero. Symbolic bank identities with bit 23 = one are not
implemented

<p>
<b>reload</b> instruction reads two storage block identifiers at the
address in register a and writes their absolute values to I/O port[ea]
and I/O port[ea + 1]. Register a is incremented by 2

<a	name="locators"/>
<h2>7: Application Memory and Location Counters</h2>

Applications are written in absolute code, as if each application occupies a computer

<p>
This is because RTA1 machine translates addresses using 72 I/O ports as relocation pointers

<p>
Program sections are declared with <a href="language.html#application_structure">location counter command</a> $(.. in column 1 

<p>
Instruction Frame is in $(0). See <a href="app.html">Simplest Application Structure</a>
and <a href="iframe.html">Large and Loadable Instruction Frames</a>

<p>
Multiple small applications can be packed in one 4096-word iframe. See <a href="#linking">Linking</a>

<p>
iframe shares its first page @ adresses 256..4095 with operand space but may have more pages of instructions from address 4096 outside operand space

<pre	style="font-size:12pt;color:#0000FF">

$(0::LOAD_SPACE_TAG/$0)		. iframe @ logical address zero
iframe_name	$application

$(1:01000)			. private data @ logical address 001000 hex

$(3:03000/$3)			. static data @ logical address 003000 hex

</pre>

Program or static date occupies as many windows 3..31 as required at addresses 003000..01F000 / 0C0000..7FFFFF

<p>
An application starts by placing assigned data memory in windows 3.. with
<a	href="language.html#base_d">$base_d</a> macro

and calling kernel routine <a href="language.html#seg_load">seg$load</a> to unpack initial data values from ROM image.
All RTA1 instruction code is shared code

<p>
Vector list which every application needs to run is preconstructed by the kernel in window 2 at addresses 002000..002FFF

<a      name="do"/>
<h2>8: $do Iteration</h2>

<b>$do</b> directive repeats a line of code
<pre	style="font-size:12pt;color:#0000FF">

[tag]	$do	count,[label]	command	[command_arguments]

</pre>

For example
<pre	style="font-size:12pt;color:#0000FF">

	$do	$o('k')=0,	$exit	this assembly requires option -k
</pre>

A column 1 tag on <b>$do</b> has a value incrementing from 1. This value
may be used in labels and values of iterated code

<pre	style="font-size:12pt;color:#0000FF">

$ masmx -klnx
MASMX 7r3
0/-INPUT>>
$(30:01E000)
TIMES	$set	5

index	$do	TIMES,float(TIMES+1-index)	1*+index-1
	$end
  :                            1 $(30:01E000)
  :                            2 TIMES $set 5
  :                            3 
1E:01E000 400001800000000000000000
                              +4 index $do TIMES,float(TIMES+1-index) 1*+index-1
1E:01E004 400004A00000000000000000
                              +4 
1E:01E008 400007C80000000000000000
                              +4 
1E:01E00C 40000AFA0000000000000000
                              +4 
1E:01E010 40000E9C4000000000000000
                              +4 
  :                            5  $end
TIMES=000005
index=000005
float(5)=$1E:01E000
float(4)=$1E:01E004
float(3)=$1E:01E008
float(2)=$1E:01E00C
float(1)=$1E:01E010
-INPUT>>=0<000000
:$(1E):01E000:01E014 

</pre>

The line of repeated code may be a macro name subassembling complex data or instructions

<a	name="proc"/>
<h2>9: $proc and $func Macros</h2>

<h3>9.1: $proc: Command and Instruction Macros</h3>

<b>$proc</b> directive heads an inline macro. <b>$end</b> directives ends all macros
and also ends the assembly. End of input also ends the assembly

<p>
Macros reference actual parameters as a function of their <b>$proc</b>
or <b>$func</b> label

<p>
For this reason macros tend to cryptic titles with separate
call names assigned a latent value with <b>$name</b> directive

<p>
Macro labels  are only visible if they are promoted with asterisk* Names
which are not promoted are reusable in the calling assembly. Many macros
may have the same <b>$proc</b> label, making paraform language easy to write
<pre	style="font-size:12pt;color:#0000FF">

$ masmx -ln
MASMX 7r3
0/-INPUT>>
p	$proc
dem1*	$name	33
dem2*	$name	99

	+	p(0, 0), p(1, 1), p(1, 3), p(2, 1:1)*p(2, 1:2):d
	$end

	dem1	0aaa,,-12 25:4
	dem2	0bbb,,12        3:3
	$end
  :                            1 p $proc
  :                            2 dem1* $name 33
  :                            3 dem2* $name 99
  :                            4 
  :                            5  + p(0, 0), p(1, 1), p(1, 3), p(2, 1:1)*p(2, 1:2):d
  :                            6  $end
  :                            7 
00:000000 021AAAFF4064        +8  dem1	0aaa,,-12	25:4
00:000002 063BBB00C009        +9  dem2	0bbb,,12	3:3
  :                            10  $end
:$(00):000000:000004 

</pre>

<b>$proc</b> macros interpret actual parameters from their <b>field,subfield:substring</b>
position. Parameters are referenced by the label on the <b>$proc</b> line which is in the
example above <b>p</b>

<p>
Actual parameters have, for example,  the syntax
<pre	style="font-size:12pt;color:#0000FF">

		<i>callname</i>	haddock	  5   44    chips, peas, salt:vinegar

</pre>
Reference paraforms have the syntax <b><i>macroname</i>([field[, subfield[:substring]]])</b>
<pre	style="font-size:12pt;color:#0000FF">


macroname	$proc

callname*	$name		100	

		macroname(1, 1)		. the first subfield of the first argument field, = <b>haddock</b>
		macroname(4, 3:2)	. the second substring of the third subfield
					. of the fourth argument field, = <b>vinegar</b>

		macroname(0, 0)		. the name used to invoke the macro, = <b>100</b>

		.
		.
		.
		$end


</pre>
The call name is <b><i>name_of_macro</i>(0, 0)</b> and has the latent value of the <b>$name</b> line

<p>
One macro may have any number of name lines
<pre	style="font-size:12pt;color:#0000FF">

p       $proc

sar*    $name   0
sbr*    $name   1
dsr*    $name   2
jdr*    $name   3

sal*    $name   4
sbl*    $name   5
dsl*    $name   6

</pre>
<b>$name</b> labels need to be promoted with an asterisk to be visible outside the macro.
The label of <b>$proc</b> is also allowed to be promoted with asterisk and callable if it
is unique in the assembly. However there is only one <b>$proc</b> line in the macro and a
latent value cannot be given 

<p>
Forward references are possible in two-pass <b>$proc</b> macros, flagged with *
<pre	style="font-size:12pt;color:#0000FF">

maybe*	$proc	*
	tp	estimation
	j	maybe_not
?	$do	maybe(),	lcal	maybe(?, 1)
maybe_not
	$end

</pre>

<i>proc_name</i> is the count of all the fields on the call line including any label

<p>
<i>proc_name</i>() is the count of actual argument fields after the callname

<p>
<i>proc_name</i>(&mu;) is the count of subfields in field &mu;

<p>
<i>proc_name</i>(&mu;,&nu;:) is the count of substrings in subfield &mu;,&nu;

<p>
If <i>proc_name</i>() is an argument calling another macro,
all the actual parameters are transferred to the new macro
at the same positions on the line
<pre	style="font-size:12pt;color:#0000FF">

$ masmx -ln
MASMX 7r3
0/-INPUT>>
p	$proc
forward* $name
 	inward	p()
	$end

p	$proc
inward*	$name
field	$do	p(),	+	p(field, 1)
	$end

	forward	10 20 40 99 101
	$end
  :                            1 p $proc
  :                            2 forward* $name
  :                            3  inward p()
  :                            4  $end
  :                            5 
  :                            6 p $proc
  :                            7 inward* $name
  :                            8 field $do p(), + p(field, 1)
  :                            9  $end
  :                            10 
00:000000 00000A              +11  forward 10 20 40 99 101
00:000001 000014              +11 
00:000002 000028              +11 
00:000003 000063              +11 
00:000004 000065              +11 
  :                            12  $end
:$(00):000000:000005 


</pre>
<p>
If <i>proc_name</i> is an argument calling another macro, all the fields in
the call line to the current macro, including any label, are arguments to
the called macro

<p>
If <i>proc_name</i>(&mu;) is an argument calling another macro,
all the subfields of field &mu; are forwarded

<p>
If <i>proc_name</i>(&mu;, &nu;) is an argument calling another macro,
the subfield &mu;,&nu; is forwarded to the called macro

<pre	style="font-size:12pt;color:#0000FF">
§
$ masmx sort_out -lnk
MASMX 7r3
3/sort_out.msm
*EOF*
  :                            1 
  :                            2 p	$proc
  :                            3 sort_out* $name
  :                            4 index	$equ	p()+1
  :                            5 ?	$do	p(),	+	p(1, 2), p(index-?, 1)
  :                            6 	$end
  :                            7 
  :                            8 p	$proc
  :                            9 backslang* $name
  :                            10 ?	$do	p(),	+	p(?, 1), p(?, 3), p(?, 2)
  :                            11 	$end
  :                            12 
  :                            13 p       $proc
  :                            14 yaname* $name		101
  :                            15         sort_out        p(0,0), p(0, 2)	p()
  :                            16         backslang       p(3) p(2) p(1)
  :                            17 	$end
  :                            18 
00:000000 028007              +19 	yaname,40	1, 2, 3		4, 5, 67, 8, 9
00:000001 028004              +19 
00:000002 028001              +19 
00:000003 028065              +19 
00:000004 070908              +19 
00:000005 040605              +19 
00:000006 010302              +19 
  :                            20 
*EOF*
:$(00):000000:000007 

</pre>

<p>
<i>proc_name</i>(&mu;,*&nu;) is a unary asterisk on subfield &mu;,&nu;.
Reference returns the value 1 if the asterisk is present, or 0

<pre	style="font-size:12pt;color:#0000FF">

$ masmx -ln
MASMX 7r3
0/-INPUT>>
star*	$proc
	+	star(1, *1)
	$end

$(4:04000)
galaxy	$res	6
	star	galaxy
	star	*galaxy
	$end
  :                            1 star* $proc
  :                            2  + star(1, *1)
  :                            3  $end
  :                            4 
  :                            5 $(4:04000)
  :                            6 galaxy $res 6
04:004006 000000              +7  star galaxy
04:004007 000001              +8  star *galaxy
  :                            9  $end
:$(04):004000:004008 


</pre>

<p>
Five more features of macro processing are shown here

<p>
Macros may contain macros, so only the outer macro can call the inner macro

<p>
<b>$proc</b> macros may be flagged with a location counter to assemble in a target
program section. Any 2-pass asterisk comes before the section flag and separate, as
<pre	style="font-size:12pt;color:#0000FF">

macro_name	$proc	*	$(TARGET_LOCATOR)

</pre>
Macros can construct a label combining a parameter with other symbols. The label is
constructed in quotes

<p>
Macros can assign a new value to the label on the call line. It is referenced
with an asterisk in column 1

<p>
Macros generate and use labels which are discarded at the end of the macro expansion.
Labels only remain for the calling level of assembly if they are promoted with trailing
asterisk

<p>
One asterisk is added to promote a label one  macro level. An asterisk at the main
assembly level externalises the label


<pre	style="font-size:12pt;color:#0000FF">
	
$ masmx indicate indicate -ln
MASMX 7r3
3/indicate.msm
*EOF*
  :                            1: 	$include	freeware/RTA1/rta/def/rta.def
  :                            2 
  :                            3 react*  $proc
  :                            4 indicate* $proc	$(1)
  :                            5 *	+	0
  :                            6 	$end
  :                            7 "react(1, 1)pointer" indicate
  :                            8 	tz 	*react(1, 1)pointer
  :                            9 	lcal	*react(1, 1)pointer
  :                            10 	$end
  :                            11 
  :                            12 $(1:01000)
  :                            13 $(0:64)
  :                            14 
01:001000 000000              +15 	react	quick
00:000040 709000              +15 
00:000041 3E9000              +15 
01:001001 000000              +16 	react	right
00:000042 709001              +16 
00:000043 3E9001              +16 
  :                            17 
*EOF*
:$(00):000040:000044 :$(01):001000:001002 
indicate.msm: object code 138 bytes: 0 errors: 0 undefined labels
$ cat indicate.txo

$01:001000
000000
$00:000040
709000 3E9000
$01:001001
000000
$00:000042
709001 3E9001
:$00*000000:000040:000044
:$01*000000:001000:001002


</pre>

<a	name="func"/>
<h3>9.2: $func: Macros to generate Assembly-Time Values</h3>

Function macros are not inline commands. They appear in expressions and generate an assembly-time value.
This operand expression obtains a functional value log2()
<pre	style="font-size:12pt;color:#0000FF">

	la, xi	20*log2(30)

</pre>
<p>
<b>$func</b> directive heads a function macro and  <b>$end</b> ends it. Function macros
return a 192-bit value with  <b>$return</b> directive

<p>
Arguments for a function are in parentheses. They are field, subfield and substring
arguments of arbitrary number

<p>
Code may be generated with values supplied by a function macro, for example
<pre	style="font-size:12pt;color:#0000FF">

        $ masmx 2log.msm -lnke
        MASMX 7r3A Build 5
        3/2log.msm
        *EOF*
          :                            1 f      $func
          :                            2 LOG*   $name
          :                            3 fulcrum        $set    f(1, 1)-1
          :                            4 ?      $do     23,     $do     1*/?-1>fulcrum, $return ?-1
          :                            5        $return -1
          :                            6        $end
          :                            7
          :                            8 $(3:03000)
        03:003000  000005              +9       +       LOG(30)
        03:003001  000005              +10      +       LOG(31)
        03:003002  000005              +11      +       LOG(32)
        03:003003  000006              +12      +       LOG(33)
          :                            13
        *EOF*
        :$(03):003000:003004
        2log.msm: object code 65 bytes: 0 errors: 0 undefined labels

        $

</pre>


Code may not be generated inline to the current location counter
inside the expanded text of a function macro, for example
<pre	style="font-size:12pt;color:#0000FF">

        $ masmx liable -lnke
        MASMX 7r3A Build 5
        3/liable.msm
        *EOF*
          :                            1 f*      $func
          :                            2         +       99
          :                            3 one     +       100
          :                            4 two     +       101
          :                            5 three   +       102
          :                            6         $snap   2
          :                            7         $return 103
          :                            8         $end
        00:000000  000063              +9         +       f()
        00:000001  000064              +9
        00:000002  000065              +9
        00:000003  000066              +9
        one=$00:000001
        two=$00:000002
        three=$00:000003
        Error: liable.msm Line 9: Function Adding Code Inline
        00:000004  000067              +9
        *EOF*
        :$(00):000000:000005
        liable.msm: object code 72 bytes: 1 errors: 0 undefined labels

        $

</pre>
This restriction is intended to avoid accidental inclusion of
data constants in instruction streams.<br>
It is consistent with the purpose of function macros, generating values not code

<p>
Assembly option flag -I releases this restriction
<pre	style="font-size:12pt;color:#0000FF">

        $ masmx viable -lnkeI
        MASMX 7r3A Build 5
        3/viable.msm
        *EOF*
          :                            1 f*       $func
          :                            2         +       99
          :                            3 one     +       100
          :                            4 two     +       101
          :                            5 three   +       102
          :                            6         $snap   2
          :                            7         $return 103
          :                            8         $end
        00:000000  000063              +9         +       f()
        00:000001  000064              +9
        00:000002  000065              +9
        00:000003  000066              +9
        one=$00:000001
        two=$00:000002
        three=$00:000003
        00:000004  000067              +9
          :                            10         $snap   2
        *EOF*
        :$(00):000000:000005
        viable.msm: object code 72 bytes: 0 errors: 0 undefined labels

        $

</pre>

<p>
A function macro can be flagged to expand only on the second assembler pass,
for the case that the function is not idempotent.
The flag is an asterisk on the title line
<pre	style="font-size:12pt;color:#0000FF">

$ masmx lquick -lnk
MASMX 7r3
3/lquick.msm
*EOF*
  :                            1 	$path		freeware/RTA1/rta
  :                            2: 	$include	def/rta.def
  :                            3: 	$include	t77.4/ip.def
  :                            4 
  :                            5 later*	$func	*
  :                            6 	$return	$5($net_socket	later(1, 1))
  :                            7 	$end
  :                            8 
  :                            9 $(5:05000/$5)
  :                            10 $(0:64)
  :                            11 
00:000040 CF5000              +12 	dl	later(127.0.0.1:8080)
  :                            13 
*EOF*
05:005000+7F0000011F90
:$(00):000040:000041 :$(05):005000:005002 

</pre>

<a	name="algors"/>
<h2>10: Runtime Algorithmic Expressions: $xqt_i and $xqt_fp</h2>

<p>
Assemblers mostly resolve expressions whose tokens are all known at assembly time

<p>
<a href="http://timmilescox.github.io/masmx/masmx.html#xqt_fp">$xqt_fp</a> and
<a href="http://timmilescox.github.io/masmx/masmx.html#xqt_i">$xqt_i</a>
directives code an instruction plan in a compiler-like fashion
to plan the resolution of expressions using run-time variables

<p>
These instruction steps are planned with the support of target-specific macros with
fixed call-names known to masmx 

<p>
$xqt_i processes integers and can resolve all expression steps
between constants at assembly time, planning the fewest possible instructions
for run time calculation

<p>
In this example the subexpression right of the OR operator <b>++</b> has been
resolved at assembly time, but left of <b>++</b> a multiply, two adds and a
shift must take place at runtime

<p>
The running accumulation is maintained in 48 bits, but it is judged to be only
only 24 bits in size until a double load, an add, a negative add, a multiply, or
a boolean operation on 48 bits has taken place. The first operation <b>one,,w0*4</b>
could be executed in one multiply step because it was known that the multiplicand
had 24 or fewer significant bits. These rules are in the target-specific macro code and
not in masmx

<pre	style="font-size:12pt;color:#0000FF">

$ masmx -lnky boolean
MASMX 7r3
3/boolean.msm
  :                            1 	$path		../
  :                            2: 	$include	def/rta.def
  :                            3: 	$include	language/fpxpress.def
  :                            4: 	$include	language/i_xpress.def
  :                            5 	$path
  :                            6 
  :                            7 $(3:03000)
03:003000 000001              +8 one	1
03:003001 000000000002        +9 two	2d
03:003003 000000000003        +10 three	3d
  :                            11 $(0:64)
00:000040 603000              +12 	$xqt_i	two+one,,w0*4+three*/16++12*/40
00:000041 960018              +12 
00:000042 E00100              +12 
00:000043 D73001              +12 
00:000044 D73003              +12 
00:000045 360010              +12 
00:000046 900101              +12 
00:000047 980102              +12 
  :                            13 	$do	$<256,$(0:256)
  :                            14 	$end
00:000100+000004
00:000101+0C0000000000
:$(00):000040:000103 :$(03):003000:003005 


</pre>
<p>
$xqt_fp includes constants and variables in expressions,
but does not attempt assembly-time calculation of all-constant expression terms

<p>
$xqt_fp concerns four-function arithmetic only. Operands are four words
or eight words in size

<p>
Here a simple algorithm with five inputs is executed in five instructions, including
operand acquisition from storage
<pre	style="font-size:12pt;color:#0000FF">


$ masmx -ln r2xample.msm
MASMX 7r3
3/r2xample.msm
*EOF*
  :                            1 	$path		../def
  :                            2: 	$include	rta.def
  :                            3 	$path		../language
  :                            4: 	$include	stack.def
  :                            5: 	$include	fpxpress.def
  :                            6 	$path
  :                            7 $(0:0)
  :                            8 
00:000000 B60040              +9 floating_algorithm*  $vector fp_routine
  :                            10 
  :                            11 $(0:64)
  :                            12 
  :                            13 fp_routine 
                                	$head_far	 params(one,	float		;
                                				two,	float		;
  :                            16 				three,	float)
  :                            17 
00:000040 4FF003              +18 	$xqt_fp		one*1.75*+1200000*two/3.0*-625000-three
00:000041 770100              +18 
00:000042 77F007              +18 
00:000043 7F0104              +18 
00:000044 6FF00B              +18 
  :                            19 
  :                            20 
00:000045 3D0000              +21 	fret		0
  :                            22 
  :                            23 	$do		$<256,$(0:256)
  :                            24 	
*EOF*
00:000100+7CD38BB7B396D7AA20B6E083
00:000104+2051D5B8447B77478A23F5F7
:$(00):000000:000108 
r2xample.msm: object code 190 bytes: 0 errors: 0 undefined labels


</pre>
masmx has taken an expression with five operands and four operators, and
turned it into a sequence of five instructions which deliver the four-word
floating result of the operations in the result registers <b>a:b:mantissa2:mantissa3</b>

<p>
Three of these tokens are identifiers whose content is only known at runtime

<p>
$xqt_fp directive scans an expression and calls macro code to write an
instruction plan. The tokens which are constants appear as literals at the foot
of the program

<p>
masmx decides whether a token is a self-evident value or a variable reference
by these rules

	<blockquote>
	a field of digits is a value<br><br>
	the address label of storage is a location<br><br>
	a label equated or set to digits is a value<br><br>
	a label equated or set to a storage label or to a location counter is a location<br><br>
	a label equated or set to another label is what that label is<br><br>
	a <b>$equf</b> label is a location
	</blockquote>

Therefore a construction
<pre	style="font-size:12pt;color:#0000FF">

bucket	$equ	4096

</pre>
would not cause a storage reference, but an immediate value.

<p>
The construction
<pre	style="font-size:12pt;color:#0000FF">

bucket	$equf	4096

</pre>
would cause a storage reference

<p>
In RTA1 the supporting macro language in <b>fpxpress.def</b> and <b>i_xpress.def</b> potentially
uses all of <b>[r k x y a b mantissa2 mantissa3 8 9 10 11 d$save d$save1 d$save2 d$ave3]</b>

<p>
Register variables in in macro constructs <b>params() scalars()</b> and external stack names in
<b> xframe()</b> are <b>$equf</b> labels and therefore referenced as variables

<p>
In this assembly <b>FACTOR</b> has been generated as a constant (visible at
the foot of the program) because <b>$equ</b> connected <b>FACTOR</b> to a
number value and not a stored location
<pre	style="font-size:12pt;color:#0000FF">

$ ~/masmx mammoth -lnk
MASMX 7r3
3/mammoth.msm
*EOF*
  :                            1 	$path		../
  :                            2: 	$include	def/rta.def
  :                            3: 	$include	language/stack.def
  :                            4: 	$include	language/fpxpress.def
  :                            5 $(0)
00:000000 B60040              +6 mammoth* $vector	sum
  :                            7 $(3:03000)
03:003000 40000F800000000000000000
                              +8 left	16384*+0
03:003004 7CD38AFBEEFAC15E58C049D8
                              +9 right	1.2*+1200000
  :                            10 
  :                            11 $(0:64)
  :                            12 
  :                            13 FACTOR	$equ	1.875
  :                            14 
                                sum	$head_far	 params(first,	float	;
  :                            16 				second,	float	)
  :                            17 
00:000040 4FF007              +18 	$xqt_fp		-left-right+first+second*FACTOR
00:000041 770100              +18 
00:000042 6F3000              +18 
00:000043 6F3004              +18 
00:000044 67F003              +18 
00:000045 3D0000              +19 	$ret
  :                            20 	$do	$<256,$(0:256)
  :                            21 
*EOF*
00:000100+400001F00000000000000000
:$(00):000000:000104 :$(03):003000:003008 


</pre>

<a	name="structure"/>
<h2>11:	Structures</h2>
<h3>11.1: Structures for Data and Instruction Code</h3>

Structures are widely used programming RTA1 system images both for describing data and for compartmenting local names in instruction code functions

<p>
Directives <a href="http://timmilescox.github.io/masmx/masmx.html#tree">$tree</a>, <a href="http://timmilescox.github.io/masmx/masmx.html#branch">$branch</a> and  <a href="http://timmilescox.github.io/masmx/masmx.html#root">$root</a> declare a structure instance

<p>
To make a template the structure is declared inside a  <a href="http://timmilescox.github.io/masmx/masmx.html#proc">$proc</a> macro

<p>
Here is an example of a data structure templated in a macro
<pre>

	p               $proc
	tcp_connection* $name
	*               $tree
	next            +       0
	state           +       TCP_LISTEN
	mss             +       576
	tsq             +       0
	?               $do     2,timer(?)        +       0
	socket_address  $netp
	remote_address  $netp
	remote_ack_window +     0:d
	sequence_ackx   +       0:d
	ack_window      +       0:d
	receiveq        dq
	deferq          dq
	q4window        dq
	q4ack           dq
	                $root
        	        $end

</pre>
A void program section works as a pointer (data values are not generated in the void section)
<pre>

	$(66::,x)
	transmission	tcp_connection

</pre>
The members are referenced using separator <a href="http://timmilescox.github.io/masmx/masmx.html#sterm">$sterm</a> which is : colon in RTA1
<pre>

			tz	transmission:receiveq:head
			lcal	process_segment

</pre>
Structure dq has members called head and tail

<p>
Up to eight structures nest


<a	name="bit_structures"/>
<h3>11.2: Bit Structures</h3>

<a href="http://timmilescox.github.io/masmx/masmx.html#bstradata">Bit structures</a> are available using directives <a href="http://timmilescox.github.io/masmx/masmx.html#record">$record[,$branch]</a> and <a href="http://timmilescox.github.io/masmx/masmx.html#root">$root</a> to construct and label structures of bit fields hierarchically

<p>
Macro code accesses the attribute definitions of bit structures to retrieve and store data fields

<a	name="directives"/>
<h2>12: masmx Directive and Function Names</h2>

<a href="http://timmilescox.github.io/masmx/masmx.html#directives">directives</a> and
<a href="http://timmilescox.github.io/masmx/masmx.html#internalf">internal functions</a>
are explained in the <a href="http://timmilescox.github.io/masmx/masmx.html">masmx.7r3 Reference Manual</a>

<p>
Directives
<a	href="#form">$form</a>
<a	href="#do">$do</a>
<a	href="#proc">$proc</a>
<a	href="#func">$func</a>
<a	href="http://timmilescox.github.io/masmx/masmx.html#end">$end</a>
<a	href="#algors">$xqt_i</a>
<a	href="#algors">$xqt_fp</a>
<a	href="http://timmilescox.github.io/masmx/masmx.html#equ">$equ</a>
<a	href="http://timmilescox.github.io/masmx/masmx.html#equf">$equf</a>
<a	href="http://timmilescox.github.io/masmx/masmx.html#set">$set</a>
<a	href="#text">$text</a> shown in this document are explained in

<a href="http://timmilescox.github.io/masmx/masmx.html#directives">masmx 8: Directives</a>

<p>
This void assembly call displays all masmx supplied names
<pre	style="font-size:12pt;color:#0000FF">

$ masmx	-kx+y	# displays masmx internal names
	$end	. ends the assembly when input is stdin

</pre>

<a      name="linking"/>
<h2>Appendix A: Linking</h2>

Link steps are masmx assemblies which input and output <a href="#file_formats">text encoded binary</a> files

<p>
Linking assemblies need a definition file rta/target.rta/def/map1.def

<p>
All application builds have a step which links the instruction frame with a micro-filesystem containing its dynamically loadable initial data
<pre	style="font-size:12pt;color:#0000FF">	

	$include	def/map1.def
	$include,$void	imports[.txo]		. just names

	$include,$binary application[.txo] $(0)	. just names and local constants

	$res	($+63**-64)-$			. align for a micro-filesystem
	$include,$binary fs[.txo]		. initial data load strings

</pre>
<p>
See also <a href="app.html">The Simplest Iframe</a> and <a href="iframe.html">Large and Loadable Iframes</a>

<p>
Multiple applications sharing one 4096-word instruction frame. iframes are read-only and may contain separate applications without conflict. Application data space is not shared and is assigned in whole pages for each process

<p>
The shared iframe is constructed by linking instruction sections which are assembled as relocatable. The corresponding data spaces are assembled with absolute address 003000

<pre	style="font-size:12pt;color:#0000FF">

	$include	def/rta.def		. the vector jump instructions are not assembled yet
	$include	def/map1.def
	$include,$void	imports[.txo]		. just names

$(0::START_PAGE)				. if START_PAGE is not known the output is dynamic loadable
app1*	$vector	app1_startup
app2*	$vector	app2_startup

	$do	64-$,	fret	0		. bounce the unused 62 vectors

	$include,$binary application1[.txo] $(0) . just instructions
	$include,$binary application2[.txo] $(0)

	$do	$<256,$(0:256)			. place local constants at higher address than registers 
	$include,$binary application1[.txo] $(4)	. just local constants
	$include,$binary application2[.txo] $(4)

	$res	($+63**-64)-$			. align for a micro-filesystem
	$include,$binary fs[.txo]		. initial data load strings
	
</pre>

<a      name="file_formats"/>
<h2>Appendix B: File Formats</h2>

<a	name="txo"/>
<h3>Text Encoded Binary (.txo) Format</h3>

masmx outputs text encoded binary files. They have the default suffix
<b>.txo</b> and they can be viewed in a text editor or a shell

<p>
Here is a sample assembly and output file
<pre>

	$ masmx assembly assembly -lnke
	MASMX 7r3A Build 8
	3/assembly.msm
	*EOF*
	  :                            1 	$path		../
	  :                            2: 	$include	def/rta.def
	  :                            3: 	$include	language/stack.def
	  :                            4 
	  :                            5 $(0:0)
	00:000000  B60040              +6 call_name* $vector	routine
	  :                            7 
	  :                            8 $(0:64)
	00:000040  770100              +9 routine	fm	(1.75)
	00:000041  3D0000              +10 	fret	0
	  :                            11 
	  :                            12 	$do	$<256,$(0:256)
	  :                            13 
	*EOF*
	00:000100+400001E00000000000000000
	:$(00):000000:000104 
	assembly.msm: object code 128 bytes: 0 errors: 0 undefined labels
	$ cat assembly.txo

	$00:000000
	B60040
	$00:000040
	770100 3D0000
	$00:000100
	400001E00000000000000000

	+call_name:$00:000000
	:$00*000000:000000:000104

</pre>
The output file assembly.txo is text readable

<p>
The lines starting $00: set the location. The first one $00:000000 sets address zero

<p>
B60040 is a jump to "routine" at address 64

<p>
770100 3D0000 are floating multiply and return instructions

<p>
the floating point literal 1.75 is at address 256 or $00:000100 because operand addresses [ 0..255 ] are registers

<p>
2nd-to-last line is the exported call name. The loader updates this to the location where this iframe is loaded

<a	name="load_string"/>
<h3>Load String Format</h3>
<p>

<a href="#lstring">lstring</a> utility constructs dynamically loadable files from txo files

<p>
A load string file may contain its absolute load address and is then not dynamically loadable but convertible to ROM format for catenation into a load image

<a	name="rom"/>
<h3>slab Format</h3>

<a href="#slab">slab</a> utility constructs ROM image from an lstring output which contains no outstanding relocation requests

<p>
Supplied builds apply the suffix <a href="#rom">.rom</a> to ROM image


<a	name="command_line"/>
<h2>Appendix X: masmx Command Line</h2>

Command line is also explained at <a href="http://timmilescox.github.io/masmx/masmx.html#commandline">masmx.7r3A Manual: Command Line</a>

<p>
There may be strings of 1-letter option flags in an arbitrary number of fields starting -hyphen anywhere on the command line

<p>
Up to 8 fields wihout leading hyphen are arguments

<p>
The first two arguments are input and output filenames
<pre>

	masmx [ -flAGs ] <i>input output</i> [ -FLagS ] [ <i>ARGUMENT3..ARGUMENT8</i> ]

</pre>
All eight arguments may be accessed in the assembly via text substitution

<p>
<a	name="text"/>
$text directive with a subfield (0, 2) translates occurences of from-text to the corresponding command line argument

<pre	style="font-size:12pt;color:#0000FF">

	$text,3		/__EXTRA_INCLUDE/
	$text,4		|__GLOBAL_VALUE|
	$text,5		\__BLANK_DEFAULT\

</pre>

$text lines must be all together in an assembly whether of this form or the form
<a href="http://timmilescox.github.io/masmx/masmx.html#text">	$text	\from\to\</a>

All command line fields are optional

<pre	style="font-size:12pt;color:#0000FF">

$ masmx -Fla source[.msm] binary[.txo] -GS -opQqci 99.def 5000 0

</pre>

If the second filename is missing, the output is <b>temp.txo</b>. Directive <b>$store</b> in the source
text assigns a different default output filename

<p>
If the first filename is missing, masmx reads source from stdin and constructs a file <b>temp.msm</b>

<p>
<a href="http://timmilescox.github.io/masmx/masmx.html#clopts">Flags</a> used in RTA1 are
<pre	style="font-size:12pt;color:#0000FF">

	-a	allow automatic literals. Already set in rta.def
	-c	C-Language number and alpha string syntax. By default leading 0 is hex, string escapes are "text":value:value:"text"
	-d	list load addresses not program-visible addresses in breakpointed sections
	-e	list generated code word-space-word
	-fghi	<a href="http://timmilescox.github.io/masmx/masmx.html#clopts">label handling, 1st / 2nd pass decisions</a>
	-k	labels case-significant
	-l	list [ down to include depth set by <b>$list <i>depth</i></b> directive ] default assembly main file
	-n	list relocation information when -l
	-p	list <b>$proc</b> macro text + actual arguments where <b>$plist</b> value &gt; macro nesting depth
	-q	list <b>$func</b> macro text + actual arguments where <b>$plist</b> value &gt; macro nesting depth
	-r	list <b>$proc</b> and <b>$func</b> macro text + actual arguments
		on first asssembly pass where <b>$plist</b> value &gt; macro nesting depth
	-u	mark assembly in error if labels are unresolved: final assembly or link
	-w	silent assembly
	-x	list labels
	-+	include masmx internal labels in list, for sorted list -x+y
	-y	order label list
	-z	string zero-fill to containing word, default space-fill. Reversed by -c

	-B	<a href="http://TimMilesCox.github.io/masmx/masmx.html#clopts">display owner and macro level of label added to $tree or $record structure</a>

	-D	translate \<i>ESCAPED</i> octal and hex sequences in "strings" and 'integers' when -c and $data_code
		otherwise escaped sequences are final as input and not translated per $data_code

	-E	floating constant rounding guard pattern is 111 default value
		flags <a href="http://TimMilesCox.github.io/masmx/masmx.html#optro">-EFGH</a> supplant each other with successive $set_option directive
	-F	floating constant rounding guard pattern is 110 instead of 111
	-G	floating constant rounding guard pattern is 101 instead of 111
	-H	floating constant rounding guard pattern is 000 instead of 111

	-I	allow function macros to generate code inline to the current location counter
	-L	<a href="http://TimMilesCox.github.io/masmx/masmx.html#clopts">display type and macro level of labels added during macro declaration</a>
	-Q	expand a <b>$func</b> macro name found in an expression even if it is screened with "quotes"
	-X	retrieve values which are not addresses exported from other assemblies
	-Y	in $record structures flag fields as signed unless their bit size is suffixed u
		otherwise bit fields are unsigned unless suffixed s. 
		macro language reads signedness of bit fields to determine manipulation
	-Z	zero-fill <b>$res</b> buffers



</pre>

masmx link flags. A link is an assembly with <b>$include,$binary</b>
<pre	style="font-size:12pt;color:#0000FF">

	-b	collate input files by segment
	-j	do not transform label references in incremental link to locator references
		until the containing section is absolute

</pre>
RTA1 structured programming macros <b>head_near / far</b> and <b>$ret</b> respond to unassigned
assembly flags <b>-VUOS</b> which may be used for tracing
<pre	style="font-size:12pt;color:#0000FF">

	-V	display stack-handling decisions
	-S	<b>$ret</b>  macro reconstructs caller parameter list in internal stack
		when returning from <b>$zero_stack</b> mode <b>head_near / far</b> routine
	-O	check enough parameters from <b>lc / c</b> call
	-U	check exact number of parameters

</pre>

<a	name="binary_utilities"/>
<h2>Appendix Y: Binary Utilities</h2>

<hr/>

<a	name="lstring"/>
<h3>lstring</h3>

lstring reads the text-encoded-binary output of masmx and
constructs a load string image for loaders

<p>
The command line is
<pre	style="font-size:12pt;color:#0000FF">

        lstring -b input.txo output

</pre>

-b option selects the binary load string format used in RTA1. Otherwise S-Records for quantum-24 are output

<p>
The input and output files are named in full with any extension they have.
masmx output files have by default extension .txo

<p>
Here is a part of a system image output from lstring with
-b option
<pre	style="font-size:12pt;color:#0000FF">
<a	name="bin"/>

        $ ../util.rta/fds24 srom
        00000000: 000001 49ffbe 000000 000000  "   I        "
        00000004: b60040 00000b d9fa7c 000000  "  @     |   "
        00000008: 000040 5500fc 10008f 10008e  "  @U        "
        0000000c: 04007c 200087 680084 dd0001  "  |   h     "
        00000010: de0049 3e004a f70100 350000  "  I> J   5  "
        00000014: 000001 fffebe 000000 000100  "            "
        00000018: 000040 000077 45324d 000000  "  @  wE2M   ".

        $

</pre>
There is a four word descriptor before each load string:
word-count, checksum, 48-bit address

<p>
lstring with -L option forwards requests for runtime Load Page Index to be added to gate structures.

<p>
These requests take the form of a flagged 4-word tuple pointing to the gate structure

<p>
This example is from the script which constructs loadable applications
The first 4-word tuple directs load update to gate location 64+1
<pre	style="font-size:12pt;color:#0000FF">

	lstring -bL gate.txo gate

	$ fds24 gate
	000000000000: 800000 7fffbe 000000 000041  "           A"
	000000000004: 000048 c1edf2 000000 000000  "  H         "
	000000000008: b60114 3d0000 3d0000 3d0000  "   =  =  =  "
	00000000000c: 3d0000 3d0000 3d0000 3d0000  "=  =  =  =  "
	

</pre>
lstring -v option outputs extra information

<p>
lstring is the final build step of loadable applications. They are not converted to ROM format

<br><br>
<hr/>

<a	name="slab"/>
<h3>slab</h3

<h3>slab ROM Image Utility</h3>

slab is the final build step of fixed load images. Input is the output from lstring. Output is ROM format

<p>
slab utility builds a ROM image on a file. A typical command line is
<pre	style="font-size:12pt;color:#0000FF">


        ../util.rta/slab srom srom.rom 28 -k

</pre>

<a	name="rom"/>
This fds24 readout of the slab output file srom.rom displays 4 words at
location zero, twelve words from location 64 and four words at
location 256

<p>
Word 0 is a jump to location 64, where the interrupt
internal stack pointer is written with the value 252

Some I/O is probed to detect the startup environment, then a GO instruction
jumps inter-bank via its constant operand <a style="color:#0000FF">000040</a> at address 256 containing
the vector value Page Index 1 location 0

<pre	style="font-size:12pt;color:#0000FF">

        $ ../util.rta/fds24 srom.rom
        00000000: b60040 000000 000000 000000  "  @         "<a style="color:#FF0000">64</a>
        00000040: 5500fc 10008f 10008e 04007c  "U          |"
        00000044: 200087 680084 dd0001 de0049  "   h       I"
        00000048: 3e004a f70100 350000 000000  "> J   5     "<a style="color:#FF0000">256</a>
        00000100: 000040 000000 000000 000000  "  @         "<a style="color:#FF0000">.</a>

        $

</pre>
If any load strings point outside the area described at
argument 3 of slab, slab won't finish the job

<p>
slab -h prints command line guidance

<pre	style="font-size:12pt;color:#0000FF">

$ slab -h

slab [-options] input[.bxl] output[.rom] [target-rom-words]

default ROM size is 1024 RTA1 words
target-rom-words is leading-zero for hex else decimal

slab ifile ofile -p          #  4096 RTA1 words
slab ifile ofile -b          #  262144 RTA1 words
slab ifile ofile -m          #  1048576 RTA1 words

slab ifile ofile number      #  number of RTA1 words
slab ifile ofile number -k   #  number * 1024 RTA1 words
slab ifile ofile number -p   #  number * 4096 RTA1 words
slab ifile ofile number -b   #  number * 262144 RTA1 words
slab ifile ofile number -m   #  number * 1048576 RTA1 words
options -v verbose -w very verbose
$

</pre>

<p>
Additonally slab -S allows a ROM-type image of a loadable application to be slabbed for diagnosis only

<p>
The load update tuples in a loadable lstring image otherwise prevent slab from completing the ROM image

<p>
The diagnosis-only quasi-ROM image may be easier to navigate with a viewer than lstring output

<br><br>
<hr/>

<a	name="fsformat"/>
<h3>fsformat</h3>
<p>
fsformat constructs device array filesystem images offline on the PC

<p>
A device array filesystem is an octet array containing an integral number of banks of 262144 words (786432 octets)
to a maximum of 17,179,869,184 words or 51,539,607,552 octets in 65536 banks

<p>
Device 1 is a device array filesystem hosting the system and enterprise web pages and 61 more devices may be device array filesystems allowing nearly 3 terabytes of filestore in an RTA1 system

fsformat command line is

<pre	style="font-size:12pt;color:#0000FF">

        $ fsformat fsimage_file [ <i>size</i> [ -T | -G | -M | -b | -p | -K ] ] < filetree_commands_textfile

</pre>

The size of the filesystem image defaults to 1 bank of 4096 64-word granules and may be typed in argument 2 <i>size</i> as
	<blockquote>
	a different number of 64-word granules<br><br>
	or governed by an option flag -TGMbpK<br>
	a number of of terawords, gigawords, megawords, banks, pages, or kilowords
	</blockquote>

<p>
Script rta/mrand7 builds device array filesystem 1 by default as 1 bank and has an optional size argument
<pre	style="font-size:12pt;color:#0000FF">

	mrand7	[<i>banks</i>]

</pre>
If fsformat reports negative filestore granules to spare, argument 2 <i>size</i> requires to be increased or an unviable filessystem could be brought online

<p>
With script mrand7 argument 1 <i>banks</i> is to be increased in case of negative remaining filestore

<p>
A textfile of commands specifies directories, files, and source paths of files, for example

<pre	style="font-size:12pt;color:#0000FF">

volume volume_name
tree boot$
tree left_boot
.
tree right_boot
.
.
tree free$tree$
.
tree etc
file network.txt etc.rta/network.txt
.
tree web
file index.html rta.doc/index.html
file rta.html rta.doc/rta.txt
file smaragd7.html rta.doc/smaragd7.txt
file language.html rta.doc/language.txt
file masmx7r3.html rta.doc/masmx7r3.txt
file connect.html rta.doc/connect.txt
file q_a.html rta.doc/q_a.txt
file footnote.html rta.doc/footnote.txt
file gnu_gpl.html rta.doc/gnu_gpl.html
.
.

</pre>

Command . period escapes one file tree level. Escaping root directory completes filesystem image construction

<br><br>
<hr/>

<a	name="4kformat"/>
<h3>4kformat</h3>

4kformat constructs core filesystem images in 4K-word pages for inclusion in RTA1 executable space

<p>
4kformat constructs the file tree using the same input commands as fsformat

<p>
Option flag -x generates linkable .txo code with exported filenames for inclusion by masmx link

<p>
Argument 2 is an offset to the file system start within the containing pages, and is not usually present
<pre	style="font-size:12pt;color:#0000FF">

	$ 4kformat -x load_segment.txo < segments_filetree_commands.txt

</pre>
Without -x The size of the filesystem image defaults to 1 page of 64 64-word granules and may be typed in argument 2 <i>size</i> as
        <blockquote>
        a different number of 64-word granules<br><br>
        or governed by an option flag -TGMbpK<br>
        a number of of terawords, gigawords, megawords, banks, pages, or kilowords
        </blockquote>

Option flag -z zero-pads to integral 4K pages for inclusion by catenation
<pre	style="font-size:12pt;color:#0000FF">

        $ 4kformat [ -z ] application_lookup.rom [ <i>size</i> [ -T | -G | -M | -b | -p | -K ] ] < lookups_filetree_commands.txt

</pre>

<p>
-x and -z are mutually exclusive

<p>
4kformat is called in root application build scripts

<br><br>
<hr/>

<a	name="1gformat"/>
<h3>1gformat</h3>

1gformat constructs micro-filesystems in 64-word granules for including data section load information in shared-code applications

<p>
1gformat constructs the file tree using the same input commands as fsformat

<p>
1gformat is mostly used with -x option because its purpose is constructing a linked application component

<p> 
Option flag -x generates linkable .txo code with exported filenames for inclusion by masmx link
and argument 2 is an offset to the file system start within the application iframe pages

<pre	style="font-size:12pt;color:#0000FF">

	$ 1gformat -x segments_include.txo $IFRAME_CODE_SIZE < segments_filetree_commands.txt

</pre>

<p>
Without -x argument 2 is the filesystem size units of 64-word granules or units per flag -TGMbpK 

<p>
Option flag -z zero-pads to integral 4K word-pages for inclusion by catenation but is rarely applicable in 1gformat

<p>
-x and -z are mutually exclusive

<p>
1gformat is called in application build scripts

<br><br>
<hr/>

<a	name="fds24"/>
<h3>fds24</h3>

fds24 is a file viewer and string or binary searcher on PCs

<p>
fds24 displays the RTA1 view of data files as an array of 24-bit word quanta

<p>
Any search arguments are on the command line

<p>
Without search arguments return key scans forward

<p>
A new scan position can be entered, leading zero for hex otherwise decimal. 256 and 0100 are the same position

<p>
Character search arguments are from  argument 3. Argument 2 is search-from position, leading zero for hex else decimal

<p>
Search hits display the containing four-word block
<pre	style="font-size:12pt;color:#0000FF">

$ fds24 rumbus 0 trunk said 'to the'
000000000008: 642068 657220 747275 6e6b0a  "d her trunk "
00000000000c: 416e64 207361 696420 676f6f  "And said goo"
000000000010: 646279 652074 6f2074 686520  "dbye to the "

$ fds24 banana.joe 0 "oe's ba"
000000000000: 4a6f65 277320 62616e 616e61  "Joe's banana"

</pre>
Binary search strings are constructed in a preliminary step

<p>
Directory rta/target.rta/image.app must be in $PATH. Command makemask constructs a binary search argument

<p>
A binary number of any size up to 192 bits can be input in decimal for search. Input in hex has leading zero

<pre	style="font-size:12pt;color:#0000FF">

$ makemask <i>mask_name</i> 0d34654117665e1a30eee883861c7af2e441a32f24153975 188
MASMX 7r3A Build 8
3/../image.app/mask.msm
*EOF*
  :                            1 
  :                            35 	$list
  :                            36 
00:000000  000004 0000BC        +37 	mask
00:000002  000000 000000        +38 	0L
*EOF*
00:000004+D34654117665E1A30EEE883861C7AF2E441A32F241539750
:$(00):000000:00000C 

</pre>
makemask argument 1 is a mask name and the output is <i>mask_name</i>.rom  Objects <i>mask_name</i>.txo and <i>mask_name</i> are also generated. Any file in current directory clashing with these three names will be lost

<p>
makemask argument 3 is the size in bits of the binary search string which starts at the leading bit position of containing 24-bit words

<p>
fds24 option -s causes a bit-pattern search for matches at any bit offset in the file to the contents of <i>mask_name</i>.rom

<p>
Argument 2 is search-from word offset, leading zero for hex otherwise decimal

<pre	style="font-size:12pt;color:#0000FF">

$ fds24 -sZvp nelly7.rom 0 <i>mask_name</i>.rom
			match @000000000010:10 188 decimal bits
nelly7.rom 000000000010: 7941d3 465411 7665e1 a30eee  "yA FT ve    "
nelly7.rom 000000000014: 883861 c7af2e 441a32 f24153  " 8a  .D 2 AS"
nelly7.rom 000000000018: 975dda d061dd 91073c 3a7220  " ]  a   <:r "

</pre>

Option flag -Z suppresses pause/prompt after display

<p>
-p displays the examined file name on output lines

<p>
-v displays the word:bit offset in hex of a match<br>
Matches which are not on a quartet aligned bit position are otherwise difficult to pinpoint 

<br><br>
<hr/>

<a	name="licence"/>
<h2>Appendix Z: Licence Note</h2>

<pre	style="font-size:12pt;color:#0000FF">
<i>

    LICENCE NOTICE


    Copyright Tim Cox, 2012
    TimMilesCox@gmx.ch

    This document is part of the RTA1 freeware processor programmable
    architecture.

    This document additionally concerns the masmx.7r3 meta-assembler
    which is a separate free program by the same author and supports
    the RTA1 architecture among other processor architectures

    RTA1 is a free processor architecture specification.
    It is licensed under the GNU General Public Licence Version 3

    The executable emulation of RTA1 is free software.

    Instruction code for the target RTA1 architecture is free software
    if it is delivered with this software

    Software programs delivered with this software to connect the
    emulated RTA1 with real network interfaces in the emulator host
    are free software

    Scripts and programs delivered with this software for running
    on other computers and interacting with the RTA1 are free software

    Scripts and utility programs for constructing RTA1 target
    executable software are free software

    You can redistribute it and/or modify RTA1
    under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    RTA1 is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with RTA1.  If not, see &lt;http://www.gnu.org/licenses/&gt;.

</i>
</pre>


</div>
</html>
