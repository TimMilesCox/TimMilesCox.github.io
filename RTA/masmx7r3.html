<html>

<div	style="font-family:times-roman;font-size:14pt">

<center>
<h1>masmx.7r3A for RTA1</h1>
<h1><a href="#binary_utilities">and Binary Utilities<a/></h1>

<i>
Copyright Tim Cox, 2014
<p>
This document is part of the RTA1 Processor Programmable Architecture Specification<br>
RTA1 is a free computer programmable architecture licensed under the GNU General Public Licence Version 3<br>

The same licence encompasses all software and documentation delivered with RTA1 Specification

<br>
The masmx.7r3 meta-assembler is free software separately licensed with the GNU General Public Licence Version 3

<br>
The full text of GNU General Public Licence Version 3 is included with these materials<br>
See also the licensing notice at the foot of this document

</i>
</center>
	<ol>
	<li><a href="#organisation">Organisation of Manuals about Programming RTA1</a></li>
	<li><a href="#masmx_settings">masmx Settings for RTA1</a></li>
	<li><a href="#language">Assembly Language</a></li>
		<ol>
		<li><a href="#labels">Labels</a></li>
		<li><a href="#commands">Command and Arguments Fields</a></li>
		<li><a href="#form">Fields Template Directive $form</a></li>
		</ol>
	<li><a href="#constants">Data Constants</a></li>
		<ol>
		<li><a href="#expressions">Expressions and Numbers</a></li>
			<ol>
			<li><a href="#operator">Operators</a></li>
			<li><a href="#numbers">Integers and Floating Point</a></li>
			<li><a href="#fp96data">Floating Point</a></li>
			<li><a href="#fp48data">Floating Storage Compression</a></li>
			<li><a href="#fp192data">192-Bit Floating Point</a></li>
			</ol>
		<li><a href="#literals">Literals</a></li>
			<ol>
			<li><a href="#automatic_literals">Automatic Literals</a></li>
			<li><a href="#tagged_literals">Tagged Literals</a></li>
			</ol>
		<li><a href="#strings">Character Strings</a></li>
		<li><a href="#comma_fields">Number Constants with Equal-Size Bit Fields</a></li>
		</ol>
	<li><a href="#instructions">Instructions and Operands</a></li>
		<ol>
		<li><a href="#operands">Register / Memory Operand Continuum</a></li>
		<li><a href="#registers">Programmable Register Model</a></li>
			<ol>
			<li><a href="#nar">Two Non-Addressable Registers</a></li>
			<li><a href="#ioar">Memory Space Mapped via I/O</a></li>
			<li><a href="#register_stack">Register Stack</a></li>
			</ol>
		<li><a href="#instruction_form">Instruction Layout</a></li>
		<li><a href="#integer_instructions">Single Integer Instructions</a></li>
		<li><a href="#sisi">Single Integer Store Instructions</a></li>
		<li><a href="#sili">Single Integer Load Instructions</a></li>
		<li><a href="#ti">Test Instructions</a></a></li>
		<li><a href="#xai">Index Register Add Instructions</a></li>
		<li><a href="#booli">Boolean Algebra Instructions</a></li>
		<li><a href="#siai">Single Integer Add Instructions</a></li>
		<li><a href="#mi">Multiply</a></li>
		<li><a href="#mf">Multiply Fractional</a></li>
		<li><a href="#di">Divide</a></li>
		<li><a href="#llsi">Large Load and Store Instructions</a></li>
		<li><a href="#liai">Large Integer Arithmetic Instructions</a></li>
		<li><a href="#fpai">Floating Arithmetic Instructions</a></li>
			<ol>
			<li><a href="#fp96i">The 96-Bit Floating Point Model</a></li>
			<li><a href="#fp192i">192-Bit Floating Arithmetic</a></li>
			</ol>
		<li><a href="#smi">Storage Modify Instructions</a></li>
		<li><a href="#si">Shift Instructions</a></li>
		<li><a href="#sim_d">SIMD and Instruction Repeat</a></li>
		<li><a href="#bsi">Bit Stream Instructions</a></li>
			<ol>
			<li><a href="#rsr">Read Staging Register</a></li>
			<li><a href="#wsr">Write Staging Register</a></li>
			</ol>
		<li><a href="#ji">Jump Instructions, Local Call / Local Return</a></li>
		<li><a href="#crii">Iframe Call / Return, Iframe Go, Internal Interrupt / Interrupt Return</a></li>
		<li><a href="#crio">Control and I/O Instructions</a></li>
		</ol>
	<li><a href="#proc">Macro Language: Procedures and Functions</a></li>
		<ol>
		<li><a href="#proc">$proc</a>: Command and Instruction Macros</li>
		<li><a href="#func">$func</a>: Macros to generate Assembly-Time Values</li>
		</ol>
	<li><a href="#array">Arrays and Structures</a></li>
		<ol>
		<li><a href="#array">Arrays</a></li>
		<ol>
			<li><a href="#array">Linear Arrays</a></li>
			<li><a href="#linear">Large Linear Arrays and macro fastarray$</a></li>
			<li><a href="#teraword">Teraword Arrays</a></li>
			<li><a href="#density">Density of Array Load Data</a></li>
		</ol>
		<li><a href="#do">Iteration: Directive $do</a></li>
		<li><a href="#structure">Structures for Data and Instruction Code</a></li>
		<li><a href="#dynamic">Internal Name Space of Parameters and Dynamic Variables</a></li>
		<li><a href="#bit_structures">Bit Structures</a></li>
		</ol>
        <li><a href="#algors">Runtime Algorithmic Expressions</a></li>
                <ol>
                <li><a href="#algors">Floating and Integer Expressions</a></li>
                <li><a href="#x_fp">Floating Algorithm Run Time Planner $xqt_fp</a></li>
                <li><a href="#x_i">Integer Algorithm Run Time Planner $xqt_i</a></li>
                <li><a href="#i_radix">Integer Radix of Algorithmic Expressions</a></li>
                <li><a href="#i_gcc64">Benchmarking Integer Algorithms with GCC</a></li>
                <li><a href="#x_atoi_fp">Data Conversion of Input Terms to Algorithms</a></li>
                </ol>
	<li><a href="#directives">masmx Directives and Automatic Functions</a></li>
	</ol>

	<ul	type="none">
	<li><a href="#file_formats">Appendix A: File Formats and Linking</a></li>
		<ul	type="none">
		<li><a href="#txo">Text Encoded Binary (.txo) Format</a></li>
		<li><a href="#load_string">Load String Format</a></li>
		<li><a href="#rom">ROM Format</a></li>
		</ul>
	<li><a href="#command_line">Appendix X: masmx Command Line</a></li>
	<li><a href="#binary_utilities">Appendix Y: Binary Utilities</a></li>
		<ul	type="none">
		<li><a href="#lstring">lstring</a></li>
		<li><a href="#slab">slab</a></li>
		<li><a href="#fsformat">fsformat</a</li>
		<li><a href="#4kformat">4kformat</a></li>
		<li><a href="#1gformat">1gformat [2|4|8gformat]</a></li>
		<li><a href="#fds24">fds24</a></li>
		</ul>
	<li><a href="#licence">Appendix Z: Licence Note</a></li>
	</ul>


<a	name="organisation"/>
<h2>1: Organisation of Manuals about Programming RTA1</h2>

This document relates RTA1 register model and instructions by functional group to the
<a href="http://timmilescox.github.io/masmx/masmx.html">masmx meta_assembler</a>

<p>
Architectural and instruction definitions are cross-referenced by link to the
<a href="rta.html"> RTA1 Processor Programmable Architecture Specification</a>

<p>
See also <a href="scripts.html">Building Applications</a>

<pre	style="font-size:12pt">

<div	style="position:relative;left:50pt;width:638pt;height:250pt;border-radius:15pt;background-color:#0000FF;color:#FFFFFF">
	click and go...		<a href="rta.html" style="color:#FFFFFF">RTA1 Architecture Specification</a>
__________________________________________________________________________________________
			|	<a href="#masmx_settings" style="color:#FFFFFF">masmx settings</a>			|
 <a href="scripts.html#build" style="color:#FFFFFF">applicaton build...</a>	|	<a href="#language" style="color:#FFFFFF">assembly language</a>		|
			|	<a href="#constants" style="color:#FFFFFF">expressions and data constants</a>	|
 <a href="scripts.html#application" style="color:#FFFFFF">how is an application?</a>	|	<a href="#instructions" style="color:#FFFFFF">instructions and operands</a> 	|
             <a href="scripts.html#_app4kq" style="color:#FFFFFF">simple app</a> |	<a href="#literals" style="color:#FFFFFF">literals</a>			|
              <a href="iframe.html" style="color:#FFFFFF">large app</a>	|       <a href="#structure" style="color:#FFFFFF">structures</a> <a href="#array" style="color:#FFFFFF">arrays</a> <a href="#do" style="color:#FFFFFF">iteration</a>	|
   <a href="scripts.html#group" style="color:#FFFFFF">apps packed together</a>	|	<a href="language.html" style="color:#FFFFFF">call sequences + dynamic variables</a>
			|	<a href="#algors" style="color:#FFFFFF">runtime algorithms</a>		|
			|					|
	     <a href="kernel.html" style="color:#FFFFFF">kernel API</a>	|	<a href="#directives" style="color:#FFFFFF">assembly directives</a>		|
    	      <a href="kernel.html#library" style="color:#FFFFFF">libraries</a>	|	<a href="#linking" style="color:#FFFFFF">linking</a>				|
 <a href="scripts.html#_library" style="color:#FFFFFF">constructing libraries</a>	|	<a href="scripts.html#locators" style="color:#FFFFFF">application memory map</a>		|
<a href="scripts.html#nvram" style="color:#FFFFFF">system image fixed apps</a>	| 	<a href="#file_formats" style="color:#FFFFFF">file formats</a>			|
			|	<a href="#command_line" style="color:#FFFFFF">command line and option flags</a>	|	<a href="http://timmilescox.github.io/masmx/masmx.html" style="color:#FFFFFF">masmx manual</a>
       <a href="scripts.html#singlemu" style="color:#FFFFFF">...build command</a>	|	<a href="#binary_utilities" style="color:#FFFFFF">binary utilities</a>		|	<a href="http://timmilescox.github.io/masmx" style="color:#FFFFFF">masmx download</a>
			|					|			<a style="color:#00FF00">.</a>
</div>

</pre>

<a      name="masmx_settings"/>
<h2>2: masmx Settings for RTA1</h2>

masmx is a target-independent meta-assembler

<p>
masmx default settings are correct for RTA1:

<pre	style="font-size:12pt;color:#0000FF">

        $word                   24		. unit of generated code + bits size single integer
        $quantum		24		. addressable storage location bits size
        $awidth                 24:48		. address space : executable space
        $floating_point         96		. default size of floating constant
        $characteristic         24		. sign + scale field of floating number
        $characteristic,48      12		. sign + scale field of compressed floating number
        $byte                   8

</pre>

<p>
RTA1 instructions and registers are added with an include file rta.def
and often more include files about I/O, macros and structures
<pre	style="font-size:12pt;color:#0000FF">

	$list		0			. keep hundreds of system names out of your listing
	$path		../			. if your app is subdirectory of rta/target.rta
	$include	def/rta.def		. the RTA1 instruction machine
	$include	def/vector.def		. your addresses and handles
	$include	def/ii.def		. service call names
	$include	def.sys/io.def		. I/O port names
	$include	language/stack.def	. function framing and call sequences
	$include	language/catalog.def	. or iframe.def for multi-applications
	$include	stream/stream.def	. if you want anything like printf
	$include	t77.4/ip.def		. for assembling anything like a socket address
	$include	lib/ascii.def		. has some nongraphic definitions like LF HT etc
	$include	image.app/imports.def	. some kernel exports
	$path					. back to PWD for the developer's own include files
	$list					. names frome here may appear in your listings

	$include	...

</pre>

<p>
Source input text is ASCII

<p>
Quoted text strings may include ASCII extensions like UTF-8 and by default are assembled octet for octet as input with padding to containind words

<p>
Directives exist for rule-based generation of character values in non-ASCII data codes and non-default byte sizes

<p>
See
<a href="#expressions"> 4.1: Expressions and Numbers</a> and
<a href="#strings"> 4.3: Character Strings</a>

<p>
Language elements not in quotes or apostrophes are from ASCII code points 0..127.


<p>
masmx default syntax elements are used for RTA1

<pre	style="font-size:12pt;color:#0000FF">

	$lterm			'.'	. comments follow PERIOD SPACE
	$sterm			':'	. substring:divider and structure:join is colon :
	$cont_char		';'	. line continuation is semicolon ;
	$quote			'"'	. "quoted" is a string in current bytes and data code
					. +"quoted" forces the token to be a label reference. See . <a href="#labr">+"label_reference"<a>

					. ' apostrophe may bound a right justified value expressed [&plusmn;]'abc'
					.   up to 192 bits in size per current $byte size and data code. See <a href="#qnu">+'values'</a> 


</pre>

<a	name="language"/>
<h2>3: Assembly Language</h2>

The line of assembly language code has an arbitrary number of fields

<pre	style="font-size:12pt;color:#0000FF">

[label]	[command]	[argument1[,argument1_subfield2,...]]	[argumentN[,argumentN_subfield2,...]]	[. comment ]

</pre>
Lines may be continued
<pre	style="font-size:12pt;color:#0000FF">

[label]	[command]	[argument1[,argument1_subfield2,...]]	;
			[argument2[,argument1_subfield2,...]]	;
			[argumentN[,argumentN_subfield2:substring2:..., ...]] 

</pre>
<a      name="labels"/>
<h3>3.1: Labels</h3>

A label starts in column 1 and ends in whitespace. A label may contain letters, digits, $_?!@: and
starts with a letter or _?!@

<p>
Many system names start with $ and are declared in quotes "$system_name" because lines starting $ are <a href="scripts.html#locators">program section controls</a>

<p>
A label may be in "" and then it starts with anything and contains anything

<p>
Without case-sensitive option -k all labels and references are translated to uppercase

<p>
The substring divider $sterm default : may be
<ul	type="square">

	<li>a character in a label</li>

	<li>a join between hierarchic labels in a <a href="#structure">structure</a> reference</li>

	<li>a divider in <a href="#strings">character strings</a> between text substrings and nongraphic value expressions
	<ul	type="square">
		<li>"":HT:"sub":"string":HT:"substring":LF:0</li>
	</ul>

	<li>a substring separator within <href="#proc">macro call</a> actual subparameters
	<ul	type="square">
		<li>,range_low:range_high,...</li>
	</ul>
        <li>character : is also a fixed <a href="#fixed">macro language</a> element for navigating actual parameters</li>
</ul>

Substring character may be changed temporarily with directive <a href="http://timmilescox.github.io/masmx/masmx.html#sterm">$sterm</a> <i>value</i> to match an actual parameter syntax

<p>
In this data declaration substrings are temporarily marked with .

<pre	style="font-size:12pt;color:#0000FF">

	__socket_address	10.0.0.9:__PORT_NUMBER
	
</pre>

<a	name="fixed"/>
Character : is a fixed macro language element in <a href="#proc">macro paraform language</a> used to navigate actual parameter substrings whatever symbol <a href="http://timmilescox.github.io/masmx/masmx.html#sterm">$sterm</a> currently is

<p>
Here a function parameter __net_address switches between dotted and colon syntax to express a socket name

<p>
$sterm values [ : . ] are in the actual parameter. The macro language element to navigate parameter substrings is always :

<pre	style="font-size:12pt;color:#0000FF">

$ masmx -lnke
MASMX 7r3A Build 11
0/-INPUT>>

f       $func   
__net_address*  $name
net_a   $set            0
        $sterm          '.'
?       $do             f(1, 1:),net_a  $set    net_a*/8++f(1, 1:?)
        $sterm          ':'
        $return         net_a*/16++f(1, 1:2)
        $end

p       $proc   
__socket_address* $name
        +               __net_address(p(1, 1)d
        $end

        __socket_address        10.0.0.9:3073

	$end
  :                            1 
  :                            2 f       $func   
  :                            3 __net_address*  $name
  :                            4 net_a   $set            0
  :                            5         $sterm          '.'
  :                            6 ?       $do             f(1, 1:),net_a  $set    net_a*/8++f(1, 1:?)
  :                            7         $sterm          ':'
  :                            8         $return         net_a*/16++f(1, 1:2)
  :                            9         $end
  :                            10 
  :                            11 p       $proc   
  :                            12 __socket_address* $name
  :                            13         +               __net_address(p(1, 1)d
  :                            14         $end
  :                            15 
00:000000  0A0000 090C01        +16         __socket_address        10.0.0.9:3073
  :                            17 
  :                            18  $end
:$(00):000000:000002 

</pre>

<p>
A label may have an arbitrary number of subscripts
<pre	style="font-size:12pt;color:#0000FF">

<i>label(5,7,600)</i>

</pre>

<p>
Reference to a subscripted label which does not exist functions as a
count of labels with the same subscripts plus one more

<p>
A label <i>label_stem(<b>4,1,20</b>)</i> is the count of labels
<i>label_stem(<b>4,1,20</b>,&xi;)</i>

<pre	style="font-size:12pt;color:#0000FF">
	<i>
	label_stem(<b>4,1,20</b>,5)<br>
	label_stem(<b>4,1,20</b>,20)<br>
	...</i>

</pre>

If no instances exist either the reference has the value of zero because it
counts an empty set

<p>
There is no requirement for label subscripts to fill a number space
continuously or evenly

<p>
Subscripted labels need not be in ascending order or any order, but may be
generated by loop control
<pre	style="font-size:12pt;color:#0000FF">

MANY	$set	65536

index	$do	MANY,a_name(MANY+1-index)	+	99*index

</pre>
Subscript expressions are normalised to decimal strings when the label is stored

<p>
For example, the first two repeats of $do above generate
<pre	style="font-size:12pt;color:#0000FF">

a_name(65536)	+	99*1
a_name(65535)	+	99*2

</pre>
and the last three generate
<pre	style="font-size:12pt;color:#0000FF">

a_name(3)	+	99*65534
a_name(2)	+	99*65535
a_name(1)	+	99*65536


</pre>
Labels inside macros only exist during macro assembly unless they are promoted

<p>
Labels in macros are promoted one macro level per trailing asterisk

<pre	style="font-size:12pt;color:#0000FF">

$ masmx -lnxk visible visible
MASMX 7r3
3/visible.msm
  :                            1 macro1*	$proc
  :                            2 	macro2
  :                            3 visible* $equ	invisible
  :                            4 	$end
  :                            5 
  :                            6 macro2* $proc
  :                            7 macro3* $proc
  :                            8 manifest****
  :                            9 private***
  :                            10 unseen
  :                            11 invisible**
  :                            12 	$end
  :                            13 	macro3
  :                            14 	$end
  :                            15 
  :                            16 $(14:0E000)
  :                            17 	macro1
  :                            18 	$end
macro1=:P1:0:000000
macro2=:P1:0:000001
manifest+=$0E:00E000
private=$0E:00E000
visible=00E000
visible.msm=0<000003
:$(0E):00E000:00E000 
visible.msm: object code 47 bytes: 0 errors: 0 undefined labels
$
$ cat visible.txo

+manifest:$0E:00E000
:$0E*000000:00E000:00E000
$

</pre>

The name "manifest" has been exported here in the <a href="#txo">output file</a>

<p>
An asterisk at the main assembly level externalises the label

<p>
Directive $set is a temporary equate

<p>
$set labels can be restated without restriction

<p>
A $set label at main assembly which is not exported may be restated with surplus asterisks but is not consequently exported

<p>
This assembly does not export any names

<pre	style="font-size:12pt;color:#0000FF">

$ masmx attestor -lnx
MASMX 7r3
3/attestor.msm
*EOF*
  :                            1 "$$local"	$set	1
  :                            2 
  :                            3 outward*	$proc
  :                            4 "$$local"******	$set	2
  :                            5 		$end
  :                            6 
  :                            7 		outward
  :                            8  
*EOF*
$$LOCAL=000002
OUTWARD=:P1:0:000000
attestor.msm=0<000003

attestor.msm: object code 0 bytes: 0 errors: 0 undefined labels
$ cat temp.txo
$

</pre>
The <a href="#file_formats">text-encoded binary</a> file temp.txo contains no exported names and no other information because no code is assembled

<a	name="commands"/>
<h3>3.2: Command and Arguments Fields</h3>

The command field is the first field to follow any whitespace. It may contain 

	<blockquote>
	nothing. Then there are no arguments either<br><br>
	a number constant or a character string constant<br><br>
	an assembler directive command<br><br>
	the macro name of an instruction or data structure
	</blockquote>

Assembly language coding is largely instruction code

<p>
Most source lines have the macro name of an instruction in the command position

<p>
Other commands can be about data structures or commands to the assembler like $include or $equ

<p>
Instruction names are macros because a meta-assembler knows no instructions until they are described in macro language

<a	name="form"/>
<h3>3.3: Fields Template Directive $form</h3>
Most instruction macros centre on a directive command
<a href="http://timmilescox.github.io/masmx/masmx.html#form">$form</a>,
which describes the instruction in bit fields

<pre	style="font-size:12pt;color:#0000FF">

isimple $form	5,3,16

p	$proc
lret*	$name	6
fret*	$name	7
	isimple	p(0, 0), 5, p(1, 1)
	$end

</pre>
Here is a corresponding line of application code
<pre	style="font-size:12pt;color:#0000FF">

	lret	1	. return and skip 1 instruction


.	the values in the generated instruction are
.	_____________________________________
.	| 00110 | 101 | 0000 0000 0000 0001 |
.	|_______|_____|_____________________|

</pre>

see also sections <b>$form</b> and <b>$proc</b>

<p>
$form also defines structures other than instructions up to eight words in size,
for example gates which navigate calls between dynamic instruction frames

<pre	style="font-size:12pt;color:#0000FF">

gate	$form		6, 18, 2, 22

	gate		7, OFFSET, 2, START_PAGE_INDEX

</pre>

<a	name="constants"/>
<h2>4: Data Constants</h2>
<a	name="expressions"/>
<h3>4.1: Expressions and Numbers</h3>
<a	name="operator"/>
<h4>4.1.1: Operators</h4>

Operators by rank are
<pre    style="font-size:12pt;color:#0000FF">

	()

	^=	=

	^&gt;	&gt;

	^&lt;	&lt;

	--

	++

	/*

	*/

	*/-

	**

	*+	*-

	+	-

	*	/	//	///

	&plusmn;	^unary

</pre>
Operators in the same rank have left-to-right precedence as they are
encountered in the expression

<p>
Operators of higher rank are evaluated first and operated last. An expression
generates an integer until a decimal exponent operator *+ *- is actioned or a
decimal point is encountered

<p>
The operators are 
<pre	style="font-size:12pt;color:#0000FF">

	_________________________________________
	|	=	|	equal		|	=  : 1 else 0
	|_______________|_______________________|
	|	^=	|	unequal		|	=  : 0 else 1
	|_______________|_______________________|
	|	&gt;	|	greater		|	&gt;  : 1 else 0
	|_______________|_______________________|
	|	&lt;	|	less		|	&lt;  : 1 else 0
	|_______________|_______________________|
	|	^&gt;	|	not greater	|	&gt;  : 0 else 1
	|_______________|_______________________|
	|	^&lt;	|	not less	|	&lt;  : 0 else 1
	|_______________|_______________________|
	|	--	|	XOR		|
	|_______________|_______________________|
	|	++	|	OR		|
	|_______________|_______________________|
	|	/*	|	shift right	|
	|_______________|_______________________|
	|	*/	|	shift left	|
	|_______________|_______________________|
	|	*/-	| right	shift algebraic	|
	|_______________|_______________________|
	|	**	|	AND		|
	|_______________|_______________________|
	|	*+	|      +decimal exponent|
	|_______________|_______________________|
	|	*-	|      -decimal exponent|
	|_______________|_______________________|
	|	+	|	PLUS		|
	|_______________|_______________________|
	|	-	|	MINUS		|
	|_______________|_______________________|
	|	*	|	MULTIPLY	|
	|_______________|_______________________|
	|	/	|	DIVIDE		|
	|_______________|_______________________|
	|	//	|	covered quotient|
	|_______________|_______________________|
	|	///	|	remainder	|
	|_______________|_______________________|


Only	+	PLUS
	-	MINUS
	**	AND
	/*	SHIFT RIGHT
	*/-	SHIFT RIGHT ALGEBRAIC may be applied to relocatable tokens


	+ PLUS - MINUS may operate without restriction on mixed relocatable and absolute tokens	

	The token left of ** <a style="color:FFFFFF;background-color:000000">AND</a> may be relocatable, not the mask. Linker range check is suppressed

	/* SHIFT RIGHT */- SHIFT RIGHT ALGEBRAIC shift the final relocated value

	/* SHIFT RIGHT shifts the relocated value logically right and range-checks unsigned

	shift left operator */ with negative shift count is SHIFT RIGHT ALGEBRAIC.
	Range check at link is signed. The target field contains at least one sign bit.
	The relocated value is shifted right algebraically


$ masmx relarith -lnk
MASMX 7r3
3/relarith.msm
*EOF*
  :                            1 ABSOLUTE	$equ	-4096
  :                            2 MINUS8		$equ	-8
  :                            3 $(5:*1)
  :                            4 relocatable	$res	1
  :                            5 $(6:06000)
  :                            6 
(+05:000000/*10)18+
06:006000 000000              +7 	+	relocatable*/-16	. signed range check after relocation
  :                            8 					. shift right algebraic 16 positions
  :                            9 
(+05)18+
06:006001 000000              +10 	+	relocatable*/-0		. signed range check after relocation
  :                            11 					. shift no positions
  :                            12 
(+05:000000/*10)18+
06:006002 000000              +13 	+	relocatable*/(-16)	. signed range check after relocation
  :                            14 					. shift right algebraic 16 positions
  :                            15 
06:006003 FFFFF0              +16 	+	ABSOLUTE*/MINUS8	. shift right algebraic at assembly time
06:006004 FFFFF0              +17 	+	ABSOLUTE*/-8		. shift right algebraic at assembly time
06:006005 00FFF0              +18 	+	0FFF000/*8		. shift right logical at assembly time	
  :                            19 
(+05:000000/*08)18
06:006006 000000              +20 	+	relocatable/*8		. unsigned range check after relocation
  :                            21 					. shift right logical 8 positions
  :                            22 
(+05:000000/*0c)18+
[+0000:000000/*0c]18+
06:006007 000000              +23 	+	relocatable+EXTERNAL*/-12 . signed range check after relocation
  :                            24 					. shift right algebraic 12 positions
  :                            25 
(+05:000000/*08)18+
06:006008 000000              +26 	+	relocatable*/MINUS8	. signed range check after relocation
  :                            27 					. shift right algebraic 8 positions
  :                            28 
*EOF*
:$(05):000000:000001 :$(06):006000:006009 


</pre>

<a	name="numbers"/>
<h4>4.1.2: Integers and Floating Point</h4>

RTA1 has twos complement integer arithmetic and ones complement floating arithmetic

<p>
&nbsp;-<i>FLOATING_EXPRESSION</i> generates the same constant as ^<i>FLOATING_EXPRESSION</i>

<p>
Integer and floating constants can be up to eight words in size

<p>
RTA1 computes <a href="rta.html#fp">floating numbers</a> of four or eight words

<p>
Number constants have the default masmx syntax. Leading 0 means hex unless the number string has a decimal point for example 0.5

<p>
A unary sign in the command field indicates a number constant
but is not always necessary
<pre	style="font-size:12pt;color:#0000FF">

	+	<i>expression</i>
	<i>-expression</i>

</pre>

<a	name="qnu"/>
An unsigned number starting with a digit or a single quote (apostrophe)
in the command field is recognised as a positive number constant

<pre	style="font-size:12pt;color:#0000FF">

$ masmx -ln
MASMX 7r3
0/-INPUT>>

        99
        1.5*+2
	'abcd'
	$end
  :                            1 
00:000000 000063              +2 	 99
00:000001 400008960000000000000000
                              +3 	1.5*+2
00:000005 000061626364        +4 	'abcd'
  :                            5 	$end
:$(00):000000:000007 


</pre>


<p>
In masmx.7r3 a unary symbol appended to the front of the
constant expression only exerts polarity on the first token

<pre	style="font-size:12pt;color:#0000FF">

$ masmx -ln
MASMX 7r3
0/-INPUT>>
	-2-2
	^0f0f++3
	-5-10*-1 
	$end
00:000000 FFFFFC              +1 	 -2-2
00:000001 FFF0F3              +2 	^0f0f++3
00:000002 BFFFFE3FFFFFFFFFFFFFFFFF
                              +3 	-5-10*-1 
  :                            4 	$end
:$(00):000000:000006 

</pre>

<p>
Unary ^ is 1s complement

<p>
A unary symbol in the command field separated by whitespace
from the following constant expression exerts polarity on the
total expression which follows

<pre	style="font-size:12pt;color:#0000FF">

$ masmx -ln
MASMX 7r3
0/-INPUT>>
	-	2-2
	-	50+50:d
	+	3072-1:t
	+	0ffffffcccccc++0ffffffEEEEEE*/48:q
        -       100000*/96:p

        +       1.75*+1200000
	$end
00:000000 000000              +1 	-	2-2
00:000001 FFFFFFFFFF9C        +2 	-	50+50:d
00:000003 000000000000000BFF  +3 	+	3072-1:t
00:000006 FFFFFFEEEEEEFFFFFFCCCCCC
                              +4 	+	0ffffffcccccc++0ffffffEEEEEE*/48:q
00:00000A FE7960000000000000000000000000
                              +5 	-	100000*/96:p
  :                            6 
00:00000F 7CD38BB7B396D7AA20B6E083
                              +7 	+	1.75*+1200000
  :                            8 	$end
:$(00):000000:000013 


</pre>
<p>
Fixed point numbers are autosized. masmx adds an extra word of signs
where the high order bit of the magnitude is not a sign.
Size can be forced with a suffix
<pre	style="font-size:12pt;color:#0000FF">

$ masmx -ln
MASMX 7r2
0/-INPUT>>
	+	255*/16
	+	255*/16:s
	$end
00:000000 000000FF0000        +1 	+	255*/16
00:000002 FF0000              +2 	+	255*/16:s
  :                            3 	$end
:$(00):000000:000003 


</pre>
The size suffixes are
<pre	style="font-size:12pt;color:#0000FF">

	:s	:S			one word
	:d	:D	:l	:L	two words
	:t	:T			three words
	:q	:Q			four words
	:p	:P			five words
	:h	:H			six words
	:z	:Z			seven words
	:o	:O			eight words

</pre>

<p>
Size suffix does not always need a colon
but it is never wrong to type the colon. Parentheses can also separate the suffix from labels and hex symbols

<p>
Upper and lowercase suffix are interchangeable


<p>
Symbols in single quotes generate the data code value in fields of byte size right justified

<pre	style="font-size:12pt;color:#0000FF">

$ masmx -ln
MASMX 7r3
0/-INPUT>>
	+	'abcd'
	$data_code	97:65	. generate 'A' when the source has 'a'
	'abcd'++128		. logical OR bit 7 on
	$ascii			. switch back to plain ASCII
	$byte	12		. make the byte size a halfword
	'abcd'
	$end
00:000000 000061626364        +1 	+	'abcd'
  :                            2 	$data_code	97:65	. generate 'A' when the source has 'a'
00:000002 0000416263E4        +3 	'abcd'++128		. logical OR bit 7 on
  :                            4 	$ascii			. switch back to plain ASCII
  :                            5 	$byte 	12		. make the byte size a halfword
00:000004 061062063064        +6 	'abcd'
  :                            7 	$end
:$(00):000000:000006 

</pre>

<p>
Tokens in an expression may be labels

<p>
<b>$equ</b> labels are fixed in value. <b>$set</b> labels can be
set again to a new value
<pre	style="font-size:12pt;color:#0000FF">

fast	$equ	1.75	. can't be changed within this subassembly
loose	$set	99	. can be changed as much as you like

</pre>
Not all operations are allowed on labels which are relocatable
storage addresses
<pre	style="font-size:12pt;color:#0000FF">

$(3:*1)			. relocatable program section

buffer	$res	20	. buffer can be in &plusmn; expressions
			. and shift right expressions

</pre>
Labels in expressions may also be masmx automatic function names
or the names of macros of the $func type

<p>
These examples show function expressions in instruction operands
instead of constants
<pre	style="font-size:12pt;color:#0000FF">

	jc	$+2	. current location counter + 2

f	$func
upto10*	$name
	$do	f(1, 1)>10,	$return	10
	$return	f(1, 1)
	$end


	lr, xi	upto10(ACTUAL_PARAMETER)		
	

</pre>
The optional tag of <b>$do</b> directive is a value incrementing
from 1
<pre	style="font-size:12pt;color:#0000FF">

$ masmx -ln
MASMX 7r3
0/-INPUT>>
mantissa	$equ	175
exponent	$do	3,	+mantissa*+exponent-3
		$end
  :                            1 mantissa	$equ	175
00:000000 400001E00000000000000000
                              +2 exponent	$do	3,	+mantissa*+exponent-3
00:000004 4000058C0000000000000000
                              +2 
00:000008 400008AF0000000000000000
                              +2 
  :                            3  		$end
:$(00):000000:00000C 

</pre>

<p>

Integers are twos-complement negative and floating numbers are 1s-complement negative

<pre    style="font-size:12pt;color:#0000FF">

        $ masmx -ln
MASMX 7r3
0/-INPUT>>
        -       6
        -       0.5
        $end
00:000000 FFFFFA              +1        -       6
00:000001 BFFFFF7FFFFFFFFFFFFFFFFF
                              +2        -       0.5
  :                            3        $end
:$(00):000000:000005


</pre>

<a	name="fp96data"/>
<h4>4.1.3 Floating Point</h4>

<p>
Floating constants are typed as decimal string with decimal point and optional e&plusmn;<br> 
or as decimal fractions with exponent operator *+ or *-<br>
or as integer expressions with tokens in any notation and exponent operator *+ or *-
<pre    style="font-size:12pt;color:#0000FF">

$ masmx -lnke
MASMX 7r3A Build 8
0/-INPUT>>
		1.23456789012345678901e1250000
EXPONENT 	$equ    1250000-20
	06B14E9F812F366C35*+EXPONENT
	$end
00:000000  7F5C5B AB90C2 6474BB A03580
                              +1   1.23456789012345678901e1250000
  :                            2 EXPONENT  $equ    1250000-20
00:000004  7F5C5B AB90C2 6474BB A03580
                              +3  06B14E9F812F366C35*+EXPONENT
  :                            4  $end
:$(00):000000:000008 


</pre>

e can be E or E+

<p>
The floating mantissa is a simple fraction.<br>
Its integral part is derived by hauling the mantissa
upwards through the fractional point<br>by the number of
positions with which the exponent exceeds the midpoint
value <b>0400000</b>
<pre	style="font-size:12pt;color:#0000FF">

	$ masmx -ln
MASMX 7r3
0/-INPUT>>
	+	1.5
	$end
00:000000 400001C00000000000000000
                              +1 	+	1.5
  :                            2 	$end
:$(00):000000:000004 


</pre>
Floating point numbers do not autosize.
They are four words unless a size override is typed

<p>
An RTA1 floating operand is four words

<p>
An eight word floating constant is generated with the macro major_minor for <a href="#fp192data">192-bit floating library</a> computation

<p>
Macro <a href="rta.html#fp48_data">fpx</a>  promotes a 48-bit compressed floating number to four words in the internal stack top

<p>
See also <a href = "#fp192i">192-Bit Floating Point</a>
and <a href="#fp48data">Floating Storage Compression</a>
<pre	style="font-size:12pt;color:#0000FF">


$ masmx -ln
MASMX 7r3
0/-INPUT>>
        $list		0
	$include	../def/rta.def
	$list
$(3:03000)
left	1.75*+1250000
right	1.75*-1250000
$(0:64)
left_plus_right
	ql	left
	fa	right


  :                            451 		$list
  :                            452 $(3:03000)
03:003000 7F5C5BF331AD4B6FFBBCAAB2
                              +453 left		1.75*+1250000
03:003004 00A3A7CE52225BC80EDFF592
                              +454 right	1.75*-1250000
  :                            455 $(0:64)
  :                            456 left_plus_right
00:000040 4F3000              +457 		ql	left
00:000041 673004              +458 		fa	right


</pre>
<a	name="fp48data"/>
<h4>4.1.4: Floating Storage Compression</h4>

See also <a href="#fpai">Floating Arithmetic Instructions</a>

<p>
The two-word suffix [ d D l L] assembles the floating expression as a 48-bit constant which library can
expand to four words at the internal stack top with macro fpx

<p>
RTA1 computes 96-bit floating-point but library macro fpp
pops a 96-bit number in a 48-bit floating format
<pre	style="font-size:12pt;color:#0000FF">

$ masmx -lnke
MASMX 7r3A Build 12
0/-INPUT>>
	$list	        0
	$path		../
	$include	def/rta.def
	$include	lib/compress.def
	$path
	$list

$(0:64)

        fpx             (4.096:d*+200)          . load and expand the 2-word input
        fa              0, sp                   . use the expanded number

        qs              0, sp
        fpp             compressed_storage      . store and compress the result
                                                . from 4 words to 2
        $do             $<256,$(0:256)

$(3:03000)
compressed_storage $res 2
        $end
  :                            493  $list
  :                            494 
  :                            495 $(0:64)
  :                            496 
00:000040  9F0100              +497         fpx             (4.096:d*+200)          . load and expand the 2-word input
00:000041  9FF000              +497 
00:000042  FF0102              +497 
00:000043  67F000              +498         fa              0, sp                   . use the expanded number
  :                            499 
00:000044  47F000              +500         qs              0, sp
00:000045  FF0103              +501         fpp             compressed_storage      . store and compress the result
00:000046  5F3000              +501 
00:000047  5FF000              +501 
  :                            502                                                 . from 4 words to 2
  :                            503         $do             $<256,$(0:256)
  :                            504 
  :                            505 $(3:03000)
  :                            506 compressed_storage $res 2
  :                            507         $end
00:000100+69BAB3C2FDDF
00:000102+[0000]18:000000
00:000103+[0001]18:000000
:$(00):000040:000104 :$(03):003000:003002 

</pre>

48-bit compressed floating format has 11 exponent bits equivalent to decimal exponent range approximately &plusmn;307
<pre	style="font-size:10pt;color:#00AF6F">


	47 46     36 35                                        0
	_________________________________________________________
	|s|   11    |		mantissa 36 bits		|
	|_|_________|___________________________________________|

</pre>
96-bit compute format has 23 exponent bits equivalent to decimal exponent range approximately &plusmn;1262611
<pre	style="font-size:10pt;color:#00AF6F">

	_________________________________________________________________________________________________
	|s|	    23		|			   mantissa 72 bits				|
	|_|_____________________|_______________________________________________________________________|
	95 94                 72 71                                                                    0

</pre>

<p>
<a	name="fp192data"/>
<h4>4.1.5: 192-Bit Floating Point</h4>

<p>

192-bit floating constants are generated with macro major_minor

<pre	style="font-size:12pt;color:#0000FF">

	$path		rta/target.rta
	$include	lib/144.def
	$path


value3	major_minor	1.222222333333111111222222333333111111222222*+1250000


</pre>
major_minor macro constructs two teamed 96-bit floating numbers for 192-bit arithmetic
with effective mantissa 144 bits

<p>
No length override is given to major_minor macro

<p>
These library calls compute 192-bit floating values:
<pre	style="font-size:12pt;color:#0000FF">


	$include	language/stack.def
									. 1st operand loadup:
									. address of operand in internal stack

	c	(fp192lib_load)			<i>source</i>,,i	. registers a b 6 7 8 9 10 11 are loaded
	c	(fp192lib_load_negative)	<i>source</i>,,i	. registers a b 6 7 8 9 10 11 are loaded

									. 4-functions arithmetic:
									. 1st operand in registers [ a..11 ]
									. address of 2nd operand in stack
									. result in registers [ a..11 ]

	c	(fp192lib_add)			<i>addend</i>,,i	. 1st addend in registers [ a..11 ]
	c	(fp192lib_add_negative)		<i>subtrahend</i>,,i	. minuend is in registers [ a..11 ]
	c	(fp192lib_multiply)		<i>multiplier</i>,,i	. multiplicand in registers [ a..11 ]
	c	(fp192lib_divide)		<i>divisor</i>,,i	. dividend is in registers [ a..11 ]

						. pushed address needs to be ,,i if it is base + displacement
						. as function parameters & dynamic variables are: displacement, sp
						. pushed address may be address,,xi if direct addressed like static

	c	(reciprocal192)			<i>value</i>,,float192	. 8-word argument in the stack
									. reciprocal delivered in [ a..11 ]

	c	(fp192lib_mfa)	<i>multiplicand</i>,,i	<i>multiplier</i>,,i	. 2 addresses in stack
								. product is written -> multiplicand

</pre>

<a	name="literals"/>
<h3>4.2: Literals</h3>

See also <a href="scripts.html#literal_tables">Literal Tables</a> and
<a href="scripts.html#locators">Application Memory Map</a>

<p>
A literal is a constant declared as an operand and
assembled at the end of a default program section or a specified section

<p>
Literals look like immediate operands but are storage
constants of any size. The instruction contains their
address, not their value

<a	name="automatic_literals"/>
<h3>4.2.1: Automatic Literals</h3>

<p>
Automatic literals are enabled with assembly flag -a

<p>
-a is already opted in header rta.def

<p>
Automatic literals are generated by reference to a value in parentheses with no operators outside as shown
<pre	style="font-size:10pt;color:#0000FF">

	ql	(1.65*+1200000)		. a 4-word floating literal generated by reference

</pre>

This literal is generated as part of this sample assembly at address 000102<sub>16</sub>

<p>
The quad load instruction invoking it is at address 000042<sub>16</sub>

<pre	style="font-size:10pt;color:#0000FF">

$ masmx -lnkez
MASMX 7r3A Build 12
0/-INPUT>>
	$list		0
	$path		../
	$include	def/rta.def
	$include	stream/stream.def
	$include	language/stack.def
	$include	lib/ascii.def
	$path
	$list

$(31:01F000)
        $list   0
?       $do     1024,number(?)  1.75*+?-1
        $list
$(3:03000)
$(0:64)
	lx	(number(512))		. a literal pointer halfway in the table of floating numbers
	lk	(127*/16)		. a literal mask value too wide to be an immediate operand
	ql	(1.65*+1200000)		. a 4-word floating literal generated by reference

	$lit	3			. change the default section for literals from 0 to 3

	printf	("the acquired floating value is %f":LF:0),,xi	a,,float
	fret	0

	$do	$<256,$(0:256)		. force section 0 literals into memory range 256+
	$end
  :                            1071  $list
  :                            1072 
  :                            1073 $(31:01F000)
  :                            1076         $list
  :                            1077 $(3:03000)
  :                            1078 $(0:64)
00:000040  500100              +1079  lx (number(512))		. a literal pointer halfway in the table of floating numbers
00:000041  480101              +1080  lk (127*/16)		. a literal mask value too wide to be an immediate operand
00:000042  4F0102              +1081  ql (1.65*+1200000)	. a 4-word floating literal generated by reference
  :                            1082 
  :                            1083  $lit 3			. change the default section for literals from 0 to 3
  :                            1084 
00:000043  8F0004              +1085  printf ("the acquired floating value is %f":LF:0),,xi a,,float
00:000044  FD3000              +1085 
00:000045  FD0001              +1085 
00:000046  FCF006              +1085 
00:000047  FF300C              +1085 
00:000048  38000F              +1085 
00:000049  3D0000              +1086  fret 0
  :                            1087 
  :                            1088  $do $<256,$(0:256)		. force section 0 literals into memory range 256+
  :                            1089  $end
00:000100+01F7FC
00:000101+7F0000
00:000102+7CD38BAD344C64F0DD0432C5
03:003000+74686520616371756972656420666C6F6174696E67207661
6C75652069732025660A0000
03:00300c+[0000]18:000000
:$(00):000040:000106 :$(03):003000:00300D :$(1F):01F000:020000 

</pre>
By default automatic literals are assembled at the end of program section $(0)

<p>
The <b>$lit</b> directive designates which program section has automatic literals at the end
<pre	style="font-size:12pt;color:#0000FF">

[tag]	$lit	3		. change the default section for literals from 0 to 3

</pre>
If <b>$lit</b> directive has no argument, automatic literals are placed
at the end of the program section containing the <b>$lit</b> directive

<p>
A literal may contain a macro generating data or code
<pre	style="font-size:12pt;color:#0000FF">

$ masmx lstruct -lnk
MASMX 7r3
3/lstruct.msm
*EOF*
  :                            1 	$path		freeware/RTA1/rta
  :                            2: 	$include	def/rta.def
  :                            3: 	$include	t77.4/ip.def
  :                            4 	$path
  :                            5 
  :                            6 $(3:03000/$3)
  :                            7 buffer	$res		2048
  :                            8 $(0:64)
00:000040 970100              +9 	ex		(dl		$3($net_socket	127.0.0.1:8080))
  :                            10 	$do		$<256,$(0:256)
  :                            11 
*EOF*
00:000100+CF3800
03:003800+7F0000011F90
:$(00):000040:000101 :$(03):003000:003802 


</pre>

<a	name="tagged_literals"/>
<h3>4.2.2: Tagged Literals</h3>

A literal which is not automatic  has a literal pool
tag before the opening parenthesis
<pre	style="font-size:12pt;color:#0000FF">

$ masmx -lnz
MASMX 7r2
0/-INPUT>>

        $list   0
        $include        freeware/RTA1/rta/def/rta.def
        $list

$(3:03000/$literals3)
$(0:64)

	lx, xi		$literals3("this way to the gastronomy hall")

	$end
  :                            1 
  :                            428         $list
  :                            429 
  :                            430 $(3:03000/$literals3)
  :                            431 $(0:64)
  :                            432 
00:000040 553000              +433  lx, xi  $literals3("this way to the gastronomy hall")
  :                            434 
  :                            435  $end
03:003000+746869732077617920746F207468652067617374726F6E6F
6D792068616C6C0000
:$(00):000040:000041 :$(03):003000:00300B 

</pre>

<a	name="strings"/>
<h3>4.3: Character Strings</h3>

Strings generate the containing number of data words. The default byte size
is 8 bits and the default data code is ASCII
<pre	style="font-size:12pt;color:#0000FF">

$ masmx strings -ln
MASMX 7r2
3/strings.msm
*EOF*
  :                            1 	$set_option	"z"
00:000000 737472696E67        +2 	"string"
  :                            3 	$byte	12
00:000002 07307407206906E067  +4 	"string"
  :                            5 	$byte	16
00:000005 0073007400720069006E0067
                              +6 	"string"
  :                            7 	$byte	24
00:000009 00007300007400007200006900006E000067
                              +8 	"string"
  :                            9 	$byte	6
00:00000F CF4CA9BA7000        +10 	"string"
  :                            11 	$byte	7
Note: strings.msm Line 12: trailing zero bits in last data word of string
00:000011 E7D3969DD9C0        +12 	"string"
  :                            13 	$byte	8
00:000013 737472696E67        +14 	"string"
  :                            15 
*EOF*
:$(00):000000:000015 

</pre>
Padding to word fill is zero with option <b>-z</b> otherwise space

<p>
Strings may contain ASCII extensions like UTF-8 
<pre	style="font-size:12pt;color:#0000FF">

$ masmx -lnke
MASMX 7r3A Build 8
0/-INPUT>>
	"canoë"
	$end
00:000000  63616E 6FC3AB        +1  "canoë"
  :                            2  $end

</pre>
The last symbol in <a style="color:#0000FF">canoë</a> occupies more memory than the others

<p>
Nondisplay byte values can be placed in strings (see also <a href="http://timmilescox.github.io/masmx/masmx.html#cstring">-c option</a>)
<pre	style="font-size:12pt;color:#0000FF">

$ masmx -ln
MASMX 7r3
0/-INPUT>>
LF	$equ	10
edit	"the result is %f":LF:0
	$end
  :                            1 LF	$equ	10
00:000000 74686520726573756C742069732025660A00
                              +2 edit	"the result is %f":LF:0
  :                            3 	$end
:$(00):000000:000006 

</pre>
<p>
In <b>masmx.7r3</b> the masmx-internal label <b>$bits</b> contains
the number of bits containing the characters in the string after the
string is assembled

<p>
The number of characters in the string can be captured

<pre	style="font-size:12pt;color:#0000FF">

$ masmx -lnz
MASMX 7r3
0/-INPUT>>
	"abcd"
	+	$bits
	+	$bits/$byte
	$end
00:000000 616263640000        +1 	"abcd"
00:000002 000020              +2 	+	$bits
00:000003 000004              +3 	+	$bits/$byte
  :                            4 	$end
:$(00):000000:000004 

</pre>


<p>
Changed data code and byte size are effective for "strings" and for
number +'strings'
<pre	style="font-size:12pt;color:#0000FF">

$ masmx -ln
MASMX 7r3
0/-INPUT>>
	"789abc"
	$data_code	97:65,66,67
	"789abc"
	$byte	12
	"789abc"
	$ascii
	"789abc"
	$byte	8
	"789abc"
	$end
00:000000 373839616263        +1 	"789abc"
  :                            2 	$data_code	97:65,66,67
00:000002 373839414243        +3 	"789abc"
  :                            4 	$byte 12
00:000004 037038039041042043  +5 	"789abc"
  :                            6 	$ascii
00:000007 037038039061062063  +7 	"789abc"
  :                            8 	$byte 8
00:00000A 373839616263        +9 	"789abc"
  :                            10 	$end
:$(00):000000:00000C 


</pre>

<a	name="comma_fields"/>
<h3>4.4: Number Constants with Equal-Size Bit Fields</h3>

A number constant divided by commas means the containing word or words is of equal sized fields. The total size is one word regardless of value truncation, unless an override suffix is typed
<pre	style="font-size:12pt;color:#0000FF">

		$ masmx -ln
MASMX 7r3
0/-INPUT>>

RED48		$equ		48
GREEN72		$equ		72
BLUE240		$equ		240

	+	RED48, GREEN72, BLUE240
	+	0FFFC, 08003, 07001:d    

	+	15, 14, 12, 0, 5, 10
	+	7, 4, 3, 6,  6, 3, 2, 5
	$end
  :                            1 
  :                            2 RED48		$equ		48
  :                            3 GREEN72	$equ		72
  :                            4 BLUE240	$equ		240
  :                            5 
00:000000 3048F0              +6 	+	RED48, GREEN72, BLUE240
00:000001 FFFC80037001        +7 	+	0FFFC, 08003, 07001:d    
  :                            8 
00:000003 FEC05A              +9 	+	15, 14, 12, 0, 5, 10
00:000004 F1ECD5              +10 	+	7, 4, 3, 6,  6, 3, 2, 5
  :                            11 	$end
:$(00):000000:000005 


</pre>


<a	name="instructions"/>
<h2>5: Instructions and Operands</h2>

Instructions are listed here in functional groups

<p>
Instructions are explained more in
<a href="rta.html#iset"> RTA1 Programmable Processor Architecture Specification 3.3: Instruction Set</a>

<p>
Most instructions imply an arithmetic operand in scalar registers or the internal stack.
All instructions derive an input or output from an effective address

<a	name="operands"/>
<h3>5.1: Register / Memory Operand Continuum</h3>
<p>
The address-side operand may be in storage or a register and may be an immediate value 

<p>
Registers are in memory address space

<a	name="registers"/>
<h3>5.2: Programmable Register Model</h3>

<a	name="nar"/>
<h4>5.2.1: Two Non-Addressable Registers</h4>

There are two <a href="rta.html#nonar">non-addressable registers</a>, the 48-bit absolute program counter and the 24-bit processor state register

<p>
Absolute program counter is never stored

<p>
PC - B0 * 4096 is pushed on calls and interrupts. Iframe Name is then pushed on far calls and interrupts

<p>
On interrupt returns and far returns popped Iframe Name:Start Page Index -> B0 * 4096 is added to popped offset
and transferred to absolute program counter


<p>
PSR is stored and loaded at interrupt and interrupt return. Its flag assignments are
<pre	style="font-size:12pt;color:#0000FF">

		23             18   16     14           8   7   6   5   4   3         0
		_________________________________________________________________________
		| I | 0 0 0 0 | i i i | 0 | see$          | H | R | R | W | F | 0 0 | C |
		|   |         |       |   | 1 2 3 4 5 6 7 |   | Z |16 |16 | P |     |   |
		|___|_________|_______|___|_______________|___|___|___|___|_R_|_____|___|


		I = 0 = current state is application: registers are 0..127
		    1 =                    interrupt: registers are 128..255

		iii	interrupt mask

		see$1 = 0 = data window 01000..01FFF  = private stack window B1
		 	1 =				Thread Control Block

		see$2 = 0 = data window 02000..02FFF  = application vector list
			1 =				kernel vector list

		see$3
		see$4
		see$5
		see$6
		see$7	select kernel data windows instead of application windows B3..B7

		half$w = 0 = read / write thirdwords
			 1 = read / write halfwords

		b$streamZR = 0 = do not clear a at start of rsr instruction
			     1 = clear a at start of rsr instruction

		b$stream16r = 0 = use 24 bits of data words in Bitstream Read Channel
			      1 = use 16 bits

		b$stream16w = 0 = use 24 bits of data words in Bitstream Write Channel
			      1 = use 16 bits

		Flag 3 fp$r is used for teaming pairs of floating numbers to calculate 192-bit values
		When fp$r is asserted floating instructions store a minor result in registers 8..11

		carry$ = carry from high-order position of integer adds and integer negative adds


</pre>

<a	name="ioar"/>
<h4>5.2.2: Memory Space Mapped in I/O Ports</h4>
<p>
Storage relocation pointers and limits are addressable as I/O ports

<a	name="register_stack"/>
<h4>5.2.3: Register Stack</h4>

The register stack populates the initial 256 locations of address space

<p>
Applications and interrupts each have 128 registers in the 256-word register stack

<p>
Application and interrupt spaces each have scalar arithmetic, pointer and special registers in their 128-word region of the register stack

<p>
Applications and ISRs each have an internal stack of 104 registers at addresses [ 24..127, 152..255 ]

<p>
Macro libraries are supplied to reuse internal stack space for demanding behaviour like recursion

<p>
Target realtime behaviour contains parameters and local variables entirely
in the internal stack. This is achieved for kernel, IP stack and supplied applications

<pre	style="font-size:12pt;color:#0000FF">

			    Application Registers						      Interrupt Registers
			    _____________________						      ___________________


		 23			       0					 23			       0
		_________________________________					_________________________________
	0	|		r		|	repeat counter	 	128	|		r_x		|
		|_______________________________|					|_______________________________|
	1	|		k		|	mask register		129	|		k_x		|
		|_______________________________|					|_______________________________|
	2	|		x		|	index register		130	|		x_x		|
		|_______________________________|					|_______________________________|
	3	|		y		|	index register		131	|		y_x		|
		|_______________________________|					|_______________________________|
	4	|		a		|  accumulator + index register	132	|		a_x		|
		|_______________________________|					|_______________________________|
	5	|		b		|  accumulator + index register	133	|		b_x		|
		|_______________________________|					|_______________________________|
	6	|	mantissa2		|	accumulator		134	|	mantissa2_x		|
		|_______________________________|					|_______________________________|
	7	|	mantissa3		|	accumulator		135	|	mantissa3_x		|
		|_______________________________|					|_______________________________|
	8	|		aA		|	accumulator		136	|		aA_x		|
		|_______________________________|					|_______________________________|
	9	|		bA		|	accumulator		137	|		bA_x		|
		|_______________________________|					|_______________________________|
	10	|	mantissa2A		|	accumulator		138	|	mantissa2A_x		|
		|_______________________________|					|_______________________________|
	11	|	mantissa3A		|	accumulator		139	|	mantissa3A_x		|
		|_______________________________|					|_______________________________|
	12	|	    	 p		|	bitstream pointer write	140	|		p_x		|
		|_______________________________|					|_______________________________|
	13	|	   	 q		|	bitstream pointer read	141	|		q_x		|
		|_______________________________|					|_______________________________|
	14	|	  	 fp		|	index register		142	|		fp_x		|
		|_______________________________|					|_______________________________|
	15	|	  	 sp		|	index register		143	|		sp_x		|
		|_______________________________|					|_______________________________|
	16	|		d$save		|	scratch			144	|				|
		|_______________________________|					|_______________________________|
	17	|		d$save1		|	scratch			145	|				|
		|_______________________________|					|_______________________________|
	18	|		d$save2		|	scratch			146	|				|
		|_______________________________|					|_______________________________|
	19	|		d$save3		|     < scratch | fp rounding > 147	|	fp$guard		|
		|_______________________________|					|_______________________________|
	20	|	   RDATAC		|	bitstream counter read	148	|	REALTIME$_CLOCK		|
		|_______________________________|					|_______________________________|
	21	|	    RDATA		|	bitstream data read	149	|	PRIORITY$		|
		|_______________________________|					|_______________________________|
	22	|	   WDATAC		|	bitstream counter write	150	|	DAYCLOCK$U		|
		|_______________________________|					|_______________________________|
	23	|	    WDATA		|	bitstream data write	151	|	DAYCLOCK$ 		|
		|_______________________________|					|_______________________________|
	24	| maximum internal stack top	|				152	|				|
		|_______________________________|					|_______________________________|
	25	|				|				153	|				|
		|_______________________________|					|_______________________________|
	26	|				|				154	|				|
		|_______________________________|					|_______________________________|
	27	|				|				155	|				|




		|_______________________________|					|_______________________________|
	124	|				|				252	|				|
		|_______________________________|					|_______________________________|
	125	|				|				253	|				|
		|_______________________________|					|_______________________________|
	126	|				|				254	|				|
		|_______________________________|					|_______________________________|
	127	|				|	first pushed word	255	|				|
		|_______________________________|	on internal stack		|_______________________________|


</pre>

Bitstream channel buffer and counter registers only exist once at locations 20..23.
It is not intended that ISRs program streams of bits, but if they do they must
first push <b>RDATAC RDATA / WDATAC WDATA</b>, because they are application registers

<p>
If ISRs program bitstreams, interrupt registers <b>p_x</b> and <b>q_x</b> are used as bitstream
storage pointers, and ISRs need not save application registers <b>p</b> and <b>q</b>

<a	name="instruction_form"/>
<h3>5.3: Instruction Layout</h3>

<p>
Instructions have an operand type indicator <b>jjj</b>, an instruction code 
<b>fffff</b> and a 16-bit address field

<p>
Six jjj values are different operand types for 32 single-integer instructions
and two jjj values select two mores lists of instructions

<p>
If the jjj field is 5, the operand is 16-bit sign extended immediate
<pre	style="font-size:12pt;color:#0000FF">


				  23      18    15                            0
				_________________________________________________
				| fffff | 101 | &plusmn;16-bit sign extended immediate	|
				|_______|_jjj_|_________________________________|


				ax, xi		-20000
				push		600,,xi


</pre>
Otherwise, if bit 15 is zero, the operand address is a direct address 15 bits in size
<pre	style="font-size:12pt;color:#0000FF">

				  23      18    15  14                        0
				_________________________________________________
				| fffff | jjj | 0 | 15-bit direct address----->	|
				|_______|_____|___|_____________________________|



		$(3:03000)
		instance	$do	20000,keyvalue(instance)	+	KEYVALUE*instance**07FFFFF

		$(0)
				dl	keyvalue(19999)
				xor	keyvalue(19997)
				xorB	keyvalue(19998)



</pre>
If instruction bit 15 is one, the instruction has a 3 bit indirection-window/index-register selector <b>xxx</b>
and a 12-bit displacement field
<pre	style="font-size:12pt;color:#0000FF">

				  23      18    15  14    11                  0
				_________________________________________________
				| fffff | jjj | 1 | xxx | 12-bit displacement->	|
				|_______|_____|___|_____|_______________________|


</pre>
If xxx is zero or one, the address is indirect. Its pointer is in the first 8192 words
in the address space. These are
<blockquote>

	the 256 registers<br>
	words 256..4095 of the current instruction frame B0<br><br>

	the 4096 words of the current private stack frame B1 (or the thread control block if PSR flag see$1 is on)

</blockquote>
<pre	style="font-size:12pt;color:#0000FF">
		$(1:01000)
		redirection	$res	1
				
		$(0)
				lr	*redirection
				ql	*(ADDRESS_7_MEGAWORD)	. big indirect address
								. in 24-bit literal constant
				tp	*11

</pre>

If xxx is 2..7 then index register [x y a b fp sp] is added to to the unsigned
12-bit displacement to form the effective address
<pre	style="font-size:10pt;color:#0000FF">

		  23                                          0			  23                                          0
		_________________________________________________		_________________________________________________
		|		effective address		|<----- + ------|		[ x y a b fp sp ]		|
		|_______________________________________________|		|_______________________________________________|
				 	^			^
					|			|
					|	    +		|
					|			|
		  23      18    15  14    11                  0
		_________________________________________________
		| fffff | jjj | 1 | xxx | 12-bit displacement->	|
		|_______|_____|___|_____|_______________________|



				la	64, b, i
				ly	descriptor:dgram, fp




</pre>

<a	name="integer_instructions"/>
<h3>5.4: Single Integer Instructions</h3>
32 instructions carry out load / store / arithmetic / boolean operations on a single
integer. These 32 instructions have as their right-side operand another register, a storage word,
part of a storage word (half or third), the effective address as an immediate value, or a
sign-extended immediate value in the range -32768..+32767

<p>
Integer instructions access a word and either third-words or halfwords.
jjj = zero = operand is the storage word at ea
<pre	style="font-size:12pt;color:#0000FF">


				z	buffer+4
				pop	buffer+5[,,w0]	. w0 is the default
							. and need not be typed

</pre>
<p>
PSR designator <b>half$w</b> is zero if the program accesses third-words
and one if the program accesses halfwords. Bytes are sign-extended to 24
bits on read and unused fields are unchanged on byte write. Bytes are not
read from registers or written to registers. All registers including the
internal stack are read and written as one or two or four 24-bit words 

<pre	style="font-size:10pt;color:#0000FF">


		byte reads							byte writes
		__________							___________

		_________________________________________________		__________________________________________________
register	|	extended signs		      data	|		|				  low order bits |
		|______________________________|________________|		|_______________________________|________________|
					      /		       /					       /	        /
					     /		      /						      /		       /
					    /		     /						     /		      /
					   /		    /						    /		     /
					  /		   /						   /		    /
					 /		  /						  /		   /
					/		 /						 /		  /
				       /		/						/		 /
				      /		       /					       /	        /
				     /		      /						      /		       /
				    /		     /						     /		      /
				   /		    /						    /                /
				  /		   /						   /                /
				 /		  /						  /		   /
		________________/________________/_______________		_________________/________________/______________
storage	word	|		| designated byte|		|		|    unchanged	 |    written	 |  unchanged	|
		|_______________|________________|______________|		|________________|_______________|______________|



		<a style="color:#FF0000">half$w = 0</a>							<a style="color:#FF0000">half$w = 1</a>
		<a style="color:#FF0000">__________</a>							<a style="color:#FF0000">__________</a>

		  23                                          0
		_________________________________________________
   jjj = 001	|	t1	|	unused on read		|
		|_______________|_______unchanged_on_write______|


   assembly language example	<a style="color:#FF0000">xorB, t1	indicators</a>
   _________________________


		  23                                          0			  23                                          0
		_________________________________________________		_________________________________________________
   jjj = 010	|unused on read	|	t2	|unused on read	|		|	    h1		|    unused on read	|
		|unchanged_on_wr|_______________|unchanged_on_wr|		|_______________________|____unchanged on write_|


   assembly language examples	<a style="color:#FF0000">ana		*margin,,t2					xor		crypto,b,h1</a>
   __________________________



		  23                                          0			  23                                          0
		_________________________________________________		_________________________________________________
   jjj = 011	|       unused on read		|	t3	|		|    unused on read	|	    h2		|
		|_______unchanged_on_write______|_______________|		|____unchanged on write_|_______________________|

				
   assembly language examples	<a style="color:#FF0000">mf		table, x, t3					ay, h2		interval</a>
   __________________________


</pre>
jjj = 100 = the operand is the effective address used as an immediate
<pre	style="font-size:12pt;color:#0000FF">

				lb, i		4, a
				lr		2,b,i			

</pre>
jjj = 101 = the immediate operand is the 16 bits of the address fields
sign extended to 24 bits
<pre	style="font-size:12pt;color:#0000FF">


				ax, xi		-8


</pre>
<b>$equf</b> directive can represent all the subfield attributes of an operand
with one name
<pre	style="font-size:12pt;color:#0000FF">

		header_byte	$equf		directory, y, t1
		HARD_LINK	$equf		'H',,xi

				la		header_byte
				aa, xi		-HARD_LINK	. compare
</pre>

<a	name="sisi"/>
<h3>5.5: Single Integer Store Instructions</h3>

The store and the test integer instructions do not take immediate operands.
The ,,i and ,,xi options of instructions sr sk sx sy sa sb z pop tz tp
are assigned to I/O and control instructions which take only an immediate
operand

Integer store instructions do not update <a href="#nar">carry$</a>

<pre	style="font-size:12pt;background-color:#0000C0;color:#FFFFFF;border-radius:10px">

	_________________________________________________________________________________________________________
	|	mnemonic|   fffff.jjj	|			|		jjj				|	
	|_______________|_______________|_______________________|_______________________________________________|
	|	<a href="rta.html#sr" style="color:#00FF00">sr</a>	|   00000.0jj	|  store repeat counter	| [w0] ++ [t1 t2 t3] -- [h1 h2]			|
	|_______________|_______________|_______________________|_______________________________________________|
	|	<a href="rta.html#sk" style="color:#00FF00">sk</a>	|   00001.0jj	|  store mask register	| [w0] ++ [t1 t2 t3] -- [h1 h2]			|
	|_______________|_______________|_______________________|_______________________________________________|
	|	<a href="rta.html#sx" style="color:#00FF00">sx</a>	|   00010.0jj	|  store x		| [w0] ++ [t1 t2 t3] -- [h1 h2]			|
	|_______________|_______________|_______________________|_______________________________________________|
	|	<a href="rta.html#sy" style="color:#00FF00">sy</a>	|   00011.0jj	|  store y		| [w0] ++ [t1 t2 t3] -- [h1 h2]			|
	|_______________|_______________|_______________________|_______________________________________________|
	|	<a href="rta.html#sa" style="color:#00FF00">sa</a>	|   00100.0jj	|  store a		| [w0] ++ [t1 t2 t3] -- [h1 h2]			|
	|_______________|_______________|_______________________|_______________________________________________|
	|	<a href="rta.html#sb" style="color:#00FF00">sb</a>	|   00101.0jj	|  store b		| [w0] ++ [t1 t2 t3] -- [h1 h2]			|
	|_______________|_______________|_______________________|_______________________________________________|
	|	<a href="rta.html#z" style="color:#00FF00">z</a>	|   00110.0jj	|  zero			| [w0] ++ [t1 t2 t3] -- [h1 h2]			|
	|_______________|_______________|_______________________|_______________________________________________|
	|	<a href="rta.html#pop" style="color:#00FF00">pop</a>	|   00111.0jj	|  pop internal stack	| [w0] ++ [t1 t2 t3] -- [h1 h2]			|
	|_______________|_______________|_______________________|_______________________________________________|


	Assembly Language Examples
	__________________________


	sx		save_pointer
        sb, h2          control_word, y
	sa		total
        z               lock_cell, x
	sr		*(HIGH_ADDRESS)
	<div	style="color:FF0000">
	push, t1	before
	push		update
	</div>
	pop		before
	pop, t1		before


</pre>

<a	name="sili"/>
<h3>5.6: Single Integer Load Instructions</h3>

Integer load instructions do not update <a href="#nar">carry$</a>

<pre	style="font-size:12pt;background-color:#0000C0;color:#FFFFFF;border-radius:10px">



        _________________________________________________________________________________________________________
        |       mnemonic|   fffff.jjj   |                       |               jjj                             |
	|_______________|_______________|_______________________|_______________________________________________|
	|	<a href="rta.html#lr" style="color:#00FF00">lr</a>	|   01000.jjj	|  load repeat counter	| [w0] ++ [t1 t2 t3] -- [h1 h2]	++ [i xi]	|
	|_______________|_______________|_______________________|_______________________________________________|
	|	<a href="rta.html#lk" style="color:#00FF00">lk</a>	|   01001.jjj	|  load mask register	| [w0] ++ [t1 t2 t3] -- [h1 h2]	++ [i xi]	|
	|_______________|_______________|_______________________|_______________________________________________|
	|	<a href="rta.html#lx" style="color:#00FF00">lx</a>	|   01010.jjj	|  load x		| [w0] ++ [t1 t2 t3] -- [h1 h2]	++ [i xi]	|
	|_______________|_______________|_______________________|_______________________________________________|
	|	<a href="rta.html#ly" style="color:#00FF00">ly</a>	|   01011.jjj	|  load y		| [w0] ++ [t1 t2 t3] -- [h1 h2]	++ [i xi]	|
	|_______________|_______________|_______________________|_______________________________________________|
	|	<a href="rta.html#la" style="color:#00FF00">la</a>	|   01100.jjj	|  load a		| [w0] ++ [t1 t2 t3] -- [h1 h2]	++ [i xi]	|
	|_______________|_______________|_______________________|_______________________________________________|
	|	<a href="rta.html#lb" style="color:#00FF00">lb</a>	|   01101.jjj	|  load b		| [w0] ++ [t1 t2 t3] -- [h1 h2]	++ [i xi]	|
	|_______________|_______________|_______________________|_______________________________________________|
	|	<a href="rta.html#push" style="color:#00FF00">push</a>	|   11111.jjj	|  push internal stack	| [w0] ++ [t1 t2 t3] -- [h1 h2]	++ [i xi]	|
	|_______________|_______________|_______________________|_______________________________________________|



	Assembly Language Examples
	__________________________

	lr	HOW_MANY,,xi
	lk	(0FFC000s)

	ly	*pointer_array_cursor
	la	8, y
	lb, i	6, a

	push, t1        before
        push            update



</pre>
push decrements the internal stack pointer and loads one register in the internal
stack with the operand value. If application sp is outside the range 25..128
before the operation the guard interrupt intervenes


<a	name="ti"/>
<h3>5.7: Test Instructions</h3>

Integer test instructions do not update <a href="#nar">carry$</a>

<p>
The operand is tested for zero or for bit 23=0. If so, the next instruction is skipped. Storage half-and
third-words are sign-extended

<pre	style="font-size:12pt;background-color:#0000C0;color:#FFFFFF;border-radius:10px">

        _________________________________________________________________________________________________________
        |       mnemonic|   fffff.jjj   |                       |               jjj                             |
        |_______________|_______________|_______________________|_______________________________________________|
	|	<a href="rta.html#tz" style="color:#00FF00">tz</a>	|   01110.0jj	|  test zero skip	| [w0] ++ [t1 t2 t3] -- [h1 h2]			|
	|_______________|_______________|_______________________|_______________________________________________|
	|	<a href="rta.html#tp" style="color:#00FF00">tp</a>	|   01111.0jj	|  test positive skip	| [w0] ++ [t1 t2 t3] -- [h1 h2]			|
	|_______________|_______________|_______________________|_______________________________________________|
	|	<a href="rta.html#tnz" style="color:#00FF00">tnz</a>	|	macro	|  test nonzero skip	| [w0] ++ [t1 t2 t3] -- [h1 h2]			|
	|_______________|_______________|_______________________|_______________________________________________|
	|	<a href="rta.html#tn" style="color:#00FF00">tn</a>	|	macro	|  test negative skip	| [w0] ++ [t1 t2 t3] -- [h1 h2]			|
	|_______________|_______________|_______________________|_______________________________________________|


	See also masked and long equal tests <a href="rta.html#mta" style="color:#00FF00">mta</a> <a href="rta.html#mta" style="color:#00FF00">mtane</a> <a href="rta.html#dte" style="color:#00FF00">dte</a> and integer compare macros <a href="rta.html#anu" style="color:#00FF00">anu</a> <a href="rta.html#anuba" style="color:#00FF00">anuba</a>



	Assembly Language Examples tz and tp
	____________________________________

<div	style="color:#FF0000">
  :                            430 $(3:03000)
  :                            431 left		$res	1
  :                            432 right	$res	1
  :                            433 
  :                            434 $(0:64)
</div>
  :                            435 examine
00:000040 783000              +436 	tp	left 
00:000041 B60046              +437 	j	left_is_negative
00:000042 703001              +438 	tz	right
00:000043 B60046              +439 	j	right_is_nonzero
<div	style="color:#FF0000">
  :                            440 
00:000044 650000              +441	la, xi	0 
00:000045 350000              +442 	lret 0
  :                            443 
  :                            444 left_is_negative
  :                            445 right_is_nonzero
00:000046 65FFFF              +446 	la, xi	-1
00:000047 350000              +447 	lret	0
</div>
</pre>

<a	name="xai"/>
<h3>5.8: Index Register Add  Instructions</h3>

Index register add instructions do not update <a href="#nar">carry$</a>

<pre	style="font-size:12pt;background-color:#0000C0;color:#FFFFFF;border-radius:10px">


        _________________________________________________________________________________________________________
        |       mnemonic|   fffff.jjj   |                       |               jjj                             |
        |_______________|_______________|_______________________|_______________________________________________|
        |       <a href="rta.html#ax" style="color:#00FF00">ax</a>      |   10000.jjj   |  x += operand		| [w0] ++ [t1 t2 t3] -- [h1 h2] ++ [i xi]       |
        |_______________|_______________|_______________________|_______________________________________________|
        |       <a href="rta.html#ay" style="color:#00FF00">ay</a>      |   10001.jjj   |  y += operand		| [w0] ++ [t1 t2 t3] -- [h1 h2] ++ [i xi]       |
        |_______________|_______________|_______________________|_______________________________________________|


	Assembly Language Examples
	__________________________

	ax, xi	-30000
	ay	increment


</pre>

<a	name="booli"/>
<h3>5.9: Boolean Algebra Instructions</h3>

Boolean algebra instructions do not update <a href="#nar">carry$</a>

<pre	style="font-size:12pt;background-color:#0000C0;color:#FFFFFF;border-radius:10px">


        _________________________________________________________________________________________________________
        |       mnemonic|   fffff.jjj   |                       |               jjj                             |
        |_______________|_______________|_______________________|_______________________________________________|
        |       <a href="rta.html#or" style="color:#00FF00">or</a>      |   10010.jjj   |  a OR operand ->a	| [w0] ++ [t1 t2 t3] -- [h1 h2] ++ [i xi]       |
        |_______________|_______________|_______________________|_______________________________________________|
        |       <a href="rta.html#orB" style="color:#00FF00">orB</a>     |   10011.jjj   |  b OR operand ->b     | [w0] ++ [t1 t2 t3] -- [h1 h2] ++ [i xi]       |
        |_______________|_______________|_______________________|_______________________________________________|
        |       <a href="rta.html#and" style="color:#00FF00">and</a>     |   10100.jjj   |  a AND operand ->a	| [w0] ++ [t1 t2 t3] -- [h1 h2] ++ [i xi]       |
        |_______________|_______________|_______________________|_______________________________________________|
        |       <a href="rta.html#andB" style="color:#00FF00">andB</a>    |   10101.jjj   |  a AND operand ->b	| [w0] ++ [t1 t2 t3] -- [h1 h2] ++ [i xi]       |
        |_______________|_______________|_______________________|_______________________________________________|
        |       <a href="rta.html#xor" style="color:#00FF00">xor</a>     |   10110.jjj   |  a XOR operand ->a	| [w0] ++ [t1 t2 t3] -- [h1 h2] ++ [i xi]       |
        |_______________|_______________|_______________________|_______________________________________________|
        |       <a href="rta.html#xorB" style="color:#00FF00">xorB</a>    |   10111.jjj   |  b XOR operand ->b	| [w0] ++ [t1 t2 t3] -- [h1 h2] ++ [i xi]       |
        |_______________|_______________|_______________________|_______________________________________________|


	Assembly Language Examples
	__________________________


	orB,xi	BASE_32
	or	(0800000s)
	and	mask,,h2

	xor	key, x
	xorB	key+1, x


</pre>

<a	name="siai"/>
<h3>5.10: Single Integer Add Instructions</h3>

<p>
The single integer add instructions add the operand or its 2s complement to accumulator a or b

<p>
carry from bit 23 of the addition is stored in <a href="#nar">carry$</a>.

<p>
Carry is not inverted after negative adds. Action is identical to the positive add of operand 2s-complement.
Flag carry$ contains the outflow from most significant bit position

<pre	style="font-size:12pt;background-color:#0000C0;color:#FFFFFF;border-radius:10px">

        _________________________________________________________________________________________________________________
        |       mnemonic|   fffff.jjj   |				|               jjj                             |
        |_______________|_______________|_______________________________|_______________________________________________|
        |       <a href="rta.html#aa" style="color:#00FF00">aa</a>      |   11000.jjj   |  a += operand			| [w0] ++ [t1 t2 t3] -- [h1 h2] ++ [i xi]       |
        |_______________|_______________|_______________________________|_______________________________________________|
        |       <a href="rta.html#ab" style="color:#00FF00">ab</a>      |   11001.jjj   |  b += operand			| [w0] ++ [t1 t2 t3] -- [h1 h2] ++ [i xi]       |
        |_______________|_______________|_______________________________|_______________________________________________|
        |       <a href="rta.html#ana" style="color:#00FF00">ana</a>     |   11010.jjj   |  a += 2s complement of operand| [w0] ++ [t1 t2 t3] -- [h1 h2] ++ [i xi]       |
        |_______________|_______________|_______________________________|_______________________________________________|
        |       <a href="rta.html#anb" style="color:#00FF00">anb</a>     |   11011.jjj   |  b += 2s complement of operand| [w0] ++ [t1 t2 t3] -- [h1 h2] ++ [i xi]       |
        |_______________|_______________|_______________________________|_______________________________________________|



	Assembly Language Examples
	__________________________

	aa	0, b
	ab, xi	-INCREMENT
	ana	6, x


</pre>

<a	name="mi"/>
<h3>5.11: Multiply</h3>

The integer multiply instruction multiplies accumulator b algebraically by the operand and stores the 48-bit product in accumulators a b
<p>

<a href="#nar">carry$</a> is not updated

<pre	style="font-size:12pt;background-color:#0000C0;color:#FFFFFF;border-radius:10px">


        _________________________________________________________________________________________________________
        |       mnemonic|   fffff.jjj   |                       |               jjj                             |
        |_______________|_______________|_______________________|_______________________________________________|
        |       <a href="rta.html#m" style="color:#00FF00">m</a>	|   11100.jjj   |  a:b = b * operand	| [w0] ++ [t1 t2 t3] -- [h1 h2] ++ [i xi]       |
        |_______________|_______________|_______________________|_______________________________________________|


	Assembly Language Examples
	__________________________

	m	scale, x


</pre>

<a	name="mf"/>
<h3>5.12: Multiply Fractional</h3>

Multiply Fractional instruction multiplies unsigned accumulator b by the operand and stores the 48-bit product in accumulators a b

<p>
The multiplier is signed and the multiplicand is unsigned

<p>
Multiply Fractional is used to render binary fractions integrally
for editing and conversion, and may also be used serially to multiply
integer multiplicands more than one word in length

<p>
<a href="#nar">carry$</a> is not updated

<pre	style="font-size:12pt;background-color:#0000C0;color:#FFFFFF;border-radius:10px">


        _________________________________________________________________________________________________________
        |       mnemonic|   fffff.jjj   |                       |               jjj                             |
        |_______________|_______________|_______________________|_______________________________________________|
        |       <a href="rta.html#mf" style="color:#00FF00">mf</a>	|   11101.jjj   |  a:b = b * operand	| [w0] ++ [t1 t2 t3] -- [h1 h2] ++ [i xi]       |
        |_______________|_______________|_______________________|_______________________________________________|



	Assembly Language Examples
	__________________________

	mf	1000,,xi

</pre>

<a	name="di"/>
<h3>5.13: Divide</h3>

The integer divide instruction algebraically divides the 48-bit
dividend in accumulators a b by the 24-bit divisor. The
remainder is stored in b. The low order 24 bits of the quotient
are stored in a. The high-order 24 bits of the quotient are
stored in register 6 mantissa2

<p>
<a href="#nar">carry$</a> is not updated

<pre	style="font-size:12pt;background-color:#0000C0;color:#FFFFFF;border-radius:10px">


        _________________________________________________________________________________________________________________
        |       mnemonic|   fffff.jjj   |				|               jjj                             |
        |_______________|_______________|_______________________________|_______________________________________________|
        |       <a href="rta.html#d" style="color:#00FF00">d</a>	|   11110.jjj   |	a:b /= operand		| [w0] ++ [t1 t2 t3] -- [h1 h2] ++ [i xi]       |
        |_______________|_______________|_______________________________|_______________________________________________|
					|   a = qotient 23:0		|
					|_______________________________|
					|   b = remainder		|
					|_______________________________|
					|   mantissa2 = quotient 47:24	|
					|_______________________________|



		 47                   23                       0
		_________________________________________________
		|    dividend 47..24	|    dividend 23..0	|
	before	|_______________________|_______________________|
	______		register a		register b



		 23                    0 23                    0 47                   24
		_________________________________________________________________________
		|      quotient 23..0	|    remainder 23..0	|    quotient 47..24	|
	after	|_______________________|_______________________|_______________________|
	____		register a		register b		register 6




	Assembly Language Examples
	__________________________

	d	proportions, y
	d, xi	1000


</pre>


<a	name="llsi"/>
<h3>5.14: Large Load and Store Instructions</h3>
<pre	style="font-size:12pt;background-color:#0000C0;color:#FFFFFF;border-radius:10px">

        _________________________________________________________________________________________________________
        |       mnemonic|   fffff.jjj   |                       |               action                          |
        |_______________|_______________|_______________________|_______________________________________________|
        |       <a href="rta.html#ds" style="color:#00FF00">ds</a>      |   11000.111   |  double store		| a:b -> 2 words @ ea				|
        |_______________|_______________|_______________________|_______________________________________________|
        |       <a href="rta.html#dl" style="color:#00FF00">dl</a>      |   11001.111   |  double load		| 2 words @ ea -> a:b				|
	|_______________|_______________|_______________________|_______________________________________________|
	|	<a href="rta.html#dpop" style="color:#00FF00">dpop</a>	|	macro	|  double pop		| 2 words @ internal stack top -> 2 words @ ea	|
        |_______________|_______________|_______________________|______________________________________sp_+=_2__|
        |       <a href="rta.html#dpush" style="color:#00FF00">dpush</a>   |   01011.111   |  double push		| sp -= 2, 2 words @ ea added to internal stack	|
        |_______________|_______________|_______________________|_______________________________________________|
        |       <a href="rta.html#qs" style="color:#00FF00">qs</a>      |   01000.111   |  quadruple store      | a:b:mantissa2:mantissa3 -> 4 words @ ea	|
        |_______________|_______________|_______________________|_______________________________________________|
        |       <a href="rta.html#ql" style="color:#00FF00">ql</a>      |   01001.111   |  quadruple load	| 4 words @ ea -> a:b:mantissa2:mantissa3       |
        |_______________|_______________|_______________________|_______________________________________________|
        |       <a href="rta.html#qpop" style="color:#00FF00">qpop</a>	|   10000.111   |  quadruple pop	| 4 words @ internal stack top -> 4 words @ ea  |
        |_______________|_______________|_______________________|______________________________________sp_+=_4__|
        |       <a href="rta.html#qpush" style="color:#00FF00">qpush</a>   |   10001.111   |  quadruple push	| sp -= 4, 4 words @ ea added to internal stack |
        |_______________|_______________|_______________________|_______________________________________________|


	Assembly Language Examples
	__________________________


	qpush	from, y
	qpop	to, x

	ql	float
	qs	0, sp

	dl	socka
	ds	save

	dpush	argument

	dpop	forward


</pre>

<a	name="liai"/>
<h3>5.15: Large Integer Arithmetic Instructions</h3>

<pre	style="font-size:12pt;background-color:#0000C0;color:#FFFFFF;border-radius:10px">

        _________________________________________________________________________________________________________
        |       mnemonic|   fffff.jjj   |                       |               action                          |
        |_______________|_______________|_______________________|_______________________________________________|
        |       <a href="rta.html#da" style="color:#00FF00">da</a>      |   11010.111   |  double add		| a:b += 2 words @ ea				|       
    	|		|		|			| carry$ = carry from MS bit of addition	|
	|_______________|_______________|_______________________|_______________________________________________|
        |       <a href="rta.html#dan" style="color:#00FF00">dan</a>	|   11011.111   |  double add negative	| a:b += 2s complement of 2 words @ ea	 	|
  	|		|		|			| carry$ = carry from MS bit of addition	|
	|_______________|_______________|_______________________|_______________________________________________|
        |       <a href="rta.html#sc" style="color:#00FF00">sc</a>      |   10110.111   |  store carry          | PSR AND 1 -> word @ ea			|
        |_______________|_______________|_______________________|_______________________________________________|
        |       <a href="rta.html#mlb" style="color:#00FF00">mlb</a>	|   10111.111   |  masked load b	| b AND NOT k OR word @ ea AND k -> b		|
        |_______________|_______________|_______________________|_______________________________________________|
        |       <a href="rta.html#mta" style="color:#00FF00">mta</a>     |   10101.111   |  masked test equal	| skip if (a AND k) = (word @ ea AND k)		|
	|_______________|_______________|_______________________|_______________________________________________|
	|	<a href="rta.html#mta" style="color:#00FF00">mtane</a>	|	macro	|masked test not equal a| skip if (a AND k) NOT = (word @ ea AND k)  	|
        |_______________|_______________|_______________________|_______________________________________________|
        |       <a href="rta.html#dte" style="color:#00FF00">dte</a>     |   01010.111   |  double test equal	| skip if value registers a:b = 2 words @ ea	|
        |_______________|_______________|_______________________|_______________________________________________|
        |       <a href="rta.html#lsc" style="color:#00FF00">lsc</a>     |   10100.111   |  load shift & count	| 1 word @ ea -> a, rotate left [sign bits]	|
        |_______________|_______________|_______________________|_______________________________count in b______|
        |       <a href="rta.html#dlsc" style="color:#00FF00">dlsc</a>    |   11100.111   |double load shift&count| 2 words @ ea -> a:b, rotate left [sign bits]	|
        |_______________|_______________|_______________________|__________________________count_in_mantissa2___|
        |       <a href="rta.html#ex" style="color:#00FF00">ex</a>	|   10010.111   |  execute		| execute the instruction @ ea			|
        |_______________|_______________|_______________________|_______________________________________________|


	Assembly Language Examples
	__________________________

	da	INTERVAL
	dan	usecs

	la	('F'*/16)
	lk	(255*/16s)
	mta	0, fp
	j	not_file_descriptor

	lk	(00FFFF)
	mlb	0, fp

	da	more
	sc	wrapped

	dlsc	integer2


</pre>


<a	name="fpai"/>
<h3>5.16: Floating Arithmetic Instructions</h3>

<a	name="fp96i"/>
<h4>5.16.1: The 96-Bit Floating Point Model</h4>

RTA1 floating arithmetic is ones complement

<p>
Floating numbers used in the four arithmetic function instructions are 96 bits or four words

<p>
The midpoint exponent is 23 bits and the all-fraction mantissa is 72 bits

<pre	style="font-size:10pt;color:#00AF6F">



        _________________________________________________________________________________________________
        |s|	 exponent	|			      mantissa					|
        |_|_____________________|_______________________________________________________________________|
        95 94                 72 71                                                                    0


</pre>
Sign = 1 indicates that all 96 bits of the number are  inverted in 1s complement

<p>
The mantissa is a simple fraction without any integral field either represented or unrepresented. The integral value
is derived by hauling the mantissa leftward through the binary point the number of positions by which the exponent
exceeds its midpoint value of <b>0400000</b>

<p>
Exponent <b>0400000</b> indicates that the normalised magnitude is &ge;0.5 and &lt;1.0

<p>
The lowest or most microscopic exponent is <b>000000</b> The highest or most astronomic exponent is <b>07FFFFF</b>

<p>
Exponentiation range is the equivalent of around &plusmn;1262611 decimal places

<p>
A number is normalised if the normalising bit in position 71 is of opposite polarity to the sign

<p>
Positive and negative zero are the two numbers with normalising bit the same value as the sign.
All unnormalised numbers are computed as zero

<p>
The rounding guard pattern applied by the current program thread is held in interrupt register 149 (hex 93)
<b>fp$guard</b> and has the default value C00000 hex. It can be changed with the following system call and
the rounding value from before is returned in application register a
<pre	style="font-size:12pt;color:#0000FF">

	la	(<i>NEW_VALUE</i>)
	ii	FP_GUARD$

</pre>
<p>
Floating arithmetic instructions do not update <a href="#nar">carry$</a>
<pre	style="font-size:12pt;background-color:#0000C0;color:#FFFFFF;border-radius:10px">

        _________________________________________________________________________________________________________
        |       mnemonic|   fffff.jjj   |                       |               action                          |
        |_______________|_______________|_______________________|_______________________________________________|
        |       <a href="rta.html#fa" style="color:#00FF00">fa</a>      |   01100.111   |  floating add		| a:b:mantissa2:mantissa3 += 4 words @ ea	|
        |_______________|_______________|_______________________|_______________________________________________|
        |       <a href="rta.html#fan" style="color:#00FF00">fan</a>     |   01101.111   |  floating add negative| a:b:mantissa2:mantissa3 += 4 words @ ea XOR 1s|
        |_______________|_______________|_______________________|_______________________________________________|
        |       <a href="rta.html#fm" style="color:#00FF00">fm</a>	|   01110.111   |  floating multiply	| a:b:mantissa2:mantissa3 *= 4 words @ ea	|
        |_______________|_______________|_______________________|_______________________________________________|
        |       <a href="rta.html#fd" style="color:#00FF00">fd</a>	|   01111.111   |  floating divide	| a:b:mantissa2:mantissa3 /= 4 words @ ea	|
        |_______________|_______________|_______________________|_______________________________________________|


	Assembly Language Examples
	__________________________


$ masmx fp_array.msm -ln
MASMX 7r3
3/fp_array.msm
*EOF*
  :                            1 	$path		../def
  :                            2: 	$include	rta.def
  :                            3 
  :                            4 $(0:64)
  :                            5 
00:000040 770100              +6 ?	$do	6,	fm	(1*-?*3)
00:000041 770104              +6 
00:000042 770108              +6 
00:000043 77010C              +6 
00:000044 770110              +6 
00:000045 770114              +6 
  :                            7 	$do	$<256,$(0:256)
  :                            8 
*EOF*
00:000100+3FFFF783126E978D4FDF3B65
00:000104+3FFFED8637BD05AF6C69B5A7
00:000108+3FFFE389705F4136B4A59732
00:00010c+3FFFD98CBCCC096F5088CBFA
00:000110+3FFFCF901D7CF73AB0ACD910
00:000114+3FFFC59392EE8E921D5D073B
:$(00):000040:000118 


</pre>

<p>
Floating Pop and Pack macro <a href="#fp48data">fpp</a> compresses numbers not requiring
mantissa precision larger than 36 bits or exponentiation outside the equivalent
of around &plusmn;305 decimal places from 96 bits at the internal stack top to
this 48-bit stored format

<pre	style="font-size:12pt;color:#0000FF">

        47 46      36 35                               0
        _________________________________________________
        |s|    11    |		     36			|
        |_|__________|__________________________________|

</pre>
Floating Push and Expand macro <a href="#fp48data">fpx</a> loads and expands compressed floating numbers to 96-bit compute format
at the internal stack top

<a	name="fp192i"/>
<h4>5.16.2: 192-Bit Floating Arithmetic</h4>

192-bit <a href="rta.html=rta1#fp">floating arithmetic</a> uses the four-function 96-bit floating instructions <a href="rta.html#fa">fa</a>
<a href="rta.html#fan">fan</a> <a href="rta.html#fm">fm</a> <a href="rta.html#fd">fd</a>
described at <a href="#fp96i">5.16.1: The 96-Bit Floating Point Model</a> 

<p>
Two 96-bit floating numbers are teamed to give an effective 144-bit mantissa when PSR flag <b>fp$r</b> is asserted.
96-bit floating instructions then store two floating results
 
<p>
The first result is stored in registers a:b:mantissa2:mantissa3 and is not rounded.
The second result is rounded and stored in registers 8:9:10:11, and is nonzero if the total
result does not fit in 96 bits. This minor result or residue is added to the next part
of the sum. The exponent of the minor part is the major exponent minus 72 minus the
normalising count of the minor mantissa
<pre	style="font-size:12pt;color:#0000FF">

	ql	first_addend
	on	fp$r		. switch residue on in PSR
	fa	second_addend	. generate a major and a minor sum
	qs	sum
	off	fp$r		. switch residue off
	ql	first_addend+4
	fa	second_addend+4	. add the second parts
	fa	$residue	. add the minor sum of the first addition
	qs	sum+4

</pre>
PSR flag <b>fp$r</b> and minor result <b>$residue</b> (registers 8..11) are used the same way with all four arithmetic operations
<pre	style="font-size:12pt;color:#0000FF">

	ql	minuend
	on	fp$r		. switch residue on in PSR
	fan	subtrahend	. generate a major and a minor difference
	off	fp$r		. switch residue off
	qs	difference
	ql	minuend+4
	fan	subtrahend+4	. find the difference between the second parts
	fa	$residue	. add the minor difference from the major part
	qs	difference+4


	ql	multiplicand
	on	fp$r		. switch residue on in PSR
	fm	multiplier	. generate a major and a minor product
	off	fp$r		. switch residue off
	qs	product
	ql	multiplicand+4
	fm	multiplier	. multiply the second part
	fa	$residue	. add the minor product of the first multiplication
	qs	product+4


	ql	dividend
	on	fp$r		. switch residue on in PSR
	fd	divisor		. generate a major and a minor quotient
	off	fp$r		. switch residue off
	qs	quotient
	ql	dividend+4
	fd	divisor		. divide the second part
	fa	$residue	. add the minor quiotient from dividing the first part
	qs	quotient+4

</pre>
If a multiplier is larger than 96 bits it is necessary to multiply by its major and
minor parts and then sum the two 192-bit products. Minor result <b>$residue</b> is
required during both multiply passes and the subsequent add of two 192-bit products

<p>
If a divisor is larger than 96 bits, a long multiply by the 192-bit reciprocal of the
divisor is advised. A divisor is longer than 96 bits if the decimal exponent
equivalent is less than zero or more than 31:

<pre	style="font-size:12pt;color:#0000FF">


        $ fp -U
        remote application socket 3 bind state 0 F 2 NB 0 udconnect state 0
        3.666666999999333333666666999999333333666666e1100000 / 3e-150000
        send state 65
        recv state 55/35 +1.222222333333111111222222333333111111222222e+1250000


</pre>


<p>
When a series of operations is iterated on one 192-bit value a large number of times,
any accumulation of rounding effects, and any accumulating discontinuity between major
and minor numbers should be suppressed. This is achieved with an intermittent
super-normalisation of the value. Its major and minor parts are summed with <b>fp$r</b>
asserted. The largest possible part of the total value is consequently stored in the
major part in registers a:b:mantissa2:mantissa3. The resulting zero or nonzero minor
part is stored in registers 8:9:10:11
<pre	style="font-size:12pt;color:#0000FF">

	  ql	minuend		. operation sequence
	  on	fp$r
	  fan	subtrahend
	  qs	difference
	  off	fp$r
	  ql	minuend+4
	  fan	subtrahend+4
	  fa	$residue

	on	fp$r		. super-normalise sequence
	fa	difference
	qs	difference
	off	fp$r
	ql	$residue

	  qs	difference+4	. completion of operation sequence


</pre>
<a	name="major_minor"/>
Procedural macro major_minor in rta/target.rta/lib/144.def generates floating constants in 192-bit format.<br>
These constants are two related and teamed 96-bit floating numbers
<pre	style="font-size:12pt;color:#0000FF">

$ masmx -lnk chaumi
MASMX 7r3A
3/chaumi.msm
*EOF*
  :                            1 	$path		../
  :                            2: 	$include	lib/144.def
  :                            3 	$path
  :                            4 $(3:03000)
03:003000 4000019C71C80B0DD1746C01
                              +5 	major_minor	1.222222333333444444555555666666777777888888
03:003004 3FFFB4CEDE8016BCC48852E0
                              +5 
  :                            6 
*EOF*
:$(03):003000:003008 

</pre>

<a	name="smi"/>
<h3>5.17: Storage Modify Instructions</h3>

Test and Set is only executed with any purpose on a storage location for inter-processor arbitration

<p>
The other seven modify instructions can be executed on a register or on storage. Execution on storage
causes a memory read followed by memory write. Execution on a register is at register-access speed
 
<pre	style="font-size:12pt;background-color:#0000C0;color:#FFFFFF;border-radius:10px">

        _________________________________________________________________________________________________________
        |       mnemonic|   fffff.jjj   |                       |               action                          |
        |_______________|_______________|_______________________|_______________________________________________|
	|		|		|			|sample word @EA [bit23=zero] skip 1 instruction|
        |       <a href="rta.html#ts" style="color:#00FF00">ts</a>      |   00000.111   |  test and set		| always write 1000 0000<sub>2</sub> -> word @EA bits 23:16|
        |_______________|_______________|_______________________|_______________________________________________|
        |       <a href="rta.html#n" style="color:#00FF00">n</a>	|   00001.111   |  negate		| word @ ea XOR= all 1s				|
        |_______________|_______________|_______________________|_______________________________________________|
        |       <a href="rta.html#inc" style="color:#00FF00">inc</a>	|   00010.111   |  increment		| word @ ea += 0000 0000 0000 0000 0000 0001	|
	|		|		|			¡ carry is not updated				|
        |_______________|_______________|_______________________|_______________________________________________|
        |       <a href="rta.html#dec" style="color:#00FF00">dec</a>	|   00011.111   |  decrement		| word @ ea += 1111 1111 1111 1111 1111 1111	|
	|		|		|			| carry is not updated				|
        |_______________|_______________|_______________________|_______________________________________________|
        |       <a href="rta.html#sim" style="color:#00FF00">sim</a>	|   00100.111   |  switch interrupt mask| switch interrupt mask with word @ea, b23:3 = 0|
        |_______________|_______________|_______________________|_______________________________________________|
        |       <a href="rta.html#popA" style="color:#00FF00">popA</a>    |   00101.111   |  pop and add to store	| word @ ea += word at internal stack top, sp++	|
	|		|		|			| carry$ is updated				|
        |_______________|_______________|_______________________|_______________________________________________|
        |       <a href="rta.html#src" style="color:#00FF00">src</a>	|   00110.111   | shift right thru carry| R.rotate word @ ea in 25-bit ring with carry$	|
        |_______________|_______________|_______________________|_______________________________________________|
        |       <a href="rta.html#slc" style="color:#00FF00">slc</a>	|   00111.111	| shift left thru carry	| L.rotate word @ ea in 25-bit ring with carry$	|
        |_______________|_______________|_______________________|_______________________________________________|


	Assembly Language Examples
	__________________________


		<a style="color:#FF0000">push, xi	MAXIMUM_INTERRUPT_MASK	. internal stack = register location</a>
		sim		0, sp


		ts		lock_word		. this has to be in memory
		j		$-1			. try again

		.
		.

		<a style="color:#FF0000">z		lock_word		. free the resource</a>
		sim		0, sp			. restore the interrupt mask
		inc		sp			. restore the internal stack


</pre>

<a	name="si"/>
<h3>5.18: Shift Instructions</h3>

Shift instructions use the effective address as the shift count. An effective address may be indexed or indirect

<p>
Double shifts shift the value in accumulators a and b as a single 48-bit register

<p>
Shift instructions do not update <a href="#nar">carry$</a>
<pre	style="font-size:12pt;background-color:#0000C0;color:#FFFFFF;border-radius:10px">

        _________________________________________________________________________________________________________________
        |       mnemonic|   fffff.jjj   |                       |               action                          	|
        |_______________|_______________|_______________________|_______________________________________________________|
        |       <a href="rta.html#sar" style="color:#00FF00">sar</a>	|   00000.110   |  shift a right	|  shift a [ea] bits right, zero fill vacated positions	|
        |_______________|_______________|_______________________|_______________________________________________________|
        |       <a href="rta.html#sbr" style="color:#00FF00">sbr</a>	|   00001.110   |  shift b right	|  shift b [ea] bits right, zero fill vacated positions	|
        |_______________|_______________|_______________________|_______________________________________________________|
        |       <a href="rta.html#dsr" style="color:#00FF00">dsr</a>	|   00010.110   |  double shift right	|shift a:b [ea] bits right, zero fill vacated positions	|
        |_______________|_______________|_______________________|_______________________________________________________|
        |       <a href="rta.html#sal" style="color:#00FF00">sal</a>	|   00100.110   |  shift a left		|  shift a [ea] bits left, zero fill vacated positions	|
        |_______________|_______________|_______________________|_______________________________________________________|
        |       <a href="rta.html#sbl" style="color:#00FF00">sbl</a>	|   00101.110   |  shift b left		|  shift b [ea] bits left, zero fill vacated positions	|
        |_______________|_______________|_______________________|_______________________________________________________|
        |       <a href="rta.html#dsl" style="color:#00FF00">dsl</a>	|   00110.110   |  double shift left	|shift a:b [ea] bits left, zero fill vacated positions	|
        |_______________|_______________|_______________________|_______________________________________________________|
        |       <a href="rta.html#rar" style="color:#00FF00">rar</a>	|   01000.110   |  rotate a right	|rotate a [ea] bits right, LS bit values to MS positions|
        |_______________|_______________|_______________________|_______________________________________________________|
        |       <a href="rta.html#rbr" style="color:#00FF00">rbr</a>	|   01001.110   |  rotate b right	|rotate b [ea] bits right, LS bit values to MS positions|
        |_______________|_______________|_______________________|_______________________________________________________|
        |       <a href="rta.html#drr" style="color:#00FF00">drr</a>	|   01010.110   |  double rotate right	|rotate a:b [ea] bits right,LS bitvalues to MS positions|
        |_______________|_______________|_______________________|_______________________________________________________|
        |       <a href="rta.html#ral" style="color:#00FF00">ral</a>	|   01100.110   |  rotate a left	| rotate a [ea] bits left, MS bit values to LS positions|
        |_______________|_______________|_______________________|_______________________________________________________|
        |       <a href="rta.html#rbl" style="color:#00FF00">rbl</a>	|   01101.110   |  rotate b left	| rotate b [ea] bits left, MS bit values to LS positions|
        |_______________|_______________|_______________________|_______________________________________________________|
        |       <a href="rta.html#drl" style="color:#00FF00">drl</a>	|   01110.110   |  double rotate left	|rotate a:b [ea] bits left, MS bitvalues to LS positions|
        |_______________|_______________|_______________________|_______________________________________________________|
        |       <a href="rta.html#saa" style="color:#00FF00">saa</a>	|   10000.110   |  shift a algebraic	|  shift a [ea] bits right, sign fill vacated positions	|
        |_______________|_______________|_______________________|_______________________________________________________|
        |       <a href="rta.html#sba" style="color:#00FF00">sba</a>	|   10001.110   |  shift b algebraic	|  shift b [ea] bits right, sign fill vacated positions	|
        |_______________|_______________|_______________________|_______________________________________________________|
        |       <a href="rta.html#dsa" style="color:#00FF00">dsa</a>	|   10010.110   | double shift algebraic|shift a:b [ea] bits right, sign fill vacated positions |
        |_______________|_______________|_______________________|_______________________________________________________|


	Assembly Language Examples
	__________________________

	dsa	48
	sbl	*log


</pre>

<a	name="sim_d"/>
<h3>5.19: SIMD and Instruction Repeat</h3>

<a href="rta.html#rex">Repeat Execute instruction</a> iterates operations on multiple datapoints

<p>
Up to 104 internal stack registers are used as accumulators

<p>
See also <a href="rta.html#sim_d">Instruction Architecture: SIMD and instruction repeat</a>

<p>
All threads are launched with a SIMD table one object in depth at the internal stack top so that the application has a second set of accumulators


<pre	style="font-size:12pt;background-color:#0000C0;color:#FFFFFF;border-radius:10px">

        _________________________________________________________________________________________________________________
        |       mnemonic|   fffff.jjj   |                       |               action                                  |
        |_______________|_______________|_______________________|_______________________________________________________|
        |       <a href="rta.html#rex" style="color:#00FF00">rex</a>	|   01110.100   |  repeat execute	|  execute instruction @ EA RDATAC times restart RDATAC	|
        |_______________|_______________|_______________________|_______________________________________________________|



	Assembly Language Example
	_________________________


	SIMD_CONTROL	(-1, 4, REPEATS-1, CONTAINER_SIZE:q)	. walk 4-register floating accumulators
								. data points 2 from a structure array
	lx	table,,xi

	rex	(fa	OFFSET_IN_CONTAINER, x)			. See also <a href="rta.html=rta1#simd_frame" style="color:#FFFFFF">SIMD Frame and Accumulator Vector</a>



	Instructions in the Scope of Repeat Execute
	___________________________________________

	<a href="rta.html#fa" style="color:#00FF00">Floating Add</a>	<a href="rta.html#fan" style="color:#00FF00">Floating Add Negative</a>	<a href="rta.html#fm" style="color:#00FF00">Floating Multiply</a>	<a href="rta.html#fd" style="color:#00FF00">Floating Divide</a>


	<a href="rta.html#da" style="color:#00FF00">Double Add</a>	<a href="rta.html#dan" style="color:#00FF00">Double Add Negative</a>

	<a href="rta.html#aa" style="color:#00FF00">Add to a</a>	<a href="rta.html#ab" style="color:#00FF00">Add to b</a>	<a href="rta.html#ana" style="color:#00FF00">Add Negative to a</a>	<a href="rta.html#anb" style="color:#00FF00">Add Negative to b</a>


	<a href="rta.html#or" style="color:#00FF00">OR  a</a>	<a href="rta.html#orB" style="color:#00FF00">OR  b</a>	<a href="rta.html#and" style="color:#00FF00">AND a</a>	<a href="rta.html#andB" style="color:#00FF00">AND b</a>	<a href="rta.html#xor" style="color:#00FF00">XOR a</a>	<a href="rta.html#xorB" style="color:#00FF00">XOR b</a>


	<a href="rta.html#sar" style="color:#00FF00">Shift a Right</a>	<a href="rta.html#sbr" style="color:#00FF00">Shift b Right</a>	<a href="rta.html#dsr" style="color:#00FF00">Double Shift Right</a>	<a href="rta.html#sal" style="color:#00FF00">Shift a Left</a>	<a href="rta.html#sbl" style="color:#00FF00">Shift B Left</a>	<a href="rta.html#dsl" style="color:#00FF00">Double Shift Left</a>
	<a href="rta.html#rar" style="color:#00FF00">Rotate a Right</a>	<a href="rta.html#rbr" style="color:#00FF00">Rotate b Right</a>	<a href="rta.html#drr" style="color:#00FF00">Double Rotate Right</a>	<a href="rta.html#ral" style="color:#00FF00">Rotate a Left</a>	<a href="rta.html#rbl" style="color:#00FF00">Rotate b Left</a>	<a href="rta.html#drl" style="color:#00FF00">Double Rotate Left</a>

	<a href="rta.html#saa" style="color:#00FF00">Shift a Algebraic</a>	<a href="rta.html#sba" style="color:#00FF00">Shift b Algebraic</a>	<a href="rta.html#dsa" style="color:#00FF00">Double Shift Algebraic</a>


	<a href="rta.html#la" style="color:#00FF00">Load a</a>		<a href="rta.html#lb" style="color:#00FF00">Load b</a>		<a href="rta.html#dl" style="color:#00FF00">Double Load</a>	<a href="rta.html#ql" style="color:#00FF00">Quadruple Load</a>
	<a href="rta.html#sa" style="color:#00FF00">Store a</a>		<a href="rta.html#sb" style="color:#00FF00">Store b</a>		<a href="rta.html#ds" style="color:#00FF00">Double Store</a>	<a href="rta.html#qs" style="color:#00FF00">Quadruple Store</a>

	
	<a href="rta.html#tz" style="color:#00FF00">Test Zero</a>	<a href="rta.html#tp" style="color:#00FF00">Test Positive</a>	<a href="rta.html#mta" style="color:#00FF00">Masked Test Equal a</a>	<a href="rta.html#dte" style="color:#00FF00">Double Test Equal</a>


</pre>


<a	name="bsi"/>
<h3>5.20: Bit Stream Instructions</h3>


<a	name="rsr"/>
<h4>5.20.1: Read Staging Register</h4>
rsr instruction shifts [sign extended ea] bits left from staging register RDATA to accumulator a

<p>
Register RDATAC is decremented by shift count ea

<p>
If RDATAC reaches zero with shift count outstanding RDATA is reloaded from memory pointed by register [q++] -> and RDATAC is restarted at 24 bits

<p>
If PSR flag <b>b$stream16r</b> = 1 the restart count in RDATAC is 16 and RDATA is shifted left 8 bit positions on reload

<p>
If PSR flag <b>b$streamZR</b> = 1 accumulator a is cleared before the transfer

<p>


<a	name="wsr"/>
<h4>5.20.2: Write Staging Register</h4>

wsr instruction shifts [sign extended ea] bits left from accumulator a to staging register WDATA

<p>
Register WDATAC is incremented by shift count <b>xi</b>

<p>
If WDATAC reaches 24 during the transfer WDATA is stored at memory pointed by register [p++] ->  and WDATAC is restarted at zero

<p>
If PSR flag <b>b$stream16w</b> = 1 data is stored and WDATAC restarted when WDATAC reaches 16

<pre	style="font-size:12pt;background-color:#0000C0;color:#FFFFFF;border-radius:10px">

        _________________________________________________________________________________________________________________
        |       mnemonic|   fffff.jjj   |                       |               action                                  |
        |_______________|_______________|_______________________|_______________________________________________________|
        |       <a href="rta.html#rsr" style="color:#00FF00">rsr</a>	|   10010.101   | read staging register	| shift [xi &le; 24] bits a<-RDATA [reload RDATA]		|
        |_______________|_______________|_______________________|_______________________________________________________|
        |       <a href="rta.html#wsr" style="color:#00FF00">wsr</a>	|   00011.101   |write staging register	| shift [xi &le; 24] bits WDATA<-a [store WDATA]		|
        |_______________|_______________|_______________________|_______________________________________________________|


	Assembly Language Examples
	__________________________

	rsr	$byte			. read a field from RDATA
	<div	style="color:FF0000">
	sal	$word-$byte		. shift data to high-order positions
	</div>
	wsr	$byte
	wsr	$word-$byte		. write latent bits from WDATA


</pre>

<a	name="ji"/>
<h3>5.21: Jump Instructions, Local Call / Local Return</h3>

Jump instructions transfer execution to effective address within current address window B0

<p>
The effective address may be indexed or indirect

<p>
Absolute program counter is updated with B0 * 4096 + effective address

<pre	style="font-size:12pt;background-color:#0000C0;color:#FFFFFF;border-radius:10px">

        _________________________________________________________________________________________________________________
        |       mnemonic|   fffff.jjj   |                       |  action			symbol B0* = B0 * 4096	|
        |_______________|_______________|_______________________|_______________________________________________________|
        |       <a href="rta.html#j" style="color:#00FF00">j</a>	|   10110.110   |  jump			|  continue execution @ B0* + ea			|
        |_______________|_______________|_______________________|_______________________________________________________|
        |       <a href="rta.html#jdr" style="color:#00FF00">jdr</a>     |   00011.110   |  jump decrement r	|  add -1 to r, jump if r &ne; -1, carry$ is not updated	|
        |_______________|_______________|_______________________|_______________________________________________________|
        |       <a href="rta.html#jnc" style="color:#00FF00">jnc</a>	|   01011.110   |  jump no carry	|  jump if carry$ of PSR = zero				|
        |_______________|_______________|_______________________|_______________________________________________________|
        |       <a href="rta.html#jc" style="color:#00FF00">jc</a>	|   01111.110   |  jump carry		|  jump if carry$ of PSR = one				|
        |_______________|_______________|_______________________|_______________________________________________________|
        |       <a href="rta.html#jza" style="color:#00FF00">jza</a>	|   11000.110   |  jump zero a		|  jump if accumulator a = zero				|
        |_______________|_______________|_______________________|_______________________________________________________|
        |       <a href="rta.html#jzb" style="color:#00FF00">jzb</a>     |   11001.110   |  jump zero b		|  jump if accumulator b = zero				|
        |_______________|_______________|_______________________|_______________________________________________________|
        |       <a href="rta.html#jnza" style="color:#00FF00">jnza</a>	|   11010.110   |  jump nonzero a	|  jump if accumulator a = nonzero			|
        |_______________|_______________|_______________________|_______________________________________________________|
        |       <a href="rta.html#jnzb" style="color:#00FF00">jnzb</a>	|   11011.110   |  jump nonzero b	|  jump if accumulator b = nonzero			|
        |_______________|_______________|_______________________|_______________________________________________________|
        |       <a href="rta.html#jpa" style="color:#00FF00">jpa</a>	|   10100.110   |  jump positive a	|  jump if accumulator a high-order bit = zero		|
        |_______________|_______________|_______________________|_______________________________________________________|
        |       <a href="rta.html#jpb" style="color:#00FF00">jpb</a>	|   10101.110   |  jump positive b	|  jump if accumulator b high-order bit = zero		|
        |_______________|_______________|_______________________|_______________________________________________________|
        |       <a href="rta.html#jna" style="color:#00FF00">jna</a>	|   11100.110   |  jump negative a	|  jump if accumulator a high-order bit = one		|
        |_______________|_______________|_______________________|_______________________________________________________|
        |       <a href="rta.html#jnb" style="color:#00FF00">jnb</a>	|   11101.110   |  jump negative b	|  jump if accumulator b high-order bit = zero		|
        |_______________|_______________|_______________________|_______________________________________________________|
        |       <a href="rta.html#jao" style="color:#00FF00">jao</a>	|   10011.110   |  jump a odd		|  jump if accumulator a low-order bit = one		|
        |_______________|_______________|_______________________|_______________________________________________________|
	|	<a href="rta.html#jao" style="color:#00FF00">jae</a>	|	macro	|  jump a even		|  jump if accumulator a low-order bit = zero		|
	|_______________|_______________|_______________________|_______________________________________________________|
        |       <a href="rta.html#jpo" style="color:#00FF00">jpo</a>	|   10111.110   |  jump parity odd	|  jump if a AND mask register k has odd parity		|
        |_______________|_______________|_______________________|_______________________________________________________|
	|	<a href="rta.html#jpo" style="color:#00FF00">jpe</a>	|	macro	|  jump parity even	|  jump if a AND mask register k has even parity 	|
	|_______________|_______________|_______________________|_______________________________________________________|
        |       <a href="rta.html#jxge" style="color:#00FF00">jxge</a>	|   11110.110   |jump x greater or equal|  jump if index register x &ge; limit pointer r		|
        |_______________|_______________|_______________________|_______________________________________________________|
        |       <a href="rta.html#jyge" style="color:#00FF00">jyge</a>	|   11111.110   |jump y greater or equal|  jump if index register y &ge; limit pointer r		|
        |_______________|_______________|_______________________|_______________________________________________________|
	|	<a href="rta.html#jxge" style="color:#00FF00">jxl</a>	|	macro	|  jump x lower		|  jump if index register x &lt; limit pointer r		|
	|_______________|_______________|_______________________|_______________________________________________________|
	|	<a href="rta.html#jyge" style="color:#00FF00">jyl</a>	|	macro	|  jump y lower		|  jump if index register y &lt; limit pointer r 		|
	|_______________|_______________|_______________________|_______________________________________________________|
        |       <a href="rta.html#jdz" style="color:#00FF00">jdz</a>	|   01111.100   |  jump double zero	|  jump if 48-bit integer in registers a and b = zero	|
        |_______________|_______________|_______________________|_______________________________________________________|
        |       <a href="rta.html#lcal" style="color:#00FF00">lcal</a>    |   00111.110   |  local call           |  push absolute PC - B0* on internal stack, jump to ea	|
        |_______________|_______________|_______________________|_______________________________________________________|


	Assembly Language Examples
	__________________________

	j	again?
again!



again?	jdr	again!

	<div    style="color:FF0000">
	lr	limit
	</div>
	jxge	enough
	lcal	more
	jc	enough
	jnb	enough


	_________________________________________________________________________________________________________________
	|       mnemonic|   fffff.jjj   |                       |  action						|
	|_______________|_______________|_______________________|_______________________________________________________|
	|       <a href="rta.html#lret" style="color:#00FF00">lret</a>	|   00110.101   |  local return		|  pop offset += ea*xi + B0 * 4k -> PC			|
	|_______________|_______________|_______________________|_______________________________________________________|



        Assembly Language Examples
        __________________________

<a style="color:#FF0000">  :                            430 $(3:03000)
  :                            431 left         $res    1
  :                            432 right        $res    1
  :                            433
  :                            434 $(0:64)</a>
  :                            435 examine
00:000040 783000              +436      tp      left
00:000041 350000              +437      lret    0       . return to instruction after lcal
00:000042 703001              +438      tz      right
00:000043 350000              +439      lret    0       . return to instruction after lcal
00:000044 350001              +440      lret    1       . return and skip one instruction

</pre>

<a	name="crii"/>
<h3>5.22: Iframe Call / Return, Iframe Go, Internal Interrupt / Interrupt Return</h3>

<pre	style="font-size:12pt;background-color:#0000C0;color:#FFFFFF;border-radius:10px">


_________________________________________________________________________________________________________________________
|       mnemonic|   fffff.jjj   |                       |  action							|
|_______________|_______________|_______________________|_______________________________________________________________|
|       <a href="rta.html#go" style="color:#00FF00">go</a>	|   11110.111   |  go to another iframe	|  target iframe page 0  -> B0: * 4k -> PC += vector		|
|_______________|_______________|_______________________|_______________________________________________________________|



_________________________________________________________
|							|	  indirect operand pointing to gate constant or variable
|       operand is storage word or register at EA       |
|                                                       |        23                                                    0
|                                                       |       _________________________________________________________
|       if operand bit 23 = 1 --------------------------------> | 1 |               address of gate                     |____
|       bits 22:0 point to a constant or variable       |       |___|___________________________________________________|    |
|       containing a 48-bit gate value                  |            22                                                0     |
|                                                       |                                                                    |
|       if operand bit 23 = 0                           |                                                                    |
|                                                       |                                                                    |
|               bit 22 is reserved                      |                                                                    |
|                                                       |                                                                    |
|               bits 21:6 are a 16-bit index of the 1st |                                                                    |
|               4K page of the target iframe            |       gate to target iframe:offset                                 |
|                                                       |                                                                    |
|               bits 5:0 are an entry point vector      |        47          42                                       24     |
|               to locations 0..63 of the target iframe |       _________________________________________________________    |
|                                                       |       | page high idx|        target instruction offset       |    |
|_______________________________________________________|       |______________|________________________________________|<---+
| 00 |       pointer to 4K-aligned page   |       vector|       | F 0 |                 iframe start page index         |
|____|21__________________________________|5___________0|       |_____|_________________________________________________|
|                                                       |              21                                              0
|                                                       |
|		B0 = operand bits 21..6 >> 6            |		B0 = gate bits 21..0 Start Page Index
|               Page High Index = 0                     |		Page High Index = bits 47..42 of gate
|               Iframe Name = B0                        |		Iframe Name = B0 OR (Page High Index nonzero) 1 << 23
|               B64 = B0                                |		B64 = B0 + Page High Index
|               PC = B0 * 4096 + operand 5..0 offset    |		PC = B0 * 4096 + gate bits 41..24 offset
|                                                       |
|                                                       |
|_______________________________________________________|



	assembler examples	go		target_identifier[, {x|y|a|b|fp|sp}]

				go		*target_identifier_indirectly

				go		(LOCATION/4096*64++VECTOR_0_63)

				go	[LITERALS_TAG](0800000++LITERALS_TAG(page_high_index*/18++offset, start_page_index:d)s)

						for large and namically loadable iframes see iframe and gate





________________________________________________________________________________________________________________________
|       <a href="rta.html#call" style="color:#00FF00">call</a>	|   11111.111   |  call another iframe	|  push offset:Iframe Name. target iframe -> B0 * 4K->PC+=vector|
|_______________|_______________|_______________________|_______________________________________________________________|


        <a      name="call"/>
        Call                    call                                                    return address -> internal stack
        ____                    ____
                                                                 23                                                    0
_________________________________________________________       _________________________________________________________
|                                                       | <a style="color:#00FF00">sp + 1</a>|                       saved offset                    |
|       Call Iframe                                     |	|_______________________________________________________|
|                                                       | <a style="color:#00FF00">sp --></a>| F 0 |                 saved Start Page Index          |
|       Program Counter minus B0 * 4096                 |	|_____|_________________________________________________|
|       is pushed to internal stack                     |             |21                                              0
|                                                       |
|       Iframe Name pushed to Internal Stack            |         0 0 | <- B64 = B0 : Page High Index on return = 0
|       = B0 -> bits 21:0 Start Page Index              |         1 0 | <- B64 > B0 : Page High Index on return
|       + iframe size flags -> bits 23:22               |			      = gate bits 47:42 @ iframe + 64
|                                                       |
|                                                       |
|_______________________________________________________|_______________________________________________________________
|                                                       |
|                                                       |
|                                                       |       indirect target operand pointing to gate constant or variable
|       operand is storage word or register at EA       |
|                                                       |        23                                                    0
|                                                       |       _________________________________________________________
|       if operand bit 23 = 1 --------------------------------> | 1 |               address of gate                     |____
|       bits 22:0 point to a constant or variable       |       |___|___________________________________________________|    |
|       containing a 48-bit gate value                  |            22                                                0     |
|                                                       |                                                                    |
|       if operand bit 23 = 0                           |                                                                    |
|                                                       |                                                                    |
|               bit 22 is reserved                      |                                                                    |
|                                                       |                                                                    |
|               bits 21:6 are a 16-bit index of the 1st |                                                                    |
|               4K page of the target iframe            |       gate to target iframe:offset                                 |
|                                                       |                                                                    |
|               bits 5:0 are an entry point vector      |        47          42                                       24     |
|               to locations 0..63 of the target iframe |       _________________________________________________________    |
|                                                       |       | page high idx|        target instruction offset       |    |
|_______________________________________________________|       |______________|________________________________________|<---+
| 00 |       pointer to 4K-aligned page   |       vector|       | F 0 |                 iframe Start Page Index         |
|____|21__________________________________|5___________0|       |_____|_________________________________________________|
|                                                       |              21                                              0
|                                                       |
|               B0 = operand bits 21..6 >> 6            |		B0 = gate bits 21..0 Start Page Index
|               Page High Index = 0                     |		Page High Index = bits 47..42 of gate
|               Iframe Name = B0                        |		Iframe Name = B0 OR (Page High Index nonzero) 1 << 23
|               B64 = B0                                |		B64 = B0 + Page High Index
|               PC = B0 * 4096 + operand 5..0 offset    |		PC = B0 * 4096 + gate bits 41..24 offset
|                                                       |
|                                                       |
|_______________________________________________________|________________________________________________________________
|                                                                                                                       |
|       on internal stack overflow / underflow [sp < 26 | sp > 128] before operation guard interrupt 95 is raised       |
|       operand is the  register or storage word at EA                                                                  |
|_______________________________________________________________________________________________________________________|


	assembler examples	call		target_identifier[, {x|y|a|b|fp|sp}]

				call		*target_identifier_indirectly

				call		(LOCATION/4096*64++VECTOR_0_63)

				call	[LITERALS_TAG](0800000++LITERALS_TAG(page_high_index*/18++offset, start_page_index:d)s)

						for large and namically loadable iframes see iframe and gate






_________________________________________________________________________________________________________________________
|       <a href="rta.html#fret" style="color:#00FF00">fret</a>	|   00111.101   |  far iframe return	|  pop B0: * 4K -> PC += pop offset += ea*xi			|
|_______________|_______________|_______________________|_______________________________________________________________|


                                                                                                    internal stack frame
                                                                 23                                                    0
_________________________________________________________       _________________________________________________________
|                                                       | <a style="color:#00FF00">sp + 1</a>|                       offset                          |
|       Iframe Name is popped from the internal stack   |	|_______________________________________________________|
|       and bits 21:0 Start Page Index written to B0    | <a style="color:#00FF00">sp --></a>| F 0 |                 iframe Start Page Index         |
|                                                       |	|_____|_________________________________________________|
|       return address offset in retrieved instruction  |       |   22|                                                0
|       frame is popped from the internal stack         |       |     |
|                                                       |       |
|       sign extended immediate operand of the return   |       |
|       instruction is added to iframe relative offset  |       |
|                                                       |       |
|       B0 * 4096 is added to iframe relative offset    |       |
|                                                       |       | 0 0 | Page High Index = 0 : iframe pages 1
|       the resulting absolute address is transferred   |       |     | B64 = B0
|       to the program counter                          |       |
|                                                       |       | 1 0 | gate descriptor @ target iframe + 64
|       if sp = 128 before fret                         |       |     | Page High Index <- gate descriptor bits 47:42
|       thread exit interrupt 70 is raised              |       |     | B64 = B0 + Page High Index - 1
|                                                       |
|       on internal stack overflow / underflow          |
|       [sp < 24 | sp > 126 ^ 128] before operation     |
|       guard interrupt 95 is raised                    |
|_______________________________________________________|
|       I/O Port 64 is updated to new highest page for  |
|       instruction execution = B0 + Page High Index - 1|
|                                                       |
|       Page High Index is derived from flag values     |
|       { 00 | 10 } in bits  23:22 of new Iframe Name   |
|                                                       |
|       flags value 00:                                 |
|       gives Page High Index 0: iframe size 1 page     |       sample gate @ target iframe + 64
|                                                       |
|       flags value 10:                                 |        47          42                                       24
|       Page High Index is read from bits 47:42 of the  |       _________________________________________________________
|       sample gate at location 64 of target the iframe |       | Page High Idx|        offset 0                        |
|_______________________________________________________|       |______________|________________________________________|
|       DISPLACEMENT is 16-bit sign extended immediate  |       | x 0 |                 iframe Start Page Index         |
|_______________________________________________________|       |_____|_________________________________________________|
                                                                       21                                              0



							_________________________________________________________________
							| ii and ir operate the interrupt stack. sp_x = register 143	|
________________________________________________________|_______________________________________________________________|
|       <a href="rta.html#ii" style="color:#00FF00">ii</a>	|   11110.101   |  internal interrupt	| push 0.PSR.B0.PC-B0*, xi 23:6 ->B0* -> PC += xi 5:0, PSR b23=1|
|_______________|_______________|_______________________|_______________________________________________________________|

        <a      name="ii"/>
        Internal Interrupt      ii                                                      interrupt frame -> internal stack
        __________________      __


                                                                 23                                                    0
_________________________________________________________       _________________________________________________________
|                                                       | <a style="color:#00FF00">sp + 3</a>|                       saved offset                    |
|       B0 * 4096 is subtracted from the value of       |	|_______________________________________________________|
|       the absolute program counter                    | <a style="color:#00FF00">sp + 2</a>| F 0 |                 saved iframe Start Page Index   |
|                                                       |	|_____|_________________________________________________|
|       the resulting instruction frame relative value  | <a style="color:#00FF00">sp + 1</a>|   22                  saved PSR                       |
|       is pushed on the interrupt internal stack       |	|                       ________________________________|
|                                                       | <a style="color:#00FF00">sp --></a>|                       latent parameter                |
|       Iframe Name = Start Page Index + size flags     |	|                       ________________________________|
|       is pushed on the interrupt internal stack       |       |
|                                                       |       |
|       PSR is pushed on the interrupt internal stack   |       | 0 0 | B64 = B0 Page High Index on i-return = 0
|                                                       |       | 1 0 | B64 > B0 Page High Index on i-return
|       latent parameter 0                              |		      = gate bits 47:42 @ iframe + 64
|       is pushed on the interrupt internal stack       |
|-------------------------------------------------------|
|                                                       |
|       PSR Flag 23 = 1                                 |
|                                                       |
|       the high-order 18 bits of the immediate operand |
|       designate a VECTOR_BANK                         |
|                                                       |
|       the low-order 6 bits if the immediate operand   |
|       designate a VECTOR_OFFSET                       |
|                                                       |
|       B0 = VECTOR_BANK                                |
|                                                       |
|       program counter = VECTOR_BANK*4096+VECTOR_OFFSET|
|_______________________________________________________|
|       VECTOR_BANK                       |VECTOR_OFFSET|
|23______________________________________6|5___________0|
|       VECTOR is 16-bit sign extended immediate        |
|_______________________________________________________|


        assembler syntax        ii      INTERRUPT_VECTOR

        assembler examples      ii      BANK_1*/6++2
                                ii      BANK_1*/6++11




_________________________________________________________________________________________________________________________
|       <a href="rta.html#ir" style="color:#00FF00">ir</a>	|   11111.101   |  interrupt return	| sp_x++, pop PSR.B0* -> PC += pop offset += xi			|
|_______________|_______________|_______________________|_______________________________________________________________|


        <a      name="ir"/>
        Interrupt Return        ir
        ________________        __

                                                                                 interrupt / return internal stack frame

                                                                 23                                                    0
_________________________________________________________       _________________________________________________________
|                                                       | <a style="color:#00FF00">sp + 3</a>|                       saved offset                    |
|                                                       |	|_______________________________________________________|
|       saved PSR is retrieved from                     | <a style="color:#00FF00">sp + 2</a>| F 0 |                 saved iframe Start Page Index   |
|       [interrupt internal stack pointer + 1]          |	|_____|_________________________________________________|
|                                                       | <a style="color:#00FF00">sp + 1</a>|   22|                 saved PSR                       |
|       saved Iframe Name is retrieved from             |	|                       ________________________________|
|       [interrupt internal stack pointer + 2]          | <a style="color:#00FF00">sp --></a>|                       latent parameter                |
|       and bits 21:0 Start Page Index transferred to B0|	|                       ________________________________|
|                                                       |       |
|       saved address offset in instruction frame       |       |
|       is retrieved from                               |       |
|       [interrupt internal stack pointer + 3]          |       | 0 0 | page high index = 0 : iframe pages 1
|                                                       |       |     | B64 = B0
|       the sign extended immediate operand of the ir   |       |
|       instruction is added to iframe relative address |       | 1 0 | gate descriptor @ target iframe + 64
|                                                       |       |     | page high index <- gate descriptor bits 47:42
|       B0 * 4096 is added to iframe relative address   |       |     | B64 = B0 + Page High Index - 1
|                                                       |
|       the resulting absolute address is transferred   |
|       to the program counter                          |
|                                                       |
|       interrupt internal stack pointer                |
|       is incremented by 4                             |
|_______________________________________________________|
|       I/O Port 64 is updated to new highest page for  |
|       instruction execution = B0 + Page High Index - 1|
|                                                       |
|       Page High Index is derived from flag values     |
|       { 00 | 10 } in bits  23:22 of new Iframe Name   |
|                                                       |
|       flags value 00:                                 |
|       gives Page High Index 0: iframe size 1 page     |       sample gate @ target iframe + 64
|                                                       |
|       flags value 10:                                 |        47          42                                       24
|       Page High Index is read from bits 47:42 of the  |       _________________________________________________________
|       sample gate at location 64 of the target iframe |       | Page High Idx|        offset 0                        |
|_______________________________________________________|       |______________|________________________________________|
|       DISPLACEMENT is 16-bit sign extended immediate  |       | x 0 |                 iframe Start Page Index         |
|_______________________________________________________|       |_____|_________________________________________________|
                                                                       21                                              0


        assembler syntax        ir      SKIP_STEPS

        assembler examples      ir      0
                                ir      -1
                                ir      2



</pre>
Return instructions <a href="rta.html#lret">lret</a> <a href="rta.html#fret">fret</a> <a href="rta.html#ir">ir</a> have a sign extended immediate
operand which is added to the return address on the stack. Nonzero operand causes return
to a location before or after the return address on the stack

	<blockquote>
	<a href="rta.html#lret">lret</a> returns from <a href="rta.html#lcal">lcal</a><br><br>
	<a href="rta.html#fret">fret</a> returns from <a href="rta.html#call">call</a><br><br>
	<a href="rta.html#ir">ir</a> returns from interrupt
	</blockquote>

<p>
<a href="rta.html#lret">lret</a> transfers the word at the stack top + operand xi + B0 * 4096 to the program counter. sp++

<p>
<a href="rta.html#fret">fret</a> transfers to the word at the stack top to B0 then the next word + operand xi
+ B0 * 4096 to the program counter. sp += 2

Internal interrupt instruction <b>ii</b> also has a sign extended immediate operand. The
low-order six bits are a vector value. Bits 21..6 designate the 4K-word start address of
the bank containing the ISR
<pre	style="font-size:12pt;color:#0000FF">

$ masmx -kln
MASMX 7r3
0/-INPUT>>
	$path		freeware/RTA1/rta/def
	$list		0
	$include	rta.def
	$include	ii.def
	$list
$(0:64)
	ql		(routine, PRIORITY, PARAMETER, EXTERNAL_STACKFRAME:q)
	ii		THREAD$
	$do	$<256,$(0:256)
	$end
  :                            1  $path  freeware/RTA1/rta/def
  :                            581  $list
  :                            582 $(0:64)
00:000040 4F0100              +583  ql  (routine, PRIORITY, PARAMETER, EXTERNAL_STACKFRAME:q)<div style="color:FF0000">
00:000041 750047              +584  ii  THREAD$</div>
  :                            585  $do $<256,$(0:256)
  :                            586  $end
00:000100+[0003]18:[0002]18*/18:[0001]18*/30:[0000]18*/48:000000000000000000000000
:$(00):000040:000104 

</pre>

Interrupts construct a four-word stack frame at the interrupt internal stack top

<p>
If the interrupted routine is an application (PSR bit 23 = 0) then interrupt <b>sp</b> is
copied to interrupt <b>fp</b> to mark the interrupted application frame

<pre	style="font-size:12pt;color:#0000FF">

		_________________________________
	0,sp	|	latent parameter	|
		|_______________________________|
	1,sp	|	interrupted PSR		|
		|_______________________________|
	2,sp	|	interrupted iframe name	|
		|_______________________________|
	3,sp	|	interrupted PC minus B0*|
		|_______________________________|

</pre>
<a href="rta.html#ii">ii</a> instruction places a latent parameter value zero in the frame

<p>
<a href="rta.html#ir">ir</a> copies saved PSR to PSR and saved B0 to B0.
B0 * 4094 + interrupted offset + XI is written to the program counter. The frame is removed
from the stack

<p>
Inter-bank jumps <a href="rta.html#go">go</a> and <a href="rta.html#call">call</a> read a single word storiage operand of format 


<pre	style="font-size:10pt;color:#00AF6F">

	    21		      6      0
	_______________________________
	|00|  Start Page Index |vector|
	|__|___________________|______|
	      16-bit pointer	6-bit
	      to 4K bank edge	vector

<div    style="color:FF0000">
		OR
</div>

	   22                        0			 47	41		    23			      0
	_______________________________			________________________________________________________
	|1|   	23-bit gate pointer   |---------------> |pagehx|  offset	   |	   iframe name	       |
	|_|___________________________|		   gate	|______|___________________|___________________________|

</pre>

<a href="rta.html#call">call</a> instruction pushes the program-counter minus B0 * 4096 on the internal stack
then pushes B0. <a href="rta.html#go">go</a> and <a href="rta.html#call">call</a> update the program counter
<pre	style="font-size:10pt;color:#00AF6F">

	B0 = (operand bit 22) ? operand[21..3] * 8 : operand[21..6] / 64
	PC = B0 * 4096 ++ (operand bit 22) ? operand[2..0] : operand[5..0]


                        _____________________
                        go / call destination
                        _____________________
                                |					 47	41		    23			       0
                                |					_________________________________________________________
                operand b22 = 0 | operand b23 = 1 [operand b22:0]----->	|pagehx|      offset	   |	    iframe name		|
                ________________|________________		   gate	|______|___________________|____________________________|
                |                               |
        ________|________               ________|________
        | iframe name = |               | iframe name = |
        | operand >> 6  |               | gate 23:0	|
        |_______________|               |_______________|
                |                               |
        ________|________               ________|________
        | offset =      |               | offset =      |
        | operand AND 63|               | gate 41:24	|
        |_______________|               |_______________|
                |                               |
	________|________		________|________
	|page high index|		|page high index|
	|	     = 0|		|   = gate 47:42|
	|_______________|		|_______________|
                |_______________________________|
                                |
                        ________|________
			|B0 = iframe name
			|   & 3FFFFF    |
			|_______________|
				|
                        ________|________
                        | PC = B0 */ 12 |
                        | OR offset     |
                        |_______________|



$ masmx ibj -ln
MASMX 7r3
3/ibj.msm
freeware/RTA1/rta/fs/fs.txo:$(0) 477 words decimal from hexadecimal 000000 to 0001DD
*EOF*
  :                            1 
  :                            2: 	$include	freeware/RTA1/rta/def/rta.def
  :                            3 	$include,$void	freeware/RTA1/rta/fs/fs.txo	$(0)
  :                            4 $(0:64)
00:000040 FF0100              +5 	call		(seg$load)
  :                            6 
  :                            7 
  :                            8 	$do		$<256,$(0:256)
  :                            9 
*EOF*
00:000100+000187
:$(00):000040:000101 


</pre>


<a	name="crio"/>
<h3>5.23: Control and I/O Instructions</h3>


<pre	style="font-size:12pt;background-color:#0000C0;color:#FFFFFF;border-radius:10px">

        _________________________________________________________________________________________________________________
        |       mnemonic|   fffff.jjj   |                       |               action                                  |
        |_______________|_______________|_______________________|_______________________________________________________|
        |       <a href="rta.html#on" style="color:#00FF00">on</a>	|   00000.101   |   on PSR flags	|  PSR flags 15..0 OR= mask value xi			|
        |_______________|_______________|_______________________|_______________________________________________________|
        |       <a href="rta.html#off" style="color:#00FF00">off</a>	|   00001.101   |  off PSR flags	|  PSR flags 15..0 AND= NOT mask value xi		|
	|_______________|_______________|_______________________|_______________________________________________________|
	|       <a href="rta.html#inA" style="color:#00FF00">inA</a>	|   00000.100   |  I/O port ea in to a 	|							|
        |_______________|_______________|_______________________|_______________________________________________________|
        |       <a href="rta.html#inB" style="color:#00FF00">inB</a>	|   00001.100   |  I/O port ea in to b 	|  							|
        |_______________|_______________|_______________________|_______________________________________________________|
        |       <a href="rta.html#outA" style="color:#00FF00">outA</a>	|   00010.100   |  out a to I/O port ea	|  							|
        |_______________|_______________|_______________________|_______________________________________________________|
	|	<a href="rta.html#outB" style="color:#00FF00">outB</a>	|   00011.100	|  out b to I/O port ea |  							|
        |_______________|_______________|_______________________|_______________________________________________________|
        |       <a href="rta.html#reload" style="color:#00FF00">reload</a>	|   00100.100   |  reload base registers|  2 * bank index @ *a,*(a+1)->io ports[ea, ea+1]. a+=2	|
        |_______________|_______________|_______________________|_______________________________________________________|
        |	<a href="rta.html#sabr" style="color:#00FF00">sabr</a>	|   00110.100   |  store a base register|bank pointer[a]->io port[ea=2..63],index[a]->TCB+64+ea	|
        |_______________|_______________|_______________________|_______________________________________________________|


	Assembly Language Examples
	__________________________


	on	b$streamZR
	off	carry$

	inA	PORT_240
	outB	PORT_240
	<div	style="color:#FF0000">
	la	transmission:buffer
	</div>
	sabr	BSOCKB

	<div	style="color:FF0000">
	..........
	</div>

	on	see$1
	<div	style="color:FF0000">
	la, xi	ABT+2
	</div>
	?	$do	23,	reload	?*2


</pre>
<b>sabr</b> instruction copies the storage block identity to 
Thread Control Block + 64 + ea and writes the absolute value to I/O port[ea]

<p>
bank identity is identical to absolute value when bit 23 of the symbolic
identity is zero. Symbolic bank identities with bit 23 = one are not
implemented

<p>
<b>reload</b> instruction reads two storage block identifiers at the
address in register a and writes their absolute values to I/O port[ea]
and I/O port[ea + 1]. Register a is incremented by 2

<a	name="proc"/>
<h2>6: Macro Language: Procedures and Functions</h2>

<h3>6.1: $proc: Command and Instruction Macros</h3>

<b>$proc</b> directive heads an inline macro. <b>$end</b> directives ends all macros
and also ends the assembly. End of input also ends the assembly

<p>
Macros reference actual parameters as a function of their
<a href="http://timmilescox.github.io/masmx/masmx.html#proc">$proc</a> or
<a href="http://timmilescox.github.io/masmx/masmx.html#func">$func</a> label

<p>
For this reason macros tend to cryptic titles with separate
call names assigned a latent value with <a href="http://timmilescox.github.io/masmx/masmx.html#name">$name</a> directive

<p>
Macro labels  are only visible if they are promoted with asterisk* Names
which are not promoted are reusable in the calling assembly. Many macros
may have the same <a href="http://timmilescox.github.io/masmx/masmx.html#proc">$proc</a> label,
making paraform language easy to write and re-use
<pre	style="font-size:12pt;color:#0000FF">

$ masmx -ln
MASMX 7r3
0/-INPUT>>
p	$proc
dem1*	$name	33
dem2*	$name	99

	+	p(0, 0), p(1, 1), p(1, 3), p(2, 1:1)*p(2, 1:2):d
	$end

	dem1	0aaa,,-12 25:4
	dem2	0bbb,,12        3:3
	$end
  :                            1 p $proc
  :                            2 dem1* $name 33
  :                            3 dem2* $name 99
  :                            4 
  :                            5  + p(0, 0), p(1, 1), p(1, 3), p(2, 1:1)*p(2, 1:2):d
  :                            6  $end
  :                            7 
00:000000 021AAAFF4064        +8  dem1	0aaa,,-12	25:4
00:000002 063BBB00C009        +9  dem2	0bbb,,12	3:3
  :                            10  $end
:$(00):000000:000004 

</pre>

<b>$proc</b> macros interpret actual parameters from their <b>field,subfield:substring</b>
position. Parameters are referenced by the label on the <b>$proc</b> line which is in the
example above <b>p</b>

<p>
Actual parameters have, for example,  the syntax
<pre	style="font-size:12pt;color:#0000FF">

		<i>callname</i>	haddock	  5   44    chips, peas, salt:vinegar

</pre>
Reference paraforms have the syntax <b><i>macroname</i>([field[, subfield[:substring]]])</b>
<pre	style="font-size:12pt;color:#0000FF">


macroname	$proc

callname*	$name		100	

		macroname(1, 1)		. the first subfield of the first argument field, = <b>haddock</b>
		macroname(4, 3:2)	. the second substring of the third subfield
					. of the fourth argument field, = <b>vinegar</b>

		macroname(0, 0)		. the name used to invoke the macro, = <b>100</b>

		.
		.
		.
		$end


</pre>
The callname can be reference with paraform <b><i>name_on_$proc_or_$func_line</i>(0, 0)</b> and has the latent value of the
<a href="http://timmilescox.github.io/masmx/masmx.html#name">$name</a> line

<p>
One macro may have any number of name lines
<pre	style="font-size:12pt;color:#0000FF">

p       $proc

sar*    $name   0
sbr*    $name   1
dsr*    $name   2
jdr*    $name   3

sal*    $name   4
sbl*    $name   5
dsl*    $name   6

</pre>
<a href="http://timmilescox.github.io/masmx/masmx.html#name">$name</a> labels
need to be promoted with an asterisk to be visible outside the macro.
The label of <a href="http://timmilescox.github.io/masmx/masmx.html#proc">$proc</a>
is also allowed to be promoted with asterisk and callable if it
is unique in the assembly. However there is only one
<a href="http://timmilescox.github.io/masmx/masmx.html#proc">$proc</a> line per macro
and that has no latent value

<p>
Forward references are possible in two-pass <a href="http://timmilescox.github.io/masmx/masmx.html#proc">$proc</a>
which is flagged with *
<pre	style="font-size:12pt;color:#0000FF">

maybe*	$proc	*
	tp	estimation
	j	maybe_not
?	$do	maybe(),	lcal	maybe(?, 1)
maybe_not
	$end

</pre>

<i>proc_name</i> is the count of all the fields on the call line including any label

<p>
<i>proc_name</i>() is the count of actual argument fields after the callname

<p>
<i>proc_name</i>(&mu;) is the count of subfields in field &mu;

<p>
<i>proc_name</i>(&mu;,&nu;:) is the count of substrings in subfield &mu;,&nu;

<p>
If <i>proc_name</i>() is an argument calling another macro,
all the actual parameters are transferred to the new macro
at the same positions on the line
<pre	style="font-size:12pt;color:#0000FF">

$ masmx -ln
MASMX 7r3
0/-INPUT>>
p	$proc
forward* $name
 	inward	p()
	$end

p	$proc
inward*	$name
field	$do	p(),	+	p(field, 1)
	$end

	forward	10 20 40 99 101
	$end
  :                            1 p $proc
  :                            2 forward* $name
  :                            3  inward p()
  :                            4  $end
  :                            5 
  :                            6 p $proc
  :                            7 inward* $name
  :                            8 field $do p(), + p(field, 1)
  :                            9  $end
  :                            10 
00:000000 00000A              +11  forward 10 20 40 99 101
00:000001 000014              +11 
00:000002 000028              +11 
00:000003 000063              +11 
00:000004 000065              +11 
  :                            12  $end
:$(00):000000:000005 


</pre>
<p>
If <i>proc_name</i> is an argument calling another macro, all the fields in
the call line to the current macro, including any label, are arguments to
the called macro

<p>
If <i>proc_name</i>(&mu;) is an argument calling another macro,
all the subfields of field &mu; are forwarded

<p>
If <i>proc_name</i>(&mu;, &nu;) is an argument calling another macro,
the subfield &mu;,&nu; is forwarded to the called macro

<pre	style="font-size:12pt;color:#0000FF">
§
$ masmx sort_out -lnk
MASMX 7r3
3/sort_out.msm
*EOF*
  :                            1 
  :                            2 p	$proc
  :                            3 sort_out* $name
  :                            4 index	$equ	p()+1
  :                            5 ?	$do	p(),	+	p(1, 2), p(index-?, 1)
  :                            6 	$end
  :                            7 
  :                            8 p	$proc
  :                            9 backslang* $name
  :                            10 ?	$do	p(),	+	p(?, 1), p(?, 3), p(?, 2)
  :                            11 	$end
  :                            12 
  :                            13 p       $proc
  :                            14 yaname* $name		101
  :                            15         sort_out        p(0,0), p(0, 2)	p()
  :                            16         backslang       p(3) p(2) p(1)
  :                            17 	$end
  :                            18 
00:000000 028007              +19 	yaname,40	1, 2, 3		4, 5, 67, 8, 9
00:000001 028004              +19 
00:000002 028001              +19 
00:000003 028065              +19 
00:000004 070908              +19 
00:000005 040605              +19 
00:000006 010302              +19 
  :                            20 
*EOF*
:$(00):000000:000007 

</pre>

<p>
<i>proc_name</i>(&mu;,*&nu;) is a unary asterisk on subfield &mu;,&nu;.
Reference returns the value 1 if the asterisk is present, or 0

<pre	style="font-size:12pt;color:#0000FF">

$ masmx -ln
MASMX 7r3
0/-INPUT>>
star*	$proc
	+	star(1, *1)
	$end

$(4:04000)
galaxy	$res	6
	star	galaxy
	star	*galaxy
	$end
  :                            1 star* $proc
  :                            2  + star(1, *1)
  :                            3  $end
  :                            4 
  :                            5 $(4:04000)
  :                            6 galaxy $res 6
04:004006 000000              +7  star galaxy
04:004007 000001              +8  star *galaxy
  :                            9  $end
:$(04):004000:004008 


</pre>

<p>
Five more features of macro processing are shown here

<p>
Macros may contain macros, so only the outer macro can call the inner macro

<p>
<b>$proc</b> macros may be flagged with a location counter to assemble in a target
program section. Any 2-pass asterisk comes before the section flag and separate, as
<pre	style="font-size:12pt;color:#0000FF">

macro_name	$proc	*	$(TARGET_LOCATOR)

</pre>
Macros can construct a label combining a parameter with other symbols. The label is
constructed in quotes

<p>
Macros can assign a new value to the label on the call line. It is referenced
with an asterisk in column 1

<p>
Macros generate and use labels which are discarded at the end of the macro expansion.
Labels only remain for the calling level of assembly if they are promoted with trailing
asterisk

<p>
One asterisk is added to promote a label one  macro level. An asterisk at the main
assembly level externalises the label


<pre	style="font-size:12pt;color:#0000FF">
	
$ masmx indicate indicate -ln
MASMX 7r3
3/indicate.msm
*EOF*
  :                            1: 	$include	freeware/RTA1/rta/def/rta.def
  :                            2 
  :                            3 react*  $proc
  :                            4 indicate* $proc	$(1)
  :                            5 *	+	0
  :                            6 	$end
  :                            7 "react(1, 1)pointer" indicate
  :                            8 	tz 	*react(1, 1)pointer
  :                            9 	lcal	*react(1, 1)pointer
  :                            10 	$end
  :                            11 
  :                            12 $(1:01000)
  :                            13 $(0:64)
  :                            14 
01:001000 000000              +15 	react	quick
00:000040 709000              +15 
00:000041 3E9000              +15 
01:001001 000000              +16 	react	right
00:000042 709001              +16 
00:000043 3E9001              +16 
  :                            17 
*EOF*
:$(00):000040:000044 :$(01):001000:001002 
indicate.msm: object code 138 bytes: 0 errors: 0 undefined labels
$ cat indicate.txo

$01:001000
000000
$00:000040
709000 3E9000
$01:001001
000000
$00:000042
709001 3E9001
:$00*000000:000040:000044
:$01*000000:001000:001002


</pre>

<a	name="func"/>
<h3>6.2: $func: Macros to generate Assembly-Time Values</h3>

Function macros are not inline commands. They appear in expressions and generate an assembly-time value.
This operand expression obtains a functional value log2()
<pre	style="font-size:12pt;color:#0000FF">

	la, xi	20*log2(30)

</pre>
<p>
<b>$func</b> directive heads a function macro and  <b>$end</b> ends it. Function macros
return a 192-bit value with  <b>$return</b> directive

<p>
Arguments for a function are in parentheses. They are field, subfield and substring
arguments of arbitrary number

<p>
Code may be generated with values supplied by a function macro, for example
<pre	style="font-size:12pt;color:#0000FF">

        $ masmx 2log.msm -lnke
        MASMX 7r3A Build 5
        3/2log.msm
        *EOF*
          :                            1 f      $func
          :                            2 LOG*   $name
          :                            3 fulcrum        $set    f(1, 1)-1
          :                            4 ?      $do     23,     $do     1*/?-1>fulcrum, $return ?-1
          :                            5        $return -1
          :                            6        $end
          :                            7
          :                            8 $(3:03000)
        03:003000  000005              +9       +       LOG(30)
        03:003001  000005              +10      +       LOG(31)
        03:003002  000005              +11      +       LOG(32)
        03:003003  000006              +12      +       LOG(33)
          :                            13
        *EOF*
        :$(03):003000:003004
        2log.msm: object code 65 bytes: 0 errors: 0 undefined labels

        $

</pre>


Code may not be generated inline to the current location counter
inside the expanded text of a function macro, for example
<pre	style="font-size:12pt;color:#0000FF">

        $ masmx liable -lnke
        MASMX 7r3A Build 5
        3/liable.msm
        *EOF*
          :                            1 f*      $func
          :                            2         +       99
          :                            3 one     +       100
          :                            4 two     +       101
          :                            5 three   +       102
          :                            6         $snap   2
          :                            7         $return 103
          :                            8         $end
        00:000000  000063              +9         +       f()
        00:000001  000064              +9
        00:000002  000065              +9
        00:000003  000066              +9
        one=$00:000001
        two=$00:000002
        three=$00:000003
        Error: liable.msm Line 9: Function Adding Code Inline
        00:000004  000067              +9
        *EOF*
        :$(00):000000:000005
        liable.msm: object code 72 bytes: 1 errors: 0 undefined labels

        $

</pre>
This restriction is intended to avoid accidental inclusion of
data constants in instruction streams.<br>
It is consistent with the purpose of function macros, generating values not code

<p>
Assembly option flag -I releases this restriction
<pre	style="font-size:12pt;color:#0000FF">

        $ masmx viable -lnkeI
        MASMX 7r3A Build 5
        3/viable.msm
        *EOF*
          :                            1 f*       $func
          :                            2         +       99
          :                            3 one     +       100
          :                            4 two     +       101
          :                            5 three   +       102
          :                            6         $snap   2
          :                            7         $return 103
          :                            8         $end
        00:000000  000063              +9         +       f()
        00:000001  000064              +9
        00:000002  000065              +9
        00:000003  000066              +9
        one=$00:000001
        two=$00:000002
        three=$00:000003
        00:000004  000067              +9
          :                            10         $snap   2
        *EOF*
        :$(00):000000:000005
        viable.msm: object code 72 bytes: 0 errors: 0 undefined labels

        $

</pre>

<p>
A function macro can be flagged to expand only on the second assembler pass,
for the case that the function is not idempotent.
The flag is an asterisk on the title line
<pre	style="font-size:12pt;color:#0000FF">

$ masmx lquick -lnk
MASMX 7r3
3/lquick.msm
*EOF*
  :                            1 	$path		freeware/RTA1/rta
  :                            2: 	$include	def/rta.def
  :                            3: 	$include	t77.4/ip.def
  :                            4 
  :                            5 later*	$func	*
  :                            6 	$return	$5($net_socket	later(1, 1))
  :                            7 	$end
  :                            8 
  :                            9 $(5:05000/$5)
  :                            10 $(0:64)
  :                            11 
00:000040 CF5000              +12 	dl	later(127.0.0.1:8080)
  :                            13 
*EOF*
05:005000+7F0000011F90
:$(00):000040:000041 :$(05):005000:005002 

</pre>

<a	name="array"/>
<h2>7: Arrays, Iteration and Structures</h2>
<h3>7.1: Arrays</h3>
<h4>7.1.1: Linear Arrays</h4>

Space available for static data is 29 pages of 4096 words totalling 118'784 words

<p>
For larger data see <a href="#linear">7.1.2. Large Linear Arrays</a> and <a href="#teraword">7.1.3: Teraword Arrays</a>

<pre	style="font-size:12pt;color:#0000FF">

	$(3)		.	static

	structure_list
	?		$do	112000/STRUCTURE_SIZE,	my_structure

</pre>

If dense initial data is assembled for large  arrays, the file system embedded in the initial instruction frame needs extra pages for the quantity of data load strings

<p>
RTA1 applications are shared-code reentrant and each new process instance unpacks initial data to static space $(3, 5) and private data space $(1)

<p>
Build seeks to pack this data in unused space in the page[s] of first instruction frame, if parameters are not set for more space

<p>
If more space is needed for load strings the build gives an error message
<pre	style="font-size:12pt;color:#0000FF">

	Error: ../image.app/load.msm Line 21: add page[s] to iframe containing segment load FS

</pre>

The physical block containing application[s] leading instruction frame and startup / initial data files needs to be larger

<p>
Space can expanded with override FS_SAFE_LIMIT in the main or containing assembly of the <a href="scripts.html">application build</a>
<pre	style="font-size:12pt;color:#0000FF">

		$include	language/iframe.def

FS_SAFE_LIMIT   $set    	SOME_PAGES*4096 . for example
		application$	0:app1 0:app2 ...
</pre>


<pre	style="font-size:12pt;color:#0000FF">


	[iframe] pages >=					iframe + data-initial
	instructions + fs					> [iframe] pages: expand
	_________________					_________________   

	_________________					_________________
	| application[s]|					| application[s]|
	| instruction	|					| instruction	|
	| code		|					| code		|
	|_______________|					|		|
	| fs		|					|		|
	| run templates	|					|		|
	| +initial data	|					|_______________|
	|_______________|					| fs		|
	| /////////////	|					| run templates	|
	|_______________|_________ next page boundary __________| +initial data	|
								|		|
								|_______________|
								| /////////////	|
								| /////////////	|
			     subsequent page boundary __________|_______________|
								
</pre>

<div	style="color:#00000040;margin-left:40pt">
The containing block can alternatively be expanded by adjusting macro call $application or catalog


<pre	style="font-size:12pt;color:#0000FF40">

	$application[<a style="color:#FF0000">,PAGE_HIGH_INDEX</a>]	0:app1_entry	0:app2_label ...

</pre>
<p>
This makes the instruction frame multi-page unnecessarily

<p>
Default <a style="color:#FF0000;font-size:12pt">PAGE_HIGH_INDEX</a> is zero = one page.
Memory is <a style="color:#FF0000;font-size:12pt">PAGE_HIGH_INDEX</a>+1 pages

</div>

There is no practical restriction how many pages may contain the leading instruction frame
and how many pages may be added for initial data

<p>
However dense arrays require space on the build platform and in the target load strings image

<p>
Application action primes arrays as efficiently as segment load. See also <a href="#density">Density of Array Load Data</a>

<p>
Literals which must be addressable from other instruction frames are in static data $(3), typically format strings for passing to stream library

<p>
Linear arrays in static may place $(3) literals outside the range of direct addressing

<pre	style="font-size:12pt;color:#0000FF">	

	00:000019  8F0008              +31 	printf	$3("%f":LF:0),,xi	8,,float
	Error: serial.msm Line 31: sign extended immediate too high
	00:00001A  FDF000              +31 

</pre>

If static becomes larger than direct address space because of linear arrays, the arrays can be placed in $(5) instead of $(3) and positoned after $(3), either by linking or directly in absolute assembly

<p>
<a href="scripts.html">Application build</a> checks if the given margin is large enough if the instruction frame contains multiple applications

<p>
For single applications which are one assembly with no make_rel file, the check for a sufficient gap for $(3) literals is placed at the end of the assembly

<p>
In this example Section $(5) arrays leaves a 256-word gap for literals at the end of $(3). This is more than normally necessary

<pre	style="font-size:12pt;color:#0000FF">

	$include	array.app/origin5

$(3:03000/$3)
.	scalars
$(5:03100)
.	arrays
$(0:0:/$0)
	catalog
	base_d	$zenith(5)-03000	1024		. $zenith(5) not $zenith(3)

	.
	.	application
	.

	$do	$<256,$(0:256)
	
	origin5		. is $(5) clear of $(3) literal table ?

</pre>
<p>

example <a style="color:#0000FF">fardown</a> is part of a multiple application build

<p>
<a href="scripts.html">Application build</a> checks if the given margin at the start of $(5) is large enough for literals at the end of $(3)

<p>
$base_d macro at line 22 states static RAM requirement from 003000<sub>16</sub> to the end of $(5) and not as otherwise to the end of section $(3)

<p>
The kernel supplies a <a style="color:#FF0000">29-page block</a> as programmed for static consisting sections $(3) and $(5)

<pre	style="font-size:12pt;color:#0000FF">

$ masmx -lnke fardown -x
MASMX 7r3A Build 12
3/fardown.msm
*EOF*
  :                            12 	$list
  :                            13 
  :                            14 $(3:03000/$3)		. static scalar data goes in $(3)
  :                            15 $(5:03100)
  :                            16 table1	$res	<a style="color:#FF0000">29*4096</a>-0100-1024-4-5*80
05:01FA6C  400001 E00000 000000 000000
                              +17 occurrence((<a style="color:#FF0000">29*4096</a>-0100-1024-8-5*80)/4)	1.75
  :                            18 $(4:*1)
  :                            19 	$lit
  :                            20 $(0:*1)
  :                            21 fardown*
00:000000  60207F              +22 	$base_d	$zenith(5)-03000	5*80	1024
00:000001  340003              +22 
00:000002  40207E              +22 
00:000003  6D0004              +22 
00:000004  54C001              +22 
(+00)0f
00:000005  F6000A              +22 

</pre>
External stack space is after array space and macro $base_d reserves for this example 5 * 80 + 1024 words

<pre	style="font-family:times-roman;color:#0000FF">

	5*80 words for 5 possible remote file states heaped at low addresses 

	1024 words printf format space for one thread from external stack root
	at 020000<sub>16</sub>, end page 31<sub>10</sub>

	any more threads needing external stack are served by more terms on $base_d line
	initial thread external stack size < the last term on the $base_d line

</pre>

<a      name="linear"/>
<h4>7.1.2: Large Linear Arrays and macro fastarray$</h4>

Large linear arrays are in blocks of 262144 words in some of windows [ 4..31 ]

<p>
At least one 4096-word page in windows [ 3..31 ] is $(3) static data and contains external stacks and open file states

<p>
$base_d macro argument 1 programs static space from 03000<sub>16</sub> to end section $(3) and does not obtain large array space

<p>
No contiguity or page sharing is possible between static data and the 262144-word banks of large linear arrays collected as program section $(5)

<p>
Large linear arrays may extend to seven megawords

<p>
Up to 28 banks are obtained at process initialisation after $base_d and before seg$load with macro fastarray$

<pre	style="font-size:12pt;color:#0000FF">

$(5:4*262144)		. if window 4 is array start window
objects
	$do	COUNT,	object

$(0*1/$0)

	$base_d	$zenith(3)-03000	1024
	fastarray$	4:31	*
	c	(seg$load)	0,,xi	(my_data:L),,long	

</pre>
2nd argument <a style=color"#0000FF">*</a> directs macro fastarray$ to close the process with a message if fewer banks are obtained than requested
<pre	style="font-size:12pt;color:#0000FF">

	load>arrays*app1
	00004f app1
	HALT 800031:0000c2

</pre>
fastarray$ is called before seg$load because seg$load loads section $(5) data. Argument <a style=color"#0000FF">*</a> avoids seg$load attempting to write void memory

<p>
On success or on shortfall without argument <a style=color"#0000FF">*</a>, fastarray$ returns register r = requested highest window + 1
and register x = actual highest window populated + 1

<p>
Highest-window-served + 1 in x can be saved during seg$load by store to a static location
<pre	style="font-size:12pt;color:#0000FF">

$(3)
beyond		$res	1
limits_pointer	$res	1

$(5...

	$base_d		$zenith(3)-03000	1024
	fastarray$	LOW_WINDOW:HIGH_WINDOW
	sx		beyond				. window after obtained array
	c		(seg$load)	0,,xi	(app_data:L),,long
	la		beyond				. read back limits window
	sal		18				. multiply by bank size
	sa		limits_pointer			. save
	lr		a				. load limits pointer

</pre>
Directive $res declares storage but no initial values. seg$load does not write $res locations

<p>
It is efficient to prime an array programmatically and that avoids tuning the instruction frame to accommodate extra-large segment load. See also <a href="#density">Density of Array Load Data</a>

<p>
fastarray$ requests requests 262144-word granules preferring memory array devices. Executable space device[0] is the last resource of request

<a	name="teraword"/>
<h4>7.1.3: Teraword Arrays</h4>

Teraword arrays use application vectors vpointer(1..1792) to construct arrays of storage granules or clusters with footprint up to 4 terawords

<p>
Initially teraword arrays are not populated at all

<p>
Teraword arrays become populated with memory in granules called into application address space,<br>
and may become populated to the extent of available memory,<br>
requested firstly from memory array devices and lastly from executable space device[0]

<p>
In view of possible scale of data, offsets and subscripts are 48 bits

<p>
<a href="kernel.html#teraword">Teraword Arrays API</a> is constructed from macro language and service calls


<a	name="density"/>
<h4>7.1.4: Density of Array Load Data</h4>

masmx directive $res reserves storage without generating any load values for it

<p>
$res is therefore the best declarator for mapping large arrays, because value declarations generate load strings

<p>
Arrays may be billions of words and load string files may not

<p>
The most efficient agent for priming a large array densely populated with values is the application

<p>
Application build tools allow about 0.25 megawords of data section load strings but this requires a large  application load image.<br>
Files on the developer platform are correspondingly large

<p>
This way of declaring 65536 * floating zero has high costs in platform space, target loading and processing
<pre	style="font-size:12pt;color:#0000FF">

floats
	$do	65536,	0.0

</pre>
The lowest cost  way of doing this, and the most rapid, is
<pre	style="font-size:12pt;color:#0000FF">

$(5)
floats	$res	65536*4
$(0)
	ql	(0.0)
	lr	65536-1,,xi

	$if	floats<32768	. if $(5) is relocatable this comparison is not allowed
	lx	floats,,xi	. but this is. It's range-checked at link
	$else
	lx	(floats:s)	. this works whether $(5) is absolute or relocatable 
	$endif

again	qs	0, x
	ax	4,,xi
	jdr	again


</pre>

<a      name="do"/>
<h3>7.2: Iteration: Directive $do</h3>

<b>$do</b> directive repeats a line of code
<pre	style="font-size:12pt;color:#0000FF">

[tag]	$do	count,[label]	command	[command_arguments]

</pre>

For example
<pre	style="font-size:12pt;color:#0000FF">

	$do	$o('k')=0,	$exit	this assembly requires option -k
</pre>

A column 1 tag on <b>$do</b> has a value incrementing from 1. This value
may be used in labels and values of iterated code

<pre	style="font-size:12pt;color:#0000FF">

$ masmx -klnx
MASMX 7r3
0/-INPUT>>
$(30:01E000)
TIMES	$set	5

index	$do	TIMES,float(TIMES+1-index)	1*+index-1
	$end
  :                            1 $(30:01E000)
  :                            2 TIMES $set 5
  :                            3 
1E:01E000 400001800000000000000000
                              +4 index $do TIMES,float(TIMES+1-index) 1*+index-1
1E:01E004 400004A00000000000000000
                              +4 
1E:01E008 400007C80000000000000000
                              +4 
1E:01E00C 40000AFA0000000000000000
                              +4 
1E:01E010 40000E9C4000000000000000
                              +4 
  :                            5  $end
TIMES=000005
index=000005
float(5)=$1E:01E000
float(4)=$1E:01E004
float(3)=$1E:01E008
float(2)=$1E:01E00C
float(1)=$1E:01E010
-INPUT>>=0<000000
:$(1E):01E000:01E014 

</pre>

The line of repeated code may be a macro name subassembling complex data or instructions

<a	name="structure"/>
<h3>7.3: Structures for Data and Instruction Code</h3>

Structures organise data and compartment name spaces

<p>
Directives <a href="http://timmilescox.github.io/masmx/masmx.html#tree">$tree</a>, <a href="http://timmilescox.github.io/masmx/masmx.html#branch">$branch</a> and  <a href="http://timmilescox.github.io/masmx/masmx.html#root">$root</a> declare a structure instance

<p>

<h4>7.3.1: Data Structure and Multiple Instances</h4>

To make a template the structure is declared inside a  <a href="http://timmilescox.github.io/masmx/masmx.html#proc">$proc</a> macro

<p>
Here is an example of a data structure templated in a macro
<pre>

	p               $proc
	tcp_connection* $name
	*               $tree
	next            +       0
	state           +       TCP_LISTEN
	mss             +       576
	tsq             +       0
	?               $do     2,timer(?)        +       0
	socket_address  $netp
	remote_address  $netp
	remote_ack_window +     0:d
	sequence_ackx   +       0:d
	ack_window      +       0:d
	receiveq        dq
	deferq          dq
	q4window        dq
	q4ack           dq
	                $root
        	        $end

</pre>
A void program section works as a pointer (data values are not generated in the void section)
<pre>

	$(66::,x)
	transmission	tcp_connection

</pre>
The members are referenced using separator <a href="http://timmilescox.github.io/masmx/masmx.html#sterm">$sterm</a> which is : colon in RTA1
<pre>

			tz	transmission:receiveq:head
			lcal	process_segment

</pre>
Structure dq has members called head and tail

<p>
Up to eight structures nest

<a	name="dynamic"/>
<h3>7.4: Internal Name Space of Parameters and Dynamic Variables</h3>

Developers often give dynamic variables and parameters of analagous functions the same internal names

<p>
This can be done in masmx by placing functions in a name structure with directives [ $tree $root ]
<pre>

function_x	$tree

	$head_near	 params(left,	int		;
				right,	int		;
				centre,	int	)	;
							;
			scalars(temp1,	int,	left	;
				temp2,	int,	right	)

.	some instructions

	$ret
	$root

</pre>

Another function can also have variables [ left right centre temp1 temp2 ]

<p>
$tree-internal names of static application can be globally referenced with $tree name as prefix

<p>
This is used where a $tree contains multiple functions or shareable data. All names must be unique within the tree
<pre>

group_y	$tree

$(3)				. static section
shared_result	0L

$(0)				. instructions section

function_a	.
		.
		$ret

function_b	.
		.
		$ret
	$root

	lcal	group_y:function_a	left1	right1	centre1
	lcal	group_y:function_b	left2	right2	centre2
	dl	group_y:shared_result

</pre>


<a	name="bit_structures"/>
<h3>7.5: Bit Structures</h3>

<a href="http://timmilescox.github.io/masmx/masmx.html#bstradata">Bit structures</a> are available using directives <a href="http://timmilescox.github.io/masmx/masmx.html#record">$record[,$branch]</a> and <a href="http://timmilescox.github.io/masmx/masmx.html#root">$root</a> to construct and label structures of bit fields hierarchically

<p>
Macro code accesses the attribute definitions of bit structures to retrieve and store data fields

<a	name="algors"/>
<h2>8: Runtime Algorithmic Expressions</h2>
<h3>8.1: Floating and Integer Expressions</h3>

Directives <a href="#x_fp">$xqt_fp</a> and <a href="#x_i">$xqt_i</a> program run time resolution of expressions referencing variable and literal values

<p>
<a href="#x_fp">$xqt_fp</a> and <a href="#x_i">$xqt_i</a> order and parameterise macro calls with universal names and target-specific implementations

<p>
<a href="#x_fp">$xqt_fp</a> delivers a floating value in result registers and expression terms are operators and floating numbers

<p>
Input terms may include ad-hoc conversions of data which is not in floating format

<p>
<a href="#x_i">$xqt_i</a> delivers an integer value in result registers and expression terms are operators and integers

<p>
Input terms may include ad-hoc conversions of data which is not binary integer

<p>
RTA1 platform has a suite of macros for floating arithmetic expressions and a suite of macros for calculating integers at radix 24 to 96 bits


<a name="x_fp"/>
<h3>8.2: Floating Algorithm Run Time Planner $xqt_fp</h3>
<pre	style="font-size:12pt;color:#0000FF"e>

	$include	language/fpxpress.def

</pre>
Directive $xqt_fp orders floating operations for run-time algorithms

<p>
Input is an expression of any complexity describing an algorithm step. 4- or 8-word result is in registers <b>a b 6 7 [ 8 9 10 11 ]</b>

<p>
An algorithm which can be stated as an expression takes one pass of one $xqt_fp line

<p>
$xqt_fp supports four functions and parentheses. All algorithmic steps are constructed from these. See also <a href="kernel.html#app_lib">floating application library</a>

<p>
Input tokens are either known at assembly time or are variables

Supplied macros calculate 96-bit floating expressions

<p>
Support for 192-bit values in expression language is scheduled for later release

<p>
Here a simple algorithm with five inputs is executed in five instructions, including
operand acquisition from storage
<pre	style="font-size:12pt;color:#0000FF">


$ masmx -ln r2xample.msm
MASMX 7r3
3/r2xample.msm
*EOF*
  :                            1 	$path		../def
  :                            2: 	$include	rta.def
  :                            3 	$path		../language
  :                            4: 	$include	stack.def
  :                            5: 	$include	fpxpress.def
  :                            6 	$path
  :                            7 $(0:0)
  :                            8 
00:000000 B60040              +9 floating_algorithm*  $vector fp_routine
  :                            10 
  :                            11 $(0:64)
  :                            12 
  :                            13 fp_routine 
                                	$head_far	 params(one,	float		;
                                				two,	float		;
  :                            16 				three,	float)
  :                            17 
00:000040 4FF003              +18 	$xqt_fp		one * 1.75*+1200000 * two / 3.0*-625000 - three
00:000041 770100              +18 
00:000042 77F007              +18 
00:000043 7F0104              +18 
00:000044 6FF00B              +18 
  :                            19 
  :                            20 
00:000045 3D0000              +21 	fret		0
  :                            22 
  :                            23 	$do		$<256,$(0:256)
  :                            24 	
*EOF*
00:000100+7CD38BB7B396D7AA20B6E083
00:000104+2051D5B8447B77478A23F5F7
:$(00):000000:000108 
r2xample.msm: object code 190 bytes: 0 errors: 0 undefined labels


</pre>
masmx has taken an expression with five operands and four operators, and
turned it into a sequence of five instructions which deliver the four-word
floating result of the operations in the result registers <b>a b mantissa2 mantissa3</b>

<p>
Three of these tokens are identifiers whose content is only known at runtime

<p>
The tokens which are constants appear as literals at the foot of the assembly

<p>
An expression in RTA1 instruction assembly language generates an effective address which some instructions use as an immediate value

<p>
$xqt_fp has different rules to discriminate between identifiers and self-evident values in an intuitive sense

	<blockquote>
	a field of digits is a value<br><br>
	an address label of storage is a location<br><br>
	a label equated or set to digits is a value<br><br>
	a label equated or set to a storage label or to a location counter is a location<br><br>
	a label equated or set to another label is what that label is<br><br>
	a <a href="http://timmilescox.github.com/masmx/masmx.html#equf">$equf</a> label is a location
	</blockquote>

Therefore a construction
<pre	style="font-size:12pt;color:#0000FF">

mass	$equ	4096.0

</pre>
is a constant

<p>
The constructs
<pre	style="font-size:12pt;color:#0000FF">

bucket	$equf	4096
scoop	$equ	$(3)

</pre>
reference storage locations

<p>
Floating numbers are too large to be immediate operands so so self-evident values are literal constants

<p>
Function header lists <b>params() scalars() xframe()</b> contain
<a href="http://timmilescox.github.com/masmx/masmx.html#equf">$equf</a> variable names

<p>
In this assembly <a style="color:#0000FF">FACTOR</a> has been generated as a constant (visible at
the foot of the program) because
<a href="http://timmilescox.github.com/masmx/masmx.html#equ">$equ</a> connected <a style="color:#0000FF">FACTOR</a> to a
number value and not a stored location
<pre	style="font-size:12pt;color:#0000FF">

$ ~/masmx mammoth -lnk
MASMX 7r3
3/mammoth.msm
*EOF*
  :                            1 	$path		../
  :                            2: 	$include	def/rta.def
  :                            3: 	$include	language/stack.def
  :                            4: 	$include	language/fpxpress.def
  :                            5 $(0)
00:000000 B60040              +6 mammoth* $vector	sum
  :                            7 $(3:03000)
03:003000 40000F800000000000000000
                              +8 left	16384*+0
03:003004 7CD38AFBEEFAC15E58C049D8
                              +9 right	1.2*+1200000
  :                            10 
  :                            11 $(0:64)
  :                            12 
  :                            13 FACTOR	$equ	1.875
  :                            14 
                                sum	$head_far	 params(first,	float	;
  :                            16 				second,	float	)
  :                            17 
00:000040 4FF007              +18 	$xqt_fp		- left - right + first + second * FACTOR
00:000041 770100              +18 
00:000042 6F3000              +18 
00:000043 6F3004              +18 
00:000044 67F003              +18 
00:000045 3D0000              +19 	$ret
  :                            20 	$do	$<256,$(0:256)
  :                            21 
*EOF*
00:000100+400001F00000000000000000
:$(00):000000:000104 :$(03):003000:003008 


</pre>

<p>
An override <a style="color:#0000FF">,,macro_name</a> may be appended as subfield 3 of an expression token, for example to convert it from integer

<pre    style="font-size:12pt;color:#0000FF">

        .... + object_needing_conversion,,macro_in_ring_111 * ....

</pre>
The macro must have a <a href="http://timmilescox.github.io/masmx/masmx.html#name">$name</a> value 111
which is called being in macro Ring 111.
See <a href="#x_atoi_fp"/>Data Conversion of Input Terms to Algorithms</a>

<p>
All floating terms in the expressions are computed at runtime including sequences of literal terms. This is in contrast to integer expressions which are computed as far as possible at assembly time

<p>
Spans of known floating terms in an expression may be resolved interactively before inclusion in assembly with <a href="fponline.html">fponline</a>
and <a href="http://timmilescox.github.com/masmx/masmx.html#equ">equated</a> to a name
<pre    style="font-size:12pt;color:#0000FF">

        $ cd rta/client
        ./rundum]      			# for routing if ./prun or ./rundum has not already run on platform
        fponline        [172.29.7...]	# if not default 172.29.7.7 = this platform
        expression
        .
        $

        . the assembly syntax for equating the value returned for the expression is

        name    $equ    value

</pre>



<a name="x_i"/>
<h3>8.3: Integer Algorithm Run Time Planner $xqt_i</h3>

Directive <a href="http://timmilescox.github.io/masmx/masmx.html#xqt_i">$xqt_i</a> codes an instruction plan
to resolve an integer expression including runtime storage contents 

<p>
These instruction steps are planned with the support of target-specific macros with
fixed call-names known to masmx 

<p>
Integer expressions may contain many more operators than floating expressions and process a fluid radix or size of value

<p>
Available operators are all the operators available to an assembly time expression 

<pre	style="font-size:12pt;color:#0000FF">


	$include	language/fpxpress.def
	$include	language/iconsta.def
	$include	language/types.def
	$include	language/i_xpress.def

</pre>

Macro suite i_xpress.def forms a dialect altered for intuitive sense from RTA assembly language

<p>
To avoid intense casting of input integer sizes integers are typed with macros in types.def
<pre	style="font-size:12pt;color:#0000FF">

source1	long	80000000000000
source2	int	7000000

dest	i72	0


</pre>
Casting is supported to expand if necessary the loaded size of integers to accommodate intermediate results
<pre	style="font-size:12pt;color:#0000FF">

	$xqt_i	source1.i72 * source2

</pre>
i72 and triple are synonyms

<p>
Shift counts stated as the names of storage fields are understood to be the values stored at those fields. This is different from RTA assembly language where the shift count is the effective address and any indirection is stated specifically

<p>
This has the effect that a term
<pre	style="font-size:12pt;color:#0000FF">

	*/ field_name  	. << field_name

</pre>
has the same meaning as
<pre	style="font-size:12pt;color:#0000FF">


	*/ *field_name	. << *field_name

</pre>
Option -C or -K uppercase has effect that indirection flag * means a pointer to another word containing the shift count
<pre	style="font-size:12pt;color:#0000FF">

	*/- *pointer_name . >> *pointer_name

</pre>


An inclusion
<pre	style="font-size:12pt;color:#0000FF">

	$include	language/c.def

.	switches -C option on

.	changes $sterm from : to . and $cont_char from ; to \

.	interprets C language operators	from the point of inclusion

.	switches -c option on for C language integer and string syntax from the point of inclusion


</pre>

If identifiers are not typed and also not cast i_xpress.def macros apply a default size of 48 bits to most integer names in the expression terms

<p>
The default size applied to multipliers, divisors and shift counts (where shift counts are obtained from storage) is 24

<p>
A shift count which is a number not a storage identifier is applied as assembly language: the effective address is the shift count

<p>
A storage field larger than one word from which a shift count is read must be either typed or cast to its actual size to alert macro language to read the shift count from the low-order word of the field

<p>
Multipliers and divisors may be any size up to 72 bits and are most efficient at 24 bits 


<p>
Expressions containing literals need a subfunction <a style="color:#0000FF">$iii</a> on the $xqt_i directive to make literals the most efficient size for the operation which uses them
<pre	style="font-size:12pt;color:#0000FF">

	$xqt_i,$iii	1500000000 + left * right

</pre>

<p>
$xqt_i resolves expression steps
between constants at assembly time, leaving the fewest possible operations
for run time calculation

<p>
If all the terms are known at assembly time, $xqt_i delivers a resolved constant to result registers without any runtime calculation

<p>
In addition to typing and casting <a style="color:#0000FF">[ int short long triple i72 quad ]</a>  macro language in i_xpress.def interprets some size designators as subfield 3 of the token.  These designators are a word <a style="color:#0000FF">[ w0 ]</a> or a byte selector <a style="color:#0000FF">[ h1 h2 t1 t2 t3 ]</a>

<pre	style="font-size:12pt;color:#0000FF">

	* storage_location,,t1

</pre>
The override part may be the name of a macro which obtains the term from a subroutine call.
See  <a href="#x_atoi_fp"/>Data Conversion of Input Terms to Algorithms</a>

<p>
In this example the subexpression right of the OR operator <b>++</b> has been
resolved at assembly time, but left of <b>++</b> a multiply, two adds and a
shift must take place at runtime. The term 12*/40 is a constant 

<p>
The first operation <b>one,,w0*4</b>
could be executed in one multiply step because it was known that the multiplicand
and multiplier both
had 24 or fewer significant bits. These rules are in the target-specific macro code and
not in masmx

<pre	style="font-size:12pt;color:#0000FF">

$ masmx -lnky boolean
MASMX 7r3
3/boolean.msm
  :                            1 	$path		../
  :                            2: 	$include	def/rta.def
  :                            3: 	$include	language/fpxpress.def
  :                            4: 	$include	language/i_xpress.def
  :                            5 	$path
  :                            6 
  :                            7 $(3:03000)
03:003000 000001              +8 one	1
03:003001 000000000002        +9 two	2d
03:003003 000000000003        +10 three	3d
  :                            11 $(0:64)
00:000040 603000              +12 	$xqt_i	two + one,,w0 * 4 + three */ 16 ++ 12 */ 40
00:000041 960018              +12 
00:000042 E00100              +12 
00:000043 D73001              +12 
00:000044 D73003              +12 
00:000045 360010              +12 
00:000046 900101              +12 
00:000047 980102              +12 
  :                            13 	$do	$<256,$(0:256)
  :                            14 	$end
00:000100+000004
00:000101+0C0000000000
:$(00):000040:000103 :$(03):003000:003005 


</pre>

<a	name="i_radix"/>
<h3>8.4: Integer Radix of Algorithmic Expressions</h3>

Macro language supplied for integer algorithms assigns each $i_xpress line an initial radix size associated with the first loaded term by type, cast or default
<pre	style="font-size:12pt;color:#0000FF">

		quad
		triple
		long

aname		int		. the type int is 24 bits


		aname.long	. aname is 24 bits but it's expanded on load to contain 48 bits = running radix

		untyped_name	. 48 bits of storage will be loaded and the running radix starts at 48 bits

</pre>
The running radix is reassessed larger by the size in words of any multipliers applied to the calculation

<p>
If any other operations like left-shifts and additions are likely to overflow the reckoned radix, it should be expanded by casting

<p>
The radix may have a reckoned maximum expansion of 96 bits and operations are programmed to compute all words containing part of the running value

<p>
Some algorithms are expressed to deliver values which can be truncated for efficiency instead of expanded in size

<p>
Macro language can be directed to truncate oversize intermediate values with the directive
<pre	style="font-size:12pt;color:#0000FF">

__RADIX	$set	48	. can be set again to large sizes

</pre>


<a	name="i_gcc64"/>
<h3>8.5: Benchmarking Integer Algorithms with GCC</h3>

Algorithic expressions can be benchmarked by comparing their results with output from 64-bit gcc programs on personal computers

<p>
See <a href="#i_bench">Appendix C: Constructing Integer Algorithm Benchmarks</a>


<a	name="x_atoi_fp"/>
<h3>8.6: Data Conversion of Input Terms to Algorithms</h3>

An override <a style="color:#0000FF">,,macro_name</a> calls a macro in Ring 111 to adapt input data, for example convert between float and integer or translate from text string to number

<p>
A macro with <a href="http://timmilescox.github.io/masmx/masmx.html#name">$name</a> value 111 is in Ring 111

<pre    style="font-size:12pt;color:#0000FF">

$ masmx ringtime -lnke
MASMX 7r3A Build 11
3/ringtime.msm
*EOF*
  :                            8 	$list
  :                            9 
  :                            10 p	$proc
  :                            11 convert_this_stuff* $name	111
  :                            12 	c	(text2float)	p(1)	fp$aside($$aside),,i
  :                            13 
  :                            14 	. text2float  must deliver result in pending area fp$aside($$aside)
  :                            15 	. and return registers unchanged
  :                            16 	$end
  :                            17 
  :                            18 
  :                            19 $(0:64/$0)
                                	$head_far	 params(left,	float	;
                                				right,	float	;
                                				centre,	float	;
  :                            23 				plank,	int	)
  :                            24 
00:000040  4FF00B              +25 	$xqt_fp		left + centre * plank,,convert_this_stuff + right
00:000041  FC0008              +25 
00:000042  F8F010              +25 
00:000043  FCF002              +25 
00:000044  FF0049              +25 
00:000045  38000F              +25 
00:000046  770008              +25 
00:000047  67F003              +25 
00:000048  67F007              +25 
  :                            26 
*EOF*
00:000049+[0000]18:000000
:$(00):000040:00004A 

</pre>

Construct
<pre	style="font-size:12pt;color:#0000FF">

	object,,[override_symbol]

</pre>
is part of supplied macro language binding RTA1 to masmx
<a href="http://timmilescox.github.io/masmx/masmx.html#xqt_fp">$xqt_fp</a> and
<a href="http://timmilescox.github.io/masmx/masmx.html#xqt_i">$xqt_i</a> directives

<a	name="directives"/>
<h2>9: masmx Directives and Automatic Functions</h2>

<p>
masmx directives are more numerous than these which feature in this document

<p>
Directives and assembler-supplied names are documented in
<a href="http://timmilescox.github.io/masmx/masmx.html#directives">masmx.7r3 manual 8: Directives</a>
and <a href="http://timmilescox.github.io/masmx/masmx.html#internalf">Automatic Functions</a>

<pre	style="font-size:11pt">
<ul	type="none">
<li><a	href="#form">$form</a>		<a  href="http://timmilescox.github.io/masmx/masmx.html#form" style="text-decoration:none">[masmx manual reference]-&gt;</li>
<li><a	href="#do">$do</a>		<a  href="http://timmilescox.github.io/masmx/masmx.html#do" style="text-decoration:none">[masmx manual reference]-&gt;</li>
<li><a	href="#proc">$proc</a>		<a  href="http://timmilescox.github.io/masmx/masmx.html#proc_call" style="text-decoration:none">[masmx manual reference 1]-&gt;	<a  href="http://timmilescox.github.io/masmx/masmx.html#proc" style="text-decoration:none">[masmx manual reference 2]-&gt;</li>
<li><a	href="#func">$func</a>		<a  href="http://timmilescox.github.io/masmx/masmx.html#func" style="text-decoration:none">[masmx manual reference]-&gt;</li>
<li><a	href="http://timmilescox.github.io/masmx/masmx.html#end">$end</a></li>
<li><a	href="#algors">$xqt_i</a></li>
<li><a	href="#algors">$xqt_fp</a></li>
<li><a	href="http://timmilescox.github.io/masmx/masmx.html#equ">$equ</a></li>
<li><a	href="http://timmilescox.github.io/masmx/masmx.html#equf">$equf</a></li>
<li><a	href="http://timmilescox.github.io/masmx/masmx.html#set">$set</a></li>
<li><a	href="#text">$text</a>		<a  href="http://timmilescox.github.io/masmx/masmx.html#text" style="text-decoration:none">[masmx manual reference]-&gt;</a></li>
</ul>
</pre>
This void assembly call displays all masmx supplied names including directives and functions
<pre	style="font-size:12pt;color:#0000FF">

$ masmx	-kx+y	# displays masmx internal names
	$end	. ends the assembly when input is stdin

</pre>

<a	name="file_formats"/>
<h2>Appendix A: File Formats and Linking</h2>

Three binary formats support RTA1 application development
<ul	type="none">

	<li>Text Encoded Binary is masmx assembly output and may be relocatable or absolute</li>
	<li><a href="#lstring">lstring</a> is an absolute load string format which may contain outstanding external name requests</li>
	<li><a href="#slab">rom image</a> which contains no metadata</li>

</ul>

Link steps required are included in supplied <a href="scripts.html">Application Construction and Build</a> scripts

<p>
Linking is a masmx assembly which can read both Text Encoded Binary and new source code inputs

<p>
Linked output is Text Encoded Binary and may be relocatable or absolute

<p>
Reading Text-Encoded Binary successfully requires a heading file from the target.rta tree
<pre	style="font-size:12">

	$include	def/map1.def

	$include,$void	filename[.txo]	[ $1, $3... ]	. fetch labels but no code, optionally filtered by program sections

	$include,$binary filename[.txo]	[ $0, $4... ]	. fetch text encoded binary code, optionally filtered by program sections

</pre>
Applications for RTA1 may be written in absolute code. A link step in all builds embeds a file system image containing initial data and run parameters

<p>
Applications may be as small as a few dozen instructions. Small applications are usually developed relocatable and linked into application group loads

<p>
Applications are all built  as far as <a href="#lstring">load strings</a> format

<p>
Applications included in NVRAM system images are first converted to <a href="#slab">rom</a> format

<p>
Loadable applications stay at lstring format. Their load address is resolved at load



<a	name="txo"/>
<h3>Text Encoded Binary (.txo) Format</h3>

masmx outputs text encoded binary files. They have the default suffix
<b>.txo</b> and they can be viewed in a text editor or a shell

<p>
Text encoded binary is explained in all topics including link request clauses in <a href="http://timmilescox.github.io/masmx/masmx.html#file_formats">masmx manual File Formats, Relocation, Linking</a>

<p>
Here is a simple assembly with .txo output file explained
<pre>

	$ masmx assembly assembly -lnke
	MASMX 7r3A Build 8
	3/assembly.msm
	*EOF*
	  :                            1 	$path		../
	  :                            2: 	$include	def/rta.def
	  :                            3: 	$include	language/stack.def
	  :                            4 
	  :                            5 $(0:0)
	00:000000  B60040              +6 call_name* $vector	routine
	  :                            7 
	  :                            8 $(0:64)
	00:000040  770100              +9 routine	fm	(1.75)
	00:000041  3D0000              +10 	fret	0
	  :                            11 
	  :                            12 	$do	$<256,$(0:256)
	  :                            13 
	*EOF*
	00:000100+400001E00000000000000000
	:$(00):000000:000104 
	assembly.msm: object code 128 bytes: 0 errors: 0 undefined labels
	$ cat assembly.txo

	$00:000000
	B60040
	$00:000040
	770100 3D0000
	$00:000100
	400001E00000000000000000

	+call_name:$00:000000
	:$00*000000:000000:000104

</pre>
The output file assembly.txo is text readable

<p>
The lines starting $00: set the location. The first one $00:000000 sets address zero

<p>
B60040 is a jump to "routine" at address 64

<p>
770100 3D0000 are floating multiply and return instructions

<p>
the floating point literal 1.75 is at address 256 or $00:000100 because operand addresses [ 0..255 ] are registers

<p>
2nd-to-last line is the exported call name. The loader updates this to the location where this iframe is loaded

<a	name="load_string"/>
<h3>Load String Format</h3>
<p>

<a href="#lstring">lstring</a> utility constructs dynamically loadable files from txo files

<p>
masmx output assembly.txo is converted to lstring format and displayed
<pre>

	$ lstring -b assembly.txo assembly
	$ fds24 assembly
	000000000000: <a style="color:#FF0000">000001 49ffbe 000000 000000</a>  "   I        "
	000000000004: b60040 <a style="color:#FF0000">000002 4bfebd 000000</a>  "  @   K     "
	000000000008: <a style="color:#FF0000">000040</a> 770100 3d0000 <a style="color:#FF0000">000004</a>  "  @w  =     "
	00000000000c: <a style="color:#FF0000">dffef9 000000 000100</a> 400001  "         @  "
	000000000010: e00000 000000 000000         "         "

</pre>
Load string descriptors <a style="color:#FF0000">{ words, checksum, address<sub>48 bits</sub> } </a> show one jump instruction at address zero, two instructions at address 64 and a four-word constant at address 256

<p>
An application built to load string format can either be dynamically loaded to an available Start Page Index
or be catenated to the NVRAM system image

<p>
There is no programming difference between NVRAM and dynamic load

<p>
All  applications can equally be NVRAM catenated or dynamically loaded

<p>
Some applications need to know their own Start Page Index and this is supplied at slab->rom or dynamic load time

<a	name="rom"/>
<h3>slab Format</h3>

<a href="#slab">slab</a> utility constructs ROM image from an lstring output which contains no outstanding address references

<pre>

	$ slab assembly assembly.rom 
	$ fds24 assembly.rom
	000000000000: b60040 000000 000000 000000  "  @         "64
	000000000040: 770100 3d0000 000000 000000  "w  =        "256
	000000000100: 400001 e00000 000000 000000  "@           ".

</pre>
<p>
Applications containing few instructions frequently share instruction pages with other Applications

<p>
All applications are shared-code reentrant

<p>
Each process instance unpacks initial data from an application-image-internal file system on launch


<p>
Builds apply the suffix <a href="#rom">.rom</a> to slab output image


<a	name="command_line"/>
<h2>Appendix X: masmx Command Line</h2>

Command line is also explained at <a href="http://timmilescox.github.io/masmx/masmx.html#commandline">masmx.7r3A Manual: Command Line</a>

<p>
There may be strings of 1-letter option flags in an arbitrary number of fields starting -hyphen anywhere on the command line

<p>
Up to 8 fields wihout leading hyphen are arguments

<p>
The first two arguments are input and output filenames
<pre>

	masmx [ -flAGs ] <i>input output</i> [ -FLagS ] [ <i>ARGUMENT3..ARGUMENT8</i> ]

</pre>
All eight arguments may be accessed in the assembly via text substitution

<p>
<a	name="text"/>
$text directive with a subfield (0, 2) translates occurences of from-text to the corresponding command line argument

<pre	style="font-size:12pt;color:#0000FF">

	$text,3		/__EXTRA_INCLUDE/
	$text,4		|__GLOBAL_VALUE|
	$text,5		\__BLANK_DEFAULT\

</pre>

$text lines must be all together in an assembly whether of this form or the form
<a href="http://timmilescox.github.io/masmx/masmx.html#text">	$text	\from\to\</a>

All command line fields are optional

<pre	style="font-size:12pt;color:#0000FF">

$ masmx -Fla source[.msm] binary[.txo] -GS -opQqci 99.def 5000 0

</pre>

If the second filename is missing, the output is <b>temp.txo</b>. Directive <b>$store</b> in the source
text assigns a different default output filename

<p>
If the first filename is missing, masmx reads source from stdin and constructs a file <b>temp.msm</b>

<p>
<a href="http://timmilescox.github.io/masmx/masmx.html#clopts">Flags</a> used in RTA1 are
<pre	style="font-size:12pt;color:#0000FF">

	-a	allow automatic literals. Already set in rta.def

	-c	C-Language number and string syntax
		without -cleading 0 is hex, string escapes are "text":value:value:"text"
		-c changes string pad from space to zero. So does -z but -zc changes sting pad to space

	-d	list load addresses not program-visible addresses in breakpointed sections
	-e	list generated code word-space-word
	-fg	<a href="http://timmilescox.github.io/masmx/masmx.html#clopts">label handling, 1st / 2nd pass decisions</a>
	-h	stop after 1st assembly pass
	-i	with -xi[p][q] display macro text in label tabel
	-k	labels case-significant
	-l	list [ down to include depth set by <b>$list <i>depth</i></b> directive ] default assembly main file
	-n	list relocation information when -l
	-p	list <b>$proc</b> macro text + actual arguments where <b>$plist</b> value &gt; macro nesting depth
	-q	list <b>$func</b> macro text + actual arguments where <b>$plist</b> value &gt; macro nesting depth
	-r	list <b>$proc</b> and <b>$func</b> macro text + actual arguments
		on first assembly pass where <b>$plist</b> value &gt; macro nesting depth

	-s	generate source updated with inclusions / text translations on 1st assembly pass
		and read updated source on 2nd assembly pass
	-u	mark assembly in error if labels are unresolved: final assembly or link
	-w	silent assembly
	-x	list labels
	-+	include masmx internal labels in list, for sorted list -x+y
	-y	order label list
	-z	string zero-fill to containing word, default space-fill. Reversed by -c

	-B	<a href="http://TimMilesCox.github.io/masmx/masmx.html#clopts">display owner and macro level of label added to $tree or $record structure</a>

	-D	translate \<i>ESCAPED</i> octal and hex sequences in "strings" and 'integers' when -c and $data_code
		otherwise escaped sequences are final as input and not translated per $data_code

	-E	floating constant rounding guard pattern is 111 default value
		flags <a href="http://TimMilesCox.github.io/masmx/masmx.html#optro">-EFGH</a> supplant each other with successive $set_option directive
	-F	floating constant rounding guard pattern is 110 instead of 111
	-G	floating constant rounding guard pattern is 101 instead of 111
	-H	floating constant rounding guard pattern is 000 instead of 111

	-I	allow function macros to generate code inline to the current location counter
	-L	<a href="http://TimMilesCox.github.io/masmx/masmx.html#clopts">display type and macro level of labels added during macro declaration</a>
	-Q	expand a <b>$func</b> macro name found in an expression even if it is screened with "quotes"
	-X	retrieve values which are not addresses exported from other assemblies
	-Y	in $record structures flag fields as signed unless their bit size is suffixed u
		otherwise bit fields are unsigned unless suffixed s. 
		macro language reads signedness of bit fields to determine manipulation
	-Z	zero-fill <b>$res</b> buffers



</pre>

masmx link flags. A link is an assembly with <b>$include,$binary</b>
<pre	style="font-size:12pt;color:#0000FF">

	-b	collate input files by segment
	-j	do not transform label references in incremental link to locator references
		until the containing section is absolute

</pre>
RTA1 structured programming macros <b>head_near / far</b> and <b>$ret</b> respond to unassigned
assembly flags <b>-VUOS</b> which may be used for tracing
<pre	style="font-size:12pt;color:#0000FF">

	-V	display stack-handling decisions
	-S	<b>$ret</b>  macro reconstructs caller parameter list in internal stack
		when returning from <b>$zero_stack</b> mode <b>head_near / far</b> routine
	-O	check enough parameters from <b>lc / c</b> call
	-U	check exact number of parameters

</pre>

<a	name="binary_utilities"/>
<h2>Appendix Y: Binary Utilities</h2>

<hr/>

<a	name="lstring"/>
<h3>lstring</h3>

lstring reads the text-encoded-binary output of masmx and
constructs a load string image for loaders

<p>
The command line is
<pre	style="font-size:12pt;color:#0000FF">

        lstring -b input.txo output

</pre>

-b option selects the binary load string format used in RTA1. Otherwise S-Records for quantum-24 are output

<p>
The input and output files are named in full with any extension they have.
masmx output files have by default extension .txo

<p>
Here is a part of a system image output from lstring with
-b option
<pre	style="font-size:12pt;color:#0000FF">
<a	name="bin"/>

        $ ../util.rta/fds24 srom
        00000000: 000001 49ffbe 000000 000000  "   I        "
        00000004: b60040 00000b d9fa7c 000000  "  @     |   "
        00000008: 000040 5500fc 10008f 10008e  "  @U        "
        0000000c: 04007c 200087 680084 dd0001  "  |   h     "
        00000010: de0049 3e004a f70100 350000  "  I> J   5  "
        00000014: 000001 fffebe 000000 000100  "            "
        00000018: 000040 000077 45324d 000000  "  @  wE2M   ".

        $

</pre>
There is a four word descriptor before each load string:
word-count, checksum, 48-bit address

<p>
lstring with -L option forwards requests for runtime Load Page Index to be added to gate structures.

<p>
These requests take the form of a flagged 4-word tuple pointing to the gate structure

<p>
This example is from the script which constructs loadable applications
The first 4-word tuple directs load update to gate location 64+1
<pre	style="font-size:12pt;color:#0000FF">

	lstring -bL gate.txo gate

	$ fds24 gate
	000000000000: 800000 7fffbe 000000 000041  "           A"
	000000000004: 000048 c1edf2 000000 000000  "  H         "
	000000000008: b60114 3d0000 3d0000 3d0000  "   =  =  =  "
	00000000000c: 3d0000 3d0000 3d0000 3d0000  "=  =  =  =  "
	

</pre>
lstring -v option outputs extra information

<p>
lstring is the final build step of loadable applications. They are not converted to ROM format

<br><br>
<hr/>

<a	name="slab"/>
<h3>slab</h3

<h3>slab ROM Image Utility</h3>

slab is the final build step of fixed load images. Input is the output from lstring. Output is ROM format

<p>
slab utility builds a ROM image on a file. A typical command line is
<pre	style="font-size:12pt;color:#0000FF">


        ../util.rta/slab srom srom.rom 28 -k

</pre>

<a	name="rom"/>
This fds24 readout of the slab output file srom.rom displays 4 words at
location zero, twelve words from location 64 and four words at
location 256

<p>
Word 0 is a jump to location 64, where the interrupt
internal stack pointer is written with the value 252

Some I/O is probed to detect the startup environment, then a GO instruction
jumps inter-bank via its constant operand <a style="color:#0000FF">000040</a> at address 256 containing
the vector value Page Index 1 location 0

<pre	style="font-size:12pt;color:#0000FF">

        $ ../util.rta/fds24 srom.rom
        00000000: b60040 000000 000000 000000  "  @         "<a style="color:#FF0000">64</a>
        00000040: 5500fc 10008f 10008e 04007c  "U          |"
        00000044: 200087 680084 dd0001 de0049  "   h       I"
        00000048: 3e004a f70100 350000 000000  "> J   5     "<a style="color:#FF0000">256</a>
        00000100: 000040 000000 000000 000000  "  @         "<a style="color:#FF0000">.</a>

        $

</pre>
If any load strings point outside the area described at
argument 3 of slab, slab won't finish the job

<p>
slab -h prints command line guidance

<pre	style="font-size:12pt;color:#0000FF">

$ slab -h

slab [-options] input[.bxl] output[.rom] [target-rom-words]

default ROM size is 1024 RTA1 words
target-rom-words is leading-zero for hex else decimal

slab ifile ofile -g	     #  64 RTA1 words
slab ifile ofile -p          #  4096 RTA1 words
slab ifile ofile -b          #  262144 RTA1 words
slab ifile ofile -M          #  1048576 RTA1 words
slab ifile ofile -G	     #  1073741824 RTA1 words

slab ifile ofile number      #  number of RTA1 words
slab ifile ofile number -g   #  number * 64 RTA1 words
slab ifile ofile number -k   #  number * 1024 RTA1 words
slab ifile ofile number -p   #  number * 4096 RTA1 words
slab ifile ofile number -b   #  number * 262144 RTA1 words
slab ifile ofile number -M   #  number * 1048576 RTA1 words
slab ifile ofile number -G   #  number * 1073741824 RTA1 words
options -v verbose -w very verbose
$

</pre>

A fourth argument is an optional offset address for loading output file data
<pre	style="font-size:12pt;color:#0000FF">

	slab ifile ofile size [-gkpbMG] <i>OFFSET</i>

</pre>
This offset is used to load tables to program high address spaces and must be known to software loading data. There is no metadata in slab format

<p>
slab -S allows a ROM-type image of a loadable application to be slabbed for diagnosis only

<p>
The load update tuples in a loadable lstring image otherwise prevent slab from completing the ROM image

<p>
The diagnosis-only quasi-ROM image may be easier to navigate with a viewer than lstring output

<br><br>
<hr/>

<a	name="fsformat"/>
<h3>fsformat</h3>
<p>
fsformat constructs device array filesystem images offline on the PC

<p>
A device array filesystem is an octet array containing an integral number of banks of 262144 words (786432 octets)
to a maximum of 17,179,869,184 words or 51,539,607,552 octets in 65536 banks

<p>
Device 1 is a device array filesystem hosting the system and enterprise web pages and 61 more devices may be device array filesystems allowing nearly 3 terabytes of filestore in an RTA1 system

fsformat command line is

<pre	style="font-size:12pt;color:#0000FF">

        $ fsformat fsimage_file [ <i>size</i> [ -T | -G | -M | -b | -p | -K ] ] < filetree_commands_textfile

</pre>

The size of the filesystem image defaults to 1 bank of 4096 64-word granules and may be typed in argument 2 <i>size</i> as
	<blockquote>
	a different number of 64-word granules<br><br>
	or governed by an option flag -TGMbpK<br>
	a number of of terawords, gigawords, megawords, banks, pages, or kilowords
	</blockquote>

<p>
Script rta/mrand7 builds device array filesystem 1 by default as 1 bank and has an optional size argument
<pre	style="font-size:12pt;color:#0000FF">

	mrand7	[<i>banks</i>]

</pre>
If fsformat reports negative filestore granules to spare, argument 2 <i>size</i> requires to be increased or an unviable filessystem could be brought online

<p>
With script mrand7 argument 1 <i>banks</i> is to be increased in case of negative remaining filestore

<p>
A textfile of commands specifies directories, files, and source paths of files, for example

<pre	style="font-size:12pt;color:#0000FF">

volume volume_name
tree boot$
tree left_boot
.
tree right_boot
.
.
tree free$tree$
.
tree etc
file network.txt etc.rta/network.txt
.
tree web
file index.html rta.doc/index.html
file rta.html rta.doc/rta.txt
file smaragd7.html rta.doc/smaragd7.txt
file language.html rta.doc/language.txt
file masmx7r3.html rta.doc/masmx7r3.txt
file connect.html rta.doc/connect.txt
file q_a.html rta.doc/q_a.txt
file footnote.html rta.doc/footnote.txt
file gnu_gpl.html rta.doc/gnu_gpl.html
.
.

</pre>

Command . period escapes one file tree level. Escaping root directory completes filesystem image construction

<br><br>
<hr/>

<a	name="4kformat"/>
<h3>4kformat</h3>

4kformat constructs core filesystem images in 4K-word pages for inclusion in RTA1 executable space

<p>
4kformat constructs the file tree using the same input commands as fsformat

<p>
Option flag -x generates linkable .txo code with exported filenames for inclusion by masmx link

<p>
Argument 2 is an offset to the file system start within the containing pages, and is not usually present
<pre	style="font-size:12pt;color:#0000FF">

	$ 4kformat -x load_segment.txo < segments_filetree_commands.txt

</pre>
Without -x The size of the filesystem image defaults to 1 page of 64 64-word granules and may be typed in argument 2 <i>size</i> as
        <blockquote>
        a different number of 64-word granules<br><br>
        or governed by an option flag -TGMbpK<br>
        a number of of terawords, gigawords, megawords, banks, pages, or kilowords
        </blockquote>

Option flag -z zero-pads to integral 4K pages for inclusion by catenation
<pre	style="font-size:12pt;color:#0000FF">

        $ 4kformat [ -z ] application_lookup.rom [ <i>size</i> [ -T | -G | -M | -b | -p | -K ] ] < lookups_filetree_commands.txt

</pre>

<p>
-x and -z are mutually exclusive

<p>
4kformat is called in root application build scripts

<br><br>
<hr/>

<a	name="1gformat"/>
<h3>1gformat</h3>

1gformat constructs micro-filesystems in 64-word granules for including data section load information in shared-code applications

<p>
1gformat constructs the file tree using the same input commands as fsformat

<p>
1gformat is mostly used with -x option because its purpose is constructing a linked application component

<p> 
Option flag -x generates linkable .txo code with exported filenames for inclusion by masmx link
and argument 2 is an offset to the file system start within the application iframe pages

<pre	style="font-size:12pt;color:#0000FF">

	$ 1gformat -x segments_include.txo $IFRAME_CODE_SIZE < segments_filetree_commands.txt

</pre>

<p>
Without -x argument 2 is the filesystem size units of 64-word granules or units per flag -TGMbpK 

<p>
Option flag -z zero-pads to integral 4K word-pages for inclusion by catenation but is rarely applicable in 1gformat

<p>
-x and -z are mutually exclusive

<p>
1gformat is called in application build scripts

<p>
1gformat does not extend directory blocks beyond 64 words but utilities 2gformat 4gformat 8gformat construct larger directory blocks

<br><br>
<hr/>

<a	name="fds24"/>
<h3>fds24</h3>

fds24 is a file viewer and string or binary searcher on PCs

<p>
fds24 displays the RTA1 view of data files as an array of 24-bit word quanta

<p>
Any search arguments are on the command line

<p>
Without search arguments return key scans forward

<p>
A new scan position can be entered, leading zero for hex otherwise decimal. 256 and 0100 are the same position

<p>
Character search arguments are from  argument 3. Argument 2 is search-from position, leading zero for hex else decimal

<p>
Search hits display the containing four-word block
<pre	style="font-size:12pt;color:#0000FF">

$ fds24 rumbus 0 trunk said 'to the'
000000000008: 642068 657220 747275 6e6b0a  "d her trunk "
00000000000c: 416e64 207361 696420 676f6f  "And said goo"
000000000010: 646279 652074 6f2074 686520  "dbye to the "

$ fds24 banana.joe 0 "oe's ba"
000000000000: 4a6f65 277320 62616e 616e61  "Joe's banana"

</pre>
Binary search strings are constructed in a preliminary step

<p>
Directory rta/target.rta/image.app must be in $PATH. Command makemask constructs a binary search argument

<p>
A binary number of any size up to 192 bits can be input in decimal for search. Input in hex has leading zero

<pre	style="font-size:12pt;color:#0000FF">

$ makemask <i>mask_name</i> 0d34654117665e1a30eee883861c7af2e441a32f24153975 188
MASMX 7r3A Build 8
3/../image.app/mask.msm
*EOF*
  :                            1 
  :                            35 	$list
  :                            36 
00:000000  000004 0000BC        +37 	mask
00:000002  000000 000000        +38 	0L
*EOF*
00:000004+D34654117665E1A30EEE883861C7AF2E441A32F241539750
:$(00):000000:00000C 

</pre>
makemask argument 1 is a mask name and the output is <i>mask_name</i>.rom  Objects <i>mask_name</i>.txo and <i>mask_name</i> are also generated. Any file in current directory clashing with these three names will be lost

<p>
makemask argument 3 is the size in bits of the binary search string which starts at the leading bit position of containing 24-bit words

<p>
fds24 option -s causes a bit-pattern search for matches at any bit offset in the file to the contents of <i>mask_name</i>.rom

<p>
Argument 2 is search-from word offset, leading zero for hex otherwise decimal

<pre	style="font-size:12pt;color:#0000FF">

$ fds24 -sZvp nelly7.rom 0 <i>mask_name</i>.rom
			match @000000000010:10 188 decimal bits
nelly7.rom 000000000010: 7941d3 465411 7665e1 a30eee  "yA FT ve    "
nelly7.rom 000000000014: 883861 c7af2e 441a32 f24153  " 8a  .D 2 AS"
nelly7.rom 000000000018: 975dda d061dd 91073c 3a7220  " ]  a   <:r "

</pre>

Option flag -Z suppresses pause/prompt after display

<p>
-p displays the examined file name on output lines

<p>
-v displays the word:bit offset in hex of a match<br>
Matches which are not on a quartet aligned bit position are otherwise difficult to pinpoint 

<br><br>
<hr/>

<a	name="licence"/>
<h2>Appendix Z: Licence Note</h2>

<pre	style="font-size:12pt;color:#0000FF">
<i>

    LICENCE NOTICE


    Copyright Tim Cox, 2012
    TimMilesCox@gmx.ch

    This document is part of the RTA1 freeware processor programmable
    architecture.

    This document additionally concerns the masmx.7r3 meta-assembler
    which is a separate free program by the same author and supports
    the RTA1 architecture among other processor architectures

    RTA1 is a free processor architecture specification.
    It is licensed under the GNU General Public Licence Version 3

    The executable emulation of RTA1 is free software.

    Instruction code for the target RTA1 architecture is free software
    if it is delivered with this software

    Software programs delivered with this software to connect the
    emulated RTA1 with real network interfaces in the emulator host
    are free software

    Scripts and programs delivered with this software for running
    on other computers and interacting with the RTA1 are free software

    Scripts and utility programs for constructing RTA1 target
    executable software are free software

    You can redistribute it and/or modify RTA1
    under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    RTA1 is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with RTA1.  If not, see &lt;http://www.gnu.org/licenses/&gt;.

</i>
</pre>


</div>
<pre>
<a	href="index.html">
<pre	style="border-radius:5px;color:#FFFFFF;background-color:#0000FF;font-size:16pt;
	width:100pt;height:25pt;top:0pt;right:20pt;position:absolute">
INTRO PAGE ->

</pre>
</a>
</html>
