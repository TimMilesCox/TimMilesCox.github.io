<html>

<div>

<center>
<h1>masmx.7r3 for RTA1</h1>

<i>
Copyright Tim Cox, 2014
<p>
This document is part of the RTA1 Processor Programmable Architecture Specification<br>
RTA1 is a free computer programmable architecture licensed under the GNU General Public Licence Version 3<br>

The same licence encompasses all software and documentation delivered with RTA1 Specification

<br>
The masmx.7r3 meta-assembler is free software separately licensed with the GNU General Public Licence Version 3

<br>
The full text of GNU General Public Licence Version 3 is included with these materials<br>
See also the licensing notice at the foot of this document

</i>
</center>

<h2>Larger Document Link</h2>

This is a summary for programming RTA1

<p>
To see everything masmx does,
refer to <a href="http://timmilescox.github.io/masmx">
masmx documentation and download</a>

<p>

For RTA1 assembly examples,        
Complete source code and assembly listing of the smaragd7 kernel and of some application protocols are in the repository RTA1

<p>
RTA1 instructions are listed by functional group in this manual,
and the storage geometry of application programs is described

<p>
To see in full RTA architecture and instruction set specification,
refer to <a href="http://timmilescox.github.io/RTA/rta">
RTA Processor Programmable Architecture Specification</a>

<p>
Or online to your emulated machine <b>http://172.29.7.7:8080</b> and hit the architecture specification button <b>rta</b>

<p>
This manual discusses some topics beyond writing assembly language code for RTA1. Kernel calls to support
data segment loading are described, plus linking and code formatting utilities

<h2>Settings for RTA1</h2>

masmx is a target-independent meta-assembler. masmx default
settings are already the correct ones for RTA1 data formats.
For RTA1 registers and instructions
<pre>

	$include	freeware/RTA1/rta/def/rta.def

</pre>
or like this
<pre>

	$path		freeware/RTA1/rta	. if that's where you have it
	$include	def/rta.def
	$path					. back to your directory

</pre>

<p>
The masmx already has these default settings. They are correct for RTA1
<pre>

        $word                   24
        $address_quantum        24
        $awidth                 24:48
        $floating_point         96
        $characteristic         24
        $characteristic,48      12
        $byte                   8

</pre>


<b>$awidth</b> has two steps because the effective address is
24 bits but the executable space is much larger. masmx can construct
code and data in all the executable space using the giant address

<p>
masmx default byte size is 8 bits and data code is ASCII.
<b>$byte</b> and the data code can be changed during
an assembly

<p>
To change the data code see the main documentation of masmx

<p>
masmx syntax element defaults are also
correct for RTA1
<pre>

	$lterm			'.'	. comments follow PERIOD SPACE
	$sterm			':'	. substrings are lexical:divisions
	$cont_char		';'	. line continuation sentinel

</pre>



<h2>Data Constants</h2>
<h3>Expressions and Numbers</h3>

Operators by rank are

	<blockquote>
	()<br>
	=<br>
	^=<br>
	><br>
	<<br>
	--<br>
	++<br>
	/*<br>
	*/<br>
	*/-<br>
	**<br>
	*+ *-<br>
	+ -<br>
	* / // ///<br>
	&plusmn; ^unary<br>
	</blockquote>


Operators in the same rank have left-to-right precedence as they are
encountered in the expression

<p>
Operators of higher rank are evaluated first and operated last. An expression
generates an integer until a decimal exponent operator *+ *- is actioned

<p>
The operators are 
<pre>

	_________________________________________
	|	=	|	equal		|	= 1 ^= 0
	|_______________|_______________________|
	|	^=	|	unequal		|	^= 1 = 0
	|_______________|_______________________|
	|	>	|	greater		|	> 1 = 0 < 0
	|_______________|_______________________|
	|	<	|	less		|	< 1 = 0 > 0
	|_______________|_______________________|
	|	--	|	XOR		|
	|_______________|_______________________|
	|	++	|	OR		|
	|_______________|_______________________|
	|	/*	|	shift right	|
	|_______________|_______________________|
	|	*/	|	shift left	|
	|_______________|_______________________|
	|	*/-	| right	shift algebraic	|
	|_______________|_______________________|
	|	**	|	AND		|
	|_______________|_______________________|
	|	*+	|      +decimal exponent|
	|_______________|_______________________|
	|	*-	|      -decimal exponent|
	|_______________|_______________________|
	|	+	|	PLUS		|
	|_______________|_______________________|
	|	-	|	MINUS		|
	|_______________|_______________________|
	|	*	|	MULTIPLY	|
	|_______________|_______________________|
	|	/	|	DIVIDE		|
	|_______________|_______________________|
	|	//	|	covered quotient|
	|_______________|_______________________|
	|	///	|	remainder	|
	|_______________|_______________________|

</pre>
<p>
Number constants have the default masmx syntax. Leading 0 means hex

<p>
masmx.7r3 has two changes from masmx7r2 in number handling

<p><b>
It is no longer necessary to precede a number constant with a unary
sign. An unsigned number starting with a digit in the command field
is now recognised as a positive number constant
</b>

<pre>

$ masmx -ln
MASMX 7r3
0/-INPUT>>

	99
	1.5*+2
        $end
  :                            1 
00:000000 000063              +2  99
00:000001 400008960000000000000000
                              +3  1.5*+2
  :                            4  $end
:$(00):000000:000005 


</pre>

<p>
A unary symbol in the command field continues to mean a number
constant, but with a new difference

<p><b>
In masmx.7r3 a unary symbol appended to the front of the
constant expression only exerts polarity on the first token
</b>

<pre>

$ masmx -ln
MASMX 7r3
0/-INPUT>>
	-2-2
	^0f0f++3
	-5-10*-1 
	$end
00:000000 FFFFFC              +1  -2-2
00:000001 FFF0F3              +2  ^0f0f++3
00:000002 BFFFFE3FFFFFFFFFFFFFFFFF
                              +3  -5-10*-1 
  :                            4  $end
:$(00):000000:000006 

</pre>

<p>
Unary ^ is 1s complement

<p><b>
As with earlier masmx distribitions, a unary symbol
separated by whitespace from the number expression
exerts polarity on the resolved total expression
that follows
</b>

<pre>

$ masmx -ln
MASMX 7r3
0/-INPUT>>
	-	2-2
	-	50+50:d
	+	3072-1:t
	+	0ffffffcccccc++0ffffffEEEEEE*/48:q
        -       100000*/96:p

        +       1.75*+1200000
	$end
00:000000 000000              +1  - 2-2
00:000001 FFFFFFFFFF9C        +2  - 50+50:d
00:000003 000000000000000BFF  +3  + 3072-1:t
00:000006 FFFFFFEEEEEEFFFFFFCCCCCC
                              +4  + 0ffffffcccccc++0ffffffEEEEEE*/48:q
00:00000A FE7960000000000000000000000000
                              +5         -       100000*/96:p
  :                            6 
00:00000F 7CD38BB7B396D7AA20B6E083
                              +7         +       1.75*+1200000
  :                            8  $end
:$(00):000000:000013 


</pre>
<p>
Fixed point numbers are autosized. masmx adds an extra word of signs
where the high order bit of the magnitude is not a sign.
Specific size can be suffixed
<pre>

$ masmx -ln
MASMX 7r2
0/-INPUT>>
	+	255*/16
	+	255*/16:s
	$end
00:000000 000000FF0000        +1  + 255*/16
00:000002 FF0000              +2  + 255*/16:s
  :                            3  $end
:$(00):000000:000003 


</pre>
The size suffixes are :s (one word) :d (two words) :t (three words)
:q (four words) :p (five words) :h (six words) :o (eight words)

<p>
:d and :l are synonymous. The size suffix does not always need a colon
but it is never wrong to type the colon. The size suffix can equally be
upper or lower case, whether the assembly is case-sensitive or not

<p>
Symbols in single quotes produce the number values assigned in the
current data code juxtaposed according to current byte size. It's a
right justified string up to maximum number size, and may be operated
in expressions
<pre>

$ masmx -ln
MASMX 7r3
0/-INPUT>>
	+	'abcd'
	$data_code	97:65	. generate 'A' when the source has 'a'
	+	'abcd'++128	. logical OR bit 7 on
	$ascii			. switch back to plain ASCII
	$byte	12		. make the byte size a halfword
	+	'abcd'
	$end
00:000000 000061626364        +1  + 'abcd'
  :                            2  $data_code 97:65
00:000002 0000416263E4        +3  + 'abcd'++128
  :                            4  $ascii
  :                            5  $byte 12
00:000004 061062063064        +6  + 'abcd'
  :                            7  $end
:$(00):000000:000006 


</pre>

<p>
Tokens may be names either of fixed value with <b>$equ</b> or revisable number with <b>$set</b>
<pre>

$ masmx -ln
MASMX 7r3
0/-INPUT>>
mantissa	$equ	175
exponent	$do	3,	+mantissa*+exponent-3
		$end
  :                            1 mantissa $equ 175
00:000000 400001E00000000000000000
                              +2 exponent $do 3, +mantissa*+exponent-3
00:000004 4000058C0000000000000000
                              +2 
00:000008 400008AF0000000000000000
                              +2 
  :                            3   $end
:$(00):000000:00000C 

</pre>
<p>
A decimal point or the exponent operators <b>*+ *-</b> make a number
floating-point

<p>
Integers are twos-complement negative and floating numbers are 1s-complement negative
<pre>

	$ masmx -ln
MASMX 7r3
0/-INPUT>>
	-       6
	-	0.5
	$end
00:000000 FFFFFA              +1  - 6
00:000001 BFFFFF7FFFFFFFFFFFFFFFFF
                              +2  - 0.5
  :                            3  $end
:$(00):000000:000005 


</pre>
The floating mantissa is a simple fraction.
Its integral part is derived by hauling the mantissa
upwards through the fractional point the number of
positions by which the exponent exceeds the midpoint
value <b>0400000</b>
<pre>

	$ masmx -ln
MASMX 7r3
0/-INPUT>>
	+	1.5
	$end
00:000000 400001C00000000000000000
                              +1  + 1.5
  :                            2  $end
:$(00):000000:000004 


</pre>
Floating point numbers do not autosize.
They are four words
<pre>


		$ masmx -ln
MASMX 7r3
0/-INPUT>>
	+	1.75*+1250000
	+	1.75*-1250000
	$end
00:000000 7F5C5BF331AD4B6FFBBCAAB2
                              +1  + 1.75*+1250000
00:000004 00A3A7CE52225BC80EDFF592
                              +2  + 1.75*-1250000
  :                            3  $end
:$(00):000000:000008 


</pre>
<p>
The two-word suffix may be used to assemble a 48-bit
compressed floating constant which RTA1 can
expand to four words at the internal stack top with the
<b>floating push and expand</b> instruction <b>fpx</b>

<p>
RTA1 computes 96-bit floating-point but the <b>floating pop and pack</b>
instruction <b>fpp</b> can store the number in a 48-bit
floating format if that has enough range for its value
<pre>

	$ masmx -ln
MASMX 7r3
0/-INPUT>>

	$list		0
	$include	freeware/RTA1/rta/def/rta.def
	$list

$(0:64)

	fpx		(4.096:d*+200)		. this instruction loads the internal stack from storage
	fa		0, sp			. use the expanded number

	qs		0, sp
	fpp		compressed_storage	. compress the 4-word result
						. this instruction pops the internal stack to storage	
	$do		$<256,$(0:256)

$(3:03000)
compressed_storage $res	2
	$end
  :                            1 
  :                            429  $list
  :                            430 
  :                            431 $(0:64)
  :                            432 
00:000040 5F0100              +433  fpx  (4.096:d*+200)
00:000041 67F000              +434  fa  0, sp   . use the expanded number
  :                            435 
00:000042 47F000              +436  qs  0, sp
00:000043 573000              +437  fpp  compressed_storage . compress the 4-word result
  :                            438  
  :                            439  $do  $<256,$(0:256)
  :                            440 
  :                            441 $(3:03000)
  :                            442 compressed_storage $res 2
  :                            443  $end
00:000100+69BAB3C2FDDF
:$(00):000040:000102 :$(03):003000:003002 


</pre>

48-bit compressed floating format has only 11 exponent bits, so its range difference
from 96-bit compute-format is a larger difference that a difference in mantissa
precision
<pre>

	47 46        36 35                                      0
	__________________________________________________________
	|s|xxxxx xxxxxx|mmmmmm mmmmmm mmmmmm mmmmmm mmmmmm mmmmmm|
	|_|____________|_________________________________________|________________________________________________________
	|s|xxxxx xxxxxx xxxxxx xxxxxx|mmmmmm mmmmmm mmmmmm mmmmmm mmmmmm mmmmmm mmmmmm mmmmmm mmmmmm mmmmmm mmmmmm mmmmmm|
	|_|__________________________|___________________________________________________________________________________|
	95 94                      72 71                                                                                0

</pre>

<p>
RTA1 two- and four-word burst reads and writes are at any word address

<p>
It's foreseen that for network transfer native RTA1 96-bit and 48-bit numbers be
translated dynamically to and from XDR formats

<p>
However XDR and non-RTA1 machines can only represent a microscopic
part of RTA1 floating range. The exchange format for large numbers is
ASCII edit string




<h3>Literals</h3>

The last floating-point assembly example also shows an automatic literal.
The two-word floating operand of the <b>fpx</b> instruction is assembled
at address 256, beyond the addresses of the RTA1 registers

<p>
A literal is a constant declared as an operand and
assembled at the end of a designated section

<p>
Literals look like immediate operands but are storage
constants of any size. The instruction contains their
address, not their value

<p>
An automatic literal is an operand starting and ending
with parenthesis. Automatic literals are  enabled with
assembly flag -a in <b>rta.def</b>
<pre>

	$set_option	"a"
	
</pre>
By default automatic literals are assembled at the end
of program section $(0)

<p>
The <b>$lit</b> directive may place automatic literals 
at the end of another program section
<pre>

[tag]	$lit	55

</pre>
A literal which is not automatic  has a literal pool
tag before the opening parenthesis
<pre>

$ masmx -lnz
MASMX 7r2
0/-INPUT>>

        $list   0
        $include        freeware/RTA1/rta/def/rta.def
        $list

$(3:03000/$literals3)
$(0:64)

	lx, xi		$literals3("this way to the gastronomy hall")

	$end
  :                            1 
  :                            428         $list
  :                            429 
  :                            430 $(3:03000/$literals3)
  :                            431 $(0:64)
  :                            432 
00:000040 553000              +433  lx, xi  $literals3("this way to the gastronomy hall")
  :                            434 
  :                            435  $end
03:003000+746869732077617920746F207468652067617374726F6E6F
6D792068616C6C0000
:$(00):000040:000041 :$(03):003000:00300B 

</pre>

<h3>More about Strings</h3>

The last literal example was a string. Bytes are any size you
say they are, default 8-bits, padded with either zero or space to integral words
<pre>

$ masmx strings -ln
MASMX 7r2
3/strings.msm
*EOF*
  :                            1 	$set_option	"z"
00:000000 737472696E67        +2 	"string"
  :                            3 	$byte	12
00:000002 07307407206906E067  +4 	"string"
  :                            5 	$byte	16
00:000005 0073007400720069006E0067
                              +6 	"string"
  :                            7 	$byte	24
00:000009 00007300007400007200006900006E000067
                              +8 	"string"
  :                            9 	$byte	6
00:00000F CF4CA9BA7000        +10 	"string"
  :                            11 	$byte	7
Note: strings.msm Line 12: trailing zero bits in last data word of string
00:000011 E7D3969DD9C0        +12 	"string"
  :                            13 	$byte	8
00:000013 737472696E67        +14 	"string"
  :                            15 
*EOF*
:$(00):000000:000015 

</pre>
String padding is zero with option <b>-c</b> or <b>-z</b> and space
with neither or both <b>-cz</b>

<p>
In <b>masmx.7r3</b> the masmx-internal label <b>$bits</b> contains
the number of bits containing the characters in the string after the
string is assembled. This does not include word-fill padding<pre>

$ masmx -lnz
MASMX 7r3
0/-INPUT>>
	"abcd"
	+	$bits
	+	$bits/$byte
	$end
00:000000 616263640000        +1  "abcd"
00:000002 000020              +2  + $bits
00:000003 000004              +3  + $bits/$byte
  :                            4  $end
:$(00):000000:000004 

</pre>

<h3>$form Bit-Field Structures</h3>

Directive <b>$form</b> types bit-field structures up to eight words long.
The structures are an integral number of words in size
<pre>

long_virtual_address	$form			1, 1, 16, 6, 6, 18

			long_virtual_address	0, 1, BANK_32768, DEVICE_2, BASE_WINDOW_44, 03000A

</pre>

<h3>Equal-Size Bit Fields</h3>

A number constant divided by commas means the containing word or words is of equal sized fields. The total size is one word regardless of value truncation, unless an override suffix is typed
<pre>

		$ masmx -ln
MASMX 7r3
0/-INPUT>>

RED48		$equ		48
GREEN72		$equ		72
BLUE240		$equ		240

	+	RED48, GREEN72, BLUE240
	+	0FFFC, 08003, 07001:d    

	+	15, 14, 12, 0, 5, 10
	+	7, 4, 3, 6,  6, 3, 2, 5
	$end
  :                            1 
  :                            2 RED48		$equ		48
  :                            3 GREEN72	$equ		72
  :                            4 BLUE240	$equ		240
  :                            5 
00:000000 3048F0              +6 	+	RED48, GREEN72, BLUE240
00:000001 FFFC80037001        +7 	+	0FFFC, 08003, 07001:d    
  :                            8 
00:000003 FEC05A              +9 	+	15, 14, 12, 0, 5, 10
00:000004 F1ECD5              +10 	+	7, 4, 3, 6,  6, 3, 2, 5
  :                            11 	$end
:$(00):000000:000005 


</pre>
<h2>Instructions and Operands</h2>

Instructions are listed in code order in the RTA1 programmable architecture
specification

<h3>Programmable Register Model</h3>
Application and interrupt space each have scalar registers and a register array called the internal stack

<p>
The size of each internal stack is 104 words intended for stringently realtime programming methods. For
programming techniques which require extensive stacks, macro libraries are supplied to reuse internal
stack space in a renewable way
<pre>

			The Application Registers						  The Interrupt Registers
			_________________________						  _______________________


		 23			       0					 23			       0
		_________________________________					_________________________________
	0	|		r		|	repeat counter	 	128	|		r_x		|
		|_______________________________|					|_______________________________|
	1	|		k		|	mask register		129	|		k_x		|
		|_______________________________|					|_______________________________|
	2	|		x		|	index register		130	|		x_x		|
		|_______________________________|					|_______________________________|
	3	|		y		|	index register		131	|		y_x		|
		|_______________________________|					|_______________________________|
	4	|		a		|  arithmetic + index register	132	|		a_x		|
		|_______________________________|					|_______________________________|
	5	|		b		|  arithmetic + index register	133	|		b_x		|
		|_______________________________|					|_______________________________|
	6	|	mantissa2		|	arithmetic register	134	|	mantissa2_x		|
		|_______________________________|					|_______________________________|
	7	|	mantissa3		|	arithmetic register	135	|	mantissa3_x		|
		|_______________________________|					|_______________________________|
	8	|		aA		|	arithmetic register	136	|		aA_x		|
		|_______________________________|					|_______________________________|
	9	|		bA		|	arithmetic register	137	|		bA_x		|
		|_______________________________|					|_______________________________|
	10	|	mantissa2A		|	arithmetic register	138	|	mantissa2A_x		|
		|_______________________________|					|_______________________________|
	11	|	mantissa3A		|	arithmetic register	139	|	mantissa3A_x		|
		|_______________________________|					|_______________________________|
	12	|	    	 p		|	bitstream pointer write	140	|		p_x		|
		|_______________________________|					|_______________________________|
	13	|	   	 q		|	bitstream pointer read	141	|		q_x		|
		|_______________________________|					|_______________________________|
	14	|	  	 fp		|	index register		142	|		fp_x		|
		|_______________________________|					|_______________________________|
	15	|	  	 sp		|	index register		143	|		sp_x		|
		|_______________________________|					|_______________________________|
	16	|				|	scratch			144	|	REALTIME$_CLOCK		|
		|_______________________________|					|_______________________________|
	17	|				|	scratch			145	|	PRIORITY$		|
		|_______________________________|					|_______________________________|
	18	|				|	scratch			146	|	DAYCLOCK$U		|
		|_______________________________|					|_______________________________|
	19	|				|	scratch			147	|	DAYCLOCK$		|
		|_______________________________|					|_______________________________|
	20	|	   RDATAC		|	bitstream counter read	148	|	X_RDATAC		|
		|_______________________________|					|_______________________________|
	21	|	    RDATA		|	bitstream data read	149	|	 X_RDATA		|
		|_______________________________|					|_______________________________|
	22	|	   WDATAC		|	bitstream counter write	150	|	X_WDATAC		|
		|_______________________________|					|_______________________________|
	23	|	    WDATA		|	bitstream data write	151	|	 X_WDATA		|
		|_______________________________|					|_______________________________|
	24	| maximum internal stack top	|				152	|				|
		|_______________________________|					|_______________________________|
	25	|				|				153	|				|
		|_______________________________|					|_______________________________|
	26	|				|				154	|				|
		|_______________________________|					|_______________________________|
	27	|				|				155	|				|




		|_______________________________|					|_______________________________|
	124	|				|				252	|				|
		|_______________________________|					|_______________________________|
	125	|				|				253	|				|
		|_______________________________|					|_______________________________|
	126	|				|				254	|				|
		|_______________________________|					|_______________________________|
	127	|				|	first pushed word	255	|				|
		|_______________________________|					|_______________________________|


</pre>
<p>
Instructions may imply scalar registers or the internal stack as left-side operand, and
have an address for a second input


<h3>Register / Memory Operand Continuum</h3>
<p>
The right-side operand may be in storage or a register. Some
instructions take an immediate operand

<p>
The registers are in the memory address space
 
<p>
Instructions have an operand type indicator jjj, an instruction code ffff and a 16-bit address field.
Six jjj values are different operand types for 32 single-integer instructions and two jjj values select
two other sets of instructions

<p>
If the jjj field is 5, the operand is 16-bit sign extended immediate
<pre>


				  23      18    15                            0
				_________________________________________________
				| fffff | 101 | &plusmn;16-bit sign extended immediate	|
				|_______|_jjj_|_________________________________|


				ax, xi		-20000
				push		600,,xi


</pre>
Otherwise, if bit 15 is zero, the operand address is a direct address 15 bits in size
<pre>

				  23      18    15  14                        0
				_________________________________________________
				| fffff | jjj | 0 | 15-bit direct address----->	|
				|_______|_____|___|_____________________________|



		$(3:03000)
		instance	$do	20000,keyvalue(instance)	+	KEYVALUE*instance**07FFFFF

		$(0)
				dl	keyvalue(19999)
				xor	keyvalue(19997)
				xorB	keyvalue(19998)



</pre>
If instruction bit 15 is one, the instruction has a 3 bit indirection-bank/index-register selector
and a 12-bit displacement field
<pre>

				  23      18    15  14    11                  0
				_________________________________________________
				| fffff | jjj | 1 | xxx | 12-bit displacement->	|
				|_______|_____|___|_____|_______________________|


</pre>
If xxx is zero or one, the address is indirect. Its pointer is in the first 8192 words
in the address space. These are
<blockquote>

	the 256 registers<br>
	words 256..4095 of the current instruction bank B0<br><br>

	the 4096 words of the current private stack bank B1 (or the TCB if PSR flag see$1 is on)

</blockquote>
<pre>
		$(1:01000)
		redirection	$res	1
				
		$(0)
				lr	*redirection
				ql	*(ADDRESS_7_MEGAWORD)	. big indirect address
								. in 24-bit literal constant
				tp	*11

</pre>

If xxx is 2..7 then index register [x y a b fp sp] is added to to the unsigned
12-bit displacement to form the effective address
<pre>

		  23                                          0			  23                                          0
		_________________________________________________		_________________________________________________
		|		effective address		|<----- + ------|		[ x y a b fp sp ]		|
		|_______________________________________________|		|_______________________________________________|
				 	^			^
					|			|
					|	    +		|
					|			|
		  23      18    15  14    11                  0
		_________________________________________________
		| fffff | jjj | 1 | xxx | 12-bit displacement->	|
		|_______|_____|___|_____|_______________________|



				la	64, b, i
				ly	descriptor:dgram, fp




</pre>

<h3>Single Integer Instructions</h3>
32 instructions carry out load / store / arithmetic / boolean operations on a single
integer. These 32 instructions have as their right-side operand another register, a storage word,
part of a storage word (half or third), the effective address as an immediate value, or a
sign-extended immediate value in the range -32768..+32767

<p>
Integer instructions access a word and either third-words or halfwords.
jjj = zero = operand is the storage word at ea
<pre>


				z	buffer+4
				pop	buffer+5[,,w0]	. w0 is the default
							. and need not be typed


</pre>
<p>
PSR designator <b>half$w</b> is zero if the program accesses third-words
and one if the program accesses halfwords. Bytes are sign-extended to 24
bits on read and unused fields are unchanged on byte write. Bytes are not
read from registers or written to registers. A register is a 24-bit integer,
including the internal stack register array 
<pre>

		half$w = 0							half$w = 1
		__________							__________

		  23                                          0
		_________________________________________________
   jjj = 001	|	t1	|////unused/////|////unused/////|
		|_______________|____unchanged__|____unchanged__|


				xorB, t1	indicators



		  23                                          0			  23                                          0
		_________________________________________________		_________________________________________________
   jjj = 010	|////unused/////|	t2	|////unused/////|		|	    h1		|///unused//unchanged///|
		|____unchanged__|_______________|____unchanged__|		|_______________________|_______________________|


				ana		*margin,,t2					xor		crypto,b,h1




		  23                                          0			  23                                          0
		_________________________________________________		_________________________________________________
   jjj = 011	|////unused/////|////unused/////|	t3	|		|///unused//unchanged///|	    h2		|
		|____unchanged__|____unchanged__|_______________|		|_______________________|_______________________|

				
				mf		table, x, t3					ay, h2		interval



</pre>
jjj = 100 = the operand is the effective address used as an immediate
<pre>

				lb, i		4, a
				lr		2,b,i			

</pre>
jjj = 101 = the immediate operand is the 16 bits of the address fields
sign extended to 24 bits
<pre>


				ax, xi		-8


</pre>
The $equf directive can represent all the subfield attributes of an operand with one name
<pre>

		header_byte	$equf		directory, y, t1
		HARD_LINK	$equf		'H',,xi

				la		header_byte
				aa, xi		-HARD_LINK	. compare
</pre>

<h3>Single Integer Store Instructions</h3>

The store and the test integer instructions do not take immediate operands.
The ,,i and ,,xi options of instructions sr sk sx sy sa sb z pop tz tp
are assigned to I/O and control instructions which take only an immediate
operand

The integer store instructions do not update <b>carry$</b>

<pre>

	_________________________________________________________________________________________________________
	|	mnemonic|   fffff.jjj	|			|		jjj				|	
	|_______________|_______________|_______________________|_______________________________________________|
	|	sr	|   00000.0jj	|  store repeat counter	| [w0] ++ [t1 t2 t3] -- [h1 h2]			|
	|_______________|_______________|_______________________|_______________________________________________|
	|	sk	|   00001.0jj	|  store mask register	| [w0] ++ [t1 t2 t3] -- [h1 h2]			|
	|_______________|_______________|_______________________|_______________________________________________|
	|	sx	|   00010.0jj	|  store x		| [w0] ++ [t1 t2 t3] -- [h1 h2]			|
	|_______________|_______________|_______________________|_______________________________________________|
	|	sy	|   00011.0jj	|  store y		| [w0] ++ [t1 t2 t3] -- [h1 h2]			|
	|_______________|_______________|_______________________|_______________________________________________|
	|	sa	|   00100.0jj	|  store a		| [w0] ++ [t1 t2 t3] -- [h1 h2]			|
	|_______________|_______________|_______________________|_______________________________________________|
	|	sb	|   00101.0jj	|  store b		| [w0] ++ [t1 t2 t3] -- [h1 h2]			|
	|_______________|_______________|_______________________|_______________________________________________|
	|	z	|   00110.0jj	|  zero			| [w0] ++ [t1 t2 t3] -- [h1 h2]			|
	|_______________|_______________|_______________________|_______________________________________________|
	|	pop	|   00111.0jj	|  pop internal stack	| [w0] ++ [t1 t2 t3] -- [h1 h2]			|
	|_______________|_______________|_______________________|_______________________________________________|


</pre>

<h3>Single Integer Load Instructions</h3>

The integer load instructions do not update <b>carry$</b>

<pre>



        _________________________________________________________________________________________________________
        |       mnemonic|   fffff.jjj   |                       |               jjj                             |
	|_______________|_______________|_______________________|_______________________________________________|
	|	lr	|   01000.jjj	|  load repeat counter	| [w0] ++ [t1 t2 t3] -- [h1 h2]	++ [i xi]	|
	|_______________|_______________|_______________________|_______________________________________________|
	|	lk	|   01001.jjj	|  load mask register	| [w0] ++ [t1 t2 t3] -- [h1 h2]	++ [i xi]	|
	|_______________|_______________|_______________________|_______________________________________________|
	|	lx	|   01010.jjj	|  load x		| [w0] ++ [t1 t2 t3] -- [h1 h2]	++ [i xi]	|
	|_______________|_______________|_______________________|_______________________________________________|
	|	ly	|   01011.jjj	|  load y		| [w0] ++ [t1 t2 t3] -- [h1 h2]	++ [i xi]	|
	|_______________|_______________|_______________________|_______________________________________________|
	|	la	|   01100.jjj	|  load a		| [w0] ++ [t1 t2 t3] -- [h1 h2]	++ [i xi]	|
	|_______________|_______________|_______________________|_______________________________________________|
	|	lb	|   01101.jjj	|  load b		| [w0] ++ [t1 t2 t3] -- [h1 h2]	++ [i xi]	|
	|_______________|_______________|_______________________|_______________________________________________|
	|	push	|   11111.jjj	|  push internal stack	| [w0] ++ [t1 t2 t3] -- [h1 h2]	++ [i xi]	|
	|_______________|_______________|_______________________|_______________________________________________|


</pre>
push decrements the internal stack pointer and loads one register in the internal
stack with the operand value. If application sp is outside the range 25..128
before the operation the guard interrupt intervenes


<h3>Test Instructions</h3>

The integer test instructions do not update <b>carry$</b>

<p>
The operand is tested for zero or for bit 23=0. If so, the next instruction is skipped. Storage half-and
third-words are sign-extended

<pre>

        _________________________________________________________________________________________________________
        |       mnemonic|   fffff.jjj   |                       |               jjj                             |
        |_______________|_______________|_______________________|_______________________________________________|
	|	tz	|   01110.0jj	|  test zero skip	| [w0] ++ [t1 t2 t3] -- [h1 h2]			|
	|_______________|_______________|_______________________|_______________________________________________|
	|	tp	|   01111.0jj	|  test positive skip	| [w0] ++ [t1 t2 t3] -- [h1 h2]			|
	|_______________|_______________|_______________________|_______________________________________________|



</pre>

<h3>Index Register Add  Instructions</h3>

The index register add instructions do not update <b>carry$</b>

<pre>


        _________________________________________________________________________________________________________
        |       mnemonic|   fffff.jjj   |                       |               jjj                             |
        |_______________|_______________|_______________________|_______________________________________________|
        |       ax      |   10000.jjj   |  x += operand		| [w0] ++ [t1 t2 t3] -- [h1 h2] ++ [i xi]       |
        |_______________|_______________|_______________________|_______________________________________________|
        |       ay      |   10001.jjj   |  y += operand		| [w0] ++ [t1 t2 t3] -- [h1 h2] ++ [i xi]       |
        |_______________|_______________|_______________________|_______________________________________________|


</pre>

<h3>Boolean Algebra Instructions</h3>

The boolean algebra instructions do not update <b>carry$</b>

<pre>


        _________________________________________________________________________________________________________
        |       mnemonic|   fffff.jjj   |                       |               jjj                             |
        |_______________|_______________|_______________________|_______________________________________________|
        |       or      |   10010.jjj   |  a OR operand ->a	| [w0] ++ [t1 t2 t3] -- [h1 h2] ++ [i xi]       |
        |_______________|_______________|_______________________|_______________________________________________|
        |       orB     |   10011.jjj   |  b OR operand ->b     | [w0] ++ [t1 t2 t3] -- [h1 h2] ++ [i xi]       |
        |_______________|_______________|_______________________|_______________________________________________|
        |       and     |   10100.jjj   |  a AND operand ->a	| [w0] ++ [t1 t2 t3] -- [h1 h2] ++ [i xi]       |
        |_______________|_______________|_______________________|_______________________________________________|
        |       andB    |   10101.jjj   |  a AND operand ->b	| [w0] ++ [t1 t2 t3] -- [h1 h2] ++ [i xi]       |
        |_______________|_______________|_______________________|_______________________________________________|
        |       xor     |   10110.jjj   |  a XOR operand ->a	| [w0] ++ [t1 t2 t3] -- [h1 h2] ++ [i xi]       |
        |_______________|_______________|_______________________|_______________________________________________|
        |       xorB    |   10111.jjj   |  b XOR operand ->b	| [w0] ++ [t1 t2 t3] -- [h1 h2] ++ [i xi]       |
        |_______________|_______________|_______________________|_______________________________________________|


</pre>

<h3>Single Integer Add Instructions</h3>

<p>
The single integer add instructions add the operand or its 2s complement
to arithmetic register a or b

<p>
carry from bit 23 of the addition is stored in <b>carry$</b>.
Carry is not inverted after negative adds. They write carry as the positive add
of the 2s complement would write carry

<pre>

        _________________________________________________________________________________________________________
        |       mnemonic|   fffff.jjj   |                       |               jjj                             |
        |_______________|_______________|_______________________|_______________________________________________|
        |       aa      |   11000.jjj   |  a += operand		| [w0] ++ [t1 t2 t3] -- [h1 h2] ++ [i xi]       |
        |_______________|_______________|_______________________|_______________________________________________|
        |       ab      |   11001.jjj   |  b += operand		| [w0] ++ [t1 t2 t3] -- [h1 h2] ++ [i xi]       |
        |_______________|_______________|_______________________|_______________________________________________|
        |       ana     |   11010.jjj   |  a += 2s complement   | [w0] ++ [t1 t2 t3] -- [h1 h2] ++ [i xi]       |
        |_______________|_______________|_______________________|_______________________________________________|
        |       anb     |   11011.jjj   |  b += 2s complement   | [w0] ++ [t1 t2 t3] -- [h1 h2] ++ [i xi]       |
        |_______________|_______________|_______________________|_______________________________________________|


</pre>

<h3>Multiply</h3>

The integer multiply instruction multiplies arithmetic register b algebraically 
by the operand and stores the 48-bit product in arithmetic registers a:b
<p>

<b>carry$</b> is not updated

<pre>


        _________________________________________________________________________________________________________
        |       m	|   11100.jjj   |  a:b = b * operand	| [w0] ++ [t1 t2 t3] -- [h1 h2] ++ [i xi]       |
        |_______________|_______________|_______________________|_______________________________________________|


</pre>

<h3>Multiply Fractional</h3>

Multiply Fractional instruction multiplies arithmetic register b by the
operand and stores the 48-bit product in arithmetic registers a:b

<p>
The multiplier is treated as signed and the multiplicand is treated
as unsigned

<p>
Multiply Fractional is used to render binary fractions integrally
for editing and conversion, and may also be used serially to multiply
integer multiplicands more than one word in length

<p>
<b>carry$</b> is not updated

<pre>


        _________________________________________________________________________________________________________
        |       mf	|   11101.jjj   |  a:b = b * operand	| [w0] ++ [t1 t2 t3] -- [h1 h2] ++ [i xi]       |
        |_______________|_______________|_______________________|_______________________________________________|


</pre>

<h3>Divide</h3>

The integer divide instruction algebraically divides the 48-bit
dividend in arithmetic registers a:b by the 24-bit divisor. The
remainder is stored in b. The low order 24 bits of the quotient
are stored in a. The high-order 24 bits of the quotient are
stored in register 6 mantissa2

<p>
<b>carry$</b> is not updated

<pre>


        _________________________________________________________________________________________________________
        |       d	|   11110.jjj   |   6:a = a:b / operand	| [w0] ++ [t1 t2 t3] -- [h1 h2] ++ [i xi]       |
        |_______________|_______________|__ b_=_a:b_///_operand_|_______________________________________________|




		  47                                              23                                          0
		_________________________________________________________________________________________________
		|	arithmetic register a = dividend 47..24	|	arithmetic register b = dividend 23..0	|
	before	|_______________________________________________|_______________________________________________|
	______



		  23                                   0   23                                   0   47                                   24
		____________________________________________________________________________________________________________________________	
		| arithmetic register a = quotient 23..0 | arithmetic register b = remainder 23..0| arithmetic register 6 = quotient 47..24|
	after	|________________________________________|________________________________________|________________________________________|
	____


</pre>



<h3>Large Load and Store Instructions</h3>
<pre>

        _________________________________________________________________________________________________________
        |       mnemonic|   fffff.jjj   |                       |               action                          |
        |_______________|_______________|_______________________|_______________________________________________|
        |       ds      |   11000.111   |  double store		| a:b -> 2 words @ ea				|
        |_______________|_______________|_______________________|_______________________________________________|
        |       dl      |   11001.111   |  double load		| 2 words @ ea -> a:b				|
        |_______________|_______________|_______________________|_______________________________________________|
        |       dpush   |   01011.111   |  double push		| sp -= 2, 2 words @ ea added to internal stack	|
        |_______________|_______________|_______________________|_______________________________________________|
        |       qs      |   01000.111   |  quadruple store      | a:b:mantissa2:mantissa3 -> 4 words @ ea	|
        |_______________|_______________|_______________________|_______________________________________________|
        |       ql      |   01001.111   |  quadruple load	| 4 words @ ea -> a:b:mantissa2:mantissa3       |
        |_______________|_______________|_______________________|_______________________________________________|
        |       qpop	|   10000.111   |  quadruple pop	| 4 words @ internal stack top -> 4 words @ ea  |
        |_______________|_______________|_______________________|_______________________________________sp_+=_4_|
        |       qpush   |   10001.111   |  quadruple push	| sp -= 4, 4 words @ ea added to internal stack |
        |_______________|_______________|_______________________|_______________________________________________|


</pre>

<h3>Large Integer Arithmetic Instructions</h3>

<pre>

        _________________________________________________________________________________________________________
        |       mnemonic|   fffff.jjj   |                       |               action                          |
        |_______________|_______________|_______________________|_______________________________________________|
        |       da      |   11010.111   |  double add		| a:b += 2 words @ ea, carry from MS bit of add	|       
        |_______________|_______________|_______________________|_______________________________________________|
        |       dan	|   11011.111   |  double add negative	| a:b += 2s complement of 2 words @ ea, 	|
        |_______________|_______________|_______________________|______________________carry_from_MS_bit_of_add_|
        |       sc      |   10110.111   |  store carry          | PSR AND 1 -> word @ ea			|
        |_______________|_______________|_______________________|_______________________________________________|
        |       mlb	|   10111.111   |  masked load b	| b AND NOT k OR word @ ea AND k -> b		|
        |_______________|_______________|_______________________|_______________________________________________|
        |       mta     |   10101.111   |  masked test equal	| skip if a AND k = word @ ea AND k		|
        |_______________|_______________|_______________________|_______________________________________________|
        |       lsc     |   10100.111   |  load shift & count	| 1 word @ ea -> a, rotate left [sign bits]	|
        |_______________|_______________|_______________________|_______________________________count in b______|
        |       dlsc    |   11100.111   |double load shift&count| 2 words @ ea -> a:b, rotate left [sign bits]	|
        |_______________|_______________|_______________________|__________________________count_in_mantissa2___|
        |       ex	|   10010.111   |  execute		| execute the instruction @ ea			|
        |_______________|_______________|_______________________|_______________________________________________|


</pre>


<h3>Floating Arithmetic Instructions</h3>

Floating arithmetic instructions do not update <b>carry$</b>

<p>
Floating numbers used in the four arithmetic function instructions have the 96-bit format
<pre>



	|sign
	| |mid-pointed exponent       
        |s|m|			      fractional mantissa
        __________________________________________________________________________________________________________________
        |s|xxxxx xxxxxx xxxxxx xxxxxx|mmmmmm mmmmmm mmmmmm mmmmmm mmmmmm mmmmmm mmmmmm mmmmmm mmmmmm mmmmmm mmmmmm mmmmmm|
        |_|__________________________|___________________________________________________________________________________|
        95 94                      72 71                                                                                0


</pre>
Sign = 1 indicates that the whole number is inverted in 1s complement. It is not an indication of negative polarity
zoned on a positively expressed magnitude 

<p>
Floating Add Negative instruction <b>fan</b> is the addition of the 1s complement

<p>
The mantissa is a simple fraction without any integral field either represented or unrepresented. The integral value
is derived by hauling the mantissa leftward through the binary point the number of positions by which the exponent
exceeds its midpoint value of <b>0400000</b>

<p>
Exponent <b>0400000</b> indicates that the normalised magnitude is &ge;0.5 and &lt;1.0

<p>
The lowest or most microscopic exponent is <b>000000</b> The highest or most atronomic exponent is <b>07FFFFF</b>

<p>
A number is normalised if the normalising bit in position 71 is of opposite polarity to the sign

<p>
Positive and negative zero are the cases of the number range with normalising bit the same value as the sign.
All unnormalised numbers are computed as zero

<pre>

        _________________________________________________________________________________________________________
        |       mnemonic|   fffff.jjj   |                       |               action                          |
        |_______________|_______________|_______________________|_______________________________________________|
        |       fpp     |   01010.111   |  floating pop & pack	| 4 word fp number @ sp -> 2 word fp number @ ea|       
        |_______________|_______________|_______________________|_______________________________internal_sp_+= 4|
        |       fpx     |   01011.111   | floating push & expand| internal sp -= 4, 2 words @ ea -> 4 words @ sp|
        |_______________|_______________|_______________________|_______________________________________________|
        |       fa      |   01100.111   |  floating add		| a:b:mantissa2:mantissa3 += 4 words @ ea	|
        |_______________|_______________|_______________________|_______________________________________________|
        |       fan     |   01101.111   |  floating add negative| a:b:mantissa2:mantissa3 += 4 words @ ea XOR 1s|
        |_______________|_______________|_______________________|_______________________________________________|
        |       fm	|   01110.111   |  floating multiply	| a:b:mantissa2:mantissa3 *= 4 words @ ea	|
        |_______________|_______________|_______________________|_______________________________________________|
        |       fd	|   01111.111   |  floating divide	| a:b:mantissa2:mantissa3 /= 4 words @ ea	|
        |_______________|_______________|_______________________|_______________________________________________|


</pre>

<p>
Floating Pop and Pack instruction <b>fpp</b> can compress numbers not requiring
mantissa precision larger than 36 bits or exponentiation outside the equivalent
of around &plusmn;305 decimal places from 96 bits at the internal stack top to
this 48-bit storage format

<pre>

        47 46        36 35                                      0
        __________________________________________________________
        |s|xxxxx xxxxxx|mmmmmm mmmmmm mmmmmm mmmmmm mmmmmm mmmmmm|
        |_|____________|_________________________________________|

</pre>
Floating Push and Expand instruction <b>fpx</b> expands compressed floating numbers to 96-bit compute format
at the internal stack top


<h3>Storage Modify Instructions</h3>

Test and Set is only executed with any purpose on a storage location for inter-processor arbitration

<p>
The other seven modify instructions can be executed on a register or on storage. Execution on storage
causes a memory read followed by memory write. Execution on a register is at register-access speed
 
<pre>

        _________________________________________________________________________________________________________
        |       mnemonic|   fffff.jjj   |                       |               action                          |
        |_______________|_______________|_______________________|_______________________________________________|
        |       ts      |   00000.111   |  test and set		| set bit 23 of word @ ea, skip if b23 was zero	|
        |_______________|_______________|_______________________|_______________________________________________|
        |       n	|   00001.111   |  negate		| word @ ea XOR= all 1s				|
        |_______________|_______________|_______________________|_______________________________________________|
        |       inc	|   00010.111   |  increment		| word @ ea += 0000 0000 0000 0000 0000 0001	|
        |_______________|_______________|_______________________|______________________carry$_is_not_updated____|
        |       dec	|   00011.111   |  decrement		| word @ ea += 1111 1111 1111 1111 1111 1111	|
        |_______________|_______________|_______________________|______________________carry$_is_not_updated____|
        |       sim	|   00100.111   |  switch interrupt mask| switch interrupt mask with word @ea, b23:3 = 0|
        |_______________|_______________|_______________________|_______________________________________________|
        |       popA    |   00101.111   |  pop and add to store	| word @ ea += word at internal stack top, sp++	|
        |_______________|_______________|_______________________|_____________________________carry$_is_updated_|
        |       src	|   00110.111   |shift right thru carry	| R.rotate word @ ea in 25-bit ring with carry	|
        |_______________|_______________|_______________________|_______________________________________________|
        |       slc	|   00111.111	| shift left thru carry	| L.rotate word @ ea in 25-bit ring with carry	|
        |_______________|_______________|_______________________|_______________________________________________|


	Assembly Language Examples
	__________________________


		push, xi	MAXIMUM_INTERRUPT_MASK	. internal stack = register location<div style="color:FF0000">
		sim		0, sp
		ts		lock_word		. this has to be in memory</div>
		j		$-1			. try again

		.
		.

		z		lock_word		. free the resource<div style="color:FF0000">
		sim		0, sp			. restore the interrupt mask
		inc		sp			. restore the internal stack</div>

</pre>


<h3>Shift Instructions</h3>

<h3>Bit Stream Instructions</h3>

<h3>Jump Instructions</h3>

<h3>Control and I/O Instructions</h3>


<h2>Application Memory, Location Counters and Dynamic Data Segment Load</h2>

<h3>Location Counters</h3>

Location counters correspond to program sections. masmx has 72 location counters.
Their RTA1 usage convention with smaragd7 kernel is
<pre>


	_________________________________________________________________________________________________________________
        |       location counter|       address window			|		purpose / address range		|
        |_______________________|_______________________________________|_______________________________________________|
        |       $(0)            |       instruction bank B0             |[ispace]000000..007FFF/[dspace]000100..000FFF	|
        |_______________________|_______________________________________|_______________________________________________|
        |       $(1:01000)	|       private stack bank B1		|	     data memory space 001000..001FFF	|
        |_______________________|_______________________________________|_______________________________________________|
        |       $(2)            |       vector bank B2			|	     data memory space 002000..002FFF	|	    
        |_______________________|_______________________________________|_______________________________________________|
        |       $(3:03000)	|       data windows  B3..B31		|	application data space 003000..01FFFF	|
        |_______________________|_______________________________________|___________________________or 0C0000..7FFFFF___|
        |			|       data windows B32..B47		|	application context kernel interface	|
        |_______________________|_______________________________________|_______________________________________________|
        |			|       data windows B48..B63           |		kernel				|
        |_______________________|_______________________________________|_______________________________________________|
        |       $(66::,x)	|       pointer in index register x	|
        |_______________________|_______________________________________|
        |       $(67::,y)	|       pointer in index register y	|
        |_______________________|_______________________________________|
        |       $(68::,a)	|       pointer in arithmetic register a|
        |_______________________|_______________________________________|
        |       $(69::,b)	|       pointer in arithmetic register b|
        |_______________________|_______________________________________|
        |       $(70::,fp)	|       frame at external stack pointer |
        |_______________________|_______________________________________|
        |       $(71::,sp)      |       frame at internal stack pointer |
        |_______________________|_______________________________________|


</pre>
$(0) contains instruction code in bank B0 and a few constants which are locally visible only

<p>
Simplest assemblies have one B0 bank starting at program-visible address zero
<pre>

$(0)
name1	$vector	entry1
name2	$vector entry2
	$do	8-$,	fret	0	. unused vectors

entry1
	.
	.

</pre>
<p>
In a ROM system image, absolute address zero is not available for an application. B0 load address is preassigned at image construction
<pre>

$(0::B0_LOAD_ADDRESS)


</pre>
<p>
If the application contains several instruction banks, $(0) declares all of them at
different load addresses. Their program-visible addresses are all based at address zero
<pre>


$(0::0)

$(0::16384)

$(0::24576)


</pre>
This is called breakpointing. Each new load address makes a new B0.
Each new bank has its own literal table. In a ROM application, the
breakpoint addresses are the absolute load addresses. In a loadable
application, the breakpoint addresses are relative to the RAM region
where the code is loaded

<p>
All locators can be breakpointed for multiple instances, but some
have special uses where breakpointing would not be useful 

<p>
$(1) contains private data in bank B1 starting at program-visible address 4096
<pre>

$(1:01000)

</pre>
smaragd7 kernel assigns at least one 4096 B1 bank at thread start, but does not place
any values in it. The application may assemble B1 at a read-only load-address in the
ROM system image, and copy the initial values on startup.

<p>
$(2) contains the vector bank. smaragd7 constructs the 4096-word vector-bank on
process launch at program-visible address 8192 = 02000 hex, based as bank B2

<p>
$(2) is declared by including vector.def. It is common to the whole process and
contains elements which are shared between all threads. These include all handle
descriptors and pointers to all initial banks and entry points of this process.

<p>
$(3) is assigned by the kernel to contain the program data in address windows
B3..B31

<p>
However at process start B3 is not based and the program's RAM initial data is not loaded

<p>
A typical ROM application memory configuration is
<pre>

	$include	def/rta.def
	$include	def/vector.def		. this defines the vector bank
						. in address window 02000

$(0::INSTRUCTIONS_LOAD_ADDRESS)
$(1:01000)					. private RAM
	+	variables
$(3:03000)					. application RAM
	+	data

$(0)
callname* $vector get_going
	$do	64-$,	fret	0

get_going
	$base_d	MY_APPLICATION_DATA_SIZE	. this macro reads VECTOR_D
						. from the vector bank,
						. bases enough windows to hold
						. the application data in B3..B31
						. points external stack pointer fp
						. to the high end of that

	c	(seg$load)	CORE_FS,,xi	;	. this call copies initialised
				(my_data_segments:d),,long  . variables to process RAM space

	.
	.

	fret	0



</pre>


<p>
Process RAM bank addresses are not known until the kernel stores their pointer
in the vector bank. Programs which are loaded during system run instead of
ROM-image-fixed also know their own B0 addresses from the
vector bank, which is necessary for multi-banked programs

<h3>seg$load Realtime RAM Initialisation</h3>
<p>
smaragd7 kernel can unpack program RAM initial values from
ROM-resident (or RAM-resident) file systems which are linked
into the application image or the total system image

<p>
A sequence of link operations and file system image operations
separate the program writeable parts into a dynamic load segment

<p>
Core file-system image construction exports a link label for each
dynamic load segment. An application instance references this
label to request initialization of its writeable data part
<pre>

	$base_d MY_APPLICATION_DATA_SIZE	. base the memory space

	c	(seg$load)	BANK_INDEX_OF_CORE_FS_START,,xi	;
				(my_ram_loadup_filename:d),,long	

</pre>
There is no directory search in the core file system. The link
label of the file has effectively completed a file open at
assembly time. <b>seg$load</b> starts unpacking load strings in
realtime. All the target windows must be based

<p>
File system images may be in core in case no other file systems are present.
A discussion of simpler techniques for copying assembly-time variable values to
program RAM follows, but the <b>seg$load</b> service has distinct advantages

<blockquote>

	<b>seg$load</b> loads all the RAM sections of the application in one call<br><br>

	<b>seg$load</b> does not write locations which have don't-care values<br><br>

	RAM images in ROM / core file systems do not buffer don't-care values<br><br>

	<b>seg$load</b> is not limited in the size of RAM image it loads<br><br>

	Each core-resident file system may contain the the RAM images of many programs<br><br>

	There may be many core-resident file systems<br><br>

</blockquote>

The steps for placing RAM assembly-time variable values in ROM or core resident
file systems are described in the linking and utilities section of this manual. 


<h3>Simple Alternatives to seg$load for Limited-Size RAM Segment Loads</h3>
<p>
The simplest programs can initialise a few scalar items without calling on
an organised segment load
<p>
An alternative to segload is a copy from ROM to RAM. This involves the breakpointed
load addressing described earlier

In this example, part of B0 is a constant pool for initializing B1
<pre>

	$ masmx -ln
MASMX 7r3
0/-INPUT>>
	$list	0
	$include	freeware/RTA1/rta/def/rta.def
	$include	freeware/RTa1/rta/language/stack.def
	$list

B0_LOAD_ADDRESS $equ    30*4096

$(0::B0_LOAD_ADDRESS)

$(1:01000:B0_LOAD_ADDRESS+3072)
one     +       99
two     +       100
three   "abc"

$(0)
entry1* $vector fireup
        $list   0
        $do     64-$,   fret    0
        $list

fireup  lx, xi  one
        ly, xi  3072
        lr, xi  768/4-1

fireup_quad
        qpush   0, y
        qpop    0, x
        ax, xi  4
        ay, xi  4
        jdr     fireup_quad

        .
        .

	$end
  :                            821  $list
  :                            822 
  :                            823 B0_LOAD_ADDRESS $equ    30*4096
  :                            824 
  :                            825 $(0::B0_LOAD_ADDRESS)
  :                            826 
  :                            827 $(1:01000:B0_LOAD_ADDRESS+3072)
01:001000 000063              +828 one     +       99
01:001001 000064              +829 two     +       100
01:001002 616263              +830 three   "abc"
  :                            831 
  :                            832 $(0)
00:000000 B60040              +833 entry1* $vector fireup
  :                            836         $list
  :                            837 
00:000040 551000              +838 fireup  lx, xi  one
00:000041 5D0C00              +839         ly, xi  3072
00:000042 4500BF              +840         lr, xi  768/4-1
  :                            841 
  :                            842 fireup_quad
00:000043 8FB000              +843         qpush   0, y
00:000044 87A000              +844         qpop    0, x
00:000045 850004              +845         ax, xi  4
00:000046 8D0004              +846         ay, xi  4
00:000047 1E0043              +847         jdr     fireup_quad
  :                            848 
  :                            849         .
  :                            850         .
  :                            851 
  :                            852  $end
:$(00):000000:000048 :$(01):001000:001003 

</pre>

Assembling again with -d option lists the load addresses, which are not the
program-visible addresses
<pre>

	$ masmx -lnd
MASMX 7r3
0/-INPUT>>
	$list	0
	$include	freeware/RTA1/rta/def/rta.def
	$include	freeware/RTa1/rta/language/stack.def
	$list

B0_LOAD_ADDRESS $equ    30*4096

$(0::B0_LOAD_ADDRESS)

$(1:01000:B0_LOAD_ADDRESS+3072)
one     +       99
two     +       100
three   "abc"

$(0)
entry1* $vector fireup
        $list   0
        $do     64-$,   fret    0
        $list

fireup  lx, xi  one
        ly, xi  3072
        lr, xi  768/4-1

fireup_quad
        qpush   0, y
        qpop    0, x
        ax, xi  4
        ay, xi  4
        jdr     fireup_quad

        .
        .

	$end
  :                            821  $list
  :                            822 
  :                            823 B0_LOAD_ADDRESS $equ    30*4096
  :                            824 
  :                            825 $(0::B0_LOAD_ADDRESS)
  :                            826 
  :                            827 $(1:01000:B0_LOAD_ADDRESS+3072)
01:01EC00 000063              +828 one     +       99
01:01EC01 000064              +829 two     +       100
01:01EC02 616263              +830 three   "abc"
  :                            831 
  :                            832 $(0)
00:01E000 B60040              +833 entry1* $vector fireup
  :                            836         $list
  :                            837 
00:01E040 551000              +838 fireup  lx, xi  one
00:01E041 5D0C00              +839         ly, xi  3072
00:01E042 4500BF              +840         lr, xi  768/4-1
  :                            841 
  :                            842 fireup_quad
00:01E043 8FB000              +843         qpush   0, y
00:01E044 87A000              +844         qpop    0, x
00:01E045 850004              +845         ax, xi  4
00:01E046 8D0004              +846         ay, xi  4
00:01E047 1E0043              +847         jdr     fireup_quad
  :                            848 
  :                            849         .
  :                            850         .
  :                            851 
  :                            852  $end
:$(00):000000:000048 :$(01):001000:001003 


</pre>
The ROM copy source doesn't have to be in B0. A separate bank or page can be assigned,
but needs to be based in an address window before it can be copied. This technique
may be good for programs which, like C-Language programs, have no don't-care-value
locations in their data section
<pre>

$(3:03000:0C000)

?	$do	1000,	+	7.5*+?
buffer	$res	96
	

$(0)
	la	(0C000)
	sabr	34
	ly	(34*/12)
	lx, xi	03000
	lr, xi	4096/4-1

load	qpush	0, y
	qpop	0, x
	ax, xi 	4
	ay, xi	4
	jdr	load

	.
	.

</pre>



<h3>ROM System Image vs Independent Applications Load</h3>

The kernel and applications may be a single ROM image

<p>
Applications otherwise load anywhere. Their addresses are internally
absolute because of hardware relocation

<p>
The loader places the program's bank identifiers and call vectors in the
program's vector bank at address window 02000..02FFF



<h3>Giant Breakpoint Address</h3>
<p>

Breakpoint addresses may be larger than the address space. This is
signaled with an *asterisk on the breakpoint address

<pre>

$(31::*00000A000000)

</pre>

<p>
A normalised long pointer is used here to access data via a 48-bit address
<pre>

$ masmx alaska -kln
MASMX 7r2
3/alaska.msm
*EOF*
  :                            1: 	$include	freeware/RTA1/rta/def/rta.def
  :                            2 
  :                            3 f	$func
  :                            4 pointer* $name
  :                            5 	$return	1*/46++f(1, 1)**0003FFFC0000*/12++$r(f(1, 1))*/18++f(1, 1)**03FFFF
  :                            6 	$end
  :                            7 
  :                            8 BASE	$set	42
  :                            9 
  :                            10 $(BASE::*03C000000)
2A:00003C000000:000063        +11 neck	+	99
2A:00003C000001:000065        +12 mutton	+	101
  :                            13 
  :                            14 $(0:64)
  :                            15 
00:000040 CF0100              +16 	dl	(pointer(mutton))
00:000041 34002A              +17 	sabr	BASE
00:000042 60D000              +18 	la	0, b
  :                            19 
  :                            20 	$do	$<256,$(0:256)
  :                            21 
*EOF*
00:000100+43C000A80001
:$(00):000040:000102 :$(2A):000000:000002 


</pre>
<p>
A very large RTA address is 48 bits in size. This accommodates the
16-gigaword executable space and any future executable space up to
256 terawords

<p>
If a large array is part of a ROM, its giant addresses are physically absolute.
Otherwise its giant addresses are relative to a load address. See the
section on linking and utilities

<p>
A data array might be loaded to an area much larger than the address
space. See <b>Appendix A: Giant Structures in Memory</b>

<h3>Relocatable Sections</h3>

Relocatable code must be made absolute before passing to the load
string formatter <b>lstring</b>

<p>
Linking is a further assembly which includes
binary in the Text-Encoded-Object format *.txo

<p>
Relocatable sections can accumulate the alike segments of many assemblies

<p>
The relocatable location counter declaration contains no addresses
but an alignment factor marked with an asterisk
<pre>

$(3:*4[/literal_pool_name])

</pre>
<p>
See <b>Appendix B: masmx Linking for RTA1</b>

<h3>Void Sections and Structure Pointers</h3>


<h2>Appendix A: Giant Structures in Memory</h2>

<h2>Appendix B: masmx Linking for RTA1</h2>

<h3>5.4 Core Resident File Systems used in Software RAM Segment Load</h3>

The input binary_image_filename is a load strings output from the
following utility steps. First all the RAM-destined part of an
assembly is separated in a linking assembly. Then the utility
lstring is executed with option -b to output binary load strings

<pre>

        $ masmx -kln


                $include        freeware/RTA1/rta/def/map1.def
                $include,$binary        my_application  $(1,3)

                                        . that includes writable parts


                $store  my_ram_part
                $end


        $ lstring -b my_ram_part.txo binary_input_filename

</pre>

The core file system image can be constructed after all segments
for inclusion have been built
<pre>

        $ 4kformat -x fsystem5.txo
        volume  fsystem5
        tree    seg$load
        file    my_ram_values binary_input_filename
	.
	.

</pre>
The two periods are required. They are not a hint at further text. The first period
returns from directory seg$load to volume root directory fsystem8. The second
period exits 4kformat utility

<p>
The inclusion of fsystem5.txo in the final image has the pattern
<pre>

        $ masmx         -kln

                $include        freeware/RTA1/rta/def/map1.def
                $include,$binary        everything_else

FS5_START_BANK_INDEX $equ       NEXT_ADDRESS//4096      . a 4K bank index

                $include,$binary        fsystem5
                $store                  totalimage

</pre>

Finally when a process instance of my_application is launched, after
the storage banks for process data are based, the function seg$load can
be called with the indentify of the core file system start bank and the
label of the file containing the RAM segment
<pre>

        $base_d MY_APPLICATION_DATA_SIZE        . base the memory space

	c	(seg$load)	FS5_START_BANK_INDEX,,xi
				(my_ram_values:d),,long

</pre>
There are two more variants of <b>seg$load</b>

<p>
<b>recursive$seg$load</b> is used in the recursive subprogramming model.
This technique replicates the unpacking of program data to an external stack
frame when a thread calls the program recursively. This is for calling programs
as if they were functions with new copies of a data segment of any size and
complexity. External stack pointer <b>fp</b> must contain the new segment
address before <b>recursive$seg$load</b>
<pre>

	c	(recursive$seg$load)	BANK_INDEX_OF_CORE_FS_START,,xi	;
					(my_dynamic_segment_filename:d),,long

</pre>
block structured programs use the xframe() part of <b>$head_near/far</b>
macro to load dynamic values in the external stack at a functional rather
than a program level

<p>
The third variant of <b>seg$load</b> is <b>array$seg$load</b>. This loads
multi-bank arrays with assembly-time initial values. The target windows
are dynamically overlaid and cannot be based before the call. The third
argument is zero if the array is assembled with absolute load addresses
and is a bank index if storage for the array has been obtained dynamically
with system calls <b>ii BANK$</b> or <b>ii ARRAY$</b>
<pre>

	la, xi	30000*262144
	ii	ARRAY$
	jza	sorry

	c	(array$seg$load)	BANK_INDEX_OF_CORE_FS_START,,xi			;
					(my_assembled_array_segment_filename:d),,long	;
					a		
 
</pre>


<h2>Appendix Y: masmx Directive and Function Names</h2>

masmx prints its internal names if options + and x are both typed. -y sorts
the label table. -k is case-sensitive, otherwise all names are uppercase


<pre>

		$ masmx -x+yk
MASMX 7r3
0/-INPUT>>
	$end

assembly list			explanation
_____________			___________

				label category	syntax column 1
				______________	_______________

$=:F:000000			function		+	$			. location counter $ or $(number)
$a=:F:000011			function		+	$a			. absolute $a current address or $a(value)
$ascii=:D:000015		directive		$ascii				. generate direct ASCII:ASCII data code as input
$awidth=:D:00002B		directive		$awidth	ea_bits[:executable_space]	. set target address size, default 24:48
$b=:F:000010			function		+	$b			. start address of section $b or $b(number)
$bank_index=:F:000012		function		+	$bank_index		. current breakpoint address of program section

$binary=0000FA						$include,$binary filename	. add *.txo text encoded binary file to linking assembly
						label	$set,$binary	text_encoded_superword_paraform . capture binary code in a label, linking assembly
 
$blank=:D:00004E		directive	label[*] $blank				. assign export level to label not yet declared
$branch=:D:00003F		directive	label	$branch				. address structure overlaid in memory. See $tree and $root
$byte=:D:00001A			directive		$byte	bits			. width of data character in "" and +'', default 8
				and function		+	$byte
$characteristic=:D:000035	directive		$characteristic[,number_size_bits] characteristic_bits
											. size of sign+exponent field in floating number, defaults:
							$characteristic		24	. default floating number size 96 bits, 24-bit characteristic
							$characteristic,48	12	. compressed floating number size 48 bits, 12-bit characteristic

$cont_char=:D:000030		directive		$cont_char	value			. line continuation character default ';'
$data_code=:D:000014		directive	 	$data_code [input:generated, input:..]	. switch to alternate data code [assign parts of it]
$directive=00007E				name	$equ,$directive	$blank_for_example	. additional name for a masmx directive
$do=:D:000004			directive	[tag]	$do	count,[label(tag)] command arguments . iterate a line of code
$else=:D:000007			directive		$else				. conditional assembly
$elseif=:D:000008		directive		$elseif	condition		. conditional assembly
$end=:D:000003			directive		$end				. end of subassembly (macro) or end of assembly 
$endif=:D:000009		directive		$endif				. conditional assembly
$equ=:D:000010			directive	label	$equ	value
$equf=:D:000043			directive	label	$equf	value,value,..		. equate a name to a tuple of values
$exit=:D:00000E			directive		$exit	stop the assembly with this message
$flag=:D:000033			directive		$flag	mark the assembly in error with this message
$flagf=:D:00000A		directive		$flag	mark the first pass assembly in error with this message
$floating_point=:D:000034	directive		$floating_point	floating_number_default_bit_size	. default 96
$form=:D:00003B			directive	name	$form	bits,bits,..		. bitfields structure template 
$func=:D:00000D			directive	name	$func	[*]			. function macro head [* second pass only]
$function=00007D				name	$equ,$function	$_for_example	. additional name for a masmx function
$hex=:D:000042			directive		$hex				. leading 0 means hex input print hex output, default
$if=:D:000006			directive		$if	condition		. conditional assembly
$include=:D:00000C		directive		$include			. include source code, see also $binary and $void
$info=:D:000044			directive		$info			. instruct the linking assembly, see also $range_check $range_check1 $offset
$linewidth=:D:00002A		directive		$linewidth	columns		. set maximum line width in output text encoded binary file
$list=:D:00001C			directive		$list	[nondefault]		. set file inclusion nest level for -l list. Just $list returns to default 
$lit=:D:00007B			directive	[tag]	$lit	location_counter	 . set which program section contains automatic literals
$load=:D:00004C			directive		$load,$bits	label		. output link adjusted binary acquired at $set,$binary
$long_absolute=0000DC				name	$pushrel,$long_absolute label_value . acquire a large label value to add to a relocatable code field
$lterm=:D:00002C		directive		$lterm	comment_character 	. default is period space, other values do not need following space
$n=:F:000001			function		+	$n			. the name value in macro call, equal to perform value macroname(0, 0)
$name=:D:000002			directive	name[*]	$name	value			. binds a macro call name to a value. Otherwise similar to $set
$net=:F:00000B			function		+	$net(value)		. local part of relocatable value = unrelocatable value. Allows all algebra
$nop=:D:00003C			directive		$nop	do nothing except optionally serve as a comment line without knowing what $lterm is
$note=:D:00003A			directive		$note	print this non-error remark
$notef=:D:00000B		directive		$notef	print this non-error remark on the first assembly pass
$o=:F:000009			directive		+	$o(value_of_option_letter)	. 1 if opted, otherwise zero
$octal=:D:000041		directive		$octal				. leading 0 means octal input print octal output, otherwise default hex
$offset=000001						$info,$offset	new_value	. update a tuple containing a relocatable address value in a link assembly
$path=:D:00001D			directive		$path	[../../][/token..]	. path prepend for $include. Cancels with just $path
$plist=:D:00001E		directive		$plist	value			. set macro expansion depth for -pqr listing. Just $plist returns to default

$proc=:D:000001			directive	label[*] $proc	[*] [$(number)]		. head of a command macro
											. label must be exported if macro text exports no labelled* $name label
											. argument * is 2-pass macro on second assembly pass
											. $(number) assembles in program section $(number)

$pushrel=:D:00004D		directive	label	$pushrel text_encoded_binary_superword_subfield		. in a linking assembly
											. capture one relocation tuple from *.txo data superword into a $equf label
$quantum=:D:000029		directive		$quantum	bitsize		. the addressable memory unit of the target architecture. Default = $word
$quote=:D:000036		directive		$quote		value		. set the string delimiter, default "
$r=:F:000006			function		+		$r		. program section (location counter]: $r of here, $r(name) of something 
$range_check=000002		directive		$info,$range_check	value	. on final relocation check value is in range of target field
$range_check1=000003		directive		$info,$range_check1	value	. check value in range of target field each time this relocation tuple is scanned
$rel=:F:00000A			function		+		$rel		. relocation alignment, zero = absolute : $rel current section or $rel(number)
$res=:D:000022			directive	[label]	$res		quanta		. declare a buffer. option -Z initial zero
$return=:D:00001B		directive		$return		expression	. leave a $func macro and return the expressed value to the assembly above
$root=:D:000047			directive		$root				. end of structured name space started with $tree or $branch
$set=:D:000011			directive	label	$set		expression	. temporary equate, actioned on all assembly passes, may be $set again to a new value
$set_option=:D:000045		directive		$set_option	"flaGS"		. set assembly options. See Appendix Z: Command Line
$snap=:D:000028a		directive		$snap[,1]	[2]		. list label table fixed or [2] dynamic part. Subfunction 1 = 1st pass	
$sterm=:D:00002D		directive		$sterm		value		. change the substring character, default ':'
$store=:D:00004F		directive		$store		path		. default assembly output file name. Suffix .txo if no '.' in path last token
$suffix=:D:00003D		directive		$suffix		[1|2]		. integer notation suffixes h o|q b d (default). 1|2 : default for leading 0 = h|d
$t=:F:000008			function		+	$t(name_or_paraform)	. category of label
 
$text=:D:000053			directive		$text	,this,that,
							$text	\these,those\any\	. translate source text on read

$trace=:D:000039		directive		$trace[,1]	expression	. display a value
$tree=:D:000046			directive	name	$tree				. structured name space, see also $branch, $root
$twos_complement=:D:00002F	directive		$twos_complement	1|0	. default 1 = 2s complement, 0 = negative integers are 1s complement
$void=0000F8						$include,$void file		. add names but not code from *.txo text encoded binary file to link assembly
											. see $binary
$word=:D:000019			directive		$word	bits
				and function	bytes_w	$equ	$word/$byte             . $word is size denominator of generated code and default integer size

$xqt_fp=:D:000050		directive		$xqt_fp	floating_tokens+operators . inline runtime expression algorithm via target-specific instruction macros
$xqt_i=:D:000051		directive		$xqt_i	integer_tokens+operators . inline runtime expression algorithm via target-specific instruction macros

$zenith=:F:000FC8		function		$if	$zenith>LIMIT
							$if	$zenith(section)>LIMIT	. unrelocated high address of section including literal pool
-INPUT>>=0<000000

-INPUT>>: object code 0 bytes: 0 errors: 0 undefined labels

</pre>

<h2>Appendix Z: masmx Command Line Options</h2>

<pre>

</pre>

_____________________________________________________________________
<pre>
<i>

    LICENCE NOTICE


    Copyright Tim Cox, 2012
    TimMilesCox@gmx.ch

    This document is part of the RTA1 processor programmable
    architecture.

    RTA1 is a free processor architecture specification.
    It is licensed under the GNU General Public Licence Version 3

    The executable emulation of RTA1 is free software.

    Instruction code for the target RTA1 architecture is free software
    if it is delivered with this software

    Software programs delivered with this software to connect the
    emulated RTA1 with real network interfaces in the emulator host
    are free software

    Scripts and programs delivered with this software for running
    on other computers and interacting with the RTA1 are free software

    The masmx target-independent meta-asembler delivered here
    is free software whether it is used for constructing RTA1 code
    or any other code. masmx is a separate free program by the
    same author and included with this software to save searching for it

    Scripts and utility programs for constructing RTA1 target
    executable software are free software

    You can redistribute it and/or modify RTA1
    under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    RTA1 is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with RTA1.  If not, see &lt;http://www.gnu.org/licenses/&gt;.

</i>
</pre>


</div>
</html>
