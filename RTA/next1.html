<div	style="font-size:16pt">

<h2>RTA1: Laying the Next Foundations</h2>

RTA1 project is about a simple low-powered semicondictor device for embedded work

<p>
RTA1 instruction architecture is a path to ultra-efficient code as an alternative to high-revving power consumption

<p>
Is there some reason to do new and better PC emulations?

<p>
Well one reason is, PC platforms are capable of lending emulated RTA1 more efficiency than ever

<p>
RTA1 isn't a project about massive performance or about ever-better emulators, but there are things it can do with the advanced features of PCs

<p>
It can reduce the effort in RTA1 96-bit and 192-bit floating arithmetic. Efficiency is cool

<p>
Simplified internal algorithms are cool

<p>
You wouldn't automatically say, large array, that's a job for RTA1. It's not even what RTA1 is for

<p>
You can configure up three terabytes of array on RTA1, but wouldn't you have to buy three terabytes of memory?

<p>
That's just where emulation on PC is a bargain. Virtual memory is there because you think it is

<p>
But why emulate anything? The 64-bit PC can do any arrays you like

<p>
Maybe you'd like to do terawords of RTA1 192-bit floating numbers

<p>
You already can, with 64-bit RTA1 emulators written in GCC. You just tell the command line: maximum executable space plus 60 more similar arrays please

<p>
So it's done anyway?

<p>
RTA1 emulators written in <a href="lo_cost.html">machine code for 32-bit platforms</a> are a success worth carrying forward. They take less power and of course are more rapid. There doesn't seem to be a C compiler that can do that

<p>
Newer and better 64-bit PCs are another success worth sharing

<p>
The next step being prepared for project RTA1 is an emulator written in 64-bit machine code specific to advanced features

<p>
For OSX and Linux platforms

<p>
RTA1 project nevertheless insists on offering free products that run right back to PowerPC and Snow Leopard. Functionality stays identical on all platforms

<p>
It's all free

<p>
Would you bolt all that memory onto an embedded semiconductor RTA1?

<p>
Well you might be doing some mighty transaction machine driving billions of memory-mapped sensors and actuators

<p>
Those 60+ array spaces are also interchangeable for solid-state filestore

<p>
Instruction code hardly takes any memory at all

</div>
