<div	style="font-size:16pt">

<h2>RTA1: Laying the Next Foundations</h2>

<div	style="color:#0000FF;font-size:21pt">
<i>see also <a href="q_a.html#mcore">Performance leaps with RTA1 SMP</a>
and <a href="lo_cost.html">Efficiency and Energy</a></i>
</div>
<br><br>

RTA1 project is about a simple low-powered semicondictor device for embedded work

<p>
RTA1 instruction architecture is a path to ultra-efficient code as an alternative to high-revving power consumption

<p>
Is there some reason to do new and better PC emulations? Yes, and they're already here

<p>
One reason is, PC platforms are capable of lending emulated RTA1 more efficiency than ever

<p>
RTA1 isn't a project about massive performance or about ever-better emulators, but there are things it can do with the advanced features of PCs

<p>
It can reduce the effort in RTA1 96-bit and 192-bit floating arithmetic. Efficiency is cool

<p>
Simplified internal algorithms are cool

<p>
You wouldn't automatically say, large array, that's a job for RTA1. It's not even what RTA1 is for

<p>
You can configure three terabytes of array on RTA1, but wouldn't you have to buy three terabytes of memory?

<p>
That's just where emulation on PC is a bargain

<p style="color:#FF0000">
However caution is urged using swap space on SSD intensively, because very little data is available about the durability of SSDs. A solution like <a href="https://www.linux-magazine.com/Online/Features/Swapping-with-zRAM">ZRAM</a> which protects a file + swap system on flash should be considered by anyone intending to process many gigawords of borrowed virtual memory intensively

<p>
But why emulate anything? The 64-bit PC can do any arrays you like

<p>
Maybe you'd like to do terawords of RTA1 192-bit floating numbers

<p>
You already can, with 64-bit RTA1 emulators. You just tell the command line: maximum executable space plus 60 more similar arrays please

<p>
This has recently become more efficient

<p>
RTA1 emulators are now SMP using core threads available on the platform. Nearly all are in Intel machine code.<br>
Thanks to Intel's icc compiler the remaining emulators derived from the C code-base are also rapid and cool-running

<p>
These new efficient emulations are close to the RTA1 project's performance objectives for future semiconductor RTA1s

<p>
And certainly more suitable for a project about low power

<p>
Newer emulators execute RTA1 instructions in a tight loop of platform machine-code

<p>
The result is double the performance of earlier RTA1 emulators and half the demand on platforms

<p>
These faster and cooler emulators are delivered in SMP for Linux and macOS 64-bit and 32-Bit Intel platforms

<p>
Newer and better 64-bit PCs are a success worth sharing

<p>
Functionality stays identical on RTA1 free emulators for platforms from PowerPC and Snow Leopard through to current OpenSUSE

<p>
It is not certain that integrators would install the maximum three terabytes of real memory on a semiconductor RTA1, but it is possible to mount the entire RTA1 executable and array spaces on a virtual memory space. That's what's emulations running on PCs are doing already

<p>
Those 60+ array spaces are also interchangeable for <a href="kernel.html#file_system">RAM file systems</a> backed up to 3rd party devices. Three terabytes are not big data, but a farm of networked RTA1s is. The 24-bit embedded device can grow into a big data machine, if other RTA1 features like 96-bit / 192-bit floating arithmetic are a persuasive factor of choice

<p>
RTA1 target instruction code hardly takes any memory at all

</div>
