<div	style="font-size:24pt">
<h2>Internal Stack, how's that?</h2>

RTA1 internal stack is a way of having many registers and making use of them

<p>
The first 256 words of operand space are registers, 128 for the application and 128 for ISRs

<p>
Being in operand space means registers can be organised like a list or table... or like a stack

<p>
160 bytes of each IP datagram received are held in the application internal stack. No storage buffer is assigned until RTA1 IP decides whether to drop the datagram or queue it to upper protocols

<p>
As execution traverses functions, parameters and dynamic objects are gathered in registers. No level-1 operand cache

<p>
The internal stack pointer does the assigning, not the software developer or any smart compiler

<p>
Large tables and arrays don't get in there, although pointers do. Big temporary space like printf format buffer goes in an external stack

<p>
If you want to do stuff like recursion, it becomes necessary to farm stack frames out to the external stack. There is macro language for doing this. It's never been necessary in the kernel or the network protocol stack 

<p>
The internal stack is opposite to conventional stacks. It's a way of getting data into the core, not a way of copying registers to RAM. A push copies storage or registers or immediate values into the internal stack. Functional parameters and dynamic variables are registers pointed by the internal stack pointer

<p>
pop operations write values from stack registers either to memory or to some other place in the register array, for example smart registers like accumulators and the internal stack pointer itself

<p>
Smart registers are in the same register array as the internal stack, but outside the part of it used as stack space

<p>
The internal stack is the call / return stack

<p>
The application thread's 128 registers are saved on thread switch in 32 instructions

</div>
