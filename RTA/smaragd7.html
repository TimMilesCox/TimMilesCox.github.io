<html>
<div	style="font-size:14pt">

<center>

<h1>The smaragd7 Kernel and API</h1>

<i>
Copyright Tim Cox, 2012<br>
This document is part of the RTA1 Processor Programmable Architecture Specification<br>
The RTA1 Architecture is freeware licensed with the GNU General Public Licence Version 3<br>
The same licence encompasses all accompanying software and documentation <br>
The full licence text is included with these materials<br>
See also the licensing notice at the foot of this document
</i>

</center>


<ol>

	<li>API</li>
	<ol>
		<li>POSIX API and Low Level Interface</li>

		<li>Kernel Call Interface and Internal Interrupt Interface</li>
	</ol>
	<li>Primitive Kernel Routines</li>
	<ol>
		<li>Launching, Switching and Ending Tasks</li>

		<li>Adding and Releasing Task Storage</li>
	</ol>
	<li>Network API</li>
	<ol>
		<li>The POSIX Network API</li>

		<li>UDP Server Low-Overhead Routines</li>
		<ol>
			<li>Zero-Copy Reference to User Datagrams</li>
                        <li>Constructing a User Datagram Response: udp_rtxbuffer</li>
                        <li>Transmitting the Response: udp_acw_send</li>
                        <li>Discarding the Input: release_udgram</li>
		</ol>

		<li>Network Buffer Descriptor</li>

		<li>TCP Low-Level Routines</li>

		<li>The TCP High-Volume Network API</li>
	</ol>
	
	<li>API Service Primitive Building Blocks</li>

	<li>File System Interface</li>
	<ol>
		<li>POSIX API</li>

		<li>File System Types and Low-Level Interfaces</li>

		<li>Core Resident File Systems</li>

		<li>Low-Level File Access Structure</li>

		<li>Memory Device Array File Systems</li>
	</ol>
</ol>

<h2>1. API</h2>

<h3>1.1 POSIX API and Low Level Interface</h3>

<p>
The smaragd7 kernel has services with POSIX-like API

<p>
The services are also addressable at a lower layer than the handle-based
POSIX model

<p>
Low level interfaces allow services on a far larger scale as well
as shorter instruction paths

<p>
POSIX APIs are centred on the handle, an integer token for a network socket
or a file. Socket and file handles share a number space

<p>
On RTA1 with smaragd7 kernel, a single server application may have
several million sustained TCP connections. The remote client session
is carried on a sustained TCP connection.

<p>
Applications do not have millions of socket handles, but may serve
millions of TCP connections over a low-level API




<h3>1.2 Kernel Call Interface and Internal Interrupt Interface</h3>

Most kernel routines have a call interface and their
arguments are on the internal stack

<p>
Some calls are internal interrupts. They are called with
the <b>ii</b> internal interrupt instruction

<p>
Functional wrappers will be placed around internal interrupt system calls
for a single and simple C-Language interface

<p>
Macro language supports a structured call interface for application
calls and kernel calls. Detailed explanation is in the separate
document <b>Towards High-Level Languages for RTA1</b>

<p>
Kernel routines which temporarily alter the address space are
implemented as internal interrupts

<p>
Return from interrupt restores the caller's environment

<p>
Arguments for internal interrupts are typically in the application
accumulator registers

<div    style="font-size:11pt">
<pre>

	la	<i>argument</i>
	ii	<i>isr_vector</i>


</pre>
</div>

<p>
A vector is a value with a 16-bit bank pointer and a 6-bit offset

<div    style="font-size:11pt">
<pre>

	00 bbbb bbbb bbbb bbbb offset

</pre>
</div>

An ISR vector value is the immediate operand of the internal
interrupt instruction <b>ii</b>

<div    style="font-size:11pt">
<pre>

	ii	ISR_VECTOR

        [example]<i>
        location: instruction                   source</i>
        <b>
        00:00004C 750047              +50       ii              THREAD$
        </b>

</pre>
</div>

<p>
The operand of the far call instruction <b>call</b>
is a variable or a constant containing the vector value
of the target routine

<div    style="font-size:11pt">
<pre>

	call	(CALL_TARGET_VECTOR_VALUE:s)

	call	variable


	[example]<i>
        location: instruction                   source</i>
        <b>
        00:000047 FF0E74              +122      call    (__socket)
        </b><i>
        location: operand</i>
        <b>
        00:000e74+000081
        </b>

</pre>
</div>

An ISR reads parameters from the application arithmetic registers,
and returns by executing an interrupt return instruction <b>ir</b>

<p>
A far call routine executes in application mode and reads parameters 
from the internal stack. It returns by executing a far return instruction <b>fret</b>

<p>
All ISRs which are internal interrupt targets in OS smaragd7 are in the
4096-word bank at absolute address 4096, i.e. the second page of storage. 

<p>
So these ISR vector values are all in the range

<div    style="font-size:11pt">
<pre>

	64++[0..63]
	000000 000000 000001 xxxxxx

        [example]<i>
        location: instruction			source</i>
        <b>
	00:00004C 750047              +50 	ii		THREAD$
	</b>

</pre>
</div>

<p>
Instruction banks can be any size, but the kernel banks are the minimum
size of 4096 words for modularity

<p>
Network call routines are in bank 2 at address 8192 and file system call
routines are in bank 6 at address 24576

<p>
Their vector values are these ranges

<div    style="font-size:11pt">
<pre>

        2*64++[0..63]
        00 0000 0000 0000 0010 yyyyyy

        6*64++[0..63]
        00 0000 0000 0000 0110 xxxxxx


        [example]<i>
        location: instruction                   source</i>
	<b>					
	00:000047 FF0E74              +122      call    (__socket)
	</b><i>
	location: operand</i>
	<b>
	00:000e74+000081
	</b>
</pre>
</div>

<p>
Because a 16-bit bank pointer to a 4K-granularity bank edge only addresses
256 megawords of executable space, the <b>call</b> instruction operand
may be a 19-bit pointer to a bank at a 32768-word boundary, with a 3-bit vector
offset, covering all 16 gigawords of executable space

<div    style="font-size:11pt">
<pre>

        00 bbbb bbbb bbbb bbbb vector   call vector value up to 256 MWord

        01 bbbb bbbb bbbb bbbb bbbvvv   call vector value up to 16 GWord

</pre>
</div>

<p>
High-memory vectors are not expected in kernel calls


<h2>2. Primitive Kernel Routines</h2>
<p>
The principal internal interrupts are these. There are more
used as building blocks for services

<div    style="font-size:11pt">
<pre>

	SPAWN$             66		= bank 1  vector  2

					process launch
					4 parameters in application registers
					a b mantissa2 mantissa3


	BANK$              67		= bank 1  vector  3

					storage acquire
					words requested in
					application register a


	ARRAY$             68		= bank 1  vector  4

					very large storage acquire
					4096-word blocks requested
					in application register a 

	BANK$FREE          69		= bank 1  vector  5

					storage relinquish
					absolute bank pointer in
					application register a


	YIELD$             65		= bank 1  vector  1

					thread switch

					on preemptive event
					or event wait
					or voluntarily


	TWAIT$             91		= bank 1  vector  27

					thread switch and wait
					microsecond count in
					application registers a:b


	EXIT$              70		= bank 1  vector  6

					end thread and subsidiary threads


	THREAD$		   71		= bank 1  vector  7

					start a new thread
					of the current process

                                        4 parameters in application registers
                                        a b mantissa2 mantissa3


</pre>
</div>

<h3>2.1 Launching, Switching and Ending Tasks: SPAWN$ YIELD$ TWAIT$ EXIT$ THREAD$</h3>


<h4>2.1.1 SPAWN$</h4>

<b>SPAWN$</b> launches a process

SPAWN$ is not a loader. The instruction part of the target application is already in executable storage

<div    style="font-size:11pt">
<pre>
        $include        ii.def


        ql      	(<i>start_vector, PRIORITY, DATA_SPACE, -B1_OCCURENCES</i>:q)
        ii      	SPAWN$

</pre>
</div>

<p>
<i>start_vector</i> is the <i>bank.vector</i> value where the process initial
thread starts

<p>
The highest priority is zero and the lowest PRIORITIES-1

<p>
<i>DATA_SPACE</i> is the size of application initial data which has
program names and addresses, i.e. <b>static</b> plus <b>global</b>.<br>
If external stacks are required they can be included in this total.
External stacks are not always needed because the internal stack is
enough for many threads

<p>
The kernel writes the start address of program storage in the process
vector bank. The application bases the assigned storage in relocation
registers B3..B31

<p>
<i>-B1_OCCURENCES</i> is a negative number indicating the number of 4096-word
frames the application requires in its private B1 stack. The default is
-1, which means the application uses one private B1 frame

<p>
B1 frames are distinct from application data banks because their content
is encapsulated in the owning application or service. Addresses in B1
are not in the address space of called or calling entities

<p>
A simple application has a single B1 frame. A service disposing tabled
resources has one or more

<p>
Recursive application models may also have a linear stack of B1 frames
plus a service aligned multiple of B1 frames

<p>
The kernel assigns a single storage area containing

<ol>

	<li>B1 banks</li>

	<li>Initial Thread Control Block</li>

	<li>a vector bank</li>

	<li>the program data space</li>

</ol>

<p>
The kernel writes the base pointer of each B1 frame and of the initial
<b>DATA_SPACE</b> into the vector bank of the new process. The vector bank
also contains 64 call vectors pointing to the load address of the process
initial instruction bank or instruction bank collection

<div    style="font-size:11pt">
<pre>


	.--  -->
	|	       [B1.n]
	|
	|--  -->
	|	       [B1.2]
	|
	|------>|---------------|		.------>-----------------
	|	|	B1.1	|		|------>| instruction	|
	|	|		|		|------>| bank vectors	|
	|	|---------------|		|------>| 0..63		|
	|	|	TCB	|		|	|		|
	|	|		|		|	|		|
	|	|---------------|		|	|_______________|
	<-------| B2		|---------------:
	.-------| vector bank	|
	:------>|---------------|
		|   data space	|
		|   B3..B31	|
		|		|



	the 64 instruction bank vectors allow an application loaded
	at an arbitrary address to locate its own inter-bank call
	addresses

	an instruction bank collection is a large application
	constructed in a multiple of 32K-word banks

	the kernel at SPAWN$ writes into the vector bank the values
	of eight vectors of each instruction bank of the application


        .--  -->       [B1.n]
	|
	|
        |--  -->
        |              [B1.2]
        |
        |------>|---------------|               .------>-----------------
        |       |       B1.1    |               |------>|1st instruction|
        |       |               |               |------>| bank vectors  |
        |       |---------------|               |------>| 0..7		|
        |       |       TCB     |               |       |               |
        |       |               |               ^	|		|
        |       |---------------|               |	|_______________|
        <-------| B2            |---------------:
        .-------| vector bank   |		|
        :------>|---------------|		|
                |   data space  |               :------>-----------------
                |   B3..B31     |               |------>|2nd instruction|
                |               |               |------>| bank vectors  |
						|------>| 0..7          |
						|       |               |
						|	|		|
						|	|_______________|
						|
						|
						:------>-----------------
						|------>|3rd instruction|
						|------>| bank vectors	|
						|------>| 0..7          |
						|	|		|
						|       |		|
						|	|_______________|
						|
						|
                                                :------>-----------------
                                                |------>|4th instruction|
                                                |------>| bank vectors  |
                                                |------>| 0..7          |
                                                |       |               |
                                                |       |		|
                                                |	|_______________|
                                                |
						.
						.
                                                .------>-----------------
                                                |------>|nth instruction|
                                                |------>| bank vectors  |
                                                .------>| 0..7          |
                                                        |               |
                                            		|		|
							|_______________|








</pre>
</div

<p>
The vector bank is already based in address window B2 at application start.
The application bases its program data in as many address windows B3..B31
as required

<div    style="font-size:11pt">
<pre>
	$include	vector.def



        la      VECTOR_D
        sabr    3
        [la, i  1, a
         sabr   4
         .
         .
         la, i  1, a
         sabr   n]

</pre>
</div>

A macro <b>$base_d</b> does this

<div    style="font-size:11pt">
<pre>
	$include	vector.def


        $base_d		<i>DATA_SPACE</i>

</pre>
</div>

DATA_SPACE is the size in words of memory with program names and addresses,
or the program data sections

<p>
The application can acquire array storage up to total memory at runtime

<p>
The instruction bank containing the <b>start_vector</b> must be loaded before
<b>SPAWN$</b>


<h4>2.1.2 YIELD$</h4>
<p>
<b>YIELD$</b> is a voluntary thread switch

<p>
<b>YIELD$</b> may  be embedded in an event handler which is preemptive
and not voluntary,<br>
or in a service request which marks the thread descriptor to block on events

<p>
<b>YIELD$</b> benefits only threads of equal or higher priority if it is called
independently of preemptive or blocking events

<div    style="font-size:11pt">
<pre>

	$include	ii.def


	ii		YIELD$

</pre>
</div>

<h4>2.1.3 TWAIT$</h4>
<p>
<b>TWAIT$</b> is a voluntary thread yield for a time in microseconds

<p>
<b>TWAIT$</b> may  be embedded in an event handler which is preemptive
and not voluntary

<p>
When the wait time is expired, the thread becomes a candidate for switching

<div    style="font-size:11pt">
<pre>

        $include        ii.def


	dl		(<i>microseconds</i>)
	ii		TWAIT$

</pre>
</div>

<h4>2.1.4 EXIT$</h4>
<p>
<b>EXIT$</b> deletes the thread. Threads, handles and storage banks are
owned directly by the process initial thread without intervening hierarchy.
Other threads own only their thread control block and can exit without
removing any resources, which remain available to remaining threads.
The exit of the initial thread removes all other threads in the process



<div    style="font-size:11pt">
<pre>

        $include        ii.def


	ii	EXIT$

</pre>
</div>

Storage which any thread acquires with BANK$ and ARRAY$ returns to the kernel
when the process initial thread exits if the storage is not freed earlier

<p>
If the application internal stack is empty (sp = 128), hardware raises
internal interrupt 70 EXIT$ on local return instruction <b>lret</b> and
far return instruction <b>fret</b>

<div    style="font-size:11pt">
<pre>

	{lret|fret}	0

</pre>
</div>

<h4>2.1.5 THREAD$</h4>
<p>
<b>THREAD$</b> starts a new thread of the current process

<div    style="font-size:11pt">
<pre>

        $include        ii.def



	ql	(<i>start_address, thread_priority, parameter, initial_fp</i>:q)
	ii	THREAD$

</pre>
</div>

<p>
The thread <i>start_address</i> is in the current instruction bank

<p>
<i>thread_priority</i> is in the range <b>0..PRIORITIES-1</b>

<p>
<i>parameter</i> is an integer value or address delivered in register <b>a</b>
of the new thread

<p>
<i>initial_fp</i> is the value of external stack pointer <b>fp</b> at
thread execution start

<p>
The new thread has a new thread control block. The process initial thread owns
all other storage banks directly even if subsidiary threads obtain them

<p>
The process initial thread owns all new threads directly without
intervening hierarchy. New threads own only their thread control
block and can exit without removing resources, which remain available
to remaining threads. The exit of the process initial thread removes
all other threads in the process

<p>
Handles in the process are global to all threads and
coordinating their use is a duty of process design


<h3>2.2 Adding and Releasing Program Storage: BANK$ ARRAY$ BANK$FREE</h3>

<p>
These primitives acquire or free storage banks up to 16 Gigawords in
size. The banks acquired are not automatically based and
may be too large to base all at once

<p>
This service is not similar to C-Language <b>stdlib.h</b> calls for
obtaining buffers by pointer. C-Library manages memory which the program
already has, and does not return it to the smaragd7 kernel but to the heap
within the application


<p>
<b>BANK$/ARRAY$</b> deliver system memory to the application in 4K-word
or 256K-word granularity

<p>
<b>BANK$FREE</b> delivers system memory back to the kernel

<p>
Bank pointer or index is the 4K-word block where a bank starts = physical address / 4096

<h4>2.2.1 BANK$</h4>
<p>
<b>BANK$</b> obtains a bank from 1 to 16777215 words in size and
records it in the process initial thread control block. The argument
in application register a is words requested. Value returned in a is
the bank pointer. Zero = no memory granted

<div    style="font-size:11pt">
<pre>

        $include        ii.def


	la, xi	<i>WORDS_REQUESTED</i>
	ii	BANK$

</pre>
</div>

<p>
The parameter is the number of words required. <b>BANK$</b> memory grant
is 4096-word blocks up to 262144 words and 262144-word blocks beyond.
The bank is a single linear block

<h4>2.2.2 ARRAY$</h4>
<p>
<b>ARRAY$</b> obtains a bank from 4096 words to 16 Gigawords in size
and records it in the process initial thread control block. The argument
in application register a is 4096-word blocks requested. Value returned
in a is the bank pointer. Zero = no memory granted

<div    style="font-size:11pt">
<pre>

        $include        ii.def


	la, xi	<i>4K_BLOCKS_REQUESTED</i>
	ii	ARRAY$

</pre>
</div>

<p>
The parameter is words required // 4096. <b>ARRAY$</b>  memory grant is
in 262144-word blocks. The bank is a single linear block

<h4>2.2.3 BANK$FREE</h4>
<p>
<b>BANK$FREE</b> returns a bank of any size to the kernel. If the process
does not possess the bank, no action is taken. The argument in application
register a is the bank pointer

<div    style="font-size:11pt">
<pre>

        $include        ii.def


	la	<i>BANK_INDEX</i>
	ii	BANK$FREE

</pre>
</div>

<h2>3. Network API</h2>
<p>
The network API has a handle-based socket interface

<p>
An application using thousands or millions of sockets
calls a lower-level API

<p>
Error conditions return a range of negative values identifying the
problem. There is no errno variable

<h3>3.1 The POSIX Network API</h3>

Socket handle values share a number space with file handles. The socket
is modelled in the vector bank, which is global to the process. Therefore
multithread processes must be designed to coordinate the use of handles


<div	style="font-size:11pt">
<pre>

        $include        ip.def




	acquiring a socket handle
	_________________________


	<b>la	([IPPROTO_TCP|IPPROTO_UDP]*/16)
	call	(__socket)</b>


	result in application register a
	+integer = socket ID
	-1	= handle not available
	-2	= protocol not supported




	binding a handle to a port and optionally to a network address
	______________________________________________________________

	<b>{ dl	($net_socket 10.0.0.63:PORT) | dsr	48 }
	ds	6
	la	socket_handle
	[lb, xi	0]
	call	(bind)</b>


	result in application register a
	0	= good
	-2	= handle is not TCP or UDP
	-3	= port number specified and not free
	-4	= no resource to model the socket




	receive
	_______

	<b>c	(recv)	socket_handle	buffer	bytes	flags</b>

	socket handle is the integer handle number

	For UDP sockets bit 23 of flags has a <b>PEEK</b> effect
	-the user datagram stays on the input queue

	flag bit 22 has <b>NON_BLOCKING</b> effect.
	<b>recv</b> is by default <b>BLOCKING</b>

	if a UDP socket has no user datagram available it
	blocks if flag bit 22 = 0

	if a TCP connection has less data available than
	requested it blocks if flag bit 22 = 0

	TCP sockets receiving XDR data require BLOCKING to
	obtain a complete result atomically

	Application protocols with BLOCKING sockets must be
	separate processes or threads from the IP main thread

	<b>recv</b> returns bytes read in register <b>a</b>

	result -22 means the handle is neither a UDP socket
	nor a TCP connection

	result 0 on a BLOCKING receive means a TCP connection
	has received remote close

	On a NON_BLOCKING receive, result 0 means there
	is no data. If the connection state is no longer
	TCP_ESTABLISHED, then a negative result indicating
	the connection state in 1s-complement is returned

	This is a departure from the EAGAIN / EWOULDBLOCK
	convention. There is no errno in RTA1. The zero
	return means no data at present, like an empty file


	receive from
	____________

	source addresses of User Datagrams can be retrieved
	on receive from the containing IP datagram

	a <b>receive from()</b> function which reads a destination
	from a <b>sockaddr_in</b> structure will be added with
	C compiler development



	send
	____

	<b>c	(send)	socket_handle	buffer	bytes	flags</b>

	socket_handle is the integer handle number

	for TCP sockets bit 3 of flags is TCP_PSH which sends
	immediately instead of on full segment

	result in application register a is bytes sent

	If the socket is NON_BLOCKING,
	if the transmission could not be immediately resourced
	actual bytes sent is in <b>a</b> and outstanding count in <b>b</b>

	a result of -2 indicates that the handle is neither
	a UDP socket not a TCP connection



	send to
	_______

	destination addresses for User Datagrams can be set
	before send

	a <b>send to()</b> function which reads addresses from
	a <b>sockaddr_in</b> structure will be added with
        C compiler development



	listen, TCP only
	________________

	Argument 1 is the socket bound to a TCP port,
	not to a TCP connection

	Argument 2 sets the socket in BLOCKING or in
	NON_BLOCKING mode

	NON_BLOCKING	$equ	0

		la	handle1				. no limit
		lb, xi	NON_BLOCKING			. = NON_BLOCKING
		call	(tcp_listen)
		
		la	handle2				. nonzero limit
		lb, xi	CONNECTION_WAITQ_MAXIMUM	. = BLOCKING
		call	(tcp_listen)

	there will be an error return in <b>a</b> if
	the handle in <b>a</b> is not a bound TCP port

	If the socket is BLOCKING, connections are
	only admitted with <b>tcp_accept</b> which
	always blocks

	If the socket is NON_BLOCKING, connections
	are accepted automatically

	Servers running in the IP main thread must not block



	tcp_accept, TCP only
	____________________


		c	(tcp_accept)	handle

	<b>tcp_accept</b> awaits an incoming connection
	on a listening socket

	The remote address is in the new transmission control
	block, and if it is required anywhere else it must be
	copied from there

	an <b>accept()</b> function which writes a <b>sockaddr_in</b>
	structure will be added with C compiler development

	<b>accept</b> is a blocking call

	Servers running in the IP main thread must not block

	Incoming connections are accepted automatically on
	NON_BLOCKING sockets



	connect and close
	_________________

		
		c	(connect)	socket_handle				;
					($net_socket 10.0.0.65:REMOTE_PORT),,long

		c	(close)		socket_handle


	connect UDP socket
	__________________

	<b>connect</b> in UDP associates the local
	socket with a remote socket, but causes no
	external protocol activity. UDP socket connect
	therefore returns immediately


	close UDP socket
	________________

	<b>close</b> in UDP frees the port and makes
	the socket handle number reassignable within
	the process. The free port accepts no traffic


	connect TCP socket
	__________________

 	<b>connect</b> in TCP changes the socket to a
	connection handle and negotiates that connection
	with the remote socket over TCP and IP protocols

	The handle may already be bound to a port
	and optionally to a local network address

	Otherwise connect() binds the socket to an available
	unique local port, and to the default network address
	of the outgoing interface

	A small number of application protocols have a
	well-known and constant client port number

	Some port numbers therefore support being bound to
	multiple sockets for outgoing connect. The sockets
	may be of one process or many

	However an outgoing connection with all addresses and
	ports identical to an existing connection is declined
	internally, so that the remote host does not reset
	the existing connection

	The kernel call

		c	(share_port)	{IPPROTO_TCP,,xi|IPPROTO_UDP,,xi}		;
					{PORT_NUMBER,,xi|port_number_variable}

	allows multiple sockets to bind to the local port number

	The individual socket moves from the port to
	the connection on connect() and is lost on close()

	To use that local port for another connect() a new
	socket must first be bound to it

        TCP socket <b>connect</b> is a blocking call

        Servers running in the IP main thread must not block

        NON_BLOCKING call <b>tcp_start_connection</b> in the
        low-level interface starts the negotiation of
        a remote connection for asynchronous completion

        a <b>connect()</b> function which reads addresses from
        a <b>sockaddr_in</b> structure will be added with
        C compiler development

	The sequence for outgoing connections is, starting with
	the optional separate bind() step


				 _______________
				(    bind()	)
				 ---------------
					|
			any port	|   specific port
			________________|________________
			|				|
		________|________			|
		| TCP names port|			|
		|_______________|			|
			|				|
			|_______________________________|
					|
					|
				________|________
				| bind the port	|
				| to address:	|
				| may be 0.0.0.0|
				|_______________|
					|
				________|________
				| handle -> port|
				|_______________|




				 _______________
				(   connect()	)
				 ---------------
					|
					|
			not bound	|	    bound
			________________|________________
			|				|
		________|________			|
		|   bind to	|			|
		|   0.0.0.0:0	|			|
		|_______________|			|
			|				|
			|_______________________________|
					|
					|
					|
				________|________
				|   construct	|
				|   connection	|
				|_______________|
					|
				________|________
				| copy local net|
				| address from	|
				| port socket	|
				|_______________|
					|
					|
					|
			local network	|  local network
			address=0.0.0.0	|address^0.0.0.0
			________________|________________
			|				|
			|				|
			|				|
		________|________			|
		|local address	|			|
		|of connection =|			|
		|default address|			|
		|of interface on|			|
		|default route	|			|
		|to remote host	|			|
		|_______________|			|
			|				|
			|				|
			|_______________________________|
					|
					|
					|
					|
				________|________
				|	handle	|
				| -> connection	|
				|_______________|
					|
					|
				________|________
				| send TCP_SYN	|
				|_______________|
					|
					|
				________|________
				| await SYN_ACK	|
				|_______________|
					|
					|
					|


	close TCP connection
	____________________


	close() removes the connection and makes the socket
	handle number free reassignable within the process

	a shareable port remains available for <b>bind()</b>
	and may still have sockets bound to it
	
	a port not configured for sharing becomes available
	for binding to one socket

	close() returns immediately. There is no blocking






</pre>
</div>

<h3>3.2 UDP Server Response Low-Overhead Routines</h3>

These network routines make UDP servers simpler to construct
and allow responses to be transmitted at very low overhead

<h4>3.2.1 Zero-Copy Reference to User Datagrams</h4>

<p>
A server which has succesfully bound to its UDP port can
use the long address of the kernel port structure to
examine its input queue for User Datagrams

<div	style="font-size:11pt">
<pre>

00:000046 600E73              +121      la      (IPPROTO_UDP*/16)
00:000047 FF0E74              +122      call    (__socket)
(+01)0f
00:000048 2002EB              +123      sa      socket1
00:000049 E60092              +124      jna     fp_error
00:00004A 6D1200              +125      lb, xi  FPSERVER_PORT
00:00004B 280007              +126      sb      7
00:00004C 300006              +127      z       6
00:00004D FF0E75              +128      call    (bind)

</pre>
</div>

<p>
These void sections give name structures to data structures

<div    style="font-size:11pt">
<pre>
				   $(66::,x)		. pointer to a port structure
				   s	socket

				   $(70::,fp)		. pointer to a network buffer
				   descriptor acw	. descriptor



				   $(0)			. resume the instruction section
</pre>
</div>
<p>


bind() returns the bank index and word offset of the port in registers 10:11

<div    style="font-size:11pt">
<pre>
				 
00:000050 CF000A              +132      dl      10
(+01)0f
00:000051 C702ED              +133      ds      portcb_lva . save that

</pre>
</div>
Register <b>b</b> is already loaded from register <b>11</b>.
The address points to address window BSOCKET.
The receive input queue is sampled

<div    style="font-size:11pt">
<pre>

00:000055 34002F              +139      sabr    BSOCKET
  :                            140 
<div    style="color:FF0000">00:000056 68D006              +141 fp_rx1 lb      s:udp:socket_inq:head, b
</div>00:000057 CE0092              +142      jzb     fp_no_traffic

</pre>
</div>

<h4>3.2.2 Constructing a User Datagram Response: udp_rtxbuffer</h4>

<b>udp_rtxbuffer</b> constructs a response datagram addressed to the remote
socket. It doesn't yet have data or checksums, but it has everything else

<p>
Call <b>udp_rtxbuffer</b> with the descriptor of the received user datagram
in <b>b</b> and the maximum bytes needed for the reply in <b>a</b>. Here the
reply will be a text string of a floating point number, up to 21 mantissa
digits and up to seven exponent digits. Some edit characters as well

<div    style="font-size:11pt">
<pre>

00:00005D 650020              +151      la, xi  21+7+1+2+1
<div    style="color:FF0000">00:00005E FF0E76              +152      call    (udp_rtxbuffer)
</div>00:00005F C6008E              +153      jza     fp_release

</pre>
</div>

If the response buffer is granted, its descriptor is in <b>a</b>

<p>
Library will be called to scan inputs, and later to edit outputs. Library
is generated for a number of byte and data code configurations. The library
version for two UTF8 characters per data word is called, because both input
and output are zero copy. The socket buffers store 16 bits of network data
per word

<p>
Distribution two octets per 24-bit word is made transparent to streaming
with the PSR flags <b>b$stream16r</b> and <b>b$stream16w</b>

<div    style="font-size:11pt">
<pre>

		Text Word in Socket Buffers
		___________________________

		_____________________________________
		| 0000 0000 | UTF8 byte | UTF8 byte |
		|___________|___________|___________|

</pre>
</div>

RTA1 bit-stream read and write channels make scan and edit irreducibly efficient for any data byte<br>
size and encoding

<p>
This example shows initialisation of bit stream control registers for scan and format library routines.<br>

Address pointers are copied from message descriptors

<div    style="font-size:11pt">
<pre>

00:000058 F8D003              +143      push    descriptor:bytes, b
00:000059 380010              +144      pop     BYTES			. don't forget to stop
  :                            145
00:00005A 300014              +146      z       RDATAC			. no bits read yet
  :                            147
00:00005B F8D006              +148      push    descriptor:apdata, b	. data word read pointer
00:00005C 38000D              +149      pop     q

</pre>
</div>

The bit-stream parameters for library edit before transmission will be used later
but can be prepared now

<div    style="font-size:11pt">
<pre>


00:000060 58C006              +155      ly      descriptor:apdata, a
00:000061 20F009              +156      sa      response_axw
00:000062 18000C              +157      sy      p			. data word write pointer
00:000063 300016              +158      z       WDATAC			. no bits written yet
00:000064 300017              +159      z       WDATA


</pre>
</div>

The application starts its functional part...

<div    style="font-size:11pt">
<pre>

00:000065 FF0E77              +161      call    (floating_scan)
00:000066 47F004              +162      qs      left
  :                            163
00:000067 FF0E78              +164      call    (symbol_scan)
00:000068 20F008              +165      sa      operator
  :                            166
00:000069 FF0E77              +167      call    (floating_scan)
00:00006A 47F000              +168      qs      right
  :                            169
00:00006B 60F008              +170      la      operator
  :                            171
00:00006C 680004              +172      anu, xi '+'
00:00006D DD002B              +172
00:00006E CE0079              +173      jzb     fp_add
00:00006F 680004              +174      anu, xi '-'


</pre>
</div>

...and finishes soon after


<div    style="font-size:11pt">
<pre>
00:00007F 4FF004              +190      ql      left
00:000080 77F000              +191      fm      right
00:000081 B60085              +192      j       fp_edit
  :                            193 fp_divide
00:000082 4FF004              +194      ql      left
00:000083 7FF000              +195      fd      right
00:000084 B60085              +196      j       fp_edit
  :                            197 fp_nop
  :                            198 fp_edit
00:000085 300010              +199      z       BYTES
00:000086 FF0E79              +200      call    (floating_edit)
  :                            201
00:000087 600E7A              +202      la      ("":10:0:0)	. we'd like to add a line feed
00:000088 1D0018              +203      wsr     24		. we must drive the last bits
								. thru the bit-stream write channel
</pre>
</div>

<h4>3.2.3 Transmitting the Response: udp_acw_send</h4>

To send the User Datagram, write the byte count to the output descriptor
and call <b>udp_acw_send</b> with the descriptor address in register <b>x</b>

<div    style="font-size:11pt">
<pre>


00:000089 50F009              +205      lx      response_axw		. network buffer descriptor
00:00008A 600010              +206      la      BYTES			. edit output byte count
00:00008B 64C001              +207      la, i   1, a			. plus the LF we added
00:00008C 20A003              +208      sa      descriptor:bytes, x	. tell the network the number
  :                            209
  :                            210
<div	style="color:FF0000">00:00008D FF0E7B              +211      call    (udp_acw_send)</div>


</pre>
</div>

If checksums are not required, the equivalent routine is <b>udp_acw_send_nocheck</b>

<p>
<h4>3.2.4 Discarding the Input: release_udgram</h4>
The received user datagram has been sampled but not taken from the port queue

<p>
Data was zero-copy processed at the head of the queue. It is now necessary to
discard that datagram or the server will loop and answer it indefinitely

<p>
The parameter of <b>release_udgram</b> is the port structure address in register <b>x</b>

<div    style="font-size:11pt">
<pre>

  :                            212
  :                            213 fp_release
(+01)0f
00:00008E 5002EE              +214      lx      portcb                  . port structure
<div    style="color:FF0000">00:00008F FF0E7C              +215      call    (release_udgram)
</div>(+01)0f
00:000090 6802EE              +216      lb      portcb                  . port structure
00:000091 B60056              +217      j       fp_rx1
  :                            218 fp_no_traffic


</pre>
</div>


<p>

<h3>3.3 Network Buffer Descriptor</h3>

The Network Buffer Descriptor of the T77.4 protocol stack is an eight-word
block containing stacked pointers

<div    style="font-size:11pt">
<pre>


	_________________________
	|	*next		|	linked list or queue forward pointer
	|_______________________|
	|	*frame		|	start address of the buffer
	|_______________________|
	|	*i_f		|	receiving interface ID
	|_______________________|
	|	 bytes		|	data octets count / byte write cursor
	|_______________________|
	|	*dgram		|	IP datagram address
	|_______________________|
	|	*uproto		|	transmission protocol {udp|tcp|icmp} header address 
	|_______________________|
	|	*apdata		|	application data address
	|_______________________|
	|	 readpoint	|	byte read cursor
	|_______________________|




</pre>
</div>


The buffer descriptor has the macro name <b>acw</b>

<p>
*frame is the buffer start address

<p>Header lengths are subtracted from the bytes count as the
buffer moves up the protocol stack. Header lengths are added
as the buffer moves downwards from the socket layer to the interface

<p>
On *frame receive, the link layer writes the *dgram pointer,
IP writes the UDP/TCP/ICMP PDU pointer, UDP or TCP writes the
application data  pointer

<p>
Overlapping receive fragments in IP cause *uproto and *apdata
to go up and bytes count to go down. The pointers are addresses

<p>
readpoint is not an address but a tally of octets read

<p>
Overlapping TCP segments on receive cause readpoint to go up.
Byte count stays unchanged

<p>
Each data word in network buffers contains eight zero bits and 16 data bits

<p>
readpoint advances in TCP socket reads. The read word address is *apdata+readpoint/2

<p>
readpoint designates an even or odd byte position at the start of a read request

<p>
The segment is read when readpoint reaches bytes

<p>
bytes advances in TCP socket write. The write word address is *apdata+bytes/2

<p>
bytes designates an even or odd byte position at the start of a write request

<p>
The segment is full when bytes reaches MSS

<p>
The socket user may direct TCP to send a segment directly with each socket write

<p>
UDP write is datagram quantum


<h3>3.4 TCP Low-Level Routines</h3>

<p>
The following are low-level network calls which are the building blocks
of the well-known socket interface

<p>
Instead of passing handles these routines use the kernel port and connection structures

<p>
There are two reasons for making this lower-level interface available
to applications

<p>
IP Protocols implementation <b>T77.4</b> allows one server
thread to have some millions of TCP connections.
See <b>3.4 The High-Volume Network API</b> below.
No process may have millions of handles. It is not desirable
to have have process tables with millions of elements

<p>
Some processing is also sidestepped with these low-level calls


<pre>

	<b>lx	connection
	call	(xaccept)</b>

</pre>

<p>
<b>xaccept</b> moves a passive connect from <b>SYNC_RECEIVED</b> to <b>ESTABLISHED</b> state

<p>
The transmission control block address is in <b>x</b>

<p>
TCP_SYN_ACK is sent to the remote socket with MSS option

<p>
<b>xaccept</b> is the building block of the <b>accept()</b> call

<p>
to walk the open and half-open connnections attached to a
port, it is necessary to bind a listening socket to that port

<p>
<b>bind</b> returns the bank:offset address in kernel space of the
listening port cell in registers 10:11

<p>
The bank containing the port cell is based at address window
<b>BSOCKET</b>

<p>
The socket attribute <b>tbase</b> is retrieved to identify the bank
where this socket has connections

<p>
The bank containing connection blocks is based at address window
<b>BSOCKET</b>

<p>
the connections in this bank are in 32 ordered chains and the
chain for the local port is a function of the local port number

<p>
the local port number may be known at assembly time and the
chain function can then be resolved at assembly

<p>
a local port number picked at runtime must be resolved to its
chain address at <b>bind</b>. A randomly numbered listening port is
possible with services bound to <b>portmapper()</b>

<div	style="font-size:11pt">
<pre>

	
	A simple server application example
	___________________________________


	$(1)					. private data bank

	tcp_socket_handle	+	0	. cached handle
	connections_bank	+	0	. cached connections array bank ID
	port_socket_long_address +	0:d	. cached Bank / offset of port cell

	connection_chain_head
		+	BSOCKET*/12++tlist:chain(1)+TPORTCHAIN(LISTENING_PORT)

	listening_port		+	LISTENING_PORT
	connection		+	0


	$(69::,b)				. pointer
	s		socket

	$(66::,x)				. pointer
	transmission	tcp_connection

	$(67::,y)				. pointer to array of connections
	tlist		tbank

	$(3)					. application data bank

	application_data $res	MAXIMUM_MESSAGE

	$(0)					. instruction bank

	first_time
		la	(IPPROTO_TCP*/16) . acquire a socket
		<b>call	(__socket)</b>
		jna	socket_error

		sa	tcp_socket_handle
		lb, xi	LISTENING_PORT

		sb	7
		z	6
		<b>call	(bind)</b>	. bind to the port

		jna	bind_error

		dl	10		. save the long address
		ds	port_socket_long_address . of the port socket

		sabr	BSOCKET		. and base it

				. register b is now a pointer to
				. the port socket structure

		push	s:tbase		. cache the bank ID
		pop	connections_bank . of the connections array

				. conditional assembly where the port number
				. is not known at assembly time

		$if	LISTENING_PORT=0

		.	if <b>bind</b> chose the port number

		la	s:socket_address+1
		and	(00FFFF)
		sa	listening_port
		<b>call	(tcp_hash_localsocket)</b>
		aa	(BSOCKET*/12++tlist:chain(1))
		sa	connection_chain_head

		$endif

	subsequently
		la	connections_bank . base the connections array
		sabr	BSOCKET

		lx      connection_chain_head
					. walk the chain which includes this port

		lk	(00FFFF)	. compare mask for
					. local port # in chain

	walk	lx	transmission:next . move along the hash chain
		tz	x
		j	a_connection
		j	no_more_connections

	a_connection
		la	transmission:socket_address+1
		mta	listening_port	. chains are shareable
		j	walk

		.	connection found for this port

		la	transmission:state
		anu, xi	<b>TCP_ESTABLISHED</b>
		jzb	traffic?
		anu, xi	<b>TCP_SYNRECEIVED</b>
		jnzb	walk		. TCP will service any other state

		<b>call	(xaccept)</b>	. move the state to TCP_ESTABLISHED

		sx	connection	. application processing will
					. certainly use register x

	traffic?
		la	transmission:receiveq:head
		jza	walk

		. if the traffic is known to be IP_DNF and TCP_PSH
		. the server can process the message in the socket buffer
		. otherwise the data must be read from the socket 


		$if	GUARANTEED_SIMPLE_MESSAGE

		lr	descriptor:bytes, a
		push	descriptor:apdata, a
		pop	q
		on	b$stream$16r	. the socket buffer uses
					. 16 data bits per word

		lcal	scan_and_respond . the application code
		lx	connection
		call	(tcp_release_rxline)	. sorted

		$else


		. 	for the sake of example this is something like
		. 	an XDR marked record and a 4-byte message length
		. 	needs to be read before the message



		lx	connection			
		push	application_data,,xi		. input buffer address
		pop	p
		z	SOCKET_OPTIONS			. blocking
		la, xi	4				. read a message length
		call	(tcp_rx)
		jnzb	incomplete			. if a = 4 then b = 0

		push	application_data,,xi		. set the receive address
		pop	p				. again
		dl	application_data		. expected length in a
		dsl	8
		push	a
		call	(tcp_rx)
		pop	r
		jnzb	incomplete			. if a = message length
							. then b = 0

		push	application_data,,xi
		pop	q
		off	b$stream16r			. the internal buffer uses
							. 24 data bits per word
		lcal	scan_and_respond

		lx	connection
				
		$endif

		j	walk

	scan_and_respond

		lcal	process

		lx	connection
		la	output_bytes

		push,xi output_data

	        pop      q
        	push,xi 05000++TCP_ACK++TCP_PSH
        	pop     SOCKET_CALL_FLAGS
        	call    (tcp_tx)
        	lret    0

</pre>
</div>

If it is assured that incoming segments are IP_DNF and TCP_PSH, then they can
be sampled zero-copy on the connection input queue and afterwards dropped
with <b>tcp_release_rxline</b>

<p>
Otherwise TCP must be called as a socket stream protocol. The example shows
<b>tcp_rx</b> being called twice, the first time in order to read a message
length

<p>
<b>tcp_rx</b> can be called instead of <b>recv()</b> if the connection block
is available, and <i>must</i> be called instead of <b>recv()</b> if there
is no POSIX handle for the connection

<p>
<b>tcp_rx</b> is part of the Low-Overhead Network API and bypasses some
processing resolving the handle. The two <b>tcp_rx</b> calls here are
the equivalent of
<pre>

	c	(recv)	tcp_socket_handle	application_data,,xi	4,,xi	0,,xi
	jna	problem
	dl	application_data
	dsl	8
	call	(recv)	tcp_socket_handle	application_data,,xi	a	0,,xi
	jna	problem

</pre>
<p>
There is nothing like zero copy output message construction in a TCP segment buffer.
The Low-Overhead Network API TCP send call is <b>tcp_tx</b>

<p>
<b>tcp_tx</b> can be called instead of <b>send()</b> if the connection block
is available, and <i>must</i> be called instead of <b>send()</b> if there
is no POSIX handle for the connection, as when one process has millions
of connections

<p>
tcp_rx</b> is part of the Low-Overhead network API and bypasses some
processing resolving the handle. The example shown is the equivalent of
<pre>

	c	(send)	tcp_socket_handle	output_data,,xi	output_bytes	TCP_PSH

</pre>

<p>
The TCP High-Volume Network API has some of the same call interfaces
as the Low-Overhead Network API but is structurally different because
the connection array banks are one per local port and the hash index
within them is a function of the remote network address
<pre>

	call	(tcp_hash_remotesocket)


</pre>
 

<h3>3.5 The TCP High-Volume Network API</h3>

<p>
A server thread may listen on some millions of TCP connections at once

<p>
The connections are sustained and carry a remote client session

<p>
Listening ports for very large numbers of connections have a dedicated
connection bank per port containing up to 169 connections

<p>
A single listening thread can serve 60000 or more listening ports. portmapper
protocol constantly updates which port is advertised for the service

<p>
Each listening port configured for high-volume activity has a private
receive and transmit buffer pool for its collection of connections

<p>
This is necessary largely because transmit segments must remained buffered
until the remote socket acknowledges them. Receive and transmit segments
additionally are never in the address space of any other applications. This
may have a security advantage

<p>
TCP accepts incoming connections automatically on the ports designated
high-volume. Handles exist neither for the connections nor the ports.
A protocol upper sublayer transfers complete input messages to a single
input queue per application. For message integrity and rapid service,
segments in each direction are required to be IP_DNF and TCP_PSH

<p>
The application accesses the TCP transmission block directly to transmit
a response segment
 
<p>
The preferred authentication model is RPC, which supports many authentication
schemes. The multiplexing of many ports on one input queue is made possible
by the RPC protocol portmapper. XDR is also supported for binary data. A text
based service may use RPC and XDR with a single opaque field containing text

<p>
The port is configured for high volume use by installing flags
and bank pointers in TCP's internal port descriptor. These bank pointers
designate the array of connections which can be constructed for the port,
and the receive and transmit buffer pools. The connection array bank
contains a pointer to the single input queue which all ports attached
to the application must write

<p>
The configuration step <b>add_hv_port()</b> adds resources to the port,
attaches its traffic to the application input queue, and adds it to
the list of ports which portmapper is directed to advertise for the
application according to comparative load and availability

<p>
<b>add_hv_port()</b> takes the place of <b>bind()</b>

<p>
The address structure which identifies the port can also specify a
local network address and a specific interface. This allows interface
load to be directed dynamically via the port numbers which are
alternated to portmapper

<div	style="font-size:11pt">
<pre>

	c	(add_hv_port)	;
		($sockaddr	<i>RPC_PROGRAM 172.29.7.11:PORT_NUMBER I_F</i>),,quadword

</pre>
</div>

High Volume TCP listening resources need not all be configured at startup. They
may be added port by port in response to demand for connections


<h2>4. API Service Building Blocks</h2>


These internal interrupt primitives are used as building blocks
in system services

<div	style="font-size:11pt">
<pre>
	HANDLE$            80		= bank 1  vector  16

					acquire a file or socket handle

					[example]
					la	(IPPROTO_UDP*/16:s)
					ii	HANDLE$


	FREE_HANDLE$       81		= bank 1  vector  17

					relinquish the file or socket handle
					number in application register a

	READ_HANDLE$       82		= bank 1  vector  18

					retrieve handle encoding into
					application registers a:b

					application supplies handle
					number in a

	READ_XVECTOR$      83		= bank 1  vector  19

					read the kernel vector bank
					location addressed by application
					register x into application register a


	WRITE_XVECTOR$     84		= bank 1  vector  20

					write the kernel vector bank
					location addressed by application
					register x from application register a
					

	READ_SOCKET$       85		= bank 1  vector  21

					handle number is in application
					register a

					return handle encoding + location of
					control cell in application a + b
					
	UHANDLE$           86		= bank 1  vector  22
					bind socket control cell to handle

					application d$save = handle number
					applicatio a = bank of control cell

					Return long address in
					application registers 10, 11

	KERNEL$B1          87		= bank 1  vector  23

					base a kernel B1 bank frame
					in address window B1

					application register a
					->kernel vector bank location of
					required kernel B1 frame pointer

	B1$                88		= bank 1  vector  24

					rebase the application current
					B1 bank frame in address window B1

	KERNEL$B1_1        89		= bank 1  vector  25

					base the kernel initial B1 bank
					frame in address window B1


	XBASE$32           96		= bank1	vector	32
	XBASE$33           97		= bank1	vector	33
	XBASE$34           98		= bank1	vector	34
	XBASE$35           99		= bank1	vector	35
	XBASE$36           100		= bank1	vector	36
	XBASE$37           101		= bank1	vector	37
	XBASE$38           102		= bank1	vector	38
	XBASE$39           103		= bank1	vector	39
	XBASE$40           104		= bank1	vector	40
	XBASE$41           105		= bank1	vector	41
	XBASE$42           106		= bank1	vector	42
	XBASE$43           107		= bank1	vector	43

                                        bank 1 vectors 32..43
                                        request to base a device array

	smaragd7 kernel bases specialised arrays outside system memory
	(devices) in a few banks starting from B32. To avoid accident,
	only interrupt code is allowed to do this. Internal interrupts
	XBASE$32..XBASE$43 are available to base device array banks


</pre>
</div>

<h2>5. File System InterFace</h2>

<h3>5.1 POSIX API</h3>

The targeted file system interface has a POSIX-like API

<div    style="font-size:11pt">
<pre>

	int open(char *path, int flags, int permissions);

	int read(int handle, char *buffer, int words);

	int write(int handle, char *buffer, int words);

	unsigned long lseek(int handle, long target_word, int whence);

	int rewind(int handle);

	int close(int handle);

</pre>
</div>
The open file is a stream of RTA1 24-bit words. Argument 3 and return value
of read() and write() plus target-position and result-position of lseek()
are a count of words

<p>
An open flag O_8 makes the open file a stream of octets instead of words.
Return value and length argument of read() and write() are then a count of
octets. So are the target-position and result-position of lseek()

<p>
There is no difference in the organisation of the file system between
open() for the default word stream interface and open() for octets.
The octet stream interface is intended for situations like NFS server.
The word stream interface is better optimised

<p>
The files recorded in the file system are not in any way different according
to whether they are loaded, read or written with the word or octet interface

<p>
There is also a minimal API for transmitting entire files on networks.
It uses no handles but presents each buffered file extent successively
to the socket

<p>
<b>open()</b> returns a handle identifier unique within the process


<p>
Returned value less than zero indentifies a problem in all file
system routines. A range of negative values indicates the problem
directly. There is no errno

<p>
The file handle value is the first argument in every file system
interface routine except <b>open()</b>

<h3>5.2 File System Types and Low-Level Interfaces</h3>

Below the POSIX-like API there are driver interfaces for NFS client,
removable Flash memory-stick / card, and RTA1 memory array file system

<p>
The first to be implemented are the RTA1 Core Resident File System
and the RTA1 memory array file system. Both are
accessible at a low-level interface below the POSIX-like interface

<h3>5.3 Core Resident File System</h3>

The Core Resident File System is largely intended to be ROM-resident
and is present in case the system has no filestore devices outside
executable space

<p>
Many Core Resident File Systems may be linked into a load image. They
each occupy a range of 4K-Word banks. An initial purpose of them is the
dynamic load of the initial RAM values of process instances at launch

<p>
Where it is preferred to execute from RAM instead of ROM, all the
parts of programs can be unpacked from Core Resident File Systems

<p>
Files in Core Resident File Systems can be read without any directory
search. The application assembly / link effectively opens all resident
files

<p>
Two low-level calls used to read files in Core Resident File Systems are
<pre>

	c	(fsrom_da)	file_access_block,,i		;
				FS5_START_BANK_INDEX,,XI	;
				(my_filename:d),,long


	c	(fsrom_read)	file_access_block,,i		;
				buffer,,i			;
				words_requested,,xi

	jna	problem
	jza	complete


</pre>

The filename used at the intialisation call is an assembly label exported
at the construction of the file system image. The utility <b>4kformat</b>
is executed with <b>-x</b> option causing the file system to be written as
a linkable masmx <b>.txo</b> file and the filename to be exported as a label
for linking. This name must be unique in the load image because it is a link
label as well as a filename. Link labels are not compartmented by directory
structure

<pre>

	$ 4kformat -x fsystem5.txo
	volume	fsystem5
	tree	seg$load
	file	my_filename binary_input_filename
	.
	.

</pre>
The two periods are required. They are not a hint at further text.
The first period returns from directory seg$load to volume root
directory fsystem5. The second period exits 4kformat utility

<p>
The inclusion of fsystem5.txo in the final image has the pattern
<pre>

	$ masmx 	-kln

		$include	freeware/RTA1/rta/def/map1.def
		$include,$binary	everything_else

FS5_START_BANK_INDEX $equ	NEXT_ADDRESS//4096	. a 4K bank index

		$include,$binary	fsystem5
		$store			totalimage

</pre>


Core Resident File Systems applied to software RAM segment load
are described in the section on linking and load image formatting
in the accompanying manual <b>masmx for RTA1</b>

<h3>5.4 Low Level File Access Structure</h3>

The access structure for data files is common for file system types. At the POSIX
interface open() function assigns the access structure and binds it to the handle

<pre>

		$include freeware/RTA1/rta/fs/fs.def
		____________________________________


	macro filep	block used in simple serial read, 6 words
	macro fileq	block with rewind/seek state, 10 words


	________________________________________________
	|	serialp:fs_type	|	serialp:device	|
	|_______________________|_______________________|
	|		serialp:extentp			|
	|_______________________________________________|
	|		serialp:absolute_pointer	|
	|_______________________________________________|
	|		rewind_extentp			|
	|_______________________________________________|
	|		quantum_pointer			|
	|_______________________________________________|



</pre>

<b>fs_type</b> defines the driver functions for the device
<p>
<b>device</b> is also labelled <b>bank</b> and is for core-resident and device-array
file systems the bank index where the file system starts

<p>
<b>extentp</b> is the long address bank:base:offset of the descriptor of the
file extent currently being processed, initially the first extent which is
also the file header

<p>
<b>absolute_pointer</b>  is the current word position relative
to the start of the device

<p>
The two remaining 48-bit fields are required if rewind or seek
is carried out

<p>
<b>rewind_extentp</b> is a saved copy of the initial file extent descriptor
long address. It is recopied to extentp for rewind / backward seek

<p>
<b>quantum_pointer</b> is the current word position relative to the
start of the file

<p>
There is also a set of octet-oriented functions for
data file processing and for these, <b>quantum_pointer</b> is the
current octet position relative to the start of the file

<p>
This structure is the first parameter by address of these file system low-level calls
<pre>

	fsrom_da	start core file using known offset of 1st extent descriptor
	fsrom_read	read data words from core file

	fs_dev_start	start file with using long address of 1st extent descriptor
	fs_dev_read	read data words
	fs_dev_write	write data words
	fs_dev_rewind	restart file with saved long address of 1st extent descriptor
			quantum_pointer = 0

	fs_dev_seek	reposition
	fs_dev_open
	fs_dev_close

	fs_dev_seek8	reposition. Anticipated use in NFS server
	fs_dev_read8	read data octets. Anticipated use in NFS server
	fs_dev_write8	write data octets. Anticipated use in NFS server

</pre>
<h3>5.5 Memory Device Array File System</h3>

File systems in external device memory arrays cannot be linked for
assembly-time file location as Core Resident File Systems can

<p>Files in device arrays are opened with a directory search because they
are not bound to the system image

<p>
fsformat utility constructs Device Memory Array file systems offline.
An example construction shows the period command returning upward
from each directory and the loaded filenames followed by source paths
<pre>

	$ fsformat fsimage5
volume remington
tree boot$
tree left_boot
.
tree right_boot
.
.
tree free$tree$
.
tree etc
file network.txt etc.rta/network.txt
.
tree web
file index.html rta.doc/index.html
file rta.html rta.doc/rta.txt
file smaragd7.html rta.doc/smaragd7.txt
file language.html rta.doc/language.txt
file masmx7r3.html rta.doc/masmx7r3.txt
file connect.html rta.doc/connect.txt
file q_a.html rta.doc/q_a.txt
file footnote.html rta.doc/footnote.txt
file gnu_gpl.html rta.doc/gnu_gpl.html
.
.


</pre>
The memory array file system is an array of up to 17,179,869,184
24-bit words outside executable space. Each memory array file system
occupies one of the 63 devices configurable outside executable space

<p>
Device memory contains all descriptors and data in the memory array
file system. To implement equivalent routines for file systems which are
not memory arrays, the drivers would need to buffer the descriptors and
data before returning pointers to the caller

<p>
This file system has been implemented initially as a read-only store
constructed offline and loaded with the emulator

<p>
The memory array file system is hierarchic and organised in directories
and files

<p>
The available lookup routines return a pointer to a buffered directory entry
or to a buffered file extent

<p>
The call <b>fs_find</b> advances from a 48-bit starting point in registers
<b>a:b</b> to locate the directory or file named in the string addressed by
<b>y</b>

<div    style="font-size:11pt">
<pre>

        lr, xi  1		. # words in search name
        ly, xi  $1("web")	. search name in ASCII
        dsr     48		. default start point
        call    (fs_find)
	ds	web_directory_start_point	

</pre>
</div>

The starting point is the pointer to the first block of a directory.
It is a long address with the layout

<div    style="font-size:11pt">
<pre>

		big.large_bank_identifier.device.memory_space_address


	 46|		       30|    24|			       0|	
	___|_____________________|______|_______________________________|
	|01|large_bank_identifier|device|      memory space address	|
	|__|_____________________|______|_______________________________|

</pre>
</div>

If the starting point is zero, the driver starts at the root directory
of the default device

<p>
The target string can be the name of a directory or a file, or a link

<p>
The string only has zero-padding, not zero termination. The length in register
<b>r</b> is the containing number of words of the name

<p>
The return value in <b>a:b</b> is a new long address pointing
to the target file or directory target entry. If the target is not found,
the return is zero

<p>
The long address does not need to be based before the call

<p>
<b>fs_dsearch</b> is similar to <b>fs_find</b>, except the input
long address must point to a directory descriptor. A search
will take place within that directory

<div    style="font-size:11pt">
<pre>

	dl	web_directory_start_point
	lx, xi	("document.html")
	lr, xi	5
	call	(fs_dsearch)	
	ds	file_cursor
	jdz	not_found
	
</pre>
</div>

<b>fs_dsearch</b> returns the long address of the first extent
descriptor of the file in <b>a:b</b>

<p>
<b>fs_xbase</b> places the file extent data pointed by extent descriptor
<b>a:b</b> into the memory space, and returns the long 
address of the following extent descriptor in registers <b>a:b</b>

<div    style="font-size:11pt">
<pre>

	dl	file_cursor
	jdz	end_of_file
	call	(fs_xbase)

	ds	file_cursor
	sr	bytes_available
	sy	data_address
	
</pre>
</div>

Register <b>y</b> points to the file data. The whole extent is in the
address space. <b>r</b> contains the number of octets in the extent.
<b>a:b</b> contain the long address of the following extent
descriptor

<p>
Routines <b>fs_1st</b> and <b>fs_read</b> in the memory array file system
interface are components for more complex calls. <b>fs_1st</b> returns the
long address of the first directory entry in the default file system.
<b>fs_read</b> returns the directory next entry. The caller must filter and
interpret the returned entries

<p>
File space in the memory array file system is awarded in multiples of 64
words. A single file extent is a maximum of 262144 words in size

<p>
space for directories is awarded in chained blocks of 1024 words

<h3>5.6 File Directory Layouts</h3>

Directory entry structures start with a format word which identifies
the entry type and size in words, excluding the format word itself

<div    style="font-size:11pt">
<pre>

	directory entry format word
	___________________________
	
	      16|      8|      0|
	________|_______|_______|
	|  type |       | words |
	|_______|_______|_______|



	Directory entries with bit 23 = 0 contain an 8-bit
	count of following words in bits 7..0

	Directory entries with bit 23 = 1 contain a 16-bit
	count of following words in bits 15..0




	directory page header
	_____________________

	Each page of a directory has a header format word
	and four control words


	47					       0
	_________________________________________________
	|  'P'  |   0   |   4   |next write word in page|
	|_______|_______|_______|_______________________|
	|unwritten words in page|
	|_______________________|________________________
	|	start granule of next page in directory	|
	|_______________________________________________|


	Directory pages may be any number of granules in size
	and are by default 1024 words

	The pointer next write word points to unused words
	at the end of the directory page



	Unused space at page end is one case of a bypass record.
        The record format word of a bypass record has bit 23 set
	to indicate that the count of following words is a 16-bit
	field in bits 15..0

	If the bypass record is only one word long, the length
	field is zero

	Bypass records are inserted to assist directory searches
	in navigating beyond unused words in directories.
	Directory entries never straddle pages

	A bypass record including its header word is re-usable space
	


	bypass record
	_____________

	23	 15	       0
	_________________________
	|  0x80	|following words|
	|_______|_______________| 




	End of page record indicates that subsequent directory entries
	if any are on following directory pages, found with the next
	page first granule pointer in the directory page header

	The end of page record has a following words count of zero
	to indicate that it consists only of a record format word

	The last word of a directory page is always a page end record



	end of directory page record
	_____________________________


	23	15	       0
	_________________________
	|  'E'	|   0	|   0	|
	|_______|_______|_______|






	filetree (directory) label
	__________________________

	47					       0
	_________________________________________________
	|  'D'  |   0   | words |  granules first page	|
	|_______|_______|_______|_______________________|
        |    start granule of first directory page	|
	|_______________________________________________|
	|	name...   ...   ...   ...   ...   ...   ...   ...
	|_______________________|_______________________|
	




	The volume label is in the top directory and
	does not describe it. It describes space on
	the medium


	volume label
	____________

        47                                             0
        _________________________________________________
        |  'V'  |   0   | words | size of device medium	|
        |_______|_______|_______|_in_banks_of_256K_words|
        |       next assignable 64-word granule         |
        |_______________________________________________| 
        |	name...   ...	...   ...   ...   ...   ...   ...
        |_______________________|_______________________|




	file label
	__________

        47                                             0
        _________________________________________________
        |  'F'  |   0   | words | granules first extent |
        |_______|_______|_______|_______________________|
        |                  start granule                |
        |_______________________________________________|
        |   granule containing next extent descriptor   |
        |_______________________________________________| 
        |   word offset next    |file written octets msW|    
        |___extent descriptor___|_______________________|
        |file written octets lsW|	name...   ...   ...  ...
        |_______________________|_______________________|



	file extent label
	_________________

        47                                             0
        _________________________________________________
        |  'X'  |   0   | words | granules this extent  |
        |_______|_______|___=_6_|_______________________|
        |                  start granule                |
        |_______________________________________________|
        |   granule containing next extent descriptor   |
        |_______________________________________________|
        |   word offset next    |
        |___extent descriptor___|



	Very large files requiring rapid and frequent seek actions
	have, instead of linked extent descriptors, a differently
	constructed file label containing a compressed array of
	descriptors to large extents



	link
	____

        47                                             0
        _________________________________________________
        |  'L'  |   0   | words |   word offset target  |
        |_______|_______|_______|___________descriptor__|
        |      granule containing target descriptor     |
        |_______________________________________________|
        |	name...		...		...
        |_______________________|




</pre>
</div>



<i>
<pre>
_______________________________________________________________________________________


LICENCE NOTE

    Copyright Tim Cox, 2012
    TimMilesCox@gmx.ch

    This document is part of the RTA1 Processor Programmable Architecture.

    RTA1 is a free processor architecture specification. It is licensed
    under the GNU General Public Licence Version 3

    The executable emulation of RTA1 is free software.

    Instruction code for the target RTA1 architecture is free software
    if it is delivered with this software

    Software programs delivered with this software to connect the
    emulated RTA1 with real network interfaces in the emulator host
    are free software

    Scripts and programs delivered with this software for running
    on other computers and interacting with the RTA1 are free software

    Scripts and utility programs for constructing RTA1 target
    executable software are free software

    You can redistribute it and/or modify RTA1
    under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    RTA1 is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with RTA1.  If not, see &lt;http://www.gnu.org/licenses/&gt;.



</pre>
</i>

</div>
</html>

