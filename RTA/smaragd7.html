<html>
<div	style="font-size:15pt">

<center>

<h1>The smaragd7 Kernel and API</h1>

<i>
Copyright Tim Cox, 2012<br>
This document is part of the RTA1 Processor Programmable Architecture<br>
The RTA1 Architecture is freeware licensed with the GNU General Public Licence Version 3<br>
The same licence encompasses all accompanying software and documentation <br>
The full licence text is included with these materials<br>
See also the licensing notice at the foot of this document
</i>

</center>

<ol>

	<li>API</li>
	<ol>
		<li>Posix Layer and Low Level Interface</li>

		<li>Kernel Call Interface and Internal Interrupt Interface</li>
	</ol>
	<li>Primitive Kernel Routines</li>
	<ol>
		<li>Launching, Switching and Ending Tasks</li>

		<li>Adding and Releasing Task Storage</li>
	</ol>
	<li>Network API</li>
	<ol>
		<li>The POSIX Network API</li>

		<li>UDP Server Response Low-Level Calls</li>

		<li>TCP Low-Level Calls and the High-Volume Network API</li>
	</ol>
	
	<li>API Service Primitive Building Blocks</li>

	<li>File System Interface</li>
	<ol>
		<li>POSIX API</li>

		<li>File System Types and Low-Level Interfaces</li>

		<li>RTA1 Memory Array File System</li>
	</ol>
</ol>

<h2>1. API</h2>

<h3>1.1 Posix Layer and Low Level Interface</h3>

<p>
The smaragd7 kernel has services on a Posix model

<p>
The services are also addressable at a lower layer than the handle-based
Posix-model API

<p>
The lower level interfaces allow services on a far larger scale as well
as shortening software paths

<p>
Posix networking is centred on the handle, an integer token
for a socket. Sockets share a number space with file handles

<p>
On RTA1 with smaragd7 kernel, a single server application may have
several million sustained TCP connections. The remote user session
is modelled on the TCP connection.

<p>
The application does not have 5..10 million socket handles, but
instead binds to TCP service at a low level




<h3>1.2 Kernel Call Interface and Internal Interrupt Interface</h3>

Most kernel routines have a call interface and their
arguments are on the internal stack

<p>
Some calls are internal interrupts. They are called with
the <b>ii</b> internal interrupt instruction. Functional
wrappers can be place around these system calls

<p>
Macro language supports a structured call interface for application
calls and kernel calls. Detailed explanation is in the separate
document <b>Towards High-Level Languages for RTA1</b>

<p>
Kernel routines which temporarily alter the address space are
implemented as internal interrupts

<p>
Return from interrupt restores the caller's environment

<p>
Arguments for internal interrupts are typically in the application
accumulator registers
<pre>

	la	<i>argument</i>
	ii	<i>isr_vector</i>


</pre>
<p>

Interrupt vector values have the same layout as far call vector values.

<p>
A vector is a value with a 16-bit bank pointer and a 6-bit offset
<pre>

	00 bbbb bbbb bbbb bbbb offset

</pre>
An ISR vector value is the immediate operand of the internal
interrupt instruction <b>ii</b>
<pre>

	ii	ISR_VECTOR

</pre>
<p>
The operand of the far call instruction <b>call</b>
is a variable or a constant containing the vector value
of the target routine
<pre>

	call	(CALL_INTERFACE_VECTOR)

	call	variable

</pre>
<p>
ISRs and kernel call routines are not interchangeable in call method

<p>
An ISR reads parameters from the application arithmetic registers,
and returns by executing an interrupt return instruction <b>ir</b>

<p>
A far call routine executes in application mode and reads parameters 
from the internal stack. It returns by executing a far return instruction <b>fret</b>

<p>
All ISRs which are internal interrupt targets in OS smaragd7 are in the
4096-word bank at absolute address 4096, i.e. the second page of storage. 

<p>
So these ISR vector values are all in the range
<pre>

	64++[0..63]
	000000 000000 000001 xxxxxx

</pre>
<p>
The kernel call interface vectors in OS smaragd7 are in 4096-word instruction
banks starting from absolute address 8192, or the third page of system memory

<p>
Instruction banks can be any size up, but the kernel banks are the minimum
size of 4096 words for modularity

<p>
Network calls are in bank 2 at address 8192 and file system calls in bank 5
at address 20480

<p>
So those kernel call routines have vector values in these ranges
<pre>

        2*64++[0..63]
        00 0000 0000 0000 0010 yyyyyy

        5*64++[0..63]
        00 0000 0000 0000 0101 xxxxxx

</pre>
<p>
Because a 16-bit bank pointer to a 4K-granularity bank edge only addresses
256 megawords of executable space, the application <b>call</b> operand
may be a 19-bit pointer to a bank at a 32768-word boundary, with a 3-bit vector
offset, covering all 16 gigawords of executable space
<pre>

        00 bbbb bbbb bbbb bbbb vector   call vector value up to 256 MWord

        01 bbbb bbbb bbbb bbbb bbbvvv   call vector value up to 16 GWord

</pre>

<p>
High-memory vectors are not expected in kernel calls


<h2>2. Primitive Kernel Routines</h2>
<p>
The principal internal interrupts are these. There are more
used as building blocks for services
<pre>

	SPAWN$             66		= bank 1  vector  2

					task launch
					4 parameters in application
					registers a b mantissa2 mantissa3


	BANK$              67		= bank 1  vector  3

					storage acquire
					words requested in application
					register a


	ARRAY$             68		= bank 1  vector  4

					very large storage acquire
					4096-word blocks requested
					in application register a 

	BANK$FREE          69		= bank 1  vector  5

					storage relinquish
					absolute bank pointer in
					application register a


	YIELD$             65		= bank 1  vector  1

					task switch

					on preemptive event
					or event wait
					or voluntarily


	TWAIT$             91		= bank 1  vector  27

					task switch and wait milliseconds
					application register a contains
					millisecond count


	EXIT$              70		= bank 1  vector  6

					end task


</pre>

<h3>2.1 Launching, Switching and Ending Tasks: SPAWN$ YIELD$ TWAIT$ EXIT$</h3>

One task launches another with the SPAWN$ primitive
<pre>

        ql      (start_vector, PRIORITY, DATA_SPACE, -B1_OCCURENCES:q)
        ii      SPAWN$

</pre>


<p>
PRIORITY may not be < zero or > PRIORITIES-1

<p>
The highest priority is zero and the lowest PRIORITIES-1

<p>
DATA_SPACE is the amount of application data storage which the
application will receive and base in banks B3..B31

<p>
-B1_OCCURENCES is a negative number indicating the number of 4096-word
banks the application requires in its private B1 stack. The default is
-1, which means the application uses one private B1 bank

<p>
B1 banks are distinct from application data banks because their content
is encapsulated in the owning application or service. Addresses in B1
are not available to called or calling entities.

<p>
A simple application has one B1 bank. A service disposing tabled resources
has one or more

<p>
Subprogramming application models may also have a linear stack of B1 banks
or a service aligned multiple of B1 banks

<p>
The kernel assigns a single storage area starting with B1 banks, then a
4096-word Task Control Block, then a 4096-word vector bank which the
application will base in B2, then the initial DATA_SPACE

<p>
The kernel writes the base adresses of all banks initially supplied to the
task and all entry point vectors in the initial instruction bank into the vector bank

<p>
The instruction bank containing the start vector must be loaded before
SPAWN$

<p>
<b>YIELD$</b> is a voluntary task switch.

<p>
<b>YIELD$</b> may  be embedded in an event handler which is preemptive
and not voluntary,<br>
or in a service request which marks the task descriptor to block on events

<p>
<b>YIELD$</b> benefits only tasks of equal or higher priority if it is called
independently of preemptive or blocking events
<pre>

	ii	YIELD$

</pre>

<p>
<b>TWAIT$</b> is a voluntary task yield for a time in milliseconds

<p>
<b>TWAIT$</b> may  be embedded in an event handler which is preemptive
and not voluntary

<p>
When the wait time is expired, the task becomes a candidate for switching
<pre>

	la, xi	milliseconds
	ii	TWAIT$

</pre>

<p>
<b>EXIT$</b> deletes the task and pools its resources
<pre>

	ii	EXIT$

</pre>

<p>
If the application internal stack is exactly as at task entry, the
far return instruction <b>fret</b> can be used to end and delete a task
<pre>

	fret	0

</pre>


<h3>2.2 Adding and Releasing Task Storage: BANK$ ARRAY$ BANK$FREE</h3>

<p>
These primitives acquire or free storage banks up to 16 Gigawords in
size. The banks acquired are not automatically based and
may be too large to base all at once

<p>
This service is not similar to C-Language library calls for
obtaining buffers by pointer. C-Library manages memory which the task
already has, and does not return it to the smaragd7 kernel but to the 
application internal management

<p>
<b>BANK$</b> obtains a bank from 1 to 16777215 words in size and
records it in the task control block. The argument in application
register a is words requested. value returned in a is the bank
pointer. Zero = no memory granted
<pre>

	la, xi	WORDS_REQUESTED
	ii	BANK$

</pre>

<p>
<b>BANK$</b> granularity of memory grant is 4096-word blocks up to 262144
words and 262144-word blocks beyond

<p>
<b>ARRAY$</b> obtains a bank from 4096 words to 16 Gigawords in size
and records it in the task control block. The argument in application
register a is 4096-word blocks requested. value returned in a is the bank
pointer. Zero = no memory granted

<pre>

	la, xi	4K_BLOCKS_REQUESTED
	ii	ARRAY$

</pre>
<p>
<b>ARRAY$</b> granularity of memory grant is 262144-word blocks

<p>
<b>BANK$FREE</b> returns a bank of any size to the kernel. If the task
does not possess the bank, no action is taken. The argument in
application register a is the bank pointer
<pre>

	la	BANK_INDEX
	ii	BANK$FREE

</pre>
<h2>3. Network API</h2>
<p>
The network API is a handle-based call interface

<p>
An application using thousands or millions of sockets
calls a lower-level set of network calls

<p>
Error conditions return a range of negative values identifying the
problem. There is no errno variable

<h3>3.1 The POSIX Network API</h3>
<pre>

	acquiring a socket handle
	_________________________


	<b>la	([IPPROTO_TCP|IPPROTO_UDP]*/16)
	call	(__socket)</b>


	result in application register a
	+integer = socket ID
	-1	= handle not available
	-2	= protocol not supported




	binding to a port and optionally to a network address
	_____________________________________________________

	<b>{ dl	($net_socket 10.0.0.63:PORT) | dsr	48 }
	ds	6
	la	socket
	[lb, xi	0]
	call	(bind)</b>


	result in application register a
	0	= good
	-2	= handle is not TCP or UDP
	-3	= port number specified and not free
	-4	= no resource to model the socket




	receive
	_______

	<b>c	(recv)	socket_handle	buffer	bytes	flags</b>

	socket handle is the integer handle number

	For UDP sockets bit 23 of flags has a <b>PEEK</b> effect
	-the user datagram stays on the input queue

	flag bit 22 has <b>NON_BLOCKING</b> effect.
	<b>recv</b> is by default <b>BLOCKING</b>

	if a UDP socket has no user datagram available it
	blocks if flag bit 22 = 0

	if a TCP connection has less data available than
	requested it blocks if flag bit 22 = 0

	sockets receiving XDR data require BLOCKING to work
	correctly. Applications protocols with BLOCKING
	sockets must be separate tasks from the IP task

	the result in application register a is bytes read

	result -2 means the handle is neither a UDP socket
	nor a TCP connection

	result -99 means a TCP connection has received remote
	close



	receive from
	____________

	source addresses of User Datagrams can be retrieved
	on receive from the containing IP datagram

	a <b>receive from()</b> function which reads a destination
	from a <b>sockaddr_in</b> structure will be added with
	C compiler development



	send
	____

	<b>c	(send)	socket_handle	buffer	bytes	flags</b>

	socket_handle is the integer handle number

	for TCP sockets bit 3 of flags is TCP_PSH which sends
	immediately instead of on full segment

	result in application register a is bytes sent

	If the socket is NON_BLOCKING,
	if the transmission could not be immediately resourced
	actual bytes sent is in <b>a</b> and outstanding count in <b>b</b>

	a result of -2 indicates that the handle is neither
	a UDP socket not a TCP connection



	send to
	_______

	destination addresses for User Datagrams can be set
	before send

	a <b>send to()</b> function which reads addresses from
	a <b>sockaddr_in</b> structure will be added with
        C compiler development



	listen, TCP only
	________________

	Argument 1 is the socket bound to a TCP port,
	not to a TCP connection

	Argument 2 sets the socket in BLOCKING or in
	NON_BLOCKING mode

	NON_BLOCKING	$equ	0

		la	handle1				. no limit
		lb, xi	NON_BLOCKING			. = NON_BLOCKING
		call	(tcp_listen)
		
		la	handle2				. nonzero limit
		lb, xi	CONNECTION_WAITQ_MAXIMUM	. = BLOCKING
		call	(tcp_listen)

	there will be an error return in <b>a</b> if
	the handle in <b>a</b> is not a bound TCP port

	If the socket is BLOCKING, connections are
	only admitted with <b>tcp_accept</b> which
	always blocks

	If the socket is NON_BLOCKING, connections
	are accepted automatically

	Servers running in the IP task must not block



	tcp_accept, TCP only
	____________________


		la	handle
		call	(tcp_accept)

	<b>tcp_accept</b> blocks and should only be called
	on blocking sockets. The new connection handle must
	be saved before another <b>tcp_accept</b> is called

	The remote address is in the transmission control
	block, and if it is required anywhere else it must
	be copied from there

	an <b>accept()</b> function which writes a <b>sockaddr_in</b>
	structure will be added with C compiler development

	<b>accept</b> is a blocking call

	Servers running in the IP task must not block

	Incoming connections are accepted automatically on
	NON_BLOCKING sockets



	connect
	_______

		dl	($net_socket 10.0.0.65:REMOTE_PORT)
		ds	6
		la	socket
		call	(connect)

	<b>connect</b> in UDP associates the local
	socket with a remote socket, but causes no
	external protocol activity

 	<b>connect</b> in TCP returns a new handle to a
	new transmission control block

        <b>connect</b> is a blocking call
        
        Servers running in the IP task must not block

	NON_BLOCKING call <b>tcp_start_connection</b> in the
	high-volume interface starts the negotiation of
	a remote connection for asynchronous completion
 
        a <b>connect()</b> function which reads addresses from
        a <b>sockaddr_in</b> structure will be added with
        C compiler development






</pre>
<h3>3.2 UDP Server Response Low-Level Calls</h3>

These network routines make UDP servers simpler to construct
and allow responses to be transmitted at very low overhead

<pre>

	udp_acw_send_nocheck
	udp_rtxbuffer

	udp_txbuffer
	udp_acw_send

	release_udgram


</pre>

<h3>3.3 TCP Low-Level Calls and The High-Volume Network API</h3>

<p>
The following are low-level network calls which are the building blocks
of the well-known socket interface

<p>
Instead of passing handles these routines use the kernel socket structures

<p>
There are two reasons for making this lower-level interface available
to applications

<p>
The network architecture is designed to allow one server
endpoint to have some millions of TCP connections. So many handles
could not be assigned or used

<p>
Some processing is also sidestepped


<pre>

	<b>lx	connection
	call	(xaccept)</b>

	move a passive connect from <b>SYNC_RECEIVED</b> to <b>ESTABLISHED</b> state
	the transmission control block address is in x

	<b>xaccept</b> is the building block of the <b>accept()</b> call

	to walk the open and half-open connnections attached to a
	port, it is necessary to bind a listening socket to that port

	<b>bind</b> returns the bank:offset address in kernel space of the
	listening socket in registers 10:11. This address must be based in
	the space <b>BSOCKET</b> and the socket structure attribute <b>tbase</b>
	retrieved to identify the bank where this socket has connections

	The bank containing connection blocks is then based at <b>BSOCKET</b>

	the connections in this bank are in 32 ordered chains and the
	chain for the local port is a function of the local port number

	the local port number may be known at assembly time and the
	chain function can then be resolved at assembly

	a local port number picked at runtime must be resolved to its
	chain address at <b>bind</b>. A randomly numbered listening port is
	conceivable with services bound to <b>portmapper()</b>


		$(1)
		tcp_socket_handle	+	0
		connections_bank	+	0
		port_socket_long_address +	0:d

		connection_chain_head
			+	BSOCKET*/12++tlist:chain(1)+TPORTCHAIN(LISTENING_PORT)

		listening_port		+	LISTENING_PORT		

		$(69::,b)
		s		socket

		$(66::,x)
		transmission	tcp_connection

		$(67::,y)
		tlist		tbank

		$(0)

		first_time	la	(IPPROTO_TCP*/16)
				<b>call	(__socket)</b>
				jna	socket_error

				sa	tcp_socket_handle
				lb, xi	LISTENING_PORT

				sb	7
				z	6
				<b>call	(bind)</b>

				jna	bind_error

				dl	10
				ds	port_socket_long_address

				sabr	BSOCKET

				.	register b is now a pointer to
				.	the port socket structure

				push	s:tbase
				pop	connections_bank

				$if	LISTENING_PORT=0
				.	if <b>bind</b> chose the port number
				la	s:socket_address+1
				and	(00FFFF)
				sa	listening_port
				<b>call	(tcp_hash_localsocket)</b>
				aa	(BSOCKET*/12++tlist:chain(1))
				sa	connection_chain_head

				$endif

		subsequently	la	connections_bank
				sabr	BSOCKET

				lx      connection_chain_head

				lk	(00FFFF)	. compare mask for
							. local port # in chain

		walk		lx	transmission:next
				tz	x
				j	a_connection
				j	no_more_connections

		a_connection	la	transmission:socket_address+1
				mta	listening_port	. chains are shareable
				j	walk

				la	transmission:state
				anu, xi	<b>TCP_ESTABLISHED</b>
				jzb	traffic?
				anu, xi	<b>TCP_SYNRECEIVED</b>
				jnzb	walk		. TCP will service any other state

				<b>call	(xaccept)</b>

		traffic?	la	transmission:receiveq:head
				jza	walk	


	Listening sockets for very large numbers of connections have dedicated connection
	banks per port, and TCP accepts incoming connections to these automatically.
	The application protocol then filters the credentials of the remote socket owner


</pre>

<h2>4. API Service Building Blocks</h2>


These internal interrupt primitives are used as building blocks
in system services

<pre>
	HANDLE$            80		= bank 1  vector  16

					acquire a file or socket handle

	FREE_HANDLE$       81		= bank 1  vector  17

					relinquish a file or socket handle
					handle number in application
					register a

	READ_HANDLE$       82		= bank 1  vector  18

					retrieve handle encoding
					in user register a
					application supplies handle
					number in a

	READ_XVECTOR$      83		= bank 1  vector  19

					read the kernel vector bank
					location in application register x
					vector word returned in
					application register a

	WRITE_XVECTOR$     84		= bank 1  vector  20
					write the kernel vector bank
					location in application register x
					value in application register a
					

	READ_SOCKET$       85		= bank 1  vector  21

					handle number is in application a
					return handle encoding +location of
					control cell in application a + b
					
	UHANDLE$           86		= bank 1  vector  22
					bind socket control cell to handle

					application d$save = handle number
					applicatio a = bank of control cell

					Return long virtual address in
					application registers 10, 11

	KERNEL$B1          87		= bank 1  vector  23
					base a kernel private data bank
					in bank B1

					application register a
					->kernel vector bank location of
					required kernel B1 occurrence

	B1$                88		= bank 1  vector  24
					rebase the caller's current
					private data bank in bank B1

	KERNEL$B1_1        89		= bank 1  vector  25

					base the initial kernel private
					data bank in bank B1


	XBASE$32           96		= bank1	vector	32
	XBASE$33           97		= bank1	vector	33
	XBASE$34           98		= bank1	vector	34
	XBASE$35           99		= bank1	vector	35
	XBASE$36           100		= bank1	vector	36
	XBASE$37           101		= bank1	vector	37
	XBASE$38           102		= bank1	vector	38
	XBASE$39           103		= bank1	vector	39
	XBASE$40           104		= bank1	vector	40
	XBASE$41           105		= bank1	vector	41
	XBASE$42           106		= bank1	vector	42
	XBASE$43           107		= bank1	vector	43

                                        bank 1 vectors 32..43
                                        request to base a device array

	smaragd7 kernel bases specialised arrays outside system memory
	(devices) in a few banks starting from B32. To avoid accident,
	only interrupt code is allowed to do this. Internal interrupts
	XBASE$32..XBASE$43 are available to base device arrays


</pre>

<h2>5. File System InterFace</h2>

<h3>5.1 POSIX API</h3>

The targeted file system interface has a POSIX-like API
<pre>

	int open(char *path, int flags, int permissions);

	int read(int handle, char *buffer, int octets);

	int write(int handle, char *buffer, int octets);

	unsigned long lseek(int handle, long target, int whence);

	int close(int handle);

</pre>
<b>open()</b> returns a handle identifier unique within the process
This value shares a number space with <b>socket()</b>

<p>
Returned value less than zero indentifies a problem in all file
system calls. A range of negative values indicates the problem
directly. There is no errno buffer

<p>
The file handle value is the first argument in the other calls

<h3>5.2 File System Types and Low-Level Interfaces</h3>

Below the Posix-like API there are driver interfaces for NFS client,
removable Flash memory-stick / card, and RTA1 memory array file system

<p>
The first to be implemented is RTA1 memory array file system. It is
accessible at a low-level interface below the Posix-like interface


<h3>5.3 RTA1 Memory Array File System</h3>

The memory array file system is an array of up to 17,179,869,184
24-bit words outside executable space. Each memory array file system
occupies one of the 63 devices configurable outside executable space

<p>
Device memory contains all descriptors and data in the memory array
file system. To use the same calls for file systems which are
not memory arrays, the drivers would need to buffer the descriptors and
data before returning pointers to the caller

<p>
This file system has been implemented initially as a read-only store
constructed offline and loaded with the emulator

<p>
The memory array file system is hierarchic and organised in directories
and file extents

<p>
The lookup calls available return a pointer to a buffered directory entry
or to a buffered file extent

<p>
The call <b>fs_find</b> advances from a 48-bit starting point in registers
<b>a:b</b> to locate the directory or file named in the string addressed by
<b>y</b>
<pre>

        lr, xi  1		. # words in search name
        ly, xi  $1("web")	. search name in ASCII
        dsr     48		. default start point
        call    (fs_find)
	ds	web_directory_start_point	

</pre>
The starting point is the pointer to the first block of a directory.
It is a  long virtual address with the layout
<pre>

		big.large_bank_identifier.device.memory_space_address


	 46|		       30|    24|			       0|	
	___|_____________________|______|_______________________________|
	|01|large_bank_identifier|device|      memory space address	|
	|__|_____________________|______|_______________________________|

</pre>
If the starting point is zero, the driver starts at the root directory
of the default device

<p>
The target string can be the name of a directory or a file, or a link

<p>
The string only has zero-padding, not zero termination. The length in register
<b>r</b> is the containing number of words of the name

<p>
The return value in <b>a:b</b> is a new long virtual address pointing
to the target file or directory target entry. If the target is not found,
the return is zero

<p>
The long virtual address does not need to be based before the call

<p>
<b>fs_dsearch</b> is similar to <b>fs_find</b>, except the input long
virtual address must point to a directory descriptor. A search
will take place within that directory
<pre>

	dl	web_directory_start_point
	lx, xi	("document.html")
	lr, xi	5
	call	(fs_dsearch)	
	ds	file_cursor
	jdz	not_found
	
</pre>
<b>fs_dsearch</b> returns the long virtual address of the first extent
descriptor of the file in <b>a:b</b>

<p>
<b>fs_xbase</b> places the file extent data pointed by extent descriptor
<b>a:b</b> into the memory space, and returns the long virtual
address of the following extent descriptor in registers <b>a:b</b>
<pre>

	dl	file_cursor
	jdz	end_of_file
	call	(fs_xbase)

	ds	file_cursor
	sr	bytes_available
	sy	data_address
	
</pre>
Register <b>y</b> points to the file data. The whole extent is in the
address space. <b>r</b> contains the number of octets in the extent.
<b>a:b</b> contain the long virtual address of the following extent
descriptor

<p>
Routines <b>fs_1st</b> and <b>fs_read</b> in the memory array file system
interface are components for more complex calls. <b>fs_1st</b> returns the
long virtual address of the first directory entry in the default file system.
<b>fs_read</b> returns the directory next entry. The caller must filter and
interpret the returned entries

<p>
File space in the memory array file system is awarded in multiples of 64
words. A single file extent is a maximum if 262144 words in size

<p>
space for directories is awarded in chained blocks of 1024 words

<p>
The directory entry structures start with a format word which identifies
the entry type and size in words, excluding the format word itself
<pre>

	directory format word
	_____________________
	
	      16|      8|      0|
	________|_______|_______|
	|  type |       | words |
	|_______|_______|_______|


	


	filetree (directory) label
	__________________________

	47					       0
	_________________________________________________
	|  'T'  |   0   | words | granules first extent	|
	|_______|_______|_______|_______________________|
        | 		   start granule		|
	|_______________________________________________|
	|   granule containing next extent descriptor	|
	|_______________________________________________|
	|   word offset next	|words written dir.block|
	|___extent descriptor___|_______________________|
	|words free in dir.block|        name...        ...         ...
	|_______________________|_______________________|
	


	volume label (top directory)
	____________________________

        47                                             0
        _________________________________________________
        |  'V'  |   0   | words |  granules in device	|
        |_______|_______|_______|_______________________|
        |            next assignable granule            |
        |_______________________________________________| 
        |words written dir.block|words free in dir.block|       
        |___extent descriptor___|_______________________|
        |        name...        ...         ...
        |_______________________|_______________________|



	file label
	__________

        47                                             0
        _________________________________________________
        |  'F'  |   0   | words | granules first extent |
        |_______|_______|_______|_______________________|
        |                  start granule                |
        |_______________________________________________|
        |   granule containing next extent descriptor   |
        |_______________________________________________| 
        |   word offset next    |file total octets 47..24     
        |___extent descriptor___|_______________________|
        |file total octets 23..0|	name...		...	   ...
        |_______________________|_______________________|



	file extent label
	_________________

        47                                             0
        _________________________________________________
        |  'X'  |   0   | words | granules this extent  |
        |_______|_______|___=_7_|_______________________|
        |                  start granule                |
        |_______________________________________________|
        |   granule containing next extent descriptor   |
        |_______________________________________________|
        |   word offset next    |
        |___extent descriptor___|



	link
	____

        47                                             0
        _________________________________________________
        |  'L'  |   0   | words |   word offset target  |
        |_______|_______|_______|___________descriptor__|
        |      granule containing target descriptor     |
        |_______________________________________________|
        |	name...		...		...
        |_______________________|





	relay (directory extension block pointer)
	_________________________________________

        71								       0
        _________________________________________________________________________
        |  'J'  |   0   | words |	start granule next block of directory	|
        |_______|_______|_______|_______________________________________________|




</pre>




<i>
<pre>
_______________________________________________________________________________________


LICENCE NOTE

    Copyright Tim Cox, 2012
    TimMilesCox@gmx.ch

    This document is part of the RTA1 Processor Programmable Architecture.

    RTA1 is a free processor architecture design. It is licensed
    under the GNU General Public Licence Version 3

    The executable emulation of RTA1 is free software.

    Instruction code for the target RTA1 architecture is free software
    if it is delivered with this software

    Software programs delivered with this software to connect the
    emulated RTA1 with real network interfaces in the emulator host
    are free software

    Scripts and programs delivered with this software for running
    on other computers and interacting with the RTA1 are free software

    The masmx target-independent meta-asembler delivered here
    is free software whether it is used for constructing RTA1 code
    or any other code. masmx is a separate free program by the
    same author and included with this software to save searching for it

    Scripts and utility programs for constructing RTA1 target
    executable software are free software

    You can redistribute it and/or modify RTA1
    under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    RTA1 is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with RTA1.  If not, see &lt;http://www.gnu.org/licenses/&gt;.



</pre>
</i>

</div>
</html>

