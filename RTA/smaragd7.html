<html>
<div	style="font-size:15pt">

<center>

<h1>The smaragd7 Kernel and API</h1>

<i>
Copyright Tim Cox, 2012<br>
This document is part of the RTA1 Processor Programmable Architecture<br>
The RTA1 Architecture is freeware licensed with the GNU General Public Licence Version 3<br>
The same licence encompasses all accompanying software and documentation <br>
The full licence text is included with these materials<br>
See also the licensing notice at the foot of this document
</i>

</center>

<ol>

	<li>API</li>
	<ol>
		<li>Posix Layer and Low Level Interface</li>

		<li>Kernel Call Interface and Internal Interrupt Interface</li>
	</ol>
	<li>Primitive Kernel Routines</li>
	<ol>
		<li>Launching, Switching and Ending Tasks</li>

		<li>Adding and Releasing Task Storage</li>
	</ol>
	<li>Network API</li>
	<ol>
		<li>The Posix Network API</li>

		<li>The High-Volume Network API</li>
	</ol>
	
	<li>API Service Primitive Building Blocks</li>

	<li>Appendix A: Prototype Online File System</li>


</ol>

<h2>1. API</h2>

<h3>1.1 Posix Layer and Low Level Interface</h3>

<p>
The smaragd7 kernel has services on a Posix model

<p>
The services are also addressable at a lower layer than the handle-based
Posix-model API

<p>
The lower level interfaces allow services on a far larger scale as well
as shortening software paths

<p>
For example, Posix networking is centred on the handle, an integer token
for a socket. Sockets share a number space with file handles

<p>
On RTA1 with smaragd7 kernel, a single application may have several million
sustained TCP connections

<p>
The application does not have 5..10 million socket handles, but
instead binds to TCP service at a low level

<p>
The remote user session is modelled on the TCP connection. One server
thread may have  millions of sustained TCP connections, not dozens of
in-and-out connections

<p>
So many socket handles are not modelled in the process handle space.
There are instead low-level APIs



<h3>1.2 Kernel Call Interface and Internal Interrupt Interface</h3>

Most kernel routines have a call interface and their
arguments are on the internal stack

<p>
Some calls are internal interrupts. They are called with
the <b>ii</b> internal interrupt instruction. Functional
wrappers can be place around these system calls

<p>
Macro language supports a structured call interface for application
calls and kernel calls. Detailed explanation is in the separate
document <b>Towards High-Level Languages for RTA1</b>

<p>
Kernel routines which temporarily alter the address space are
implemented as internal interrupts

<p>
Return from interrupt restores the caller's environment

<p>
Arguments for internal interrups are typically in the applicatio
accumulator registers
<pre>

	la, xi	<i>argument</i>
	ii	<i>vector</i>

</pre>
<p>

Interrupt vector values have the same layout as far call vector values.

<p>
A vector is a value with a 16-bit bank pointer and a 6-bit offset
<pre>

	00 bbbb bbbb bbbb bbbb offset

</pre>
The vector value is the sign-extended-immediate operand of the internal
interrupt instruction <b>ii</b>
<pre>

	ii	ISR_VECTOR

</pre>
<p>
The operand of the far call instruction <b>call</b>
instruction is a variable or a literal constant
<pre>

	call	(CALL_INTERFACE_VECTOR)

</pre>
<p>
ISRs and kernel call routines are not interchangeable in call method

<p>
An ISR reads parameters from the application arithmetic registers,
and returns by executing an interrupt return instruction <b>ir</b>

<p>
A far call routine executes in application mode and reads parameters 
from the internal stack. It returns by executing a far return instruction <b>fret</b>

<p>
All ISRs which are internal interrupt targets are in the
4096-word bank at absolute address 4096, i.e. the second page of storage. 

<p>
So these vector values are all in the range
<pre>

	64++[0..63]
	000000 000000 000001 xxxxxx

</pre>
<p>
The kernel call interface vectors are in 4096-word instruction banks
starting from absolute address 8192, or the third page of system memory

<p>
Instruction banks can be any size up, but the kernel banks are the minimum
size of 4096 words for modularity

<p>
Network calls are in bank 2 at address 8192 and file system calls in bank 5
at address 20480

<p>
So those kernel call routines have vector values in these ranges
<pre>

        2*64++[0..63]
        00 0000 0000 0000 0010 yyyyyy

        5*64++[0..63]
        00 0000 0000 0000 0101 xxxxxx

</pre>
<p>
Because a 16-bit bank pointer to a 4K-granularity bank edge only addresses
256 megawords of executable space, application  <b>call</b> operand vectors
may be a 19-bit pointer to a bank at a 32678-word boundary, with a 3-bit vector
offset, covering all 16 gigawords of executable space
<pre>

        00 bbbb bbbb bbbb bbbb vector   call vector value up to 256 MWord

        01 bbbb bbbb bbbb bbbb bbbvvv   call vector value up to 16 GWord

</pre>

<p>
High-memory vectors are not expected in kernel calls


<h2>2. Primitive Kernel Routines</h2>
<p>
The principal internal interrupts are these. There are more
used as building blocks for services
<pre>

	SPAWN$             66		= bank 1  vector  2

					task launch
					4 parameters in application
					registers a b mantissa2 mantissa3


	BANK$              67		= bank 1  vector  3

					storage acquire
					words requested in application
					register a


	ARRAY$             68		= bank 1  vector  4

					very large storage acquire
					4096-word blocks requested
					in application register a 

	BANK$FREE          69		= bank 1  vector  5

					storage relinquish
					absolute bank pointer in
					application register a


	YIELD$             65		= bank 1  vector  1

					task switch



	TWAIT$             91		= bank 1  vector  27

					task switch and wait milliseconds
					application register a contains
					millisecond count



	EXIT$              70		= bank 1  vector  6

					end task


</pre>

<h3>2.1 Launching, Switching and Ending Tasks: SPAWN$ YIELD$ TWAIT$ EXIT$</h3>

One task launches another with the SPAWN$ primitive
<pre>

        ql      (start_vector, PRIORITY, DATA_SPACE, -B1_OCCURENCES:q)
        ii      SPAWN$

</pre>


<p>
PRIORITY may not be < zero or > PRIORITIES-1

<p>
The highest priority is zero and the lowest PRIORITIES-1

<p>
DATA_SPACE is the amount of application data storage which the
application will receive and base in banks B3..B31

<p>
-B1_OCCURENCES is a negative number indicating the number of 4096-word
banks the application requires in its private B1 stack. The default is
-1, which means the application uses one private B1 bank

<p>
B1 banks are distinct from application data banks because their content
is encapsulated in the owning application or service. Adresses in B1
are not available to called or calling entities.

<p>
A simple application has one B1 bank. A service disposing tabled resources
has one or more

<p>
Subprogramming application models may also have a linear stack of B1 banks
or a service aligned multiple of B1 banks

<p>
The kernel assigns a single storage area starting with B1 banks, then a
4096-word Task Control Block, then a 4096-word vector bank which the
application will base in B2, then the initial DATA_SPACE

<p>
The kernel writes the base adresses of all banks initially supplied to the
task and all entry point vectors in the initial instruction bank into the vector bank

<p>
The instruction bank containing the start vector must be loaded before
SPAWN$

<p>
<b>YIELD$</b> is a voluntary task switch. Practically, it only benefits
equal or higher priority tasks, unless the task descriptor has been marked
to block on an event in steps combined with the <b>YIELD$</b> call
<pre>

	ii	YIELD$

</pre>

<p>
<b>TWAIT$</b> is a voluntary task yield for a time in milliseconds.
When the wait time is expired, the task becomes a candidate for switching
<pre>

	la, xi	milliseconds
	ii	TWAIT$

</pre>

<p>
<b>EXIT$</b> deletes the task and pools its resources
<pre>

	ii	EXIT$

</pre>

<p>
If the application internal stack is exactly as at task entry, the
far return instruction <b>fret</b> can be used to end and delete a task
<pre>

	fret	0

</pre>


<h3>2.2 Adding and Releasing Task Storage: BANK$ ARRAY$ BANK$FREE</h3>

<p>
These primitives acquire or free storage banks up to 16 Gigawords in
size. The banks acquired are not automatically based and
may be too large to base all at once

<p>
This service is not similar to C-Language library calls for
obtaining buffers by pointer. C-Library manages memory which the task
already has, and does not return it to the smaragd7 kernel but to the 
application internal management

<p>
<b>BANK$</b> obtains a bank from 1 to 16777215 words in size and
records it in the task control block. The argument in application
register a is words requested. value returned in a is the bank
pointer. Zero = no memory granted
<pre>

	la, xi	WORDS_REQUESTED
	ii	BANK$

</pre>

<p>
<b>BANK$</b> granularity of memory grant is 4096-word blocks up to 262144
words and 262144-word blocks beyond

<p>
<b>ARRAY$</b> obtains a bank from 4096 words to 16 Gigawords in size
and records it in the task control block. The argument in application
register a is 4096-word blocks requested. value returned in a is the bank
pointer. Zero = no memory granted

<pre>

	la, xi	4K_BLOCKS_REQUESTED
	ii	ARRAY$

</pre>
<p>
<b>ARRAY$</b> granularity of memory grant is 262144-word blocks

<p>
<b>BANK$FREE</b> returns a bank of any size to the kernel. If the task
does not possess the bank, no action is taken. The argument in
application register a is the bank pointer
<pre>

	la	BANK_INDEX
	ii	BANK$FREE

</pre>
<h2>3. Network API</h2>
<p>
The network API is a handle-based call interface

<p>
An application using thousands or millions of sockets
calls a lower-level set of network calls

<p>
Errors conditions return a range of negative values identifying the
problem. There is no errno variable

<h3>3.1 The Posix Network API</h3>
<pre>

	<b>la	([IPPROTO_TCP|IPPROTO_UDP]*/16)
	call	(__socket)</b>


	result in application register a
	+integer = socket ID
	-1	= handle not available
	-2	= protocol not supported



	<b>[dl	(net_address*/16++port:d)|dsr	48]
	ds	6
	la	socket
	[lb, xi	0]
	call	(bind)</b>


	result in application register a
	0	= good
	-2	= handle is not TCP or UDP
	-3	= port number specified and not free
	-4	= no resource to model the socket



	<b>c	(recv)	socket_handle	buffer	bytes	flags</b>

	socket handle is the integer handle number

	For UDP sockets bit 23 of flags has a <b>PEEK</b> effect
	-the user datagram stays on the input queue

	flag bit 22 has <b>NON_BLOCKING</b> effect.
	<b>recv</b> is by default <b>BLOCKING</b>

	if a UDP socket has no user datagram available it
	blocks if flag bit 22 = 0

	if a TCP connection has less data available than
	requested it blocks if flag bit 22 = 0

	sockets receiving XDR data require BLOCKING to work
	correctly. Applications protocols with BLOCKING
	sockets must be separate tasks from the IP task

	the result in application register a is bytes read

	result -2 means the handle is neither a UDP socket
	nor a TCP connection

	result -99 means a TCP connection has received remote
	close



	<b>c	(send)	socket_handle	buffer	bytes	flags</b>

	socket_handle is the integer handle number

	for TCP sockets bit 3 of flags is TCP_PSH which sends
	immediately instead of on full segment

	result in application register a is bytes sent

	If the socket is NON_BLOCKING,
	if the transmission could not be immediately resourced
	actual bytes sent is in a and outstanding count in b

	a result of -2 indicates that the handle is neither
	a UDP socket not a TCP connection

bind            $equ            T77_V++2
recv            $equ            T77_V++6
send            $equ            T77_V++7
ipsend          $equ            T77_V++8
tcp_accept      $equ            T77_V++9
tcp_send_push   $equ            T77_V++10
tcp_ack_fin     $equ            T77_V++11
xaccept         $equ            T77_V++49

</pre>
<h3>3.2 The High-Volume Network API</h3>


<p>
The following are low-level network calls which are the building blocks
of the well-known socket interface

<p>
Instead of passing handles these routines use the kernel socket structures

<p>
There are two reasons for making this lower-level interface available
to applications

<p>
The network architecture is designed to allow one server
endpoint to have some millions of TCP connections. So many handles
could not be assigned or used

<p>
Some processing is also sidestepped



<pre>

	<b>lx	connection
	call	(xaccept)</b>

	move a passive connect from <b>SYNC_RECEIVED</b> to <b>ESTABLISHED</b> state
	the transmission control block address is in x

	<b>xaccept</b> is the building block of the <b>accept()</b> call

	to walk the open and half-open connnections attached to a
	port, it is necessary to bind a listening socket to that port

	<b>bind</b> returns the bank:offset address in kernel space of the
	listening socket in registers 10:11. This address must be based in
	the space <b>BSOCKET</b> and the socket structure attribute <b>tbase</b>
	retrieved to identify the bank where this socket has connections

	The bank containing connection blocks is then based at <b>BSOCKET</b>

	the connections in this bank are in 32 ordered chains and the
	chain for the local port is a function of the local port number

	the local port number may be known at assembly time and the
	chain function can then be resolved at assembly

	a local port number picked at runtime must be resolved to its
	chain address at <b>bind</b>. A randomly numbered listening port is
	conceivable with services bound to <b>portmapper()</b>


		$(1)
		tcp_socket_handle	+	0
		connections_bank	+	0
		port_socket_long_address +	0:d

		connection_chain_head
			+	BSOCKET*/12++tlist:chain(1)+TPORTCHAIN(LISTENING_PORT)

		listening_port		+	LISTENING_PORT		

		$(69::,b)
		s		socket

		$(66::,x)
		transmission	tcp_connection

		$(67::,y)
		tlist		tbank

		$(0)

		first_time	la	(IPPROTO_TCP*/16)
				<b>call	(__socket)</b>
				jna	socket_error

				sa	tcp_socket_handle
				lb, xi	LISTENING_PORT

				sb	7
				z	6
				<b>call	(bind)</b>

				jna	bind_error

				dl	10
				ds	port_socket_long_address

				sabr	BSOCKET

				.	register b is now a pointer to
				.	the port socket structure

				push	s:tbase
				pop	connections_bank

				$if	LISTENING_PORT=0
				.	if <b>bind</b> chose the port number
				la	s:socket_address+1
				and	(00FFFF)
				sa	listening_port
				<b>call	(tcp_hash_localsocket)</b>
				aa	(BSOCKET*/12++tlist:chain(1))
				sa	connection_chain_head

				$endif

		subsequently	la	connections_bank
				sabr	BSOCKET

				lx      connection_chain_head

				lk	(00FFFF)	. compare mask for
							. local port # in chain

		walk		lx	transmission:next
				tz	x
				j	a_connection
				j	no_more_connections

		a_connection	la	transmission:socket_address+1
				mta	listening_port	. chains are shareable
				j	walk

				la	transmission:state
				anu, xi	<b>TCP_ESTABLISHED</b>
				jzb	traffic?
				anu, xi	<b>TCP_SYNRECEIVED</b>
				jnzb	walk		. TCP will service any other state

				<b>call	(xaccept)</b>

		traffic?	la	transmission:receiveq:head
				jza	walk	


	Listening sockets for very large numbers of connections have dedicated connection
	banks per port, and TCP accepts incoming connections to these automatically.
	The application protocol then filters the credentials of the remote socket owner


tcp_release_rxline      $equ    T77_V++50

tcp_rx          $equ            T77_V++53
tcp_tx          $equ            T77_V++54
tcp_addbyte     $equ            T77_V++55
tcp_pushbytes   $equ            T77_V++56

udgram_rx       $equ            T77_V++57
udgram_tx       $equ            T77_V++58
tfer_dgram      $equ            T77_V++4
release_udgram  $equ            T77_V++5

udp_acw_send_nocheck $equ       T77_V++59
udp_rtxbuffer   $equ            T77_V++60
udp_send        $equ            T77_V++61
udp_txbuffer    $equ            T77_V++62
udp_acw_send    $equ            T77_V++63
net_disengage   $equ            T77_V++3
</pre>





<h2>4. API Service Building Blocks</h2>


These internal interrupt primitives are used as building blocks
in system services

<pre>
	HANDLE$            80		= bank 1  vector  16

					acquire a file or socket handle

	FREE_HANDLE$       81		= bank 1  vector  17

					relinquish a file or socket handle
					handle number in application
					register a

	READ_HANDLE$       82		= bank 1  vector  18

					retrieve handle encoding
					in user register a
					application supplies handle
					number in a

	READ_XVECTOR$      83		= bank 1  vector  19

					read the kernel vector bank
					location in application register x
					vector word returned in
					application register a

	WRITE_XVECTOR$     84		= bank 1  vector  20
					write the kernel vector bank
					location in application register x
					value in application register a
					

	READ_SOCKET$       85		= bank 1  vector  21

					handle number is in application a
					return handle encoding +location of
					control cell in application a + b
					
	UHANDLE$           86		= bank 1  vector  22
					bind socket control cell to handle

					application d$save = handle number
					applicatio a = bank of control cell

					Return long virtual address in
					application registers 10, 11

	KERNEL$B1          87		= bank 1  vector  23
					base a kernel private data bank
					in bank B1

					application register a
					->kernel vector bank location of
					required kernel B1 occurrence

	B1$                88		= bank 1  vector  24
					rebase the caller's current
					private data bank in bank B1

	KERNEL$B1_1        89		= bank 1  vector  25

					base the initial kernel private
					data bank in bank B1


	XBASE$32           96		= bank1	vector	32
	XBASE$33           97		= bank1	vector	33
	XBASE$34           98		= bank1	vector	34
	XBASE$35           99		= bank1	vector	35
	XBASE$36           100		= bank1	vector	36
	XBASE$37           101		= bank1	vector	37
	XBASE$38           102		= bank1	vector	38
	XBASE$39           103		= bank1	vector	39
	XBASE$40           104		= bank1	vector	40
	XBASE$41           105		= bank1	vector	41
	XBASE$42           106		= bank1	vector	42
	XBASE$43           107		= bank1	vector	43

                                        bank 1 vectors 32..43
                                        request to base a device array

	smaragd7 kernel bases specialised arrays outside system memory
	(devices) in a few banks starting from B32. To avoid accident,
	only interrupt code is allowed to do this. Internal interrupts
	XBASE$32..XBASE$43 are available to base device arrays


</pre>

<h2>Appendix A: Prototype Online File System</h2>


<i>
<pre>
_______________________________________________________________________________________


LICENCE NOTE

    Copyright Tim Cox, 2012
    TimMilesCox@gmx.ch

    This document is part of the RTA1 Processor Programmable Architecture.

    RTA1 is a free processor architecture design. It is licensed
    under the GNU General Public Licence Version 3

    The executable emulation of RTA1 is free software.

    Instruction code for the target RTA1 architecture is free software
    if it is delivered with this software

    Software programs delivered with this software to connect the
    emulated RTA1 with real network interfaces in the emulator host
    are free software

    Scripts and programs delivered with this software for running
    on other computers and interacting with the RTA1 are free software

    The masmx target-independent meta-asembler delivered here
    is free software whether it is used for constructing RTA1 code
    or any other code. masmx is a separate free program by the
    same author and included with this software to save searching for it

    Scripts and utility programs for constructing RTA1 target
    executable software are free software

    You can redistribute it and/or modify RTA1
    under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    RTA1 is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with RTA1.  If not, see &lt;http://www.gnu.org/licenses/&gt;.



</pre>
</i>

</div>
</html>

