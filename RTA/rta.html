<html>
<div	style="font-family:times-roman;font-size:14pt">

<a	href="index.html">
<pre	style="border-radius:5px;color:#FFFFFF;background-color:#0000FF;font-size:12pt;
	width:52pt;height:28pt;top:0pt;right:20pt;position:absolute">
 INTRO
  PAGE
</pre>
</a>

<center>
<h1>
	The RTA1 Processor Architecture
</h1>
<i>
Copyright Tim Cox, 2012<br>
RTA1 Architecture is freeware licensed with the GNU General Public Licence Version 3<br>
This processor programmable architecture specification is the principal and central subject of the licence<br>
The same licence encompasses all accompanying software and documentation <br>
The full licence text is included with these materials<br>
See also the licensing notice at the foot of this document
</i>
<h2>
	Programmable Architecture Specification
</h2>
</center>

<a	name="oview"/>
<div	style="margin-left:60pt">
<i>

<p>
RTA1 is a computer processor architecture which has run in emulation on Unix host computers since January 2012
<p>
Scalability is claimed for the RTA1 architecture. It can run simple dedicated
microcontroller applications in a few dozen words of storage,<br> and it can run 
as a major system maintaining some millions of TCP connections simultaneously

<p>
RTA1 is designed for symmetric multiprocessing, an important plane of scalability

<p>
A register stack gathers operands as functions are traversed, eliminating level-1 operand cache

<p>
RTA  I/O space is a further plane of scalability<br><br>

I/O ports<br>
  &nbsp;&nbsp;&nbsp;&nbsp;multicast and unicast interrupts between SMP instruction processors
  for true synchronisation and exact realtime response<br>

  &nbsp;&nbsp;&nbsp;&nbsp;organise memory space<br>

  &nbsp;&nbsp;&nbsp;&nbsp;manage energy<br>

  &nbsp;&nbsp;&nbsp;&nbsp;add system functionality flexibly<br>

<p>
Excellent code density is claimed for RTA1. The emulated prototype runs
IP, UDP and TCP in 3750 instructions

<p>
Another 4000 instructions run Telnet, MIB-II and snmp v1, a simple HTTP 
server,<br>and floating point servers for online interaction with
RTA1 96-bit / 192-bit floating architecture

<p>
IP in the emulated prototype is interfaced to real networks.<br>RTA1 Telnet,
SNMP, HTTP, ICMP and floating point servers interact with other computers


</i>
</div>

	<a	name="index"/>
	<ol>
		<li><a href="#quoview">Overview</a></li>
		<ol>
			<li><a href="#geometry">Geometry</a></li>
			<li><a href="#glossary">Essential Glossary</a></li>
		</ol>
		<li><a href="#spaces">Address Spaces</a></li>
		<ol>
			<li><a href="#exar">Executable Space and Array Space</a></li>
			<li><a href="#aspace">Address Space</a></li>
			<li><a href="#ospace">Operand Address Space</a></li>
			<li><a href="#ispace">Instruction Frame and IFrame Name</a></li>
			<li><a href="#istack">The Internal Stack</a></li>
			<li><a href="#asum">Address Space Summary and Diagram</a></li>
			<ol>
				<li><a href="#space_summary">Summary of Instruction and Operand Address Spaces</a></li>
				<li><a href="#address_array">Addressing Arrays</a></li>
				<li><a href="#large_array">Large Arrays</a></li>
				<li><a href="#ultra_array">Ultra-Large and Distributed Arrays</a></li>
				<li><a href="#multi_word">Multi-Word Write Operands straddling Address Windows</a></li>
			</ol>
			<li><a href="#protection">Protection and Safety</a></li>
			<ol>
				<li><a href="#xlimit">Execution Protection</a></li>
				<li><a href="#safety">Operand Protection</a></li>
				<li><a href="#optimal_safe">Elective Safe Storage Practice</a></li>
				<li><a href="#device">Device Array Protection</a></li>
			</ol>
			<li><a href="#thread">Thread Switch and Address Space</a></li>
			<li><a href="#ioport">I/O Ports for Inter-Processor Signaling / Memory and Peripheral Configuration / Timer Restart</a></li>
			<ol>
				<li><a href="#iosignal">I/O Ports for Inter-Processor Signaling</a></li>
				<li><a href="#iomem">I/O Ports for Memory and Peripheral Configuration</a></li>
				<li><a href="#iotimer">I/O Port for Timer Interval Restart</a></li>
				<li><a href="#iolist">I/O Port Assignments List</a></li>
			</ol>
			<li><a href="#iassign">Interrupt Assignments</a></li>
		</ol>
		<li><a href="#regisi">Registers and Instruction Set</a></li>
		<ol>
			<li><a href="#nonar">Non-Addressable Registers</a></li>
			<li><a href="#register">Addressable Application and Interrupt Registers</a></li>
			<li><a href="#iset">Instruction Set Summary</a> and <a href="#lookup">Lookup Panel</a></li>
			<li><a href="#ifield">Instruction Layout and Effective Address Generation</a></li>
			<ol>
				<li><a href="#layout">Instruction Layout</a></li>
				<li><a href="#ea">Effective Address Generation</a></li>
				<li><a href="#ocodes">Operand Codes and Instruction Files</a></li>
			</ol>
			<li><a href="#isymbol">Instruction Field Summary and Programming Symbols</a></li>
			<li><a href="#instru">Instructions</a></li>
			<ol>
				<li><a href="#i24s"><i>Integer Store Instructions</i></a></li>
				<li><a href="#i24l"><i>Integer Load Instructions</i></a></li>
				<li><a href="#i24t"><i>Integer Test Instructions</i></a></li>
				<li><a href="#i24x"><i>Index Register Add Instructions</i></a></li>
				<li><a href="#i24b"><i>Boolean Instructions</i></a></li>
				<li><a href="#i24a"><i>Integer Arithmetic Instructions</i></a></li>
				<li><a href="#io"><i>I/O Ports Input and Output Instructions</i></a></li>
				<li><a href="#relo"><i>Process and Thread Memory Switch Instructions</i></a></li>
				<li><a href="#onoff"><i>PSR Flags Update Instructions</i></a></li>
				<li><a href="#bstream"><i>Bit Stream Read and Write Channels</i></a></li>
				<li><a href="#lfiret"><i>Return Instructions, Internal Interrupt and Interrupt Stack Frame</i></a></li>
				<li><a href="#shijo"><i>Shift and Jump Instructions</i></a></li>
				<li><a href="#modify"><i>Target Modify Instructions</i></a></li><br>
				<li><a href="#scala"><i>Double and Quadword Load and Store<br>
					Masked, Execute, and Scale Operations<br>
					Large Integer Arithmetic</i></a></li><br>
				<li><a href="#fp"><i>96-Bit and 192-Bit Floating-Point</i>
				<ul	type="none"><i>
					<li><a href="#fp">Floating Point Instructions</a></li>
					<li><a href="#fp96">96-Bit Floating Point</a></li>
					<li><a href="#fp192">192-Bit Floating Point</a></li>
					<li><a href="#fpround">Rounding Setting</a></li>
					<li><a href="#fpoflo">Exponent Underflow and Overflow Handling</a></li>
					<li><a href="#fpcompress">Floating Point Compression for Storage</a></li>
				</i></ul><br>
				<li><a href="#gocall"><i>Far Go and Call</i></a></li>
			</ol>
		</ol>
	</ol>

	<ul	type="none">

	<li><a href="#sim_d">Appendix A: SIMD and Instruction Repeat</a></li>

	</ul>

<a	name="quoview"/>
<h2>1. Overview</h2>

<a	name="geometry"/>
<h3>1.1 Geometry</h3>
<p>
RTA1 is a 24-bit word-addressing architecture with 24- 48- and 96-bit arithmetic.<br>
For unusual requirements RTA1 can calculate 192-bit floating values

<p>
Integer arithmetic is twos complement and floating point arithmetic is ones complement

<p>
The addressable storage location is the 24-bit computer word. Instructions are one computer word in size

<a	name="glossary"/>
<h3>1.2 Essential Glossary</h3>
<pre	style="font-size:11pt">
	<a	name="pagex"/>
	<a	style="color:#0000FF">
	page</a>			4096 data memory words on a 4096-word boundary in executable space
	<a	name="bankx"/>
	<a	style="color:#0000FF">
	bank</a>			262144 data memory words on a 262144-word boundary
				in executable space <a href="#devicex">device<a>[0] or another <a href="#devicex">device<a>[1..63] 
	<a	name="devicex"/>
	<a	style="color:#0000FF">
	device</a>			a memory space up to 16 gigawords which may be

					device[0] executable space
					maximum 16 gigawords in 4194304 pages

					devices[1..63] peripheral arrays
					maximum 16 gigawords per device in 65536 banks of

						24-bit array memory with system memory characteristics

						24-bit filestore static memory

						16-bit network trunk shared memory
	<a	name="start_pagex"/>
	<a	style="color:#0000FF">
	Start Page Index</a>	Start Page Index is the address / 4096 of some assigned memory
				for example an instruction frame or application data memory
	<a	name="iframe"/>
	<a	style="color:#0000FF">
	instruction frame</a>	an instruction frame is one or more pages of memory containing instructions and constants
				an instruction frame is a callable entity with entry points
				and may contain a library or one or more applications in part or total

	<a	style="color:#0000FF">
	Iframe Name</a>		Iframe Name is the 22-bit Start Page Index of an instruction frame
				tagged by two flag bits valued

					00	for an instruction frame of one page

					10	for an instruction frame of more than one page

						_________________________________________
				iframe name	| 00 |		Start Page Index	|
						| 10 |__________________________________|
						     |21			       0


	<a	name="vector"/>
	<a	style="color:#0000FF">
	vector</a>			a vector is a 24-bit value identifying an entry point in
				a fixed one-page instruction frame in the first 256 Megawords of system memory

				Start Page Index in a vector is 16 bits in size. Six bits are the vector offset


						_________________________________________
				vector		| 00 |	   Start Page Index    | <a style="color:#0000FF">offset</a>	|
						|____|_________________________|________|
						     |21		      6|5      0

						call	<a style="color:#0000FF">(PAGE*/6++OFFSET)</a>	. 24-bit constant or variable

				$vector macro is coded at location <a style="color:#0000FF">offset</a> of target page
				it exports value page:offset and jumps to target <a style="color:#0000FF">routine</a>

					call_name*	$vector	<a style="color:#0000FF">routine</a>

				The 24-bit vector value is the storage operand of <a href="#call">call</a> and <a href="#go">go</a> instructions
	<a	style="color:#0000FF">
	pointer to gate</a>		a high-order bit in the operand of <a href="#call">call</a> and <a href="#go">go</a> instructions
				flags a pointer in program memory to a <a href="#gate">gate</a> instead of a vector value

						_________________________________________
				pointer to gate	| 1 |		address of <a href="#gate">gate</a>		|
						|___|___________________________________|
						    |22				       0

						call	<a style="color:#0000FF">(1*/23++GATE_ADDRESS:s)</a>	. 24-bit constant or variable
	<a	name="gate"/>
	<a	style="color:#0000FF">
	gate</a>			a gate is the 48-bit descriptor of an entry point at any offset
				in a an instruction frame up to 64 pages in size anywhere in executable space

				bits 47 to 42 of a gate descriptor are the Page High Index of the gate
				Page High Index is instruction frame pages minus one

				a target instruction frame of one page therefore has Page High Index zero

				the second word of the gate descriptor is Iframe Name
				flag bits 23:22 of Iframe Name are 10 if Page High Index is nonzero

				dynamic load instruction frames are called by gate
				any instruction frame larger than one page is called by gate


				gate
				_________________________________________________________________________________
				| pppppp |		offset		| 00 |		Start Page Index	|
				|________|______________________________| 10 |__________________________________|
			    	       42|			      24|    |21			       0



	<a	name="vector_list"/>
	<a	style="color:#0000FF">
	vector list</a>		the vector list is a 4K-word page of data pointers and structures
				vector list is in application addresses 002000<sub>16</sub>..002FFF<sub>16</sub>

				vector list is constructed at process launch, is application read-only
				and  is common to all threads of the application

</pre>

<a	name="spaces"/>
<h2>2. Address Spaces</h2>


<a	name="exar"/>
<h3>2.1	Executable Space and Array Space</h3>

<p>
RTA1 places blocks of 4096 words or 262144 words in 64 windows of address space

<p>
These documents sometimes call 4K a page and 256K a bank

<p>
The limit of executable space (or system memory) is 16 gigawords. Executable space
is not all in the address space at once

<p>
The primary objective of a compact address space is compression but there are also
gains in security and locality of reference

<p>
Additional arrays up to one teraword total which are not part of executable space
may be added

<p>
RTA1 documentation calls these additional arrays devices, and they may each contain up to<br>
16 gigawords of 8- 16- or 24-bit memory. Device arrays may include among other applications<br>
video RAMs, dual-ported 16-bit network buffers, and memory-addressable 24-bit filestores

<p>
The compressed layout of relocation registers allows one space of 16 gigawords<br>
to be organised in windows of 4K Words. 4K organisation is needed for executable space

<p>
64 * 16-gigaword device arrays may at the same time be organised in windows of 256K words.<br>
System memory or executable space is device array 0 and is is the only device array which<br>
may be organised in windows either of 4096 words or of 262144 words

<p>
Relocation registers are one word in size to minimise cycles at context switch and to make<br>
relocation values the width of I/O ports. Each relocation register is implemented in one I/O port
<pre	style="font-size:11pt">


				    executable space 16 gigawords
				    _____________________________

			 ________________________________________________
			 | 22 page select bits	        | 12 offset bits|
			 |______________________________|_______________|
			 | 16 bank select bits |          18 offset bits|
			 |_____________________|________________________|


				    peripheral + array space 1 teraword
				    ___________________________________

		_________________________________________________________
		| device | 16 bank select bits |          18 offset bits|
		|________|_____________________|________________________|








				    relocation pointer value, 4K page 
				    _________________________________

				    _____________________________________
				    | 00 | 22 page select bits		|
				    |____|______________________________|




				    relocation pointer value, 256K bank
				    ___________________________________

				    _____________________________________
				    | 01 | 16 bank select bits | device	|
				    |____|_____________________|________|


</pre>
Bit 22 of the relocation pointer is "big" or "big bank".
Device 0 is system memory, so system memory is placed in the address space
in ranges of 4096-word blocks or in ranges of 262144-word blocks.

<p>
Device arrays can be placed in the address space in ranges of 262144-word blocks
<pre	style="font-size:11pt">

	_________________________________________________________________________________
	|										|
	|			ADDRESS SPACE AND EXECUTABLE SPACE			|
	|_______________________________________________________________________________|
	|										|
	|                                                                               |
	|										|
	|	Address space is the space which the effective address can reach	|
	|       i.e. the space which code can see at one moment             		|
	|										|
	|	Different memory can be in the address space at different times		|
	|										|
	|	Executable space is memory that can contain both instructions and data	|
	|										|
	|	In RTA1 that's the maximum 16 Gigawords of device [ 0 ]			|
	|	which is 1024 times the address space					|
	|										|
	|	RTA1 needs program memory to be						|
	|										|
	|		relocation-register-selectable in 4K-word pages			|
	|		and in 256K-word banks						|
	|										|
	|		24-bit-word writable / readable					|
	|										|
	|			optimally readable in bursts of 1 / 2 / 4 / 8 words	|
	|			at any 24-bit word address				|
	|										|
	|			optimally writable in bursts of 1 / 2 / 4 words		|
	|			at any 24-bit word address				|
	|										|
	|		able to do atomic read-modify-write on a single word		|
	|		at least when in SMP configuration				|
	|										|
	|	Storage from <a href="#device">Array devices</a> [ 1..63 ] is <a href="#sabr">based</a> only in 256K-word blocks	|
	|	and may be of type SYSMEM which supports atomic read + write		|
	|										|
	|	Peripheral array devices of types filestore and network trunk 		|
	|	are not required to support atomic update cyles				|
	|										|
	|_______________________________________________________________________________|


</pre>

<a	name="aspace">
<h3>2.2 Address Space</h3>

<p>
RTA1 has two 16-megaword address spaces, one each for instructions and operands

<p>
There is overlap between instruction and operand spaces to allow constants to be embedded in code

<p>
Instruction address space is one memory window which may move over all the 16-gigaword executable space

<p>
The operand address space has many simultaneous fixed and moving windows on the 16 gigaword executable space and the teraword array space


<a	name="ospace"/>
<h3>2.3 Operand Address Space</h3>
<p>
Operand address space starts with the 256 registers, except for instructions
<a href="#ts">Test and Set</a> and <a href="#ex">Execute</a>
<pre	style="font-size:11pt">

					__________________________________
					| 0000 0000 0000 0000 | register |
					|_____________________|__________|


</pre>
From address 256, operand address space is 16 megawords in 64 windows

<p>
From effective address 256 to 262143, address bits 17..12 select window 0..63
<pre	style="font-size:11pt">

					__________________________________
					|000 000| window| 12 offset bits |
					|_______|_______|________________|
					| window|         18 offset bits |
					|_______|________________________|


</pre>
<p>
From effective address 262144, address bits 23..18 select window 1..63.

They are the same windows wider open

<p>
The 6-bit window index corresponds to a relocation pointer in I/O ports 0..63
(or to certain switchable alternatives in I/O ports 65..71)

<pre	style="font-size:11pt">

        Two instructions do not access register operands at addresses 0..255

        Targets of the <a href="#ex">execute</a> and <a href="#ts">test and set</a> instructions are in memory windows 0..63

        Test And Set instruction is not used to update registers but may not update iframe B0 either

        Execute instruction may execute instructions at effective memory addresses lower than 256
        so that locations near the start of the instruction frame may be used to table target instructions for Execute

        Some memories like network trunks and filestores may not be suitable for Execute or Test and Set operations

</pre>

<a	name="ispace"/>
<h3>2.4 Instruction Frame and IFrame Name</h3>

<p>
Instructions are read from the Instruction Frame window B0

<p>
Window B0 is memory starting at the 4K-word block-edge pointed by I/O Port 0

<p>
The last page of the the Instruction Frame is pointed in I/O Port 64

<p>
The simplest iframe is a single page

<p>
I/O port 64 contains [B0] + IFrame Pages - 1.

<p> 
I/O ports 0 and 64 are written by far call / far return instructions and interrupt / interrupt return

<p>
Instructions are read from the leading edge of window B0 and not from
registers or any different address window

<p>
The 48-bit program counter is absolute. B0 Page Index * 4096
is added to make jump addresses absolute and subtracted to make saved addresses relative

<p>
Words 256..4095 of window B0 are in the operand address space as well as the
instruction window

<p>
IFrame Name is the 22-bit Iframe Start Page Index and two flag bits determining IFrame Size.
<pre	style="font-size:11pt">

					__________________________________
					| ff |       B0 Page Index	 |
					|____|___________________________|
					   22|				0

</pre>
IFrame Name updates as an iframe is entered and is stacked for return when the iframe calls out or interrupts

<p>
IFrame Start Page Index stripped of flags is written to base B0 in I/O Port 0 for operand addressing,
and is used to form an absolute program counter address B0 * 4096 + offset on entry or return into the iframe

<p>
The way flag bits 23:22 determine IFrame Size is explained with instructions
<pre	style="font-size:11pt">

	<a	href="#gocall">far go and call</a>

	<a      href="#fret">far return</a>

	<a      href="#ir">interrupt return</a>

</pre>
<a	name="istack"/>
<h3>2.5 The Internal Stack</h3>
<p>
RTA1 is intended to work very fast without having operand cache

<p>
The large array of scratch registers is organised in an internal stack which gathers operands as functions are traversed

<p>
In the absence of operand cache, SMP configurations do not need cache coherency electronics

<p>
Software avoids double updates by recognising the scope of test-and-set locks

<p>
The internal stack has a logic footprint infinitessimally smaller than any level-one cache, 
but can produce a very large performance advantage

<p>
The part of the register stack available to an application is 128 words, and the part
of it organised in an internal stack is 104 words

<p>
At thread switch RTA1 swaps 128 application registers in 32 instructions

<p>
The working of the internal stack is somewhat inverse to an external stack.

<p>
Push and pop operands have an effective address in memory space

<p>
A push is a load into CPU registers in RTA1, and a pop is a store
<pre	style="font-size:11pt">


				A push is a load to the CPU in RTA1
				___________________________________


							_________________________________________
	________________________________		|					|
	|		|		|		|					|
	|		|		|		|					|
	|	CPU	|	scalar	|		|	total operand space
	|		|    registers	|		|	registers + storage + immediate values
	|		|		|		|
	|		|_______________|		|
	|		|	--sp	|		|
	|		|_______________|		|
	|				|		|
	|				|		|
	|				|		|
	|	________________________|				_________________
	|new stack top	|	+	|<------<--------<--------<-----|     data	|
	|		|_______________|				|_______________|
	|		|		|		|
	|		|   internal	|		|
	|		|      stack	|






				A pop is a store from the CPU in RTA1
				_____________________________________


							_________________________________________
	________________________________		|					|
	|		|		|		|					|
	|		|		|		|					|
	|	CPU	|	scalar	|		|	total operand space
	|		|    registers	|		|	registers + storage
	|		|		|		|
	|		|_______________|		|
	|		|	sp++	|		|
	|		|_______________|		|
	|				|		|
	|				|		|
	|				|		|
	|		_ _ _ _ _ _ _ _ |				_________________
	|				|------>------>-------->------->|     data	|
	|	________|_______________|				|_______________|
	|new stack top	|		|		|
	|		|   internal	|		|
	|		|      stack	|




</pre>


<a	name="asum"/>
<h3>2.6 Address Space Summary and Diagram</h3>

<pre	style="font-size:11pt">

	<a	name="space_summary"/>
	Summary of Instruction and Operand Address Spaces
	_________________________________________________


	Instructions are only obtained from window B0
	and B0 switches between instruction frames

	Operands may be obtained from the registers,
	from part of the actual instruction block in window B0,
	from the 63 actual application data blocks,
	from the seven alternative data blocks used by the kernel

	An application may have gigawords of storage
	in blocks from 4096 words to 16 gigawords in size

	Up to 63 blocks of 4096 words or 262144 words
	are at any time visible in 63 address windows

	Relocation Registers 1..63 are I/O ports 1..63

	Applications can change which blocks of storage
	are based in their 63 data address windows

	The thread current data spaces do not need to
	be saved at context switch. They are already
	mirrored in the Thread Control Block





	instruction address	|  operand address space
	space			|
	________________________|________________________				
	|0			|0			|
	|			|	registers	|
	|			|255____________________|				TCB and 6 kernel data windows B66..B71  
	|			 256			|				switch over application windows B1..B7
	|						| 
	|	  Window 0				|
	|						|
	|			 4095___________________|________________________
	|			|4096			|4096 alternative	|	thread control block B65
	|			|			|			|	is in adresses hex 001000..001FFF
	|			|	Window 1	|       Window 65	|	when PSR Flag see$1 = 1
	|			|			|	TCB		|
	|			|8191___________________|_______________________|
	|			|8192			|8192 alternative	|	kernel vector list B66
	|			|			|			|	is in adresses hex 002000..002FFF
	|			|	Window 2	|	Window 66	|	when PSR Flag see$2 = 1
	|			|	Vector List	|	Kernel Vectors	|
	|			|12287__________________|_______________________|
	|			|12288 or 786432	|12K / 768K alternative	|	kernel data windows B67..B71 
	|			|			|			|	populated with pages / banks
	|			|	Window 3	|	Window 67		as required
	|			|			|				and switch over windows B3..B7
	|			|16383_or_1048575_______|_______________________	in address space hex 003000..007FFF
	|			|16384 or 1048576	|16K / 1024K alternative|		   	  or 0C0000..1CFFFF
	|			|			|			|	per PSR flags see$3..see$7
	|			|	Window 4	|	Window 68
	|			|			|
	|			|_______________________|_______________________
	|			|20K or 1280K		|20K / 1280K alternative|
	|			|			|			|
	|			|	Window 5	|	Window 69
	|			|			|
	|			|_______________________|_______________________
	|			|24K or 1536K		|24K / 1536K alternative|
	|			|			|			|
	|			|	Window 6	|	Window 70	|
	|			|			|			|
	|			|_______________________|_______________________|
	|			|28K or 1792K		|28K / 1792K alternative|
	|			|			|			|
	|			|	Window 7	|	Window 71	|
	|			|			|			|
	|			|_______________________|_______________________|
	|			|32K or 2048K		|
	|			|			|
	|			|	Window 8	|
	|			|			|
	|			|_______________________|
	|			|36K or 2304K		|
	|			|			|
	|			|	Window 9	|
	|			|			|
	|			|_______________________|
	|			|40K or 2560K		|
	|			|			|
	|			|	Window 10	|
	|			|			|
	|			|_______________________|
	|			|44K or 2816K		|
	|			|			|
	


				|			|
				|			|
				|_______________________|
				|248K or 15872K		|
				|			|
				|	Window 62	|
				|			|
				|_______________________|
				|252K or 16128K		|
				|			|
				|	Window 63	|
				|			|
				|262143_or_16777215_____|




	<a	name="address_array"/>
	Addressing Arrays
	_________________

	Directly addressed application static data is in
	sequential address windows mapping continuous storage


	Arrays less than the address space in size can be addressed all at once
	in one or more address windows

				_________________________
				|			|
		WINDOW n	|	.---------------|-------.
				|_______|_______________|	|
				|	|		|	|
		WINDOW n + 1	|	|		|	|
				|_______|_______________|	|<-----	array addressed
				|	|		|	|	in a range of
		WINDOW n + 2	|	|		|	|	address windows
				|_______|_______________|	|
				|	|		|	|
		WINDOW n + x	|	.---------------|-------.
				|_______________________|





	<a	name="large_array"/>
	Contiguous Large Arrays
	_______________________

	When an array is many times the address space in size, address windows
	are used as cursors in the array, fixing dynamically on buckets of one or
	two memory blocks

	For example

			dl		array_offset
			dsl		6		. separate the 262144-word block-id
							. from the word offset

			orB, xi		WINDOW		. tag the word offset
			rbr		6		. with an address window


		.	____________________________
		.	|WINDOW|    word offset    |	<- effective address
		.	|______|___________________|	   start of structure
		.					   in accumulator / index register b


			sal		6		. position the big-block index
			aa		array_start_bank. add the array start block-id

			sabr		WINDOW		. base the block where the structure
							. starts in the address window

			la, i		64, a		. identify the next big block
			sabr		WINDOW+1	. base that in the adjacent 
							. address window

							. accumulator / index register  b is now a pointer to a
							. guaranteed 262145 words from the
							. leading edge of the structure

							. this array is any size up to
							. 16 gigawords


	<a	name="ultra_array"/>
	Ultra-Large and Distributed Arrays
	__________________________________

	Successive blocks of a large array need not be in physically continuous storage.

	The application vector page is used to frame
	<a href="kernel.html#teraword">arrays with footprint 4 terawords populated up to 1 teraword of memory<a>
	distributed over multiple array devices



	<a	name="multi_word"/>
	Multi-Word Write Operands straddling Banks
	__________________________________________

	Burst reads and writes of two or four words are at any word address.
	There is no bus alignment larger than a word

	Instructions reading or writing an operand which straddles storage blocks
	serialise the operation to word pairs or to single words

	Base pointers are relocation registers addressed as I/O ports
	and select a block either of 4096 words (a "page") or 262144 words a (a "bank")


</pre>


<a	name="protection"/>
<h3>2.7 Protection and Safety</h3>
<pre	style="font-size:11pt">

	<a	name="xlimit"/>
	Execution Protection
	____________________

	Instruction code executes either as application code or interrupt service routines

	A kernel invariably contains both application code and ISRs

	Application path traverses among instruction frames with far <a href="#go">go</a>, <a href="#call">call</a> and <a href="#fret">return</a> instructions

	Execution outside instruction frame range raises interrupt GUARD$

	Instruction frame starts at the page indexed in Port B0. Port 64 points to the Instruction Frame final page

		Port 64 = B0 + Instruction Frame Pages - 1

	Two or more pages at memory start are reserved for interrupt code

	Applications cannot enter ISR space via far <a href="#call">call</a> or <a href="#go">go</a> instruction
	although ISRs can <a href="#call">call</a>, <a href="#go">go</a> and <a href="#fret">far return</a> in this space,
	and may call outside ISR space to ISR extensions in application space

	System call interrupts (<a href="#ii">ii instruction</a>), external and spontaneous interrupts enter ISR space

	ISR space is defined by start of memory and Application Threshold Page pointer I/O Port 72

		_________________________
		|	ISR space	|
		|_______________________|________application threshold
		|			|


	Application Threshold is set by the system image at startup

	Applications and ISRs may not make service call interrupts to any pages except ISR space
	Applications may not make service call interrupts into page zero termed the restart page

		_________________________________page 0
                |       restart page	|
	ISR	|_______________________|________page 1
	space	|  service call ISRs	|
                |_______________________|________application threshold


	The restart page is reserved for interrupts which are not service calls for applications.
	These include

		restart

		soft restart elected by ISRs on serious anomaly

		<a href="kernel.html#external_i">external interrupts</a>

		floating exponent underflow / overflow

		time quantum incrementer overflow

		SMP core to core alert unicast / multicast raised by writing I/O Port 79 MCAST_TO$

	Some service call ISRs are only callable from designated kernel instruction frames

	The end of NVRAM space is defined by ROM / RAM threshold page pointer I/O Port 124

                _________________________
                |       ISR space       |
                |_______________________|________application threshold
                |                       |
		|	NVRAM continued	|
		|			|
		|			|
		|_______________________|________ROM / RAM threshold		
		|			|
		|	RAM		|


	<a	name="safety"/>
	Operand Protection
	__________________

	Applications may not place ISR space in operand address space with <a href="#sabr">sabr</a> instruction or <a href="#outA">outA |</a><a href="#outB"> outB</a> instructions

	Scope of sabr instruction is address space windows [ 2..63 ]

	outA|B instruction selects memory in address space windows [ 1, 65..71 ]
	but an application may not select memory in windows [ 65..71 ]

	An attempted write in NVRAM space raises the guard interrupt

	Reads and writes in unassigned address space windows are not possible. Windows may be set to a void state.
	Storage should only be placed in address windows of routines designated to access that storage

	Some writeable storage is for applications read-only. Prevented are

		reads and writes above WINDOW+4095 in an address window where a 4K memory block is based
		memory blocks in address space windows are 4096 or 262144 words in size

		writes from applications to

			interrupt registers

			the instruction window B0

			the application vector window B2

			the thread control block B65

			the kernel vector window B66

			kernel data windows B67..B71

		are stopped with guard interrupt
		interrupt code constructs these spaces

	Memory communicating between kernel and applications is placed in the address space during kernel routines


	<a	name="optimal_safe"/>
	Elective Safe Storage Practice
	______________________________

	Applications may place any block of executable memory except ISR space in an address space window

	Kernel and applications have the option of safe managed memory practice using the application vector list
	which the kernel may write and the application may read. See <a href="kernel.html#teraword">Teraword Arrays</a>

	Every process has its own vector list common to all its threads

	Applications identify static memory from the vector list on initialisation

	A kernel links any subsequent dynamic memory grants to the application memory estate
	and may write dynamic or shared memory pointers in the application vector list to prevent accidental change

	Pointers to far <a href="#call">call</a> and <a href="#go">go</a> targets known at build time are protected
	because they are in the literal table of the calling instruction frame which may not write itself



	<a	name="device"/>
	Device Array Protection
	_______________________

	Device arrays are  typed in the high order two bits of values read from I / O ports [ 128..191<sub>10</sub> ]


					|5     
		________________________|________
 		|10|	memory banks	| pages	| 24-bit system memory: applications may <a href="#sabr">base</a> blocks of these devices
		|__|____________________|_______|	
		|01|000000| network trunk banks	| 16-bit memory shared with platform: ISRs <a href="#sabr">base</a> banks of these devices
		|__|______|_____________________|
		|11|000000|	filestore banks	| 24-bit filestore memory: only ISRs <a href="#sabr">base</a> banks of these devices
		|__|______|_____________________|
			16|			

		*	the sizes are granule high index = [ pages / banks ] minus one

		*	type 00<sub>2</sub> indicates no device or storage

		*	applications and ISRs may <a href="#sabr">base</a> pages or banks of device [ 0 ] executable space

				<a href="#sabr">base</a> value in accumulator a
				_________________________________
				|00|		page		|
				|__|____________________________|

			applications and ISRs may <a href="#sabr">base</a> banks of any other device [ 1..63 ] of type SYSMEM(10<sub>2</sub>)

				<a href="#sabr">base</a> value in accumulator a

				_________________________________
				|01|		bank	 |device|
				|__|_____________________|______|
							 |5



	Peripheral arrays of types network trunk and filestore can only be based by interrupt code.
	This is to prevent accidental damage to static RAM file systems  or disruption in network frame trunks

        These rules are applied when <a href="#sabr">sabr</a> instruction places storage in the address space,
        not when storage is read or written

	An inadvertant attempt to base storage of a filestore or network trunk device from an application
	raises the <a href="#iassign">Guard Interrupt</a>

	Service call ISRs which base peripheral blocks are only callable from kernel iframes.
	Kernel routines unbase peripheral storage and kernel data before returning to applications

</pre>

<a	name="thread"/>
<h3>2.8 Thread Switch and Address Space</h3>

Thread current memory block pointers are not saved on thread switch because they are
already mirrored in the thread control block when the application selects memory

<p>
62 window pointers are reloaded in 31 instructions


<a	name="ioport"/>
<h3>2.9 I/O Ports for Inter-Processor Signalling / Memory and Peripheral Configuration / Timer Restart</h3>

<a	name="iosignal"/>
<h4>2.9.1: I/O Ports for Inter-Processor Signalling</h4>

<p>
I/O Port 79 MCAST_TO$ is written to multicast or unicast interrupts between SMP cores

<p>
Objective may be peripheral activation, realtime thread switch, dayclock update or other alignment, arrest of threads on process exit

<p>
SMP core / core multicast alert interrupt is driven with destination mask in MCAST_TO$ and source indication in I/O Port 78 MCAST_PENDING$

<p>
Source indications in MCAST_PENDING$ may be multiple, are reset on a single read, and are individually acknowledged in kernel storage
<pre	style="font-size:11pt">

	alert unicast/multicast		outA|B to Port 79 MCAST_TO$
					raises MCAST_PENDING$[ 1 << sending core ] at up to 24 cores
					parameters in kernel storage
</pre>

<a	name="iomem"/>
<h4>2.9.2: I/O Ports for Memory and Peripheral Configuration</h4>


I/O ports function as relocation registers and also read out memory configuration values

<p>
Port 124 <b>ram$threshold</b> contains the Start Page Index of the first RAM page in executable space

<p>
ROM is at page locations before <b>ram$threshold</b> and contains an initial instruction code image
which may be a boot routine, an operating system or an complete application image

<p>
RTA1 machine detects the size of system memory from Port 128 <b>device$flags</b>

<p>
Port 128 is the first of 64 ports describing peripheral memory typed as [ system memory |  network frames trunk | filestore ]

<a	name="iotimer"/>
<h4>2.9.3: I/O Port for Timer Interval Restart</h4>


<p>
One core may be attached to a high-frequency time quantum incrementer which interrupts on overflow

<p>
The incrementer is restarted by writing Port 76

<a	name="iolist"/>
<h4>2.9.4: I/O Port Assignments</h4>
<pre	style="font-size:11pt">

	0			actual instruction frame start page		see <a href="#go">go</a> <a href="#call">call</a> <a href="#fret">fret</a> <a href="#ii">ii</a> <a href="#ir">ir</a> <a href="#sabr">sabr</a>
	1			application private data page pointer
	2:63			application data memory window pointers
	64			actual instruction frame highest page		see <a href="#go">go</a> <a href="#call">call</a> <a href="#fret">fret</a> <a href="#ii">ii</a> <a href="#ir">ir</a> <a href="#sabr">sabr</a>
	65			thread control block pointer
	66:71			kernel data window pointers
	72	application$L	<a name="thresho"/>application lower threshold page pointer	see <a href="#go">go</a> <a href="#call">call</a> <a href="#fret">fret</a> <a href="#ii">ii</a> <a href="#ir">ir</a> <a href="#sabr">sabr</a>
				system images contain ISRs below page index APPLICATION_L
				kernel applications and all applications and libraries start at page index APPLICATION_L

	74	XI_PENDING$	external interrupts pending readable indications
	75	XI_ACK$		external interrupts acknowledge writeable lines	
	76	INC$START	high-frequency timer incrementer restart write

	77	CORE_SOCKET$	core position index on schematic	
	73	CORE_PIN$	1 << CORE_SOCKET$
	125	CORES_MASK$	1 << CORE_SOCKET$ index of all instruction processors present

	78	MCAST_PENDING$	cores -> core alert multicast pending interrupt indications
	79	MCAST_TO$	core -> core[s] alert multicast write (preemption, dayclock update, process exit->threads arrest)
	80..87	I$DATA		external devices data / status inputs
	88..95	O$DATA		external devices data / command outputs	
	101	time$zone	timezone seconds difference from GMT
	102	INDICATION$	hardware / firmware command pins
	103	chill$down	powersave programmable microseconds
	124	ram$threshold	ROM / RAM threshold
	128			system memory 4K-block high index
	129:191			devices 1:63 attributes / array size

</pre>

<a	name="iassign"/>
<h3>2.10: Interrupt Assignments</h3>

<p>
The first 4K-word block of storage or PAGE_0 contains ISR vectors:
<pre	style="font-size:11pt">

	0:0	restart
	0:1	soft restart elected by ISRs on serious anomaly
	0:2	up to eight <a href="kernel.html#external_i">external interrupts</a> distinguished by I/O port XI_PENDING$
	0:3	floating exponent underflow / overflow
	0:4	time quantum incrementer overflow restarted by writing I/O Port INC$START
	0:5	SMP core to core alert unicast / multicast interrupts
		raised by writing I/O Port 79 <a href="#iolist">MCAST_TO$</a>
		identified in I/O Port 78 <a href="#iolist">MCAST_PENDING$</a>

	plus optionally a boot routine

</pre>
The second 4K-word storage block PAGE_1 contains service call ISRs

<p>
Applications call these services with <a href="#ii">ii</a> instruction

<p>
Three service ISRs are raised automatically and also callable with <a href="#ii">ii</a> instruction
<pre	style="font-size:11pt">

	1:1	<a href="kernel.html#yield_ii">YIELD$</a>	is application callable and is also raised on expiry of timeslice
			timeslice applies when REALTIME$_CLOCK is nonzero and interrupt mask is zero
			and is a decrementing instruction ration graded by thread priority 

	1:6	<a href="kernel.html#exit_ii">EXIT$</a>	is application callable
			and is also raised by lret or fret instruction
			on internal stack empty sp = 128 in application mode

	1:31	<a href="kernel.html#guard_ii">GUARD$</a>	is raised automatically on instruction fault
			applications may also call GUARD$ diagnostically 

</pre>
<p>
PAGE_1 system call ISRs in the <a href="kernel.html">prototype kernel</a> are at these vectors
<pre	style="font-size:11pt">

	1:0
	1:1	<a href="kernel.html#yield_ii">YIELD$</a>		context switch
	1:2	<a href="kernel.html#spawn_ii">SPAWN$</a>		launch process
	1:3	<a href="kernel.html#bank_ii">BANK$</a>		acquire storage
	1:4	<a href="kernel.html#array_ii">ARRAY$</a>		acquire large storage
	1:5	<a href="kernel.html#bank_free_ii">BANK$FREE</a>	relinquish storage
	1:6	<a href="kernel.html#exit_ii">EXIT$</a>		terminate process or thread
	1:7	<a href="kernel.html#thread_ii">THREAD$</a>		launch thread

	1:8	<a href="kernel.html#total_free_ii">TOTAL$FREE</a>	amount of storage free 
	1:9	<a href="kernel.html#tag_ii">TAG$</a>		name a thread
<div style="color:#000080;background-color:#E0FFFF80">	1:10	<a href="kernel.html#assign_xvector_ii">ASSIGN_XVECTOR$</a>	add memory to kernel, write vector
</div>	1:11	<a href="kernel.html#itable_ii">I$TABLE</a>		initialise thread interrupts table 
	1:12	<a href="kernel.html#affinity_ii">AFFINITY$</a>	thread attach to specific core[s]
	1:13
	1:14	<a href="kernel.html#fp_xpo_flag_ii">FP_XPO$FLAG</a>	read and clear floating exponent outflow event
	1:15	<a href="kernel.html#xint_bind_ii">XINT$BIND</a>	thread bind interrupt source

<div style="color:#000080;background-color:#E0FFFF80">	1:16	<a href="kernel.html#handle_ii">HANDLE$</a>		acquire a handle
	1:17	<a href="kernel.html#free_handle_ii">FREE_HANDLE$</a>	relinquish a handle
	1:18	<a href="kernel.html#read_handle_ii">READ_HANDLE$</a>	read 1st word handle encoding
	1:19	<a href="kernel.html#read_xvector_ii">READ_XVECTOR$</a>	read a value from kernel vector list
	1:20	<a href="kernel.html#write_xvector_ii">WRITE_XVECTOR$</a>	write a value in kernel vector list
	1:21	<a href="kernel.html#read_socket_ii">READ_SOCKET$</a>	read both words handle encoding
	1:22	<a href="kernel.html#usocketc_ii">USOCKET$C</a>	connect/accept: attach transmission control block to handle
	1:23	<a href="kernel.html#kernel_b1_ii">KERNEL$B1</a>	switch B1 window to named kernel B1

	1:24	<a href="kernel.html#b1_ii">B1$</a>		switch B1 window to application actual B1
	1:25	<a href="kernel.html#kernel_b1_ii_1">KERNEL$B1_1</a>	switch B1 window to kernel initial B1
	1:26	<a href="kernel.html#dayclock_w_ii">DAYCLOCK$W</a>	write registers DAYCLOCK$U:DAYCLOCK$
</div>	1:27	<a href="kernel.html#twait_ii">TWAIT$</a>		wait milliseconds
	1:28	<a href="kernel.html#event_wait_ii">EVENT_WAIT$</a>	thread wait realtime event
	1:29	<a href="kernel.html#event_free_ii">EVENT_FREE$</a>	clear wait state of thread
	1:30	<a href="kernel.html#switch_fp_guard_ii">FP_GUARD$</a>	set floating point rounding guard pattern
	1:31	<a href="kernel.html#guard_ii">GUARD$</a>		diagnostic call to fault ISR

<div style="color:#000080;background-color:#E0FFFF80">	1:32	<a href="kernel.html#xbase_ii">XBASE$32</a>	place peripheral memory array in address window
	1:33	<a href="kernel.html#xbase_ii">XBASE$33</a>
	1:34	<a href="kernel.html#xbase_ii">XBASE$34</a>
	1:35	<a href="kernel.html#xbase_ii">XBASE$35</a>
	1:36	<a href="kernel.html#xbase_ii">XBASE$36</a>
	1:37	<a href="kernel.html#xbase_ii">XBASE$37</a>
	1:38	<a href="kernel.html#xbase_ii">XBASE$38</a>
	1:39	<a href="kernel.html#xbase_ii">XBASE$39</a>

	1:40	<a href="kernel.html#xbase_ii">XBASE$40</a>
	1:41	<a href="kernel.html#xbase_ii">XBASE$41</a>
	1:42	<a href="kernel.html#xbase_ii">XBASE$42</a>
	1:43	<a href="kernel.html#xbase_ii">XBASE$43</a>
	1:44	<a href="kernel.html#cache_standard_netbuf_ii">CACHE_NETB$</a>	IP initialisation call
	1:45	<a href="kernel.html#base_standard_netbuf_ii">ON_NETB$</a>	place socket buffer array in application address space
	1:46	<a href="kernel.html#unbase_deviceb_ii">FREE_DEVB$</a>	void address space window 32 used for peripheral arrays 
	1:47	<a href="kernel.html#unbase_socketb_ii">FREE_SOCKB$</a>	void address space window 47 used for socket structure

	1:48	<a href="kernel.html#unbase_standard_netbuf_ii">FREE_NETB$</a>	void application address windows -> socket buffer array
	1:49	<a href="kernel.html#net2sym_ii">NET2SYM$</a>	assign TCP connection as process stdin stdout stderr
</div>	1:50	<a href="kernel.html#thread_state_ii">THREAD$STATE</a>	retrieve state of thread
	1:51	<a href="kernel.html#storage_block_idxa_ii">A$IDX</a>		retrieve active page pointer [a]
	1:52	<a href="kernel.html#storage_block_idxb_ii">B$IDX</a>		retrieve active page pointer [b]
	1:53
	1:54
	1:55

<div style="color:#000080;background-color:#E0FFFF80">	1:56	<a href="kernel.html#usocket_ii">USOCKET$</a>	bind: attach port socket structure to handle
	1:57	<a href="kernel.html#file_open_frame_ii">FO$FRAME</a>	file open: obtain file open block
	1:58	<a href="kernel.html#files_open_heap_ii">FO$HEAP</a>		thread start: initialise files open heap
	1:59	<a href="kernel.html#file_handle_ii">FILE$HANDLE</a>	file open: attach file open block attach to handle
</div>	1:60	<a href="kernel.html#zeta_ii">$ZETA</a>		terminate named process or thread
	1:61	<a href="kernel.html#send_alert_ii">ALERT$</a>		request core to core[s] multicast transmission
	1:62
	1:63
	
</pre>
<a style="color:#000080;background-color:#E0FFFF80">Shaded entries</a> are ISRs mainly called from kernel routines. Some are kept to a closed ring of calling iframes for safety and screened from other callers

<a	name="regisi"/>
<h2>3. Registers and Instruction Set</h2>

<a	name="nonar"/>
<h3>3.1 Non-Addressable Registers</h3>

<p>
Two registers are not addressable. The program counter which contains an absolute address 48 bits in size, and the Processor State Register, which contains settings and the carry bit

<p>
The program counter is never stored as its absolute 48-bit value. Its value minus B0 * 4096 is pushed on the internal stack
on interrupts and calls

<p>
Interrupts and calls between instruction frames push Iframe Name after pushing intraframe offset

<p>
The Processor State Register is saved on interrupts

<p>
The layout of the Processor State Register is
<pre	style="font-size:11pt">

		23             18   16     14           8   7   6   5   4   3       0
		_______________________________________________________________________
		| I | 0 0 0 0 | i i i | 0 | see$          | H | R | R | W | F 0 0 | C |
		|   |         |       |   | 1 2 3 4 5 6 7 |   | Z |16 |16 | P     |   |
		|___|_________|_______|___|_______________|___|___|___|___|_R_____|___|

</pre>
The PSR flags shown as 0 are not currently used
<p>
PSR flags 15..0 are directly application programmable with instructions <b>on</b> and <b>off</b>

<p>
Flag 23 <b>I</b> is on during an interrupt: <a href="#register">accumulator, index, mask and counter registers</a> are in the range 128..255. Application registers are 0..127.

<p>
All 256 registers  are absolutely addressable like storage operands, but <a href="#register">applications cannot write interrupt registers</a>.

<p>
Flags 18..16 <b>iii</b> are the interrupt mask. Both applications and ISRs can swap and restore the
interrupt mask with the <b>Switch Interrupt Mask</b> instruction <b>sim</b>

<p>
Flags 14..8 <b>see$1..see$7</b> individually place TCB and kernel storage in B65..B71 in address windows 1..7
where otherwise application data storage in B1..B7 is addressed

<p>
Flag 7 <b>half$w</b> concerns instructions which can take a byte operand as an alternative to a word operand.
RTA1 is not an octet-addressing machine, and any byte other than a 24-bit byte is a field of a storage location.

The 32 instructions in Instruction File 1 may take a storage word or part of a storage word as operand.
These bytes are either halfwords (12 bits) with sign extension on read
<pre	style="font-size:11pt">

		 23			 11		       0
		_________________________________________________
		|	    h1		|	  h2		|
		|_______________________|_______________________|

</pre>
<p>
or else they are thirdwords (8 bits) with sign extension on read
<pre	style="font-size:11pt">

		 23		 15		 7	       0
		_________________________________________________
		|	t1	|	t2	|	t3	|
		|_______________|_______________|_______________|

</pre>		
<p>

It is undesirable that the File 1 Instructions should all have five different encodings
for accessing bytes

<p>
Instructions which access bytes have three byte-select encodings available.
The application accesses thirdwords unless PSR flag <b>half$w</b> = 1 = halfword access

<p>
Flags 6 5 and 4 adjust the <b>Bit Stream Read Channel</b> and <b>Bit Stream Write Channel</b>

<p>
Flag 6 <b>b$streamZR</b> affects the operation of the <b>Read Staging Register</b> instruction <b>rsr</b>,
which makes a stream of bits or bytes serially available to the arithmetic registers

<p>
<b>b$streamZR</b> states that bits from the staging register <b>RDATA</b> shall be shifted into a cleared arithmetic register,
saving an extra instruction to mask the required field. Otherwise the previous arithmetic register contents are shifted towards
the high order bit positions as new bits are transferred from <b>RDATA</b>

<p>
Flag 5 <b>b$stream16r</b> also affects the operation of <b>Read Staging Register</b>.
Only 16 bits are delivered from each input data word if <b>b$stream16r</b> = 1.
The high-order bits 23..16 are discarded when <b>b$stream16r</b> = 1.
This allows efficient handling with network data and with 16-bit peripherals.
If <b>b$stream16r</b> = 0 successive <b>rsr</b> instructions deliver all the 24 bits read from storage.

<p>
Flag 4 <b>b$stream16w</b> affects the operation of <b>Write Staging Register</b> instruction <b>wsr</b>
which writes a stream of bits or bytes from the arithmetic registers. Bits shifted into Staging Register
<b>WDATA</b> are stored at 16 bits per data word when <b>b$stream16w</b> = 1.
This allows efficient handling with network data and with 16-bit peripherals.
If <b>b$stream16w</b> = 0 successive <b>wsr</b> instructions compose 24 bits for each storage write.

<p>
Flag 3 <b>fp$r</b> is used for teaming pairs of floating numbers to calculate 192-bit values.
When <b>fp$r</b> is asserted floating instructions store a minor result in registers
8..11. If the entire result is contained in the major result in accumulators a:b:mantissa2:mantiss3 then
the minor result is zero. The minor result is used in further floating operations on pairs of 96-bit
floating numbers for 192-bit values

<p>
Flag 0 <b>carry$</b> is set or cleared by this subset of the fixed point instructions
<pre	style="font-size:11pt">

	<a href="#aa">aa</a>	add to accumulator a
	<a href="#ab">ab</a>	add to accumulator b
	<a href="#ana">ana</a>	add 2s-complement to accumulator a
	<a href="#anb">anb</a>	add 2s-complement to accumulator b
	<a href="#da">da</a>	double length ddd to accumulators a:b
	<a href="#dan">dan</a>	double length add 2s-complement to accumulators a:b
	<a href="#src">src</a>	circular shift right through carry$
	<a href="#slc">slc</a>	circular shift left through carry$
	<a href="#popA">popA</a>	pop and AddTo

</pre>

<p>
The instructions which add the twos complement of the operand, <a href="#ana">ana</a> <a href="#anb">anb</a> <a href="#dan">dan</a>,
have the same result in carry$ as positive adds which have that twos complement as input operand.
carry$ is set if addition at the register high order bit position carries

<p>
There are no PSR condition bits other than carry$. All other conditions are available in the register
containing the instruction result. Many different results can be examined long after they are generated


<p>
The conditional jump instructions which examine carry$ or a register or storage word are
<pre	style="font-size:11pt">
	<a href="#jc">jc</a>	Jump Carry
	<a href="#jnc">jnc</a>	Jump No Carry
	<a href="#jza">jza</a>	Jump Zero a
	<a href="#jzb">jzb</a>	Jump Zero b
        <a href="#jnza">jnza</a>	Jump NonZero a
        <a href="#jnzb">jnzb</a> 	Jump NonZero b
	<a href="#jpa">jpa</a>	Jump Positive a
	<a href="#jpb">jpb</a>	Jump Positive b
	<a href="#jna">jna</a>	Jump Negative a
	<a href="#jnb">jnb</a>	Jump Negative b
	<a href="#jpo">jpo</a>	Jump Parity Odd [ a <a style="color:FFFFFF;background-color:0000FF">AND</a> k ]	[ macro <a href="#jpo">jpe</a> Jump Parity Even ]
	<a href="#jao">jao</a>	Jump a Odd 			[ macro <a href="#jao">jae</a> Jump a Even ]
	<a href="#jdz">jdz</a>	Jump a b Double Zero
	<a href="#mta">mta</a>	Masked Test a skip Equal	[ macro <a href="#mta">mtane</a> Masked Test a Skip NOT = ]
	<a href="#dte">dte</a>	Double Test skip Equal
	<a href="#tz">tz</a>	Test Zero skip
	<a href="#tp">tp</a>	Test Positive skip
	<a href="#ts">ts</a>	Test and Set skip
	<a href="#jxge">jxge</a>	Jump x NOT < r			[ macro <a href="#jxge">jxl</a> Jump x < r ]
	<a href="#jyge">jyge</a>	Jump y NOT < r			[ macro <a href="#jxge">jyl</a> Jump y < r ]
	<a href="#jdr">jdr</a>	Jump Decrement Repeat Count
</pre>

<a	name="register"/>
<h3>3.2 Addressable Application and Interrupt Registers</h3>

<p>
RTA1 registers occur twice. The application has 128 registers and interrupts have 128 registers

<p>
All 256 registers are in the operand address space as one linear array, but applications cannot write interrupt registers

<p>
Some registers are implicitly addressed as the register operand of an instruction.
These register-side operands are compartmented by application / interrupt context

<p>
The interrupt register set is a replica of the application register set, and has the same arithmetic registers,
index registers and special-purpose registers, with some minor differences

<p>
Having one set of interrupt registers does not mean that interrupts are not nested.
It means that certain much-used ISRs which are never nested in execution have a set of registers which can be used without saving.
Other ISRs wich may run nested must save registers before they change them.
Interrupts also have an internal stack made from 104 of their 128 registers.

<p>
An important category of interrupts which are never nested is application-callable kernel routines
which are implemented as internal interrupts. These have a set of registers for immediate free use,
and they only need to touch the application registers in order to read parameters and write results

<p>
It is advisable to implement a kernel routine as an internal interrupt instead of a call if the routine
temporarily manipulates the address space via the PSR flags. On return from interrupt the the saved PSR
is reloaded and all flags are restored


<pre	style="font-size:11pt">



		Layout of the Register Stack
		____________________________

		Notes
		_____

		Only registers 0..127 switch with the thread

		The internal stack addressed with sp is only large enough for scalars and pointers
		Frame Pointer register fp is intended to be an external stack pointer for structures and arrays

		The application internal stack pointer is guarded from overflow (decrement
		below 24) and underflow (increment above 128). At sp = 128 the internal
		stack is completely empty. At sp = 24 the internal stack is completely full
		Stack range violation raises the guard interrupt at vector 1:31

		DAYCLOCK$U:DAYCLOCK$ are a millisecond counter in the interrupt register list
		All threads read the dayclock register pair atomically with 48-bit-operand instructions

		Interrupt TIMER$ is sprung for example from a nanosecond incrementer
		and one designated core updates the 48-bit millisecond dayclock and
		writes it to kernel storage

		The designated core writes I/O port DAYCLOCK$UPDATE$ to multicast
		interrupt TIME$POINT to the other cores. They update the dayclock
		value in their own registers

				dl	dayclock$	. read kernel storage
				ds	DAYCLOCK$U	. write registers
				ir	0		. return from TIME$POINT ISR

		The incrementer can be programmed for doubled, octupled or other power-2
		higher frequency than a millisecond, making the dayclock quantum a fraction
		of a millisecond and timer interrupt more frequent

		A negative number of beats is output to a high-frequency incrementer via
		I/O port OVERFLOWER$. TIMER$ interrupts when when the incrementer carries

		The processor executing ISR TIMER$ reprograms OVERFLOWER$

		The emulated machine retrieves millisecond time periodically from the emulator host

		PRIORITY$ is a copy of the running thread's priority stored by software for
		rapid retrieval at thread switch, and for instant evaluation of SMP inter-processor
		preemptive interrupt broadcasts

		REALTIME$_CLOCK is a decrementing timer count which switches the running
		thread on expiry. If the initial REALTIME$_CLOCK value assigned to the thread
		is zero, neither decrement nor switch interrupt takes place




			The Application Registers						  The Interrupt Registers
			_________________________						  _______________________


		 23			       0					 23			       0
		_________________________________					_________________________________
	0	|		r		|  repeat count + limit pointer	128	|		r_x		|
		|_______________________________|					|_______________________________|
	1	|		k		|	mask register		129	|		k_x		|
		|_______________________________|					|_______________________________|
	2	|		x		|	index register		130	|		x_x		|
		|_______________________________|					|_______________________________|
	3	|		y		|	index register		131	|		y_x		|
		|_______________________________|					|_______________________________|
	4	|		a		|  accumulator + index register	132	|		a_x		|
		|_______________________________|					|_______________________________|
	5	|		b		|  accumulator + index register	133	|		b_x		|
		|_______________________________|					|_______________________________|
	6	|	mantissa2		|	accumulator		134	|	mantissa2_x		|
		|_______________________________|					|_______________________________|
	7	|	mantissa3		|	accumulator		135	|	mantissa3_x		|
		|_______________________________|					|_______________________________|
	8	|		aA		|	accumulator		136	|		aA_x		|
		|_______________________________|					|_______________________________|
	9	|		bA		|	accumulator		137	|		bA_x		|
		|_______________________________|					|_______________________________|
	10	|	mantissa2A		|	accumulator		138	|	mantissa2A_x		|
		|_______________________________|					|_______________________________|
	11	|	mantissa3A		|	accumulator		139	|	mantissa3A_x		|
		|_______________________________|					|_______________________________|
	12	|	    	 p		|	bitstream pointer write	140	|		p_x		|
		|_______________________________|					|_______________________________|
	13	|	   	 q		|	bitstream pointer read	141	|		q_x		|
		|_______________________________|					|_______________________________|
	14	|	  	 fp		|	index register		142	|		fp_x		|
		|_______________________________|					|_______________________________|
	15	|	  	 sp		|	index register		143	|		sp_x		|
		|_______________________________|					|_______________________________|
	16	|				|	scratch			144	|				|
		|_______________________________|					|_______________________________|
	17	|				|	scratch			145	|				|
		|_______________________________|					|_______________________________|
	18	|				|	scratch			146	|				|
		|_______________________________|					|_______________________________|
	19	|				|     < scratch	| rounding >	147	|	fp$guard		|
		|_______________________________|					|_______________________________|
	20	|	   RDATAC		|	bitstream counter read	148	|	REALTIME$_CLOCK		|
		|_______________________________|					|_______________________________|
	21	|	    RDATA		|	bitstream data read	149	|	PRIORITY$		|
		|_______________________________|					|_______________________________|
	22	|	   WDATAC		|	bitstream counter write	150	|	DAYCLOCK$U		|
		|_______________________________|					|_______________________________|
	23	|	    WDATA		|	bitstream data write	151	|	DAYCLOCK$		|
		|_______________________________|					|_______________________________|
	24	|	maximal pushed word	|				152	|				|
		|_______________________________|					|_______________________________|
	25	|				|				153	|				|
		|_______________________________|					|_______________________________|
	26	|				|				154	|				|
		|_______________________________|					|_______________________________|
	27	|				|				155	|				|
		|_______________________________|					|_______________________________|
	28	|				|				156	|				|
		|_______________________________|					|_______________________________|
	29	|				|				157	|				|








	118									246
		|_______________________________|					|_______________________________|
	119	|				|				247	|				|
		|_______________________________|					|_______________________________|
	120	|				|				248	|				|
		|_______________________________|					|_______________________________|
	121	|				|				249	|				|
		|_______________________________|					|_______________________________|
	122	|				|				250	|				|
		|_______________________________|					|_______________________________|
	123	|				|				251	|				|
		|_______________________________|					|_______________________________|
	124	|				|				252	|				|
		|_______________________________|					|_______________________________|
	125	|				|				253	|				|
		|_______________________________|					|_______________________________|
	126	|				|				254	|				|
		|_______________________________|					|_______________________________|
	127	|				|	first pushed word	255	|				|
		|_______________________________|					|_______________________________|




	bit stream channel control registers in the user register set

	        RDATAC
		RDATA
        	WDATAC
		WDATA

        are not duplicated in the interrupt register set as other registers are

        their equivalent positions 148..151 are taken by clock and timer registers

		REALTIME$_CLOCK
		PRIORITY$
		DAYCLOCK$U
		DAYCLOCK$

        Few ISRs are expected to program bit streams. An ISR which programs RDATAC RDATA 
	or WDATAC WDATA must first save them. Instructions rsr wsr in interrupt mode use
	application RDATAC RDATA WDATAC WDATA at absolute addresses 20..23

	storage read pointer q used by rsr instruction is replicated in application and
	interrupt register sets. rsr instruction in interrupt mode uses q_x. ISRs may
	otherwise use q_x as a general purpose pointer

	storage write pointer p used by wsr instruction is replicated in application and
	and interrupt register sets. wsr instruction in interrupt mode uses p_x. ISRs may
	otherwise use p_x as a general purpose pointer


</pre>



<a	name="iset"/>
<h3>3.3 Instruction Set Summary and <a href="#lookup">Lookup Panel</a></h3>

<p>
RTA1 instructions are grouped in 5 columns called instruction files.
The five instruction files map to eight operand characteristics.

<p>
Instruction File 1 spans six of the eight operand types. Instruction File 1 is integer operations
with single word operand. The 24-bit operand may be read from a word, a half or third word,
the immediate value of the effective address, or a sign-extended immediate value

<p>
Instruction Files 4A and 5A are a small number of special instructions which only need an effective address immediate or a sign-extended immediate.

<p>
Instruction File 6 contains shifts and jumps which use the effective address as an immediate operand.

<p>
Instruction File 7 contains arithmetic instructions which have an operand of one, two or four words

<pre	style="font-size:11pt">


	<a	name="lookup"/>
	Instructions Lookup Panel		Instruction File 4a			Instruction File 5A
	_________________________		___________________			___________________

						<a href="#ina">inA</a>	In Port to A			<a href="#on">on</a>	PSR Flags On
						<a href="#inb">inB</a>	In Port to B			<a href="#off">off</a>	PSR Flags Off

						<a href="#outa">outA</a>	Out A to Port			<a href="#rsr">rsr</a>	Read Staging Register
						<a href="#outb">outB</a>	Out B to Port			<a href="#wsr">wsr</a>	Write Staging Register

						<a href="#reload">reload</a>	switch application memory


						<a href="#sabr">sabr</a>	Store a to Base Register	<a href="#lret">lret</a>	local return
											<a href="#fret">fret</a>	far return

						<a href="#rex">rex</a>	Repeat Execute			<a href="#ii">ii</a>	Internal Interrupt
						<a href="#jdz">jdz</a>	Jump Double Zero		<a href="#ir">ir</a>	Interrupt Return



	Instruction File 1			Instruction File 6			Instruction File 7
	__________________			__________________			__________________


	<a href="#sr">sr</a>	Store Repeat Count		<a href="#sar">sar</a>	Shift a Right			<a href="#ts">ts</a>	Test and Set
	<a href="#sk">sk</a>	Store Mask Register		<a href="#sbr">sbr</a>	Shift b Right			<a href="#n">n</a>	Negate

	<a href="#sx">sx</a>	Store Index Pointer x		<a href="#dsr">dsr</a>	Double Shift Right		<a href="#inc">inc</a>	Increment
	<a href="#sy">sy</a>	Store Index Pointer y		<a href="#jdr">jdr</a>	Jump Decrement Repeat Count	<a href="#dec">dec</a>	Decrement

	<a href="#sa">sa</a>	Store Accumulator a		<a href="#sal">sal</a>	Shift a Left			<a href="#sim">sim</a>	Switch Interrupt Mask
	<a href="#sb">sb</a>	Store Accumulator b		<a href="#sbl">sbl</a>	Shift b Left			<a href="#popa">popA</a>	Pop and AddTo

	<a href="#z">z</a>	Store Zero			<a href="#dsl">dsl</a>	Double Shift Left		<a href="#src">src</a>	Shift Circular Right through Carry
	<a href="#pop">pop</a>	Pop				<a href="#lcal">lcal</a>	Local Call			<a href="#slc">slc</a>	Shift Circular Left through Carry

	<a href="#lr">lr</a>	Load Repeat Count		<a href="#rar">rar</a>	Rotate a Right			<a href="#qs">qs</a>	Quadruple Store
	<a href="#lk">lk</a>	Load Mask Register		<a href="#rbr">rbr</a>	Rotate b Right			<a href="#ql">ql</a>	Quadruple Load

	<a href="#lx">lx</a>	Load Index Pointer x		<a href="#drr">drr</a>	Double Rotate Right		<a href="#dte">dte</a>	Double Test Equal
	<a href="#ly">ly</a>	Load Index Pointer y		<a href="#jnc">jnc</a>	Jump No Carry			<a href="#dpop">dpop</a>	Double Pop (macro)

	<a href="#la">la</a>	Load Accumulator a		<a href="#ral">ral</a>	Rotate a Left			<a href="#fa">fa</a>	Floating Add
	<a href="#lb">lb</a>	Load Accumulator b		<a href="#rbl">rbl</a>	Rotate b Left			<a href="#fan">fan</a>	Floating Add Negative

	<a href="#tz">tz</a>	Test Zero			<a href="#drl">drl</a>	Double Rotate Left		<a href="#fm">fm</a>	Floating Multiply
	<a href="#tp">tp</a>	Test Positive			<a href="#jc">jc</a>	Jump on Carry			<a href="#fd">fd</a>	Floating Divide
	<a href="#tnz">tnz</a>	Test NonZero (macro)
	<a href="#tn">tn</a>	Test Negative (macro)

	<a href="#ax">ax</a>	Add to Index Pointer x		<a href="#saa">saa</a>	Shift a Algebraic		<a href="#qpop">qpop</a>	Quadruple Pop
	<a href="#ay">ay</a>	Add to Index Pointer y		<a href="#sba">sba</a>	Shift b Algebraic		<a href="#qpush">qpush</a>	Quadruple Push

	<a href="#or">or</a>	OR Accumulator a		<a href="#dsa">dsa</a>	Double Shift Algebraic		<a href="#ex">ex</a>	Execute
	<a href="#orb">orB</a>	OR Accumulator b		<a href="#jao">jao</a>	Jump a Odd			<a href="#dpush">dpush</a>	Double Push
						<a href="#jao">jae</a>	Jump a Even (macro)

	<a href="#and">and</a>	AND Accumulator a		<a href="#jpa">jpa</a>	Jump Positive a			<a href="#lsc">lsc</a>	Load Shift and Count
	<a href="#andb">andB</a>	AND Accumulator b		<a href="#jpb">jpb</a>	Jump Positive b			<a href="#mta">mta</a>	Masked Test Equal a
											<a href="#mtane">mtane</a>  Masked Test Not Equal a (macro)

	<a href="#xor">xor</a>	XOR Accumulator a		<a href="#j">j</a>	Jump				<a href="#sc">sc</a>	Store Carry
	<a href="#xorb">xorB</a>	XOR Accumulator b		<a href="#jpo">jpo</a>	Jump Parity Odd			<a href="#mlb">mlb</a>	Masked Load b
						<a href="#jpo">jpe</a>	Jump Parity Even (macro)

	<a href="#aa">aa</a>	Add To Accumulator a		<a href="#jza">jza</a>	Jump Zero a			<a href="#ds">ds</a>	Double Store
	<a href="#ab">ab</a>	Add To Accumulator b		<a href="#jzb">jzb</a>	Jump Zero b			<a href="#dl">dl</a>	Double Load

	<a href="#ana">ana</a>	Add Negative To Accumulator a	<a href="#jnza">jnza</a>	Jump NonZero a			<a href="#da">da</a>	Double Add
	<a href="#anb">anb</a>	Add Negative To Accumulator b	<a href="#jnzb">jnzb</a>	Jump NonZero b			<a href="#dan">dan</a>	Double Add Negative

	<a href="#m">m</a>	Multiply			<a href="#jna">jna</a>	Jump Negative a			<a href="#dlsc">dlsc</a>	Double Load Shift and Count
	<a href="#mf">mf</a>	Multiply Fractional		<a href="#jnb">jnb</a>	Jump Negative b

	<a href="#d">d</a>	Divide				<a href="#jxge">jxge</a>	Jump x Not Less Than r		<a href="#go">go</a>	Jump to Iframe
	<a href="#push">push</a>	Push				<a href="#jyge">jyge</a>	Jump y Not Less Than r		<a href="#call">call</a>	Call Iframe
						<a href="#jxge">jxl</a>	Jump x Less Than r (macro)
						<a href="#jyge">jyl</a>	Jump x Less Than r (macro)

	INTEGER COMPARE MACROS
	______________________

	<a href="#anu">anu/tanu</a>	Add Negative Upper a (macro)
	<a href="#anuba">anuba/tanuba</a>	Add Negative Upper b (macro)

</pre>

<a	name="ifield"/>
<h3>3.4 Instruction Layout, Effective Address Generation and Operand Codes</h3>
<a	name="layout"/>
<h4>3.4.1 Instruction Layout</h4>

<p>
The operand code is marked J and determines the operand type
and which instruction file the instruction F is from

<p>
The instruction stem code is marked F and determines an instruction within the instruction file

<p>
Instructions in File 1 derive a single 24-bit operand from a register, a storage word or byte, the effective address as immediate operand, or a sign-extended-immediate

<p>
Instructions in File 4A take the effective address as immediate operand

<p>
Instructions in File 5A take a sign-extended immediate operand

<p>
Instructions in File 6 take the effective address as immediate operand

<p>
Instructions in File 7 take a one-word two-word or four-word operand in registers or storage

<pre	style="font-size:11pt">


		 23         18   15                            0
		_________________________________________________
		|     F    | J  |            address            |       instruction word
		|__________|____|_______________________________|       ________________



</pre>
<a	name="ea"/>
<h4>3.4.2 Effective Address Generation</h4>
<pre	style="font-size:11pt">



	effective address generation
	____________________________


	If the operand code J is other than 5, an effective address is
	generated according to fields I X U of the address as shown here




		 23         18     14    11                    0
		_________________________________________________
		|     F    | J  |I|  X  |           U           |       instruction word
		|__________|____|_|_____|_______________________|       ________________
				|
				|15




	if I = 0 the effective address is 15 bits X U

	if I = 1

		if X = 0
			the effective address is indirect and found in in the storage word at 0 + U

			if U < 256 the indirect 24-bit address is the value in a register 
			otherwise the 24-bit indirect address is the value in a storage word
			in Window 0 locations 256..4095


		if X = 1
			the effective address is indirect and found in the storage word at 
			4096 + U which is in Window 1 (Window 65 if see$1 is on)





		Base + Displacement Addressing I=1 and X = [2|3|4|5|6|7]
		________________________________________________________


		 23					       0
		_________________________________________________		
		|		index value 24 bits		|	index register [x|y|a|b|fp|sp]
		|_______________________________________________|	______________________________
					|			|
					|    + displacement	|
					|    12 bits unsigned	|
		 23         18     14	 11	               0
	  	_________________________________________________
		|     F    | J  |I|  X  |	    U		|	instruction word
		|__________|____|_|_____|_______________________|	________________
				|
				|15			


		if X = 2
			the effective address is the sum of
			index register x plus the 12 unsigned bits U


		if X = 3
			the effective address is the sum of
			index register y plus the 12 unsigned bits U


		if X = 4
			the effective address is the sum of
			accumulator a plus the 12 unsigned bits U


		if X = 5
			the effective address is the sum of
			accumulator b plus the 12 unsigned bits U


		if X = 6
			the effective address is the sum of
			frame pointer register fp plus the 12 unsigned bits U


		if X = 7
			the effective address is the sum of
			stack pointer register sp plus the 12 unsigned bits U



</pre>
<a	name="ocodes"/>
<h4>3.4.3 Operand Codes and Instruction Files</h4>
<pre	style="font-size:11pt">



	The meanings of operand code J
	______________________________


	000	The instruction is in Instruction File 1			mnemonic w0
		and the storage operand is the computer word
		at the effective address I X U					assembler syntax example
										________________________

										la		this_word
										sx		that_word, y, w0
										push		a_word

										ly		*indirectly

										________________________

										operand W0 = word is the default
										the mnemonic W0 need not be typed
										________________________


		 23					       0
		_________________________________________________
		|						|	register
		|_______________________________________________|	________
		|						|

		|						|

		|						|

		|_______________________________________________|
		|		       w0			|	storage
		|_______________________________________________|	_______
		 23					       0




 





	operand codes J 001..011 when PSR Flag half$w = 0
	_________________________________________________

	Partial words are only written and read in system memory

	Bytes are sign extended to a 24-bit word on load, including
	push to the internal stack from a byte of system memory

	Byte writes to storage are from the low-order bits of the
	source register, including byte writes to system memory
	from the register at the internal stack top----------------->		pop[,t1|t2|t3]	target

	Only 24-bit words are read from registers addressed as storage
	Only 24-bit words are written to registers addressed as storage

 


	001	The instruction is in Instruction File 1			mnemonic t1
		and the storage operand is bits 23..16 of
		the word at effective address I X U				assembler syntax example
										________________________

		load and store are to bits 7..0 of the CPU			lb, t1		structure, fp		
		register with sign extension on load				pop		outside,,t1

		bits 15..0 of the memory word are unchanged on store





		 23					       0
		_________________________________________________
		|<------- sign extension on read:		|	register
		|_______________________________________________|	________
						|		|
								|		
		<------------------------------->		|
		|						
								|
		|		<------------------------------->
		|		|		
		|_______________|_______________________________
		|	t1	|		|		|	storage
		|_______________|_______________|_______________|	_______
				 23	      16










	010	The instruction is in Instruction File 1			mnemonic t2
		and the storage operand is bits 15..8 of
		the word at effective address I X U				assembler syntax example
										________________________

		load and store are to bits 7..0 of the CPU			andB, t2	record, y		
		register with sign extension on load				tp		reaction, fp, t2
										sr, t2		latent_parameter
		bits 23..16, 7..0 of the memory word
		are unchanged on store



 



 


		 23					       0
		_________________________________________________
		|<------- sign extension on read:		|	register
		|_______________________________________________|	________
						|		|
						|		|
				<--------------->		|
				|				
								|
				|		<--------------->
				|		|		
		________________|_______________|_______________
		|		|	t2	|		|	storage
		|_______________|_______________|_______________|	_______
				 15	       8








	011	The instruction is in Instruction File 1			mnemonic t3
		and the storage operand is bits 7..0 of
		the word at effective address I X U				assembler syntax example
										________________________

		load and store are to bits 7..0 of the CPU			d, t3		divisor_array, x
		register with sign extension on load				push		everyone,,t3

		bits 23..8 are unchanged on store

		PARTIAL WORDS MAY ONLY BE READ FROM SYSTEM			xor, t3		keyvalue
		MEMORY AND WRITTEN TO SYSTEM MEMORY

		REGISTERS ARE 24-BIT WORD SCALARS
		OR MULTI-WORD-SCALARS






		 23					       0
		_________________________________________________
		|<------- sign extension on read:		|	register
		|_______________________________________________|	________
						|		|
						|		|
						|		|
								
						|		|
						|		|				
		________________________________|_______________|
		|		|		|	t3	|	storage
		|_______________|_______________|_______________|	_______
						 7	       0








	operand codes J 010..011 when PSR Flag half$w = 1
	_________________________________________________

	Partial words are only written and read in system memory

	Bytes are sign extended to a 24-bit word on load, including
	push to the internal stack from a byte of system memory

	Byte writes to storage are from the low-order bits of the
	source register, including byte writes to system memory
	from the register at the internal stack top----------------->		pop[,h1|h2]	 target

	Only 24-bit words are read from registers addressed as storage
	Only 24-bit words are written to registers addressed as storage




	010	The instruction is in Instruction File 1			mnemonic h1
		and the storage operand is bits 23..12 of
		the word at effective address I X U				assembler syntax example
										________________________

		load and store are to bits 11..0 of the CPU			lb, h1		katakana_table, a
		register with sign extension on load				z		restart_counter,,h1

		bits 11..0 of the memory word are unchanged on store



 


		 23					       0
		_________________________________________________
		|<------- sign extension:			|	register
		|_______________________________________________|	________
					|			|
					|			|
		<----------------------->			|
		|						
								|
		|			<----------------------->
		|			|		
		|_______________________|_______________________
		|	    h1		|			|	storage
		|_______________________|_______________________|	_______
		 23		      12




 







	011	The instruction is in Instruction File 1			mnemonic h2
		and the storage operand is bits 11..0 of
		the word at effective address I X U				assembler syntax example
										________________________

		load and store are to bits 11..0 of the CPU			tz, h2		restart_counter
		register with sign extension on load				pop		along, b, h2

		bits 23..12 of the memory word are unchanged on store





		 23					       0
		_________________________________________________
		|<------- sign extension:			|	register
		|_______________________________________________|	________
					|			|
								|
					|			|
					|			
					|			|		
		________________________|_______________________|
		|			|	   h2		|	storage
		|_______________________|_______________________|	_______
					 11		       0








	Operand Codes J 100..111
	________________________

	100	The instruction is in Instruction File 1			mnemomic i
		and the immediate operand is the effective
		address with or without indirection or indexing			assembler syntax example
										________________________

										lr, i		4, x

										lx, i		frame_size, sp
										aa, i		63



		instructions in Instruction File 4A also have J			sabr		BASE_REGISTER_33
		code 100 and the effective address as operand			inB		PORT_131A






	101	The instruction is in Instruction File 1			mnemonic xi
		and the sign extended immediate operand
		is I X U = bits 15..0 of the instruction word			assembler syntax example
										________________________

										ax, xi		-FRAME_SIZE

										ly, xi		$literal("ISBN %s ":;
													 "Title %s ":;
													 "Author %s\n")

										push, xi	-12500



		 23					       0
	 	_________________________________________________
		|+sign extension+				|	register
		|_______________________________________________|	_______
				|				|
				|				|		
								|
				|						
				|				|
		________________|_______________________________|
		| ffff f  | 101	|	   immediate		|	instruction
		|_________|_____|_______________________________|	___________
				 15			       0





		instructions in Instruction File 5A also have J = 101		rsr		BYTE_SIZE
		nd the sign extended 16-bit immediate operand I X U		on		see$6++see$7
										lret		+1



	110	The instruction is in Instruction File 6 and the		assembler syntax example
		operand is the effective address after any			________________________
		indirection or indexing
										drl		BYTE_SIZE
										dsr		15, x
										j		*somewhere
										jc		not_less
										sal		*PAGE_SIZE_LOG
										lcal		0, a



	111	The instruction is in Instruction File 7 and the		assembler syntax example
		operand is one or two or four words at the			________________________
		effective address I X U

										fm	$literals_B3(1.633*-1200009)

										qpush		segment:sequence
												

										dlsc		mantissa
										ds		normalised

										popA		byte_count, x



</pre>

<a	name="isymbol"/>
<h3>3.5 Instruction Field Summary and Programming Symbols</h3>

All instructions at present have one operand field and most may have subfields

<p>
The first subfield is the operand address or value, the second a possible index register, the third an operand type, for example
<pre	style="font-size:12pt">

	andB	table, x, h1

</pre>
<p>
The third subfield, operand type [w0 | h1 | h2 | t1 | t2 | t3 | i | xi] is only for the single-integer instructions
in Instruction File 1 and has the default w0. A File 1 instruction may alternatively mark the operand type
on the instruction field
<pre	style="font-size:12pt">

	ly, i	buffer+10
	aa,t2	matrix, b

</pre>
<p>
An instruction may have operand indirection marked with unary * but then may not also have indexing
<pre	style="font-size:12pt">

	j	*pointer
	lx	*pointer2,,t1

</pre>

<p>
Operand type sign-extended-immediate <b>xi</b> may be designated on File 1 instructions and is automatic on File 5A instructions.
<b>xi</b> operand precludes both indirection and indexing
<pre	style="font-size:12pt">

	ax	-12,,xi
	lret	1

</pre>

Designation <b>i</b> immediate is the effective address used as an immediate operand and may have indirection or indexing.
<b>i</b> operand may be designated for a File 1 instruction and is automatic for File 4A (I/O) and File 6 (jump and shift) instructions
<pre	style="font-size:12pt">

	ab	1,a,i		. add one more than the value in a to b
	inB	*port_table_pointer
	ral	*page_size_log
	j	along

</pre>
<p>
The large arithmetic instructions in Instruction File 7 have storage operands one, two or four words in size,
and may use indirection or indexing to address them
<pre	style="font-size:12pt">

	ql	running_total
	fa	parameter, sp
	
</pre>

<a	name="instru"/>
<h3>3.6 Instructions</h3>

See <a href="#iset">Lookup Panel</a> to find an instruction by name

<pre	style="font-size:12pt">

	<a      name="i24s"/>
	<div    style="margin-left:28pt;font-family:times-roman;font-size:12.75pt;color:0000FF">
	<i>3.6.1	Integer Store Instructions</i>
	</div>
	instructions	<a href="#sr">sr</a>	<a href="#sk">sk</a>	 see also double word store	<a href="#ds">ds</a>
			<a href="#sx">sx</a>	<a href="#sy">sy</a>				and
			<a href="#sa">sa</a>	<a href="#sb">sb</a>	quadword store instructions	<a href="#qs">qs</a>	<a href="#qpop">qpop</a>
			<a href="#z">z</a>	<a href="#pop">pop</a>


	Integer store instructions write a word, or a third or halfword


	An operand mode J mnemonic may be typed either after the instruction mnemonic
	or after the index position:

                sa, t1          record_control_word, y

	Integer store instructions write thirdwords when PSR Flag <b>half$w</b> = 0
	and halfwords when PSR Flag <b>half$w</b> = 1:

		pop		sense_record,,h2








	<a	name="sr"/>
	Store Repeat Count	sr
	__________________	__

				_________________________________________________________
				|							|
				|	repeat count and limit pointer register r	|
				|	is stored					|
				|_______________________________________________________|
				|	destination is memory/register at EA		|
				|	memory target may be a word, half or thirdword	|
				|_______________________________________________________|



	assembler syntax	sr[, {w0|h1|h2}]		target[, {x|y|a|b|fp|sp}] 	

				sr[, {w0|t1|t2|t3}]		target[, {x|y|a|b|fp|sp}]

				sr[, {w0|h1|h2}]		*ptarget	

				sr[, {w0|t1|t2|t3}]		*ptarget

				sr				target[, {x|y|a|b|fp|sp}][, {w0|h1|h2}] 	

				sr				target[, {x|y|a|b|fp|sp}][, {w0|t1|t2|t3}]

				sr				*ptarget[,, {w0|h1|h2}] 	

				sr				*ptarget[,, {w0|t1|t2|t3}]


	assembler examples	sr		target
				sr, h2		target
				sr		target,b,t1
				sr		*ptarget,,h1

				_________________________________________________________
	Instruction Code 0	| 0 0 0 0 0 | 0 . . |		<a style="color:#00AF6F">  address</a>		|
				|___________|_______|___________________________________|
				




	<a	name="sk"/>
	Store Mask Register	sk
	___________________	__

				_________________________________________________________
				|							|
				|	mask register k is stored			|
				|_______________________________________________________|
				|	destination is memory/register at EA		|
				|	memory target may be a word, half or thirdword	|
				|_______________________________________________________|



	assembler syntax	sk[, {w0|h1|h2}]		target[, {x|y|a|b|fp|sp}] 	

				sk[, {w0|t1|t2|t3}]		target[, {x|y|a|b|fp|sp}]

				sk[, {w0|h1|h2}]		*ptarget	

				sk[, {w0|t1|t2|t3}]		*ptarget

				sk				target[, {x|y|a|b|fp|sp}][, {w0|h1|h2}] 	

				sk				target[, {x|y|a|b|fp|sp}][, {w0|t1|t2|t3}]

				sk				*ptarget[,, {w0|h1|h2}] 	

				sk				*ptarget[,, {w0|t1|t2|t3}]


	assembler examples	sk		target
				sk, h2		target, x
				sk		target,,t1
				sk		*ptarget,,h1

				_________________________________________________________
	Instruction Code 1	| 0 0 0 0 1 | 0 . . |		<a style="color:#00AF6F">  address</a>		|
				|___________|_______|___________________________________|
				




	<a	name="sx"/>
	Store Index Register x	sx
	______________________	__


				_________________________________________________________
				|							|
				|	index register x is stored			|
				|_______________________________________________________|
				|	destination is memory/register at EA		|
				|	memory target may be a word, half or thirdword	|
				|_______________________________________________________|


	assembler syntax	sx[, {w0|h1|h2}]		target[, {x|y|a|b|fp|sp}] 	

				sx[, {w0|t1|t2|t3}]		target[, {x|y|a|b|fp|sp}]

				sx[, {w0|h1|h2}]		*ptarget	

				sx[, {w0|t1|t2|t3}]		*ptarget

				sx				target[, {x|y|a|b|fp|sp}][, {w0|h1|h2}] 	

				sx				target[, {x|y|a|b|fp|sp}][, {w0|t1|t2|t3}]

				sx				*ptarget[,, {w0|h1|h2}] 	

				sx				*ptarget[,, {w0|t1|t2|t3}]


	assembler examples	sx		target, a
				sx, h2		target
				sx		target,,t1
				sx		*ptarget,,h1

				_________________________________________________________
	Instruction Code 2	| 0 0 0 1 0 | 0 . . |		<a style="color:#00AF6F">  address</a>		|
				|___________|_______|___________________________________|
				


	<a	name="sy"/>
	Store Index Register y	sy
	______________________	__

				_________________________________________________________
				|							|
				|	index register y is stored			|
				|_______________________________________________________|
				|	destination is memory/register at EA		|
				|	memory target may be a word, half or thirdword	|
				|_______________________________________________________|


	assembler syntax	sy[, {w0|h1|h2}]		target[, {x|y|a|b|fp|sp}] 	

				sy[, {w0|t1|t2|t3}]		target[, {x|y|a|b|fp|sp}]

				sy[, {w0|h1|h2}]		*ptarget	

				sy[, {w0|t1|t2|t3}]		*ptarget

				sy				target[, {x|y|a|b|fp|sp}][, {w0|h1|h2}] 	

				sy				target[, {x|y|a|b|fp|sp}][, {w0|t1|t2|t3}]

				sy				*ptarget[,, {w0|h1|h2}] 	

				sy				*ptarget[,, {w0|t1|t2|t3}]


	assembler examples	sy		target
				sy, h2		target
				sy		target,b,t1
				sy		*ptarget,,h1

				_________________________________________________________
	Instruction Code 3	| 0 0 0 1 1 | 0 . . |		<a style="color:#00AF6F">  address</a>		|
				|___________|_______|___________________________________|
				


	<a	name="sa"/>
	Store Accumulator a	sa
	___________________	__


				_________________________________________________________
				|							|
				|	accumulator a is stored				|
				|_______________________________________________________|
				|	destination is memory/register at EA		|
				|	memory target may be a word, half or thirdword	|
				|_______________________________________________________|



	assembler syntax	sa[, {w0|h1|h2}]		target[, {x|y|a|b|fp|sp}] 	

				sa[, {w0|t1|t2|t3}]		target[, {x|y|a|b|fp|sp}]

				sa[, {w0|h1|h2}]		*ptarget	

				sa[, {w0|t1|t2|t3}]		*ptarget

				sa				target[, {x|y|a|b|fp|sp}][, {w0|h1|h2}] 	

				sa				target[, {x|y|a|b|fp|sp}][, {w0|t1|t2|t3}]

				sa				*ptarget[,, {w0|h1|h2}] 	

				sa				*ptarget[,, {w0|t1|t2|t3}]


	assembler examples	sa		target, x
				sa		*(31*/18++OFFSET)
				sa, h2		target
				sa		target,,t1
				sa		*ptarget,,h1

				_________________________________________________________
	Instruction Code 4	| 0 0 1 0 0 | 0 . . |		<a style="color:#00AF6F">  address</a>		|
				|___________|_______|___________________________________|
				


	<a	name="sb"/>
	Store Accumulator b	sb
	___________________	__


				_________________________________________________________
				|							|
				|	accumulator b is stored				|
				|_______________________________________________________|
				|	destination is memory/register at EA		|
				|	memory target may be a word, half or thirdword	|
				|_______________________________________________________|


	assembler syntax	sb[, {w0|h1|h2}]		target[, {x|y|a|b|fp|sp}] 	

				sb[, {w0|t1|t2|t3}]		target[, {x|y|a|b|fp|sp}]

				sb[, {w0|h1|h2}]		*ptarget	

				sb[, {w0|t1|t2|t3}]		*ptarget

				sb				target[, {x|y|a|b|fp|sp}][, {w0|h1|h2}] 	

				sb				target[, {x|y|a|b|fp|sp}][, {w0|t1|t2|t3}]

				sb				*ptarget[,, {w0|h1|h2}] 	

				sb				*ptarget[,, {w0|t1|t2|t3}]


	assembler examples	sb		target
				sb, h2		target
				sb		target,y,t1
				sb		*ptarget,,h1

				_________________________________________________________
	Instruction Code 5	| 0 0 1 0 1 | 0 . . |		<a style="color:#00AF6F">  address</a>		|
				|___________|_______|___________________________________|
				



	<a	name="z"/>
	Store Zero		z
	__________		_


				_________________________________________________________
				|							|
				|	value zero is written at the operand address	|
				|_______________________________________________________|
				|	destination is memory/register at EA		|
				|	memory target may be a word, half or thirdword	|
				|_______________________________________________________|


	assembler syntax	z[, {w0|h1|h2}]			target[, {x|y|a|b|fp|sp}] 	

				z[, {w0|t1|t2|t3}]		target[, {x|y|a|b|fp|sp}]

				z[, {w0|h1|h2}]			*ptarget	

				z[, {w0|t1|t2|t3}]		*ptarget

				z				target[, {x|y|a|b|fp|sp}][, {w0|h1|h2}] 	

				z				target[, {x|y|a|b|fp|sp}][, {w0|t1|t2|t3}]

				z				*ptarget[,, {w0|h1|h2}] 	

				z				*ptarget[,, {w0|t1|t2|t3}]


	assembler examples	z		target, fp
				z, h2		target
				z		target,,t1
				z		*ptarget,,h1

				_________________________________________________________
	Instruction Code 6	| 0 0 1 1 0 | 0 . . |		<a style="color:#00AF6F">  address</a>		|
				|___________|_______|___________________________________|
				



	<a	name="pop"/>
	pop			pop
	___			___

				_________________________________________________________
				|							|
				|	the data word at the internal stack top is 	| 
				|	stored the operand address			|
				|	internal stack pointer sp is incremented	|
				|_______________________________________________________|
                                |       on internal stack overflow / underflow		|
                                |       [sp < 24 | sp > 127] before operation           |
                                |       guard interrupt 95 is raised                    |
				|_______________________________________________________|
				|	destination is memory/register at EA		|
				|	memory target may be a word, half or thirdword	|
				|_______________________________________________________|


	assembler syntax	pop[, {w0|h1|h2}]		target[, {x|y|a|b|fp|sp}] 	

				pop[, {w0|t1|t2|t3}]		target[, {x|y|a|b|fp|sp}]

				pop[, {w0|h1|h2}]		*ptarget

				pop[, {w0|t1|t2|t3}]		*ptarget

				pop				target[, {x|y|a|b|fp|sp}][, {w0|h1|h2}] 	

				pop				target[, {x|y|a|b|fp|sp}][, {w0|t1|t2|t3}]

				pop				*ptarget[,, {w0|h1|h2}] 	

				pop				*ptarget[,, {w0|t1|t2|t3}]


	assembler examples	pop		target
				pop, h2		target
				pop		target,b,t1
				pop		*ptarget,,h1

				_________________________________________________________
	Instruction Code 7	| 0 0 1 1 1 | 0 . . |		<a style="color:#00AF6F">  address</a>		|
				|___________|_______|___________________________________|
				




        <a      name="i24l"/>
        <div    style="margin-left:28pt;font-family:times-roman;font-size:12.75pt;color:0000FF">
        <i>3.6.2	Integer Load Instructions</i>
        </div>
	instructions	<a href="#lr">lr</a>		<a href="#lk">lk</a>		see also double word	<a href="#dl">dl</a>	<a href="#dpush">dpush</a>
			<a href="#lx">lx</a>		<a href="#ly">ly</a>				 and
			<a href="#la">la</a>		<a href="#lb">lb</a>	  quadword load instructions	<a href="#ql">ql</a>	<a href="#qpush">qpush</a>
			<a href="#push">push</a>


        Integer load instructions read a one-word operand, a third or halfword,
        the effective address itself as an immediate operand, or a sign-extended immediate operand.


        An operand mode J mnemonic may be typed either after the instruction mnemonic
        or after the index position:

                ly, i           4, b

                lx              4, b, i

                push            -640,,xi

                la, t1          record_control_word, y

        Integer load instructions can read thirdwords when PSR Flag <b>half$w</b> = 0
        and halfwords when PSR Flag <b>half$w</b> = 1:

		lk		masks, y, h1








	<a	name="lr"/>
	Load Repeat Count	lr
	_________________	__


				_________________________________________________________
				|							|
				|	repeat count and limit pointer register r 	|
				|	is loaded					|
				|_______________________________________________________|
				|	source is memory/register value at EA		|
				|	or the value EA or a signed immediate		|
				|	memory source may be a word, half or thirdword	|
				|_______________________________________________________|




	assembler syntax	lr[, {w0|h1|h2|i}]		target[, {x|y|a|b|fp|sp}] 	

				lr[, {w0|t1|t2|t3|i}]		target[, {x|y|a|b|fp|sp}]

				lr[, {w0|h1|h2|i}]		*ptarget

				lr[, {w0|t1|t2|t3|i}]		*ptarget

				lr, i				VALUE[, {x|y|a|b|fp|sp}]

				lr, xi				VALUE

				lr				target[, {x|y|a|b|fp|sp}][, {w0|h1|h2|i}] 	

				lr				target[, {x|y|a|b|fp|sp}][, {w0|t1|t2|t3|i}]

				lr				*ptarget[,, {w0|h1|h2|i}] 	

				lr				*ptarget[,, {w0|t1|t2|t3|i}]

				lr				VALUE[, {x|y|a|b|fp|sp}], i

				lr				VALUE,, xi


	assembler examples	lr			target, sp
				lr			(5000000)
				lr, h2			target
				lr			target,,t1
				lr			*ptarget,,h1

				lr, xi			-48000/2
				lr			12, y, i
				lr, i			apointer
				lr, i			*apointer	[ = lr	apointer ]

				_________________________________________________________
	Instruction Code 8	| 0 1 0 0 0 | . . . |		<a style="color:#00AF6F">  address</a>		|
				|___________|_______|___________________________________|
				





	<a	name="lk"/>
	Load Mask Register	lk
	__________________	__


				_________________________________________________________
				|							|
				|	mask register k is loaded	 		|
				|_______________________________________________________|
				|	operand is memory/register value at EA		|
				|	or the value EA or a signed immediate		|
				|	memory source may be a word, half or thirdword	|
				|_______________________________________________________|




	assembler syntax	lk[, {w0|h1|h2|i}]		mask[, {x|y|a|b|fp|sp}] 	

				lk[, {w0|t1|t2|t3|i}]		mask[, {x|y|a|b|fp|sp}]

				lk[, {w0|h1|h2|i}]		*pmask

				lk[, {w0|t1|t2|t3|i}]		*pmask

				lk, i				MASK[, {x|y|a|b|fp|sp}]

				lk, xi				MASK

				lk				mask[, {x|y|a|b|fp|sp}][, {w0|h1|h2|i}] 	

				lk				mask[, {x|y|a|b|fp|sp}][, {w0|t1|t2|t3|i}]

				lk				*pmask[,, {w0|h1|h2|i}] 	

				lk				*pmask[,, {w0|t1|t2|t3|i}]

				lk				MASK[, {x|y|a|b|fp|sp}], i

				lk				MASK,, xi


	assembler examples	lk			mask
				lk			(0FC0000:s)
				lk, h2			mask, y
				lk			mask,,t1
				lk			*ptarget,,h1

				lk, xi			-48000/2
				lk			12, y, i
				lk, i			apointer
				lk, i			*apointer	[ = lk	apointer ]

				_________________________________________________________
	Instruction Code 9	| 0 1 0 0 1 | . . . |		<a style="color:#00AF6F">  address</a>		|
				|___________|_______|___________________________________|
				





	<a	name="lx"/>
	Load Index Register x	lx
	_____________________	__


				_________________________________________________________
				|							|
				|	index register x is loaded	 		|
				|_______________________________________________________|
				|	operand is memory/register value at EA		|
				|	or the value EA or a signed immediate		|
				|	memory source may be a word, half or thirdword	|
				|_______________________________________________________|



	assembler syntax	lx[, {w0|h1|h2|i}]		target[, {x|y|a|b|fp|sp}] 	

				lx[, {w0|t1|t2|t3|i}]		target[, {x|y|a|b|fp|sp}]

				lx[, {w0|h1|h2|i}]		*ptarget

				lx[, {w0|t1|t2|t3|i}]		*ptarget

				lx, i				VALUE[, {x|y|a|b|fp|sp}]

				lx, xi				VALUE

				lx				target[, {x|y|a|b|fp|sp}][, {w0|h1|h2|i}] 	

				lx				target[, {x|y|a|b|fp|sp}][, {w0|t1|t2|t3|i}]

				lx				*ptarget[,, {w0|h1|h2|i}] 	

				lx				*ptarget[,, {w0|t1|t2|t3|i}]

				lx				VALUE[, {x|y|a|b|fp|sp}], i

				lx				VALUE,, xi


	assembler examples	lx			target, b
				lx			(47*/18++240:s)
				lx, h2			target
				lx			target,,t1
				lx			*ptarget,,h1

				lx, xi			-48000/2
				lx			12, y, i
				lx, i			apointer
				lx, i			*apointer	[ = lx	apointer ]

				_________________________________________________________
	Instruction Code 10	| 0 1 0 1 0 | . . . |		<a style="color:#00AF6F">  address</a>		|
				|___________|_______|___________________________________|
				





	<a	name="ly"/>
	Load Index Register y	ly
	_____________________	__


				_________________________________________________________
				|							|
				|	index register y is loaded			|
				|_______________________________________________________|
				|	operand is memory/register value at EA		|
				|	or the value EA or a signed immediate		|
				|	memory source may be a word, half or thirdword	|
				|_______________________________________________________|



	assembler syntax	ly[, {w0|h1|h2|i}]		target[, {x|y|a|b|fp|sp}] 	

				ly[, {w0|t1|t2|t3|i}]		target[, {x|y|a|b|fp|sp}]

				ly[, {w0|h1|h2|i}]		*ptarget

				ly[, {w0|t1|t2|t3|i}]		*ptarget

				ly, i				VALUE[, {x|y|a|b|fp|sp}]

				ly, xi				VALUE

				ly				target[, {x|y|a|b|fp|sp}][, {w0|h1|h2|i}] 	

				ly				target[, {x|y|a|b|fp|sp}][, {w0|t1|t2|t3|i}]

				ly				*ptarget[,, {w0|h1|h2|i}] 	

				ly				*ptarget[,, {w0|t1|t2|t3|i}]

				ly				VALUE[, {x|y|a|b|fp|sp}], i

				ly				VALUE,, xi


	assembler examples	ly			target
				ly			*(HIGH_ORDER_ADDRESS:s)
				ly, h2			target, a
				ly			target,,t1
				ly			*ptarget

				ly, xi			-48000/2
				ly			12, y, i
				ly, i			apointer
				ly, i			*apointer	[ = ly	apointer ]

				_________________________________________________________
	Instruction Code 11	| 0 1 0 1 1 | . . . |		<a style="color:#00AF6F">  address</a>		|
				|___________|_______|___________________________________|
				





	<a	name="la"/>
	Load Accumulator a	la
	__________________	___


				_________________________________________________________
				|							|
				|	accumulator a is loaded				|
				|_______________________________________________________|
				|	operand is memory/register value at EA		|
				|	or the value EA or a signed immediate		|
				|	memory source may be a word, half or thirdword	|
				|_______________________________________________________|





	assembler syntax	la[, {w0|h1|h2|i}]		target[, {x|y|a|b|fp|sp}] 	

				la[, {w0|t1|t2|t3|i}]		target[, {x|y|a|b|fp|sp}]

				la[, {w0|h1|h2|i}]		*ptarget

				la[, {w0|t1|t2|t3|i}]		*ptarget

				la, i				VALUE[, {x|y|a|b|fp|sp}]

				la, xi				VALUE

				la				target[, {x|y|a|b|fp|sp}][, {w0|h1|h2|i}] 	

				la				target[, {x|y|a|b|fp|sp}][, {w0|t1|t2|t3|i}]

				la				*ptarget[,, {w0|h1|h2|i}] 	

				la				*ptarget[,, {w0|t1|t2|t3|i}]

				la				VALUE[, {x|y|a|b|fp|sp}], i

				la				VALUE,, xi


	assembler examples	la			target, sp
				la, h2			target
				la			target,,t1
				la			*ptarget,,h1

				la, xi			-48000/2
				la			12, y, i
				la, i			apointer
				la, i			*apointer	[ = la	apointer ]

				_________________________________________________________
	Instruction Code 12	| 0 1 1 0 0 | . . . |		<a style="color:#00AF6F">  address</a>		|
				|___________|_______|___________________________________|
				





	<a	name="lb"/>
	Load Accumulator b	lb
	__________________	___


				_________________________________________________________
				|							|
				|	accumulator b is loaded				|
				|_______________________________________________________|
				|	operand is memory/register value at EA		|
				|	or the value EA or a signed immediate		|
				|	memory source may be a word, half or thirdword	|
				|_______________________________________________________|



	assembler syntax	lb[, {w0|h1|h2|i}]		target[, {x|y|a|b|fp|sp}] 	

				lb[, {w0|t1|t2|t3|i}]		target[, {x|y|a|b|fp|sp}]

				lb[, {w0|h1|h2|i}]		*ptarget

				lb[, {w0|t1|t2|t3|i}]		*ptarget

				lb, i				VALUE[, {x|y|a|b|fp|sp}]

				lb, xi				VALUE

				lb				target[, {x|y|a|b|fp|sp}][, {w0|h1|h2|i}] 	

				lb				target[, {x|y|a|b|fp|sp}][, {w0|t1|t2|t3|i}]

				lb				*ptarget[,, {w0|h1|h2|i}] 	

				lb				*ptarget[,, {w0|t1|t2|t3|i}]

				lb				VALUE[, {x|y|a|b|fp|sp}], i

				lb				VALUE,, xi


	assembler examples	lb			target, a
				lb, h2			target
				lb			target,,t1
				lb			*ptarget,,h1

				lb, xi			-48000/2
				lb			12, y, i
				lb, i			apointer
				lb, i			*apointer	[ = lb	apointer ]

				_________________________________________________________
	Instruction Code 13	| 0 1 1 0 1 | . . . |		<a style="color:#00AF6F">  address</a>		|
				|___________|_______|___________________________________|
				




	<a	name="push"/>
	push			push
	____			____

				_________________________________________________________
				|							|
				|	internal stack pointer sp is decremented	| 
				|	operand is copied to the new internal stack top	|
				|_______________________________________________________|
                                |       on internal stack overflow / underflow		|
                                |       [sp < 25 | sp > 128] before operation           |
                                |       guard interrupt 95 is raised                    |
				|_______________________________________________________|
				|	operand is memory/register value at EA		|
				|	or the value EA or a signed immediate		|
				|	memory source may be a word, half or thirdword	|
				|_______________________________________________________|


	assembler syntax	push[, {w0|h1|h2|i}]		target[, {x|y|a|b|fp|sp}] 	

				push[, {w0|t1|t2|t3|i}]		target[, {x|y|a|b|fp|sp}]

				push[, {w0|h1|h2|i}]		*ptarget

				push[, {w0|t1|t2|t3|i}]		*ptarget

				push, i				VALUE[, {x|y|a|b|fp|sp}]

				push, xi			VALUE

				push				target[, {x|y|a|b|fp|sp}][, {w0|h1|h2|i}] 	

				push				target[, {x|y|a|b|fp|sp}][, {w0|t1|t2|t3|i}]

				push				*ptarget[,, {w0|h1|h2|i}] 	

				push				*ptarget[,, {w0|t1|t2|t3|i}]

				push				VALUE[, {x|y|a|b|fp|sp}], i

				push				VALUE,, xi


	assembler examples	push			target
				push			(45*262144+OFFSET:s)
				push			(45*/18++OFFSET:s)
				push, h2		target
				push			target,,t1
				push			*ptarget,,h1

				push, xi		-48000/2
				push			12, y, i
				push, i			apointer
				push, i			*apointer	[ = 	push	apointer ]

				_________________________________________________________
	Instruction Code 31	| 1 1 1 1 1 | . . . |		<a style="color:#00AF6F">  address</a>		|
				|___________|_______|___________________________________|
				





        <a      name="i24t"/>
        <div    style="margin-left:28pt;font-family:times-roman;font-size:12.75pt;color:0000FF">
        <i>3.6.3        Integer Test Instructions</i>
        </div>
	instructions	<a href="#tz">Test Zero</a>		<a href="#tp">Test Positive</a>

	macros		<a href="#tnz">Test NonZero</a>		<a href="#tn">Test Negative</a>


        Integer test instructions sample a word, or a third or halfword


        An operand mode J mnemonic may be typed either after the instruction mnemonic
        or after the index position:

                tz, t1		record_control_word, y

        Integer test instructions sample thirdwords when PSR Flag <b>half$w</b> = 0
        and halfwords when PSR Flag <b>half$w</b> = 1:

                tp		sense_record,,h2








	<a	name="tz"/>
	Test Zero		tz
	_________		__


				_________________________________________________________
				|							|
				|	next instruction is skipped if operand is zero 	|
				|_______________________________________________________|
				|	operand is memory/register value at EA		|
				|	memory target may be a word, half or thirdword	|
				|_______________________________________________________|
				|	<a href="#rex_tz">repeat execute</a> instruction			|
				|	can iterate tz instruction as a search		|
				|_______________________________________________________|


	assembler syntax	tz[, {w0|h1|h2}]		target[, {x|y|a|b|fp|sp|}] 	

				tz[, {w0|t1|t2|t3}]		target[, {x|y|a|b|fp|sp}]

				tz[, {w0|h1|h2}]		*ptarget	

				tz[, {w0|t1|t2|t3}]		*ptarget

				tz				target[, {x|y|a|b|fp|sp|}][, {w0|h1|h2}] 	

				tz				target[, {x|y|a|b|fp|sp}][, {w0|t1|t2|t3}]

				tz				*ptarget[,, {w0|h1|h2}] 	

				tz				*ptarget[,, {w0|t1|t2|t3}]


	assembler examples	tz		target
				tz, h2		target, fp
				tz		target,,t1
				tz		*ptarget,,h1

				_________________________________________________________
	Instruction Code 14	| 0 1 1 1 0 | 0 . . |		<a style="color:#00AF6F">  address</a>		|
				|___________|_______|___________________________________|
				



	<a	name="tnz"/>
	Test Nonzero	macro	tnz
	____________		___

	Test Nonzero is a 2-instruction macro which skips the next instruction if operand is nonzero
	Operand types and assembly syntax are as <a href="#tz">Test Zero</a> instruction




	<a	name="tp"/>
	Test Positive		tp
	_____________		__

				_________________________________________________________
				|							|
				|	next instruction is skipped if operand bit 23	|
				|	is zero						|
				|	half and thirdwords have sign extension		|
				|_______________________________________________________|
				|	operand is memory/register value at EA		|
				|	memory target may be a word, half or thirdword	|
				|_______________________________________________________|
				|	<a href="#rex_tp">repeat execute</a> instruction			|
				|	can iterate tp instruction as a search		|
				|_______________________________________________________|



	assembler syntax	tp[, {w0|h1|h2}]		target[, {x|y|a|b|fp|sp|}] 	

				tp[, {w0|t1|t2|t3}]		target[, {x|y|a|b|fp|sp}]

				tp[, {w0|h1|h2}]		*ptarget	

				tp[, {w0|t1|t2|t3}]		*ptarget

				tp				target[, {x|y|a|b|fp|sp|}][, {w0|h1|h2}] 	

				tp				target[, {x|y|a|b|fp|sp}][, {w0|t1|t2|t3}]

				tp				*ptarget[,, {w0|h1|h2}] 	

				tp				*ptarget[,, {w0|t1|t2|t3}]


	assembler examples	tp		target, y
				tp		*(HIGH_ADDRESS:s)
				tp, h2		target
				tp		target,,t1
				tp		*ptarget

				_________________________________________________________
	Instruction Code 15	| 0 1 1 1 1 | 0 . . |		<a style="color:#00AF6F">  address</a>		|
				|___________|_______|___________________________________|
				


	<a	name="tn"/>
	Test Negative	macro	tn
	_____________		__

	Test Negative is a 2-instruction macro which skips the next instruction if operand is negative
	Operand types and assembly syntax are as <a href="#tp">Test Positive</a> instruction




        <a      name="i24x"/>
        <div    style="margin-left:28pt;font-family:times-roman;font-size:12.75pt;color:0000FF">
        <i>3.6.4        Index Register Add Instructions</i>
        </div>
	instructions	<a href="#ax">ax</a>	<a href="#ay">ay</a>


        Index register add instructions read a one-word operand, a third or halfword,
        the effective address itself as an immediate operand, or a sign-extended immediate operand.


        An operand mode J mnemonic may be typed either after the instruction mnemonic
        or after the index position:

                ay, i           4, b

                ax              4, b, i

                ax		-640,,xi

                ay, t1          record_control_word, y

        Index register add instructions can read thirdwords when PSR Flag <b>half$w</b> = 0
        and halfwords when PSR Flag <b>half$w</b> = 1:

                ax              displacements, y, h1










	<a	name="ax"/>
	Add to Index Register x	ax
	_______________________	__


				_________________________________________________________
				|							|
				|	operand is added to index register x		|
				|	<a href="#nonar">carry$</a> is not affected				|
				|_______________________________________________________|
				|	operand is memory/register value at EA		|
				|	or the value EA or a signed immediate		|
				|	memory source may be a word, half or thirdword	|
				|_______________________________________________________|



	assembler syntax	ax[, {w0|h1|h2|i}]		address_update[, {x|y|a|b|fp|sp}] 	

				ax[, {w0|t1|t2|t3|i}]		address_update[, {x|y|a|b|fp|sp}]

				ax[, {w0|h1|h2|i}]		*paddress_update

				ax[, {w0|t1|t2|t3|i}]		*paddress_update

				ax, i				ADDRESS_UPDATE[, {x|y|a|b|fp|sp}]

				ax, xi				ADDRESS_UPDATE

				ax				address_update[, {x|y|a|b|fp|sp}][, {w0|h1|h2|i}] 	

				ax				address_update[, {x|y|a|b|fp|sp}][, {w0|t1|t2|t3|i}]

				ax				*paddress_update[,, {w0|h1|h2|i}] 	

				ax				*paddress_update[,, {w0|t1|t2|t3|i}]

				ax				ADDRESS_UPDATE[, {x|y|a|b|fp|sp}], i

				ax				ADDRESS_UPDATE,, xi


	assembler examples	ax			address_update
				ax, h2			address_update, b
				ax			address_update,,t1
				ax			*paddress_update,,h1

				ax, xi			-48000/2
				ax			12, y, i
				ax, i			apointer
				ax, i			*apointer	[ =	ax	apointer ]

				_________________________________________________________
	Instruction Code 16	| 1 0 0 0 0 | . . . |		<a style="color:#00AF6F">  address</a>		|
				|___________|_______|___________________________________|
				








	<a	name="ay"/>
	Add to Index Register y	ay
	_______________________	__


				_________________________________________________________
				|							|
				|	operand is added to index register y		|
				|	<a href="#nonar">carry$</a> is not affected				|
				|_______________________________________________________|
				|	operand is memory/register value at EA		|
				|	or the value EA or a signed immediate		|
				|	memory source may be a word, half or thirdword	|
				|_______________________________________________________|



	assembler syntax	ay[, {w0|h1|h2|i}]		address_update[, {x|y|a|b|fp|sp}] 	

				ay[, {w0|t1|t2|t3|i}]		address_update[, {x|y|a|b|fp|sp}]

				ay[, {w0|h1|h2|i}]		*paddress_update

				ay[, {w0|t1|t2|t3|i}]		*paddress_update

				ay, i				ADDRESS_UPDATE[, {x|y|a|b|fp|sp}]

				ay, xi				ADDRESS_UPDATE

				ay				address_update[, {x|y|a|b|fp|sp}][, {w0|h1|h2|i}] 	

				ay				address_update[, {x|y|a|b|fp|sp}][, {w0|t1|t2|t3|i}]

				ay				*paddress_update[,, {w0|h1|h2|i}] 	

				ay				*paddress_update[,, {w0|t1|t2|t3|i}]

				ay				ADDRESS_UPDATE[, {x|y|a|b|fp|sp}], i

				ay				ADDRESS_UPDATE,, xi


	assembler examples	ay			address_update, x
				ay, h2			address_update
				ay			address_update,,t1
				ay			*paddress_update,,h1

				ay, xi			-48000/2
				ay			12, y, i
				ay, i			apointer
				ay, i			*apointer	[ =	ay	apointer ]

				_________________________________________________________
	Instruction Code 17	| 1 0 0 0 1 | . . . |		<a style="color:#00AF6F">  address</a>		|
				|___________|_______|___________________________________|
				








        <a      name="i24b"/>
        <div    style="margin-left:28pt;font-family:times-roman;font-size:12.75pt;color:0000FF">
        <i>3.6.5        Boolean Instructions</i>
        </div>
	instructions	<a href="#or">or</a>		<a href="#orb">orB</a>
			<a href="#and">and</a>		<a href="#andb">andB</a>
			<a href="#xor">xor</a>		<a href="#xorb">xorB</a>


        Boolean instructions read a one-word operand, a third or halfword,
        the effective address itself as an immediate operand, or a sign-extended immediate operand.


        An operand mode J mnemonic may be typed either after the instruction mnemonic
        or after the index position:

                orB, i		4, b

                xor		4, b, i

                and		-640,,xi

                xorB, t1	record_control_word, y

        Boolean instructions can read thirdwords when PSR Flag <b>half$w</b> = 0
        and halfwords when PSR Flag <b>half$w</b> = 1:

                andB		masks, y, h1








	<a	name="or"/>
	Or Accumulator a	or
	________________	__


				_________________________________________________________
				|							|
				|	accumulator a OR operand -> a			|
				|_______________________________________________________|
				|	operand is memory/register value at EA		|
				|	or the value EA or a signed immediate		|
				|	memory source may be a word, half or thirdword	|
				|_______________________________________________________|



	assembler syntax	or[, {w0|h1|h2|i}]		mask[, {x|y|a|b|fp|sp}] 	

				or[, {w0|t1|t2|t3|i}]		mask[, {x|y|a|b|fp|sp}]

				or[, {w0|h1|h2|i}]		*pmask

				or[, {w0|t1|t2|t3|i}]		*pmask

				or, i				MASK[, {x|y|a|b|fp|sp}]

				or, xi				MASK

				or				mask[, {x|y|a|b|fp|sp}][, {w0|h1|h2|i}] 	

				or				mask[, {x|y|a|b|fp|sp}][, {w0|t1|t2|t3|i}]

				or				*pmask[,, {w0|h1|h2|i}] 	

				or				*pmask[,, {w0|t1|t2|t3|i}]

				or				MASK[, {x|y|a|b|fp|sp}], i

				or				MASK,, xi


	assembler examples	or			mask
				or, h2			mask, b
				or			mask,,t1
				or			*pmask,,h1

				or, xi			-48000/2
				or			12, y, i
				or, i			apointer
				or, i			*apointer	[ =	or	apointer ]

				_________________________________________________________
	Instruction Code 18	| 1 0 0 1 0 | . . . |		<a style="color:#00AF6F">  address</a>		|
				|___________|_______|___________________________________|
				








	<a	name="orb"/>
	Or Accumulator b	orB
	________________	___


				_________________________________________________________
				|							|
				|	accumulator b OR operand -> b			|
				|_______________________________________________________|
				|	operand is memory/register value at EA		|
				|	or the value EA or a signed immediate		|
				|	memory source may be a word, half or thirdword	|
				|_______________________________________________________|




	assembler syntax	orB[, {w0|h1|h2|i}]		mask[, {x|y|a|b|fp|sp}] 	

				orB[, {w0|t1|t2|t3|i}]		mask[, {x|y|a|b|fp|sp}]

				orB[, {w0|h1|h2|i}]		*pmask

				orB[, {w0|t1|t2|t3|i}]		*pmask

				orB, i				MASK[, {x|y|a|b|fp|sp}]

				orB, xi				MASK

				orB				mask[, {x|y|a|b|fp|sp}][, {w0|h1|h2|i}] 	

				orB				mask[, {x|y|a|b|fp|sp}][, {w0|t1|t2|t3|i}]

				orB				*pmask[,, {w0|h1|h2|i}] 	

				orB				*pmask[,, {w0|t1|t2|t3|i}]

				orB				MASK[, {x|y|a|b|fp|sp}], i

				orB				MASK,, xi


	assembler examples	orB			mask
				orB, h2			mask
				orB			mask,a,t1
				orB			*pmask,,h1

				orB, xi			-48000/2
				orB			12, y, i
				orB, i			apointer
				orB, i			*apointer	[ =	orB	apointer ]

				_________________________________________________________
	Instruction Code 19	| 1 0 0 1 1 | . . . |		<a style="color:#00AF6F">  address</a>		|
				|___________|_______|___________________________________|
				








	<a	name="and"/>
	And Accumulator a	and
	_________________	___


				_________________________________________________________
				|							|
				|	accumulator a AND operand -> a			|
				|_______________________________________________________|
				|	operand is memory/register value at EA		|
				|	or the value EA or a signed immediate		|
				|	memory source may be a word, half or thirdword	|
				|_______________________________________________________|




	assembler syntax	and[, {w0|h1|h2|i}]		mask[, {x|y|a|b|fp|sp}] 	

				and[, {w0|t1|t2|t3|i}]		mask[, {x|y|a|b|fp|sp}]

				and[, {w0|h1|h2|i}]		*pmask

				and[, {w0|t1|t2|t3|i}]		*pmask

				and, i				MASK[, {x|y|a|b|fp|sp}]

				and, xi				MASK

				and				mask[, {x|y|a|b|fp|sp}][, {w0|h1|h2|i}] 	

				and				mask[, {x|y|a|b|fp|sp}][, {w0|t1|t2|t3|i}]

				and				*pmask[,, {w0|h1|h2|i}] 	

				and				*pmask[,, {w0|t1|t2|t3|i}]

				and				MASK[, {x|y|a|b|fp|sp}], i

				and				MASK,, xi


	assembler examples	and			mask
				and, h2			mask, x
				and			mask,,t1
				and			*pmask,,h1

				and, xi			-48000/2
				and			12, y, i
				and, i			apointer
				and, i			*apointer	[ =	and	apointer ]

				_________________________________________________________
	Instruction Code 20	| 1 0 1 0 0 | . . . |		<a style="color:#00AF6F">  address</a>		|
				|___________|_______|___________________________________|
				








	<a	name="andb"/>
	And Accumulator b	andB
	__________________	___


				_________________________________________________________
				|							|
				|	accumulator b AND operand -> b			|
				|_______________________________________________________|
				|	operand is memory/register value at EA		|
				|	or the value EA or a signed immediate		|
				|	memory source may be a word, half or thirdword	|
				|_______________________________________________________|



	assembler syntax	andB[, {w0|h1|h2|i}]		mask[, {x|y|a|b|fp|sp}] 	

				andB[, {w0|t1|t2|t3|i}]		mask[, {x|y|a|b|fp|sp}]

				andB[, {w0|h1|h2|i}]		*pmask

				andB[, {w0|t1|t2|t3|i}]		*pmask

				andB, i				MASK[, {x|y|a|b|fp|sp}]

				andB, xi			MASK

				andB				mask[, {x|y|a|b|fp|sp}][, {w0|h1|h2|i}] 	

				andB				mask[, {x|y|a|b|fp|sp}][, {w0|t1|t2|t3|i}]

				andB				*pmask[,, {w0|h1|h2|i}] 	

				andB				*pmask[,, {w0|t1|t2|t3|i}]

				andB				MASK[, {x|y|a|b|fp|sp}], i

				andB				MASK,, xi


	assembler examples	andB			(MASK_VALUE)
				andB, h2		mask
				andB			mask,,t1
				andB			*pmask,,h1

				andB, xi		-48000/2
				andB			12, y, i
				andB, i			apointer
				andB, i			*apointer	[ =	andB	apointer ]

				_________________________________________________________
	Instruction Code 21	| 1 0 1 0 1 | . . . |		<a style="color:#00AF6F">  address</a>		|
				|___________|_______|___________________________________|
				








	<a	name="xor"/>
	Exlusive Or Accumulator a	xor
	_________________________	___


				_________________________________________________________
				|							|
				|	accumulator a XOR operand -> a			|
				|_______________________________________________________|
				|	operand is memory/register value at EA		|
				|	or the value EA or a signed immediate		|
				|	memory source may be a word, half or thirdword	|
				|_______________________________________________________|


	assembler syntax	xor[, {w0|h1|h2|i}]		mask[, {x|y|a|b|fp|sp}] 	

				xor[, {w0|t1|t2|t3|i}]		mask[, {x|y|a|b|fp|sp}]

				xor[, {w0|h1|h2|i}]		*pmask

				xor[, {w0|t1|t2|t3|i}]		*pmask

				xor, i				MASK[, {x|y|a|b|fp|sp}]

				xor, xi				MASK

				xor				mask[, {x|y|a|b|fp|sp}][, {w0|h1|h2|i}] 	

				xor				mask[, {x|y|a|b|fp|sp}][, {w0|t1|t2|t3|i}]

				xor				*pmask[,, {w0|h1|h2|i}] 	

				xor				*pmask[,, {w0|t1|t2|t3|i}]

				xor				MASK[, {x|y|a|b|fp|sp}], i

				xor				MASK,, xi


	assembler examples	xor			mask
				xor, h2			mask
				xor			mask,,t1
				xor			*pmask,,h1

				xor, xi			-48000/2
				xor			12, y, i
				xor, i			apointer
				xor, i			*apointer	[ =	xor	apointer ]

				_________________________________________________________
	Instruction Code 22	| 1 0 1 1 0 | . . . |		<a style="color:#00AF6F">  address</a>		|
				|___________|_______|___________________________________|
				








	<a	name="xorb"/>
	Exlusive Or Accumulator b	xorB
	_________________________	____


				_________________________________________________________
				|							|
				|	accumulator b XOR operand -> b			|
				|_______________________________________________________|
				|	operand is memory/register value at EA		|
				|	or the value EA or a signed immediate		|
				|	memory source may be a word, half or thirdword	|
				|_______________________________________________________|


	assembler syntax	xorB[, {w0|h1|h2|i}]		mask[, {x|y|a|b|fp|sp}] 	

				xorB[, {w0|t1|t2|t3|i}]		mask[, {x|y|a|b|fp|sp}]

				xorB[, {w0|h1|h2|i}]		*pmask

				xorB[, {w0|t1|t2|t3|i}]		*pmask

				xorB, i				MASK[, {x|y|a|b|fp|sp}]

				xorB, xi			MASK

				xorB				mask[, {x|y|a|b|fp|sp}][, {w0|h1|h2|i}] 	

				xorB				mask[, {x|y|a|b|fp|sp}][, {w0|t1|t2|t3|i}]

				xorB				*pmask[,, {w0|h1|h2|i}] 	

				xorB				*pmask[,, {w0|t1|t2|t3|i}]

				xorB				MASK[, {x|y|a|b|fp|sp}], i

				xorB				MASK,, xi


	assembler examples	xorB			mask
				xorB, h2		mask
				xorB			mask,a,t1
				xorB			*pmask,,h1

				xorB, xi		-48000/2
				xorB			12, y, i
				xorB, i			apointer
				xorB, i			*apointer	[ =	xorB	apointer ]

				_________________________________________________________
	Instruction Code 23	| 1 0 1 1 1 | . . . |		<a style="color:#00AF6F">  address</a>		|
				|___________|_______|___________________________________|
				




        <a      name="i24a"/>
        <div    style="margin-left:28pt;font-family:times-roman;font-size:12.75pt;color:0000FF">
        <i>3.6.6        Integer Arithmetic Instructions</i>
        </div>
	instructions	<a href="#aa">aa</a>		<a href="#ana">ana</a>		see also double word	<a href="#da">da</a>
			<a href="#ab">ab</a>		<a href="#anb">anb</a>		  add &plusmn; instructions	<a href="#dan">dan</a>
			<a href="#m">m</a>		<a href="#d">d</a>
			<a href="#mf">mf</a>

	compare macros	<a href="#anu">anu / tanu</a>	<a href="#anuba">anuba / tanuba</a>


        Integer arithmetic instructions read a one-word operand, a third or halfword,
        the effective address itself as an immediate operand, or a sign-extended immediate operand.


        An operand mode J mnemonic may be typed either after the instruction mnemonic
        or after the index position:

                aa, i		4, b

                m		4, b, i

                d		-640,,xi

                mf, t1		record_control_word, y

        Integer arithmetic instructions can read thirdwords when PSR Flag <b>half$w</b> = 0
        and halfwords when PSR Flag <b>half$w</b> = 1:

                anb		masks, y, h1








	<a	name="aa"/>
	Add to Accumulator a	aa
	____________________	__

				_________________________________________________________
				|							|
				|	accumulator a + operand -> a			|
				|	<a href="#nonar">carry$</a> = the carry from bit 23 of the addition	|
				|_______________________________________________________|
				|	operand is memory/register value at EA		|
				|	or the value EA or a signed immediate		|
				|	memory source may be a word, half or thirdword	|
				|_______________________________________________________|


	assembler syntax	aa[, {w0|h1|h2|i}]		addend[, {x|y|a|b|fp|sp}] 	

				aa[, {w0|t1|t2|t3|i}]		addend[, {x|y|a|b|fp|sp}]

				aa[, {w0|h1|h2|i}]		*paddend

				aa[, {w0|t1|t2|t3|i}]		*paddend

				aa, i				ADDEND[, {x|y|a|b|fp|sp}]

				aa, xi				ADDEND

				aa				addend[, {x|y|a|b|fp|sp}][, {w0|h1|h2|i}] 	

				aa				addend[, {x|y|a|b|fp|sp}][, {w0|t1|t2|t3|i}]

				aa				*paddend[,, {w0|h1|h2|i}] 	

				aa				*paddend[,, {w0|t1|t2|t3|i}]

				aa				ADDEND[, {x|y|a|b|fp|sp}], i

				aa				ADDEND,, xi


	assembler examples	aa			addend
				aa			(2000000)
				aa, h2			addend
				aa			addend,,t1
				aa			*paddend,,h1

				aa, xi			-48000/2
				aa			12, y, i
				aa, i			apointer
				aa, i			*apointer	[ =	aa	apointer ]

				_________________________________________________________
	Instruction Code 24	| 1 1 0 0 0 | . . . |		<a style="color:#00AF6F">  address</a>		|
				|___________|_______|___________________________________|
				








	<a	name="ab"/>
	Add to Accumulator b	ab
	____________________	__

				_________________________________________________________
				|							|
				|	accumulator b + operand -> b			|
				|	<a href="#nonar">carry$</a> = the carry from bit 23 of the addition	|
				|_______________________________________________________|
				|	operand is memory/register value at EA		|
				|	or the value EA or a signed immediate		|
				|	memory source may be a word, half or thirdword	|
				|_______________________________________________________|


	assembler syntax	ab[, {w0|h1|h2|i}]		addend[, {x|y|a|b|fp|sp}] 	

				ab[, {w0|t1|t2|t3|i}]		addend[, {x|y|a|b|fp|sp}]

				ab[, {w0|h1|h2|i}]		*paddend

				ab[, {w0|t1|t2|t3|i}]		*paddend

				ab, i				ADDEND[, {x|y|a|b|fp|sp}]

				ab, xi				ADDEND

				ab				addend[, {x|y|a|b|fp|sp}][, {w0|h1|h2|i}] 	

				ab				addend[, {x|y|a|b|fp|sp}][, {w0|t1|t2|t3|i}]

				ab				*paddend[,, {w0|h1|h2|i}] 	

				ab				*paddend[,, {w0|t1|t2|t3|i}]

				ab				ADDEND[, {x|y|a|b|fp|sp}], i

				ab				ADDEND, xi


	assembler examples	ab			addend, x
				ab			(-3000000)
				ab, h2			addend
				ab			addend,,t1
				ab			*paddend,,h1

				ab, xi			-48000/2
				ab			12, y, i
				ab, i			apointer
				ab, i			*apointer	[ =	ab	apointer ]

				_________________________________________________________
	Instruction Code 25	| 1 1 0 0 1 | . . . |		<a style="color:#00AF6F">  address</a>		|
				|___________|_______|___________________________________|
				








	<a	name="ana"/>
	Add Negative to Accumulator  a	ana
	___________________________	___

				_________________________________________________________
				|							|
				|	accumulator a += 2s-complement(operand)		|
				|	<a href="#nonar">carry$</a> = the carry from bit 23 of the addition	|
				|_______________________________________________________|
				|	operand is memory/register value at EA		|
				|	or the value EA or a signed immediate		|
				|	memory source may be a word, half or thirdword	|
				|_______________________________________________________|


	assembler syntax	ana[, {w0|h1|h2|i}]		subtrahend[, {x|y|a|b|fp|sp}] 	

				ana[, {w0|t1|t2|t3|i}]		subtrahend[, {x|y|a|b|fp|sp}]

				ana[, {w0|h1|h2|i}]		*psubtrahend

				ana[, {w0|t1|t2|t3|i}]		*psubtrahend

				ana, i				SUBTRAHEND[, {x|y|a|b|fp|sp}]

				ana, xi				SUBTRAHEND

				ana				subtrahend[, {x|y|a|b|fp|sp}][, {w0|h1|h2|i}] 	

				ana				subtrahend[, {x|y|a|b|fp|sp}][, {w0|t1|t2|t3|i}]

				ana				*psubtrahend[,, {w0|h1|h2|i}] 	

				ana				*psubtrahend[,, {w0|t1|t2|t3|i}]

				ana				SUBTRAHEND[, {x|y|a|b|fp|sp}], i

				ana				SUBTRAHEND,, xi


	assembler examples	ana			subtrahend
				ana, h2			subtrahend
				ana			subtrahend,,t1
				ana			*psubtrahend,,h1

				ana, xi			-48000/2
				ana			12, y, i
				ana, i			apointer
				ana, i			*apointer	[ =	ana	apointer ]

				_________________________________________________________
	Instruction Code 26	| 1 1 0 1 0 | . . . |		<a style="color:#00AF6F">  address</a>		|
				|___________|_______|___________________________________|
				






	<a	name="anb"/>
	Add Negative to Accumulator b	anb
	_____________________________	___

				_________________________________________________________
				|							|
				|	accumulator b += 2scomplement(operand)		|
				|	<a href="#nonar">carry$</a> = the carry from bit 23 of the addition	|
				|_______________________________________________________|
				|	operand is memory/register value at EA		|
				|	or the value EA or a signed immediate		|
				|	memory source may be a word, half or thirdword	|
				|_______________________________________________________|


	assembler syntax	anb[, {w0|h1|h2|i}]		subtrahend[, {x|y|a|b|fp|sp}] 	

				anb[, {w0|t1|t2|t3|i}]		subtrahend[, {x|y|a|b|fp|sp}]

				anb, {w0|h1|h2|i}]		*psubtrahend

				anb[, {w0|t1|t2|t3|i}]		*psubtrahend

				anb, i				SUBTRAHEND[, {x|y|a|b|fp|sp}]

				anb, xi				SUBTRAHEND

				anb				subtrahend[, {x|y|a|b|fp|sp}][, {w0|h1|h2|i}] 	

				anb				subtrahend[, {x|y|a|b|fp|sp}][, {w0|t1|t2|t3|i}]

				anb				*psubtrahend[,, {w0|h1|h2|i}] 	

				anb				*psubtrahend[,, {w0|t1|t2|t3|i}]

				anb				SUBTRAHEND[, {x|y|a|b|fp|sp}], i

				anb				SUBTRAHEND,, xi


	assembler examples	anb			subtrahend, a
				anb, h2			subtrahend
				anb			subtrahend,,t1
				anb			*psubtrahend,,h1

				anb, xi			-48000/2
				anb			12, y, i
				anb, i			apointer
				anb, i			*apointer	[ =	anb	apointer ]

				_________________________________________________________
	Instruction Code 27	| 1 1 0 1 1 | . . . |		<a style="color:#00AF6F">  address</a>		|
				|___________|_______|___________________________________|
				






	<a	name="m"/>
	Multiply		m
	________		_


				_________________________________________________________
				|							|
				|	multiplicand in accumulator b and operand	|
				|	are multiplied algebraically			|					
				|	giving 48-bit product in accumulators a b	|
				|_______________________________________________________|
				|	operand is memory/register value at EA		|
				|	or the value EA or a signed immediate		|
				|	memory source may be a word, half or thirdword	|
				|_______________________________________________________|
				|	in <a href="#rex_m" style="color:#00AF6F">instruction repeat context</a>			|
				|	multiplicand is 48 bits in two target registers	|
				|_______________________________________________________|



	assembler syntax	m[, {w0|h1|h2|i}]		multiplier[, {x|y|a|b|fp|sp}] 	

				m[, {w0|t1|t2|t3|i}]		multiplier[, {x|y|a|b|fp|sp}]

				m[, {w0|h1|h2|i}]		*pmultiplier

				m[, {w0|t1|t2|t3|i}]		*pmultiplier

				m, i				MULTIPLIER[, {x|y|a|b|fp|sp}]

				m, xi				MULTIPLIER

				m				multiplier[, {x|y|a|b|fp|sp}][, {w0|h1|h2|i}] 	

				m				multiplier[, {x|y|a|b|fp|sp}][, {w0|t1|t2|t3|i}]

				m				*pmultiplier[,, {w0|h1|h2|i}] 	

				m				*pmultiplier[,, {w0|t1|t2|t3|i}]

				m				MULTIPLIER[, {x|y|a|b|fp|sp}], i

				m				MULTIPLIER,, xi


	assembler examples	m			multiplier
				m			(-1250000)
				m, h2			multiplier
				m			multiplier,,t1
				m			*pmultiplier,,h1

				m, xi			-48000/2
				m			12, y, i
				m, i			apointer
				m, i			*apointer	[ =	m	apointer ]

				_________________________________________________________
	Instruction Code 28	| 1 1 1 0 0 | . . . |		<a style="color:#00AF6F">  address</a>		|
				|___________|_______|___________________________________|
				








	<a	name="mf"/>
	Multiply Fractional	mf
	___________________	__

				_________________________________________________________
				|							|
				|	unsigned integer in accumulator b is multiplied	|
				|	by signed multiplier				|
				|	signed 48-bit product is in accumulators a b	|
				|							|
				|	multiply fractional is used for			|
				|							|
				|	   display edit of floating fractions		|
				|							|
				|	   integer multiplication with multiplicands of	|
				|	   2 or more words				|
				|_______________________________________________________|
				|	multiplier is memory/register value at EA	|
				|	or the value EA or a signed immediate.		|
				|	memory source may be a word, half or thirdword	|
				|_______________________________________________________|
				|	in <a href="#rex_mf" style="color:#00AF6F">instruction repeat context</a>			|
				|	mf instruction assign is 24-bit signed multiply	|
				|_______________________________________________________|


	assembler syntax	mf[, {w0|h1|h2|i}]		multiplier[, {x|y|a|b|fp|sp}] 	

				mf[, {w0|t1|t2|t3|i}]		multiplier[, {x|y|a|b|fp|sp}]

				mf[, {w0|h1|h2|i}]		*pmultiplier

				mf[, {w0|t1|t2|t3|i}]		*pmultiplier

				mf, i				MULTIPLIER[, {x|y|a|b|fp|sp}]

				mf, xi				MULTIPLIER

				mf				multiplier[, {x|y|a|b|fp|sp}][, {w0|h1|h2|i}] 	

				mf				multiplier[, {x|y|a|b|fp|sp}][, {w0|t1|t2|t3|i}]

				mf				*pmultiplier[,, {w0|h1|h2|i}] 	

				mf				*pmultiplier[,, {w0|t1|t2|t3|i}]

				mf				MULTIPLIER[, {x|y|a|b|fp|sp}], i

				mf				MULTIPLIER,, xi


	assembler examples	mf			multiplier, x
				mf, h2			multiplier
				mf			multiplier,,t1
				mf			*pmultiplier,,h1

				mf, xi			-48000/2
				mf			12, y, i
				mf, i			apointer
				mf, i			*apointer	[ =	mf	apointer ]

				_________________________________________________________
	Instruction Code 29	| 1 1 1 0 1 | . . . |		<a style="color:#00AF6F">  address</a>		|
				|___________|_______|___________________________________|
				








	<a	name="d"/>
	Divide			d
	______			_

				_________________________________________________________
				|							|
				|	the 48-bit integer in accumulators		|
				|	a and b is divided algebraically by the operand	|
				|	giving a 48-bit integer quotient and 24-bit	|
				|	integer remainder				|
				|							|
				|	quotient low-order 24 bits are in accumulator a	|
				|	and high-order 24-bits in accumulator mantissa2	|
				|							|
				|	remainder is in accumulator b			|
				|							|
				|	there is no divide fault. Overflow is discarded	|
				|							|
				|_______________________________________________________|
				|	operand is memory/register value at EA		|
				|	or the value EA or a signed immediate		|
				|	memory source may be a word, half or thirdword	|
				|_______________________________________________________|
				|	in <a href="#rex_d" style="color:#00AF6F">instruction repeat context</a>			|
				|	results are stored in a different order		| 
				|_______________________________________________________|


	assembler syntax	d[, {w0|h1|h2|i}]		divisor[, {x|y|a|b|fp|sp}] 	

				d[, {w0|t1|t2|t3|i}]		divisor[, {x|y|a|b|fp|sp}]

				d[, {w0|h1|h2|i}]		*pdivisor

				d[, {w0|t1|t2|t3|i}]		*pdivisor

				d, i				DIVISOR[, {x|y|a|b|fp|sp}]

				d, xi				DIVISOR

				d				divisor[, {x|y|a|b|fp|sp}][, {w0|h1|h2|i}] 	

				d				divisor[, {x|y|a|b|fp|sp}][, {w0|t1|t2|t3|i}]

				d				*pdivisor[,, {w0|h1|h2|i}] 	

				d				*pdivisor[,, {w0|t1|t2|t3|i}]

				d				DIVISOR[, {x|y|a|b|fp|sp}], i

				d				value,, xi


	assembler examples	d			divisor
				d			(1000000)
				d, h2			divisor
				d			divisor,,t1
				d			*pdivisor,,h1

				d, xi			-48000/2
				d			12, y, i
				d, i			apointer
				d, i			*apointer	[ =	d	apointer ]

				_________________________________________________________
	Instruction Code 30	| 1 1 1 1 0 | . . . |		<a style="color:#00AF6F">  address</a>		|
				|___________|_______|___________________________________|
				



	INTEGER COMPARE MACROS
	______________________


        <a      name="anu"/>
        Add Negative Upper	macros  anu tanu
        __________________		________

        Add Negative Upper is a 2-instruction macro and stores (accumulator a minus operand) in accumulator b
        <a href="#nonar">carry$</a> or result in accumulator b may be tested for results with instructions <a href="#jc">jc</a> <a href="#jnc">jnc</a> <a href="#jzb">jzb</a> <a href="#jnzb">jnzb</a> <a href="#jpb">jpb</a> <a href="#jnb">jnb</a>

        macro tanu is used insted of anu in ISRs to compare interrupt accumulator a = 128+4 a_x.
	tanu stores difference (a_x minus operand) in interrupt accumulator b = 128+5 b_x.

        Operand types and assembly syntax are as <a href="#ana">Add Negative a</a> instruction




        <a      name="anuba"/>
        Add Negative Upper b    macros  anuba tanuba
        ____________________            ____________

        Add Negative Upper b is a 2-instruction macro and stores (accumulator b minus operand) in accumulator a
        <a href="#nonar">carry$</a> or result in accumulator a may be tested for results with instructions <a href="#jc">jc</a> <a href="#jnc">jnc</a> <a href="#jza">jza</a> <a href="#jnza">jnza</a> <a href="#jpa">jpa</a> <a href="#jna">jna</a> <a href="#jae">jae</a> <a href="#jpe">jpe</a>

        macro tanuba is used instead of anuba in ISRs to compare interrupt accumulator b = 128+5 b_x.
	tanuba stores difference (b_x minus operand) in interrupt accumulator a = 128+4 a_x. 

        Operand types and assembly syntax are as <a href="#anb">Add Negative b</a> instruction




	<a	name="io"/>
	<div    style="margin-left:28pt;font-family:times-roman;font-size:12.75pt;color:0000FF">
	<i>3.6.7	I/O Ports Input and Output Instructions</i>
	</div>
	instructions	<a href="#ina">inA</a>		<a href="#outa">outA</a>
			<a href="#inb">inB</a>		<a href="#outb">outB</a>


	Input and Output Instructions identify the target port by effective address
	with or without indirection or indexing:


		inA		SOURCE_PORT
		outB		*target_port_pointer

		inB		RELATIVE_PORT_NUMBER, a






	<a	name="ina"/>
	I/O In to Accumulator a		inA
	_______________________		___

				_________________________________________________________
				|							|
				|	I/O port[EA] is read to accumulator a		|
				|_______________________________________________________|
				|	source is the I/O port EA			|
				|_______________________________________________________|

	assembler syntax	inA		PORT_NUMBER[, {x|y|a|b|fp|sp}]
				inA		*port_number_variable

				_________________________________________________________
	Instruction Code 0.4	| 0 0 0 0 0 | 1 0 0 | . . . .  . . . . . . . . . . . .	|
				|___________|_______|___________________________________|





	<a	name="inb"/>
	I/O In to Accumulator b		inB
	_______________________		___

				_________________________________________________________
				|							|
				|	I/O port[EA] is read to accumulator b		|
				|_______________________________________________________|
				|	source is the I/O port EA			|
				|_______________________________________________________|


	assembler syntax	inB		PORT_NUMBER[, {x|y|a|b|fp|sp}]
				inB		*port_number_variable

				_________________________________________________________
	Instruction Code 1.4	| 0 0 0 0 1 | 1 0 0 | . . . .  . . . . . . . . . . . .	|
				|___________|_______|___________________________________|





	<a	name="outa"/>
	I/O Out from Accumulator a	outA
	__________________________	____

				_________________________________________________________
				|							|
				|    value is written from accumulator a to I/O port[EA]|
				|_______________________________________________________|
				|	target is the I/O port EA			|
				|_______________________________________________________|

	assembler syntax	outA		PORT_NUMBER[, {x|y|a|b|fp|sp}]
				outA		*port_number_variable

				_________________________________________________________
	Instruction Code 2.4	| 0 0 0 1 0 | 1 0 0 | . . . .  . . . . . . . . . . . .	|
				|___________|_______|___________________________________|






	<a	name="outb"/>
	I/O Out from Accumulator b	outB
	__________________________	____

				_________________________________________________________
				|							|
				|    value is written from accumulator b to I/O port[EA]|
				|_______________________________________________________|
				|	target is the I/O port EA			|
				|_______________________________________________________|


	assembler syntax	outB		PORT_NUMBER[, {x|y|a|b|fp|sp}]
				outB		*port_number_variable

				_________________________________________________________
	Instruction Code 3.4	| 0 0 0 1 1 | 1 0 0 | . . . .  . . . . . . . . . . . .	|
				|___________|_______|___________________________________|






        <a      name="relo"/>
        <div    style="margin-left:28pt;font-family:times-roman;font-size:12.75pt;color:0000FF">
        <i>3.6.8        Process and Thread Memory Switch Instructions</i>
        </div>
	Applications issue <a href="#sabr">sabr</a> instruction to select memory blocks B2..B63

	Kernel issues <a href="#reload">reload</a> instruction to switch application memory space

	<a href="#b1">B1</a> is a private stack frame organised with I/O instructions




	<a	name="sabr"/>
	Store Accumulator a to Base Register	sabr
	____________________________________	____


				_________________________________________________________
				|							|
				|	the absolute pointer part of the storage	|
				|	block identified in accumulator a is written 	|
				|	to data window pointer I/O Port[EA/PAGE]	|
				|							|
				|	the storage block symbolic identifier is copied	|
				|	from accumulator a to memory window 65 (thread	|
				|	control block) offset 64 + EA/PAGE		|
				|							|
				|	value of EA may be 2..63			|
				|							|
				|	symbolic identifier and absolute storage pointer|
				|	are identical. There are no translated pointer	|
				|	values in the scope of sabr instruction		|
				|							|
				|	sabr is an instruction for application use	|
				|	but only interrupt code may place a block	|
				|	of a filestore or network relay device array	|
				|	in a data address space window			|
				|							|
				|	applications may place executable memory	|
				|	and device arrays with the same bus behaviour as|
				|	executable space in data address space windows	|
				|							|
				|	neither applications nor interrupt code may base|
				|	executable pages below the <a href="#thresho">application threshold</a>|
				|							|
				|	sabr operations which are not permitted	raise	|
				|	interrupt GUARD$ 				|
				|							|
				|	if the target device array does not have the	|
				|	requested page then sabr instruction assigns	|
				|	the pointer value C00001 to the address window	|
				|							|
				|	pointer value C00001 raises interrupt GUARD$	|
				|	on memory read or write	in the assigned window	|
				|							|
				|	C00001 is the unique member of a range of	|
				|	functional storage base pointer values		|
				|							|
				|	the unused address windows of threads		|	 
				|	have the pointer value C00001			|
				|_______________________________________________________|




	assembler syntax	sabr		RELOCATION_REGISTER_ID[, {x|y|a|b|fp|sp}]
				sabr		*base_register_id_variable

				_________________________________________________________
	Instruction Code 6.4	| 0 0 1 1 0 | 1 0 0 | . . . .  . . . . . . . . . . . .	|
				|___________|_______|___________________________________|







	<a	name="reload"/>
	Reload			reload
	______			______

				_________________________________________________________
				|							|
				|	two storage block identifiers are read from	|
				|	memory at the address in accumulator a		|
				|							|
				|	the two retrieved storage pointers are written	|
				|	to relocation registers				|
				|							|
				|		I/O Port[EA]				|
				|		I/O Port[EA + 1]			|
				|							|
				|	accumulator a is incremented by 2		|
				|							|
				|	value of EA can be 2..62			|
				|_______________________________________________________|
				|							|
				|	reload instruction is used in the loadup beat	|
				|	of thread/process switch			|
				|							|
				|	it reads the list of identifiers which is stored|
				|	in the thread control block as the application	|
				|	obtains memory					|
				|_______________________________________________________|
				|	source is two storage words at [a]		|
				|	target is memory block pointer ports[EA, EA + 1]|
				|_______________________________________________________|


	assembler syntax	reload			RELOCATION_REGISTER_PAIR[, {x|y|a|b|fp|sp}]
				reload			*base_register_id_variable


	assembler example	la, xi		TCB_BASE_REGISTER_TABLE+B2
			?	$do		USER_WINDOWS/2,	reload	?*2

				_________________________________________________________
	Instruction Code 4.4	| 0 0 1 0 0 | 1 0 0 | . . . .  . . . . . . . . . . . .	|
				|___________|_______|___________________________________|




	<a	name="b1"/>
	<div	style="font-size:11pt">
	_________________________________________________________________________________________________________________
	|					   BANK B1 PRIVATE STORAGE FRAME					|
	|_______________________________________________________________________________________________________________|
	|														|
	|	window B1 is a frame in a private stack. B1 is outside the scope of sabr and reload instructions	|
	|														|
	|	<a href="#sabr">sabr</a> and <a href="#reload">reload</a> instructions concern windows B2..B63							|
	|														|
	|	applications execute sabr instruction to base memory blocks in B2..B63					|
	|	sabr also copies the relocation values through to the TCB						|
	|														|
	|	reload instruction bases some or all of B2..B63 in pairs on the loadup beat of thread switch		|
	|														|
	|	Applications manipulate and restore B1 pointer in a different dynamic from B2..63			|
	|														|
	|	Thread switch inputs B1 from I/O Port 1 and saves it individually					|
	|	Thread switch outputs B1 of the loading thread to I/O Port 1 individually				|
	|														|
	|_______________________________________________________________________________________________________________|
	|														|
	|														|
	|	A process has at least one B1 frame or 4K block								|
        |														|
        |	a B1 frame contains private data at addresses 4096..8191						|
	|														|
	|	divisions of a process may have separate B1 frames							|
	|														|
	|	the owning entity of a B1 frame may be a thread, a service, a function,					|
	|	or a recursive execution of a function									|
	|														|
	|	services base a B1 frame temporarily to use private data on behalf of calling routines			|
	|														|
	|	it may not be assumed that a called entity may reference addresses in the caller B1 framea		|
	|	so call parameters by reference are not in the adresses 001000..001FFF					|
	|														|
	|	the private data in B1 may include mechanical information underlying a service and compiler-generated	|
	|	information like database subschemas									|
	|														|
	|														|
	|_______________________________________________________________________________________________________________|
	</div>





        <a      name="onoff"/>
        <div    style="margin-left:28pt;font-family:times-roman;font-size:12.75pt;color:0000FF">
        <i>3.6.9	PSR Flags Update Instructions</i>
        </div>
	<a	name="on"/>
	<a href="#on">On</a> and <a href="#off">Off</a> instructions switch PSR flags according to bits 15..0 of
	the sign-extended immediate operand


	PSR Flags On		on
	____________		__

				_________________________________________________________
				|							|
				|	1 is written to PSR flags designated by 1 in the|
				|	immediate operand. Only Flags 15..0 are affected|
				|_______________________________________________________|
				|	MASK is 16-bit immediate with sign extension	|
				|_______________________________________________________|


	assembler syntax	on	PSR_FLAGS_MASK

	assembler example	on	see$1++see$6++see$7


				_________________________________________________________
	Instruction Code 0.5	| 0 0 0 0 0 | 1 0 1 |		   MASK			|
				|___________|_______|___________________________________|





	<a	name="off"/>
	PSR Flags Off		off
	_____________		___


				_________________________________________________________
				|							|
				|	0 is written to PSR flags designated by 1 in the|
				|	immediate operand. Only Flags 15..0 are affected|
				|_______________________________________________________|
				|	MASK is 16-bit immediate with sign extension	|
				|_______________________________________________________|


	assembler syntax	off	PSR_FLAGS_MASK

	assembler example	off	half$w++carry$

				_________________________________________________________
	Instruction Code 1.5	| 0 0 0 0 1 | 1 0 1 | 		    MASK		|
				|___________|_______|___________________________________|




	<a      name="bstream"/>
	<div    style="margin-left:28pt;font-family:times-roman;font-size:12.75pt;color:0000FF">
	<i>3.6.10	Bit Stream Read and Write Channels</i>
	</div>
	instructions	<a href="#rsr">Read Staging Register</a>	<a href="#wsr">Write Staging Register</a>


<div	style="font-size:11pt">
        _________________________________________________________________________________________________________________
        |					    The Bit Stream Read Channel						|
        |_______________________________________________________________________________________________________________|
        |														|
	|	The Bit Stream Read Channel allows storage to be read in bit fields up to 24 bits			|
	|	Bit fields may be read across word boundaries transparently						|
	|														|
	|	Successive reads may be field of equal or irregular size				 		|
	|	Alternatively successive reads may be an irregular number of bits					|
	|														|
	|	24 bits may be read from each storage word, or 16 bits to accommodate 16-bit input devices		|
	|														|
	|	Read Staging Register instruction drives the Bit Stream Read Channel					|
	|_______________________________________________________________________________________________________________|
<a	style="color:0000FF">
	_________________________________________________________________________________________________________________
	|						   Multiplexing							|
	|_______________________________________________________________________________________________________________|
	|														|
	|	The Bit Stream Read Channel is within application context, so every thread has one			|
	|														|
	|	Many applications only scan one read stream, stdin							|
	|														|
	|	The prototype kernel smaragd7 has a system call for switching stream states				|
	|	so that an application may scan many ANSI filestreams and other arrays in overlapped time		|
	|_______________________________________________________________________________________________________________|
</a>
</div>


	<a	name="rsr"/>
	Read Staging Register	rsr
	_____________________	___

	rsr instruction shifts BITS bits from storage stream *q to accumulator a
	controlled by counter register RDATAC and buffered in data register RDATA

	BITS is the sign extended immediate operand

				_________________________________________________________
				|							|
				|	shift BITS bits left from Staging Register	|
				|	RDATA to accumulator a				|
				|							|
				|	reload RDATA from storage on empty		|
				|							|
				|_______________________________________________________|
				|							|
				|	if RDATAC < BITS				|
				|							|
				|		subtract RDATAC	from BITS		|
				|							|
				|		shift RDATAC bits to accumulator a	|
				|							|
				|		read memory/register to RDATA with	|
				|		Pointer Register *q			|
				|							|
				|		increment Pointer Register q		|
				|							|
				|		restart RDATAC = RSTREAM_WORD		|
				|							|
				|	shift BITS bits from RDATA to accumulator a	|
				|							|
				|	subtract BITS from RDATAC			|
				|_______________________________________________________|
				|							|
				|	if PSR Flag b$streamZR = 0 displace the prior	|
				|	value in accumulator a leftwards		|
				|							|
				|	if PSR Flag b$streamZR = 1 clear accumulator a	|
				|	before shifting from RDATA			|
				|							|
				|	if PSR Flag b$stream16r = 0 RSTREAM_WORD = 24	|
				|							|
				|	if PSR Flag b$stream16r = 1 RSTREAM_WORD = 16	|
				|	and RDATA is shifted left 8 bits on memory read	|
				|							|
				|_______________________________________________________|
				|							|
				|	RDATAC RDATA and q are registers		|
				|							|
				|	RSTREAM_WORD is a term not a register		|
				|_______________________________________________________|
				|	BITS is 16-bit immediate with sign extension  	|
				|_______________________________________________________|
				|							|
				|	RDATAC and RDATA are application registers	|
				|	not replicated as interrupt registers		|
				|							|
				|	if ISRs program bit read streams they use	|
				|	application registers RDATAC and RDATA and	|
				|	must first save them				|
				|							|
				|	storage read pointer q is replicated in		|
				|	application and interrupt register sets		|
				|							|
				|	rsr instruction in interrupt mode uses q_x	|
				|_______________________________________________________|

	assembler syntax	rsr	BITS_TO_READ

	assembler example	rsr	BYTE_SIZE

				_________________________________________________________
	Instruction Code 2.5	| 0 0 0 1 0 | 1 0 1 | 		    BITS		|
				|___________|_______|___________________________________|





	<div	style="font-size:11pt">
        _________________________________________________________________________________________________________________
        |					The Bit Stream Write Channel						|
        |_______________________________________________________________________________________________________________|
        |														|
        |       The Bit Stream Write Channel allows storage to be written as a stream of bits in fields up 24 bits	|
        |       Bit fields may be written across word boundaries transparently                                          |
        |														|
        |       Successive writes may each be bit fields of equal or irregular size					|
        |														|
        |       write thru is data words of 24 bits, or 16 bits for 16-bit output devices				|
        |														|
        |       Write Staging Register instruction drives the Bit Stream Write Channel					|
        |_______________________________________________________________________________________________________________|

	<a      style="color:0000FF">
        _________________________________________________________________________________________________________________
        |						Multiplexing							|
        |_______________________________________________________________________________________________________________|
        |														|
        |       The Bit Stream Write Channel is within application context, so every thread has one			|
        |														|
        |       Many applications only format one write stream, stdout							|
        |														|
        |       The prototype kernel smaragd7 has a system call for switching stream states				|
        |       so that an application may format many ANSI filestreams and other arrays in overlapped time		|
	|_______________________________________________________________________________________________________________|
	</a>
	</div>



	<a	name="wsr"/>
	Write Staging Register	wsr
	______________________	___


	wsr instruction shifts BITS bits from arithmetic accumulator a to storage stream *p
	controlled by counter register WDATAC and buffered in data register WDATA

	BITS is the sign extended immediate operand 


				_________________________________________________________
				|							|
				|	shift BITS bits left from accumulator a		|
				|	to Staging Register WDATA			|
				|							|
				|	write WDATA to storage on full			|
				|							|
				|_______________________________________________________|
				|							|
				|	WSPACE = WSTREAM_WORD - WDATAC			|
				|							|
				|	if BITS >= WSPACE				|
				|							|
				|		subtract WSPACE from BITS		|
				|							|
				|		shift WSPACE bits to WDATA		|
				|							|
				|		write WDATA to memory/register with	|
				|		Pointer Register *p			|
				|							|
				|		increment Pointer Register p		|
				|							|
				|		restart WDATAC = 0			|
				|							|
				|		restart WDATA = 0			|
				|							|
				|	shift BITS bits from accumulator a to WDATA	|
				|							|
				|	add BITS to WDATAC				|
				|_______________________________________________________|
				|							|
				|	if PSR Flag b$stream16w = 0 WSTREAM_WORD = 24	|
				|							|
				|	if PSR Flag b$stream16w = 1 WSTREAM_WORD = 16	|
				|							|
				|_______________________________________________________|
				|							|
				|	WDATAC WDATA and p are registers		|
				|							|
				|	WSPACE and WSTREAM_WORD are terms not registers	|
				|_______________________________________________________|
				|	BITS is 16-bit immediate with sign extension	|
				|_______________________________________________________|
				|							|
				|	WDATAC and WDATA are application registers	|
				|	not replicated as interrupt registers		|
				|							|
				|	if ISRs program bit write streams they use	|
				|	application registers WDATAC and WDATA and	|
				|	must first save them				|
				|							|
				|	storage write pointer p is replicated in	|
				|	application and interrupt register sets		|
				|							|
				|	wsr instruction in interrupt mode uses p_x	|
				|_______________________________________________________|


	assembler syntax	wsr		BITS_TO_WRITE

	assembler example	sal		24-BYTE_SIZE
				wsr		BYTE_SIZE


				_________________________________________________________
	Instruction Code 3.5	| 0 0 0 1 1 | 1 0 1 | 		    BITS		|
				|___________|_______|___________________________________|


				_________________________________________________________
				|	at the end of a stream of wsr writes software	|
				|	intervention may be needed to write outstanding	|
				|	bits of an incomplete data word			|
				|_______________________________________________________|
				|	if zero-padding is required, an unconditional	|
				|	write instruction drives a conditional write	|
				|_______________________________________________________|


				wsr		$word-$byte


				_________________________________________________________
				|	if the unwritten values in the last written word|
				|	must be unchanged, conditional masking is needed|
				|_______________________________________________________| 


										write_last_bits	lb	*p	
												la	WDATA
				tz		WDATAC						sbl	*WDATAC
				lcal		write_last_bits					dsr	*WDATAC
												sb	*p
												lret	0




	<a      name="lfiret"/>
	<div    style="margin-left:28pt;font-family:times-roman;font-size:12.75pt;color:0000FF">
	<i>3.6.11	Return Instructions, Internal Interrupt and Interrupt Stack Frame</i>
	</div>
	instructions	<a href="#lret">Local Return</a>		<a href="#ii">Internal Interrupt</a>
			<a href="#fret">Far Return</a>		<a href="#ir">Interrrupt return</a>

	<a	href="#is_frame">Interrupt Stack Frame</a>

	Return instructions increment the stacked return address with the sign extended immediate operand
 



	<a	name="lret"/>
	Local Return		lret
	____________		____

				_________________________________________________________
				|							|
				|	return address relative to current instruction	|
				|	window B0 is popped from the internal stack	|
				|							|
				|	sign extended immediate operand of the return	|
				|	instruction is added to the relative address	|
				|							|
				|	B0 * 4096 is added to the relative address	|
				|							|
				|	the resulting absolute address is transferred	|
				|	to the program counter				|
				|							|
				|	if sp = 128 before lret				|
				|	thread exit interrupt 70 is raised		|
				|							|
				|	on internal stack overflow / underflow		|
				|	[sp < 24 | sp > 128] before operation		|
				|	guard interrupt 95 is raised			|
				|							|
				|_______________________________________________________|
				|	DISPLACEMENT is 16-bit sign extended immediate	|
				|_______________________________________________________|


	assembler syntax	lret		SKIP_STEPS

	assembler examples	lret		0
				lret		1
				lret		-1
				lret		2

				_________________________________________________________
	Instruction Code 6.5	| 0 0 1 1 0 | 1 0 1 | 		  DISPLACEMENT		|
				|___________|_______|___________________________________|






	<a	name="fret"/>
	Far Return		fret
	__________		____
	<div	style="font-size:11pt">
									 internal stack frame

									 23						       0
	_________________________________________________________	_________________________________________________________
	|							|	|			offset				| sp + 1
	|	Iframe Name is popped from the internal stack	|	|_______________________________________________________|
	|	and bits 21:0 Start Page Index written to B0	|	| F 0 |			iframe Start Page Index		| <-- sp 
	|							|	|_____|_________________________________________________|
	|	return address offset in retrieved instruction	|	|   22|						       0
	|	frame is popped from the internal stack		|	|     |
	|							|	|
	|	sign extended immediate operand of the return	|	|
	|	instruction is added to iframe relative offset	|	|
	|							|	|
	|	B0 * 4096 is added to iframe relative offset	|	|
	|							|	| 0 0 | Page High Index = 0 : iframe pages 1
	|	the resulting absolute address is transferred	|	|     | B64 = B0
	|	to the program counter				|	| 
	|							|	| 1 0 |	gate descriptor @ target iframe + 64
        |       if sp = 128 before fret                         |	|     |	Page High Index <- gate descriptor bits 47:42
        |       thread exit interrupt 70 is raised		|	|     | B64 = B0 + Page High Index
        |                                                       |
        |       on internal stack overflow / underflow		|
        |       [sp < 24 | sp > 126 ^ 128] before operation	|
	|	guard interrupt 95 is raised			|
        |_______________________________________________________|
	|	I/O Port 64 is updated to new highest page for 	|
	|	instruction execution = B0 + Page High Index - 1|
	|							|
	|	Page High Index is derived from flag values	|
	|	{ 00 | 10 } in bits  23:22 of new Iframe Name	|
	|							|
	|	flags value 00:					|
	|	gives Page High Index 0: iframe size 1 page	|	sample gate @ target iframe + 64
	|							|
	|	flags value 10:					|	 47	     42					      24
	|	Page High Index is read from bits 47:42 of the	|	_________________________________________________________
	|	sample gate at location 64 of target the iframe	|	| Page High Idx| 	offset 0    			| 
	|_______________________________________________________|	|______________|________________________________________|
	|	DISPLACEMENT is 16-bit sign extended immediate	|	| x 0 |			iframe Start Page Index		|
	|_______________________________________________________|	|_____|_________________________________________________|
									       21					       0
	</div>


	assembler syntax	fret		SKIP_STEPS

	assembler examples	fret		0
				fret		-1
				fret		1
				fret		2

				_________________________________________________________
	Instruction Code 7.5	| 0 0 1 1 1 | 1 0 1 | 		DISPLACEMENT		|
				|___________|_______|___________________________________|




	<a	name="is_frame">
	<div	style="font-size:11pt">
	_________________________________________________________________________________________________________________
	|					   	INTERRUPTS							|
	|_______________________________________________________________________________________________________________|
	|														|
	|	on external or internal interrupt									|
	|	_________________________________									|
	|														|
	|	absolute Program Counter minus B0 * 4096 is pushed onto the Interrupt Internal Stack			|
	|														|
	|	iframe name (ff:B0) is pushed onto the Interrupt Internal Stack						|
	|														|
	|	PSR is pushed onto the Interrupt Internal Stack								|
	|														|
	|	a latent parameter word is pushed onto the Interrupt Internal Stack					|
	|	when instruction ii raises the interrupt, the latent parameter word = 0					|
	|														|
	|	if PSR Flag 23 = 0 then Interrupt Stack Pointer sp_x is copied to Interrupt Frame Pointer fp_x		|
	|	this marks which Interrupt Stack Frame is the interrupted application					|
	|	the absolute address of the application Interrupt Stack Frame should always be 252			|
	|														|
	|	1 is written to PSR Flag 23										|
	|														|
	|_______________________________________________________________________________________________________________|
	|														|
	|			The Interrupt Stack Frame at Interrupt Stack Pointer sp_x is				|
	|			____________________________________________________________				|
	|														|
	|														|
	|	 95			 71			 47			 23		       0	|
	|	_________________________________________________________________________________________________	|
	|	|    latent parameter	|	saved PSR	|   saved iframe name	| 	saved offset	|	|
	|	|_______________________|_______________________|_______________________|_______________________|	|
	|	 *sp			 +1,sp		 	 +2,sp			 +3,sp				|
	|_______________________________________________________________________________________________________________|
	</div>



	<a	name="ii"/>
	Internal Interrupt	ii					 interrupt frame -> internal stack
	__________________	__					 sp is interrupt stack pointer sp_x
	<div	style="font-size:11pt">

									 23						       0
	_________________________________________________________	_________________________________________________________
	|							|	|			saved offset			| sp + 3
	|	B0 * 4096 is subtracted from the value of	|	|_______________________________________________________|
	|	the absolute program counter			|	| F 0 |			saved iframe Start Page Index	| sp + 2
	|							|	|_____|_________________________________________________|
	|	the resulting instruction frame relative value	|	|   22			saved PSR			| sp + 1
	|	is pushed on the interrupt internal stack	|	|			________________________________|
	|							|	|			latent parameter		| <-- sp
	|	Iframe Name = Start Page Index + size flags	|	|			________________________________|
	|	is pushed on the interrupt internal stack	|	|
	|							|	|
	|	PSR is pushed on the interrupt internal stack 	|	| 0 0 | B64 = B0 Page High Index on i-return = 0
	|							|	| 1 0 | B64 > B0 Page High Index on i-return
	|	latent parameter 0				|				= gate bits 47:42 @ iframe + 64
	|	is pushed on the interrupt internal stack	|
	|-------------------------------------------------------|
	|							| 
	|	PSR Flag 23 = 1					|
	|							|
	|	the high-order 18 bits of the immediate operand	|
	|	designate a VECTOR_BANK				|
	|							|
	|	the low-order 6 bits if the immediate operand	|
	|	designate a VECTOR_OFFSET			|
	|							|
	|	B0 = VECTOR_BANK				|
	|							|
	|	program counter = VECTOR_BANK*4096+VECTOR_OFFSET|
	|_______________________________________________________|
	|	VECTOR_BANK			  |VECTOR_OFFSET|
	|23______________________________________6|5___________0|
	|	VECTOR is 16-bit sign extended immediate	|
	|_______________________________________________________|
	</div>


	assembler syntax	ii	INTERRUPT_VECTOR

	assembler examples	ii	BANK_1*/6++2
				ii	BANK_1*/6++11

				_________________________________________________________
	Instruction Code 14.5	| 0 1 1 1 0 | 1 0 1 |		  VECTOR		|
				|___________|_______|___________________________________|






	<a	name="ir"/>
	Interrupt Return	ir
	________________	__
	<div	style="font-size:11pt">

								 	 interrupt / return internal stack frame
									 sp is interrupt stack pointer sp_x


									 23						       0
	_________________________________________________________	_________________________________________________________
	|							|	|			saved offset			| sp + 3
	|							|	|_______________________________________________________|
	|	saved PSR is retrieved from			|	| F 0 |			saved iframe Start Page Index	| sp + 2
	|	[interrupt internal stack pointer + 1]		|	|_____|_________________________________________________|
	|							|	|   22|			saved PSR			| sp + 1
	|	saved Iframe Name is retrieved from		|	|			________________________________|
	|	[interrupt internal stack pointer + 2]		|	|			latent parameter		| <-- sp
	|	and bits 21:0 Start Page Index transferred to B0|	|			________________________________|
	|							|	|
	|	saved address offset in instruction frame	|	|
	|	is retrieved from				|	|
	|	[interrupt internal stack pointer + 3]		|	| 0 0 |	page high index = 0 : iframe pages 1
	|							|	|     |	B64 = B0
	|	the sign extended immediate operand of the ir	|	|
	|	instruction is added to iframe relative address	|	| 1 0 |	gate descriptor @ target iframe + 64
	|							|	|     |	page high index <- gate descriptor bits 47:42
	|	B0 * 4096 is added to iframe relative address	|	|     |	B64 = B0 + Page High Index 
	|							|
	|	the resulting absolute address is transferred	|
	|	to the program counter				|
	|							|
	|	interrupt internal stack pointer		|
	|	is incremented by 4				|
        |_______________________________________________________|
        |       I/O Port 64 is updated to new highest page for  |
        |       instruction execution = B0 + Page High Index - 1|
        |                                                       |
        |       Page High Index is derived from flag values     |
        |       { 00 | 10 } in bits  23:22 of new Iframe Name   |
        |                                                       |
        |       flags value 00:                                 |
        |       gives Page High Index 0: iframe size 1 page     |       sample gate @ target iframe + 64
        |                                                       |
        |       flags value 10:                                 |        47          42                                       24
        |       Page High Index is read from bits 47:42 of the  |       _________________________________________________________
        |       sample gate at location 64 of the target iframe |       | Page High Idx|        offset 0                        | 
        |_______________________________________________________|       |______________|________________________________________|
        |       DISPLACEMENT is 16-bit sign extended immediate  |       | x 0 |                 iframe Start Page Index         | 
        |_______________________________________________________|       |_____|_________________________________________________|

	assembler syntax	ir	SKIP_STEPS

	assembler examples	ir	0
				ir	-1
				ir	2

				_________________________________________________________
	Instruction Code 15.5	| 0 1 1 1 1 | 1 0 1 | 		DISPLACEMENT		|
				|___________|_______|___________________________________|







	<a      name="shijo"/>
	<div    style="margin-left:28pt;font-family:times-roman;font-size:12.75pt;color:0000FF">
	<i>3.6.12      Shift and Jump Instructions</i>
	</div>
	Shift instructions and jump instructions use the effective address
	with or without indirection or indexing as an immediate operand

	instructions	<a href="#sar">Shift a Right</a>			<a href="#j">Jump</a>
			<a href="#sbr">Shift b Right</a>			<a href="#lcal">Local Call</a>
			<a href="#dsr">Double Shift Right</a>		<a href="#jc">Jump Carry</a>
			<a href="#sal">Shift a Left</a>			<a href="#jnc">Jump No Carry</a>
			<a href="#sbl">Shift b Left</a>			<a href="#jza">Jump Zero a</a>
			<a href="#dsl">Double Shift Left</a>		<a href="#jzb">Jump Zero b</a>
			<a href="#rar">Rotate a Right</a>			<a href="#jnza">Jump NonZero a</a>
			<a href="#rbr">Rotate b Right</a>			<a href="#jnzb">Jump NonZero b</a>
			<a href="#drr">Double Rotate Right</a>		<a href="#jpa">Jump Positive a</a>
			<a href="#ral">Rotate a Left</a>			<a href="#jpb">Jump Positive b</a>
			<a href="#rbl">Rotate b Left</a>			<a href="#jna">Jump Negative a</a>
			<a href="#drl">Double Rotate Left</a>		<a href="#jnb">Jump Negative b</a>
			<a href="#saa">Shift a Algebraic</a>		<a href="#jao">Jump a Odd</a>			<a href="#jao">Jump a Even (macro)</a>
			<a href="#sba">Shift b Algebraic</a>		<a href="#jpo">Jump Parity k**a Odd</a>		<a href="#jpo">Jump Parity Even (macro)</a>
			<a href="#dsa">Double Shift Algebraic</a>		<a href="#jdr">Jump Decrement Counter Register</a>
							<a href="#jxge">Jump x NOT < r</a>			<a href="#jxge">Jump x < r (macro)</a> 
							<a href="#jyge">Jump y NOT < r</a>			<a href="#jyge">Jump y < r (macro)</a>
							<a href="#jdz">Jump Double Zero</a>


			see also	target modify instructions	<a href="#src">src</a> and <a href="#slc">slc</a>
					scale instructions		<a href="#lsc">lsc</a> and <a href="#dlsc">dlsc</a>
					far jump instructions		<a href="#go">go</a>  and <a href="#call">call</a>		


	<a	name="sar"/>
	Shift Accumulator a Right	sar
	_________________________	___

				_________________________________________________________
				|							|
				|	the value in accumulator a is shifted right	|
				|	for EA bit positions				|
				|	0 is written to vacated high-order bit positions|
				|_______________________________________________________|


	assembler syntax	sar	BIT_POSITIONS[, {x|y|a|b|fp|sp}]
				sar	*shift_distance_variable

				_________________________________________________________
	Instruction Code 0.6	| 0 0 0 0 0 | 1 1 0 | . . . .  . . . . . . . . . . . .	|
				|___________|_______|___________________________________|






	<a	name="sbr"/>
	Shift Accumulator b Right	sbr
	_________________________	___

				_________________________________________________________
				|							|
				|	the value in accumulator b is shifted right	|
				|	for EA bit positions				|
				|	0 is written to vacated high-order bit positions|
				|_______________________________________________________|


	assembler syntax	sbr	BIT_POSITIONS[, {x|y|a|b|fp|sp}]
				sbr	*shift_distance_variable

				_________________________________________________________
	Instruction Code 1.6	| 0 0 0 0 1 | 1 1 0 |		<a style="color:#00AF6F">  address</a>		|
				|___________|_______|___________________________________|






	<a	name="dsr"/>
	Double Shift Right	dsr
	__________________	___

				_________________________________________________________
				|							|
				|	the 48-bit value in accumulators a b		|
				|	is shifted right for EA bit positions		|
				|	0 is written to vacated high-order bit positions|
				|_______________________________________________________|


	assembler syntax	dsr	BIT_POSITIONS[, {x|y|a|b|fp|sp}]
				dsr	*shift_distance_variable

				_________________________________________________________
	Instruction Code 2.6	| 0 0 0 1 0 | 1 1 0 |		<a style="color:#00AF6F">  address</a>		|
				|___________|_______|___________________________________|





	<a	name="jdr"/>
	Jump Decrement Repeat Count	jdr
	___________________________	___


				_________________________________________________________
				|							|
				|	repeat count register r	is decremented.		|
				|	instruction path jumps to EA			|
				|	unless r changes from 0 to -1			|
				|_______________________________________________________|


	assembler syntax	jdr	jump_address[, {x|y|a|b|fp|sp}]
				jdr	*jump_pointer

				_________________________________________________________
	Instruction Code 3.6	| 0 0 0 1 1 | 1 1 0 |		<a style="color:#00AF6F">  address</a>		|
				|___________|_______|___________________________________|





	<a	name="sal"/>
	Shift Accumulator a Left	sal
	________________________	___

				_________________________________________________________
				|							|
				|	the value in accumulator a is shifted left	|
				|	for EA bit positions				|
				|	0 is written to vacated low-order bit positions |
				|_______________________________________________________|


	assembler syntax	sal	BIT_POSITIONS[, {x|y|a|b|fp|sp}]
				sal	*shift_distance_variable

				_________________________________________________________
	Instruction Code 4.6	| 0 0 1 0 0 | 1 1 0 |		<a style="color:#00AF6F">  address</a>		|
				|___________|_______|___________________________________|






	<a	name="sbl"/>
	Shift Accumulator b Left	sbl
	________________________	___

				_________________________________________________________
				|							|
				|	the value in accumulator b is shifted		|
				|	for EA bit positions				|
				|	0 is written to vacated low-order bit positions	|
				|_______________________________________________________|


	assembler syntax	sbl	BIT_POSITIONS[, {x|y|a|b|fp|sp}]
				sbl	*shift_distance_variable

				_________________________________________________________
	Instruction Code 5.6	| 0 0 1 0 1 | 1 1 0 |		<a style="color:#00AF6F">  address</a>		|
				|___________|_______|___________________________________|






	<a	name="dsl"/>
	Double Shift Left	dsl
	_________________	___

				_________________________________________________________
				|							|
				|	the 48-bit value in accumulators a b		|
				|	is shifted left for EA bit positions		|
				|	0 is written to vacated low-order bit positions	|
				|_______________________________________________________|


	assembler syntax	dsl	BIT_POSITIONS[, {x|y|a|b|fp|sp}]
				dsl	*shift_distance_variable

				_________________________________________________________
	Instruction Code 6.6	| 0 0 1 1 0 | 1 1 0 |		<a style="color:#00AF6F">  address</a>		|
				|___________|_______|___________________________________|






	<a	name="lcal"/>
	Local Call		lcal
	__________		____


				_________________________________________________________
				|							|
				|	absolute program counter minus B0 * 4096	|	
				|	is pushed onto the internal stack		|
				|							|
				|	new program counter = B0 * 4096 + EA:		|
				|	instruction path jumps to EA			|
				|							|
                                |       on internal stack overflow / underflow		|
                                |       [sp < 25 | sp > 128] before operation           |
                                |       guard interrupt 95 is raised			|
				|_______________________________________________________|



	assembler syntax	lcal	jump_address[, {x|y|a|b|fp|sp}]
				lcal	*jump_pointer

				_________________________________________________________
	Instruction Code 7.6	| 0 0 1 1 1 | 1 1 0 |		<a style="color:#00AF6F">  address</a>		|
				|___________|_______|___________________________________|





	<a	name="rar"/>
	Rotate Accumulator a Right	rar
	__________________________	___

				_________________________________________________________
				|							|
				|	the value in accumulator a is rotated right	|
				|	for EA bit positions				|
				|	values shifted out of the register are		|
				|	transferred to high-order bit positions 	|
				|_______________________________________________________|

	assembler syntax	rar	BIT_POSITIONS[, {x|y|a|b|fp|sp}]
				rar	*shift_distance_variable

				_________________________________________________________
	Instruction Code 8.6	| 0 1 0 0 0 | 1 1 0 |		<a style="color:#00AF6F">  address</a>		|
				|___________|_______|___________________________________|





	<a	name="rbr"/>
	Rotate Accumulator b Right	rbr
	__________________________	___

				_________________________________________________________
				|							|
				|	the value in accumulator b is rotated right	|
				|	for EA bit positions				|
				|	values shifted out of the register are		|
				|	transferred to high-order bit positions		|
				|_______________________________________________________|


	assembler syntax	rbr	BIT_POSITIONS[, {x|y|a|b|fp|sp}]
				rbr	*shift_distance_variable

				_________________________________________________________
	Instruction Code 9.6	| 0 1 0 0 1 | 1 1 0 |		<a style="color:#00AF6F">  address</a>		|
				|___________|_______|___________________________________|





	<a	name="drr"/>
	Double Rotate Right	drr
	___________________	___

				_________________________________________________________
				|							|
				|	the 48-bit value in accumulators a b		|
				|	is rotated right for EA bit positions		|
				|	values shifted out of the register pair are	|
				|	transferred to high-order bit positions		|
				|_______________________________________________________|


	assembler syntax	drr	BIT_POSITIONS[, {x|y|a|b|fp|sp}]
				drr	*shift_distance_variable

				_________________________________________________________
	Instruction Code 10.6	| 0 1 0 1 0 | 1 1 0 |		<a style="color:#00AF6F">  address</a>		|
				|___________|_______|___________________________________|





	<a	name="jnc"/>
	Jump No Carry		jnc
	_____________		___

				_________________________________________________________
				|							|
				|	instruction path jumps to EA if <a href="#nonar">carry$</a> flag is 0|
				|_______________________________________________________|


	assembler syntax	jnc	jump_address[, {x|y|a|b|fp|sp}]
				jnc	*jump_pointer

				_________________________________________________________
	Instruction Code 11.6	| 0 1 0 1 1 | 1 1 0 |		<a style="color:#00AF6F">  address</a>		|
				|___________|_______|___________________________________|






	<a	name="ral"/>
	Rotate Accumulator a Left	ral
	_________________________	___

				_________________________________________________________
				|							|
				|	the value in accumulator a is rotated left	|
				|	for EA bit positions				|
				|	values shifted out of the register are		|
				|	transferred to low-order bit positions		|
				|_______________________________________________________|


	assembler syntax	ral	BIT_POSITIONS[, {x|y|a|b|fp|sp}]
				ral	*shift_distance_variable

				_________________________________________________________
	Instruction Code 12.6	| 0 1 1 0 0 | 1 1 0 |		<a style="color:#00AF6F">  address</a>		|
				|___________|_______|___________________________________|






	<a	name="rbl"/>
	Rotate Accumulator b Left	rbl
	_________________________	___

				_________________________________________________________
				|							|
				|	the value in accumulator b is rotated left	|
				|	for EA bit positions				|
				|	values shifted out of the register are		|
				|	transferred to low-order bit positions		|
				|_______________________________________________________|


	assembler syntax	rbl	BIT_POSITIONS[, {x|y|a|b|fp|sp}]
				rbl	*shift_distance_variable

				_________________________________________________________
	Instruction Code 13.6	| 0 1 1 0 1 | 1 1 0 |		<a style="color:#00AF6F">  address</a>		|
				|___________|_______|___________________________________|






	<a	name="drl"/>
	Double Rotate Left	drl
	__________________	___

				_________________________________________________________
				|							|
				|	the 48-bit value in accumulators a  b		|
				|	is rotated left for EA bit positions		|
				|	values shifted out of the register pair are	|
				|	transferred to low-order bit positions		|
				|_______________________________________________________|


	assembler syntax	drl	BIT_POSITIONS[, {x|y|a|b|fp|sp}]
				drl	*shift_distance_variable

				_________________________________________________________
	Instruction Code 14.6	| 0 1 1 1 0 | 1 1 0 |		<a style="color:#00AF6F">  address</a>		|
				|___________|_______|___________________________________|






	<a	name="jc"/>
	Jump on Carry		jc
	_____________		__

				_________________________________________________________
				|							|
				|	instruction path jumps to EA if <a href="#nonar">carry$</a> flag is 1|
				|_______________________________________________________|



	assembler syntax	jc	jump_address[, {x|y|a|b|fp|sp}]
				jc	*jump_pointer

				_________________________________________________________
	Instruction Code 15.6	| 0 1 1 1 1 | 1 1 0 |		<a style="color:#00AF6F">  address</a>		|
				|___________|_______|___________________________________|






	<a	name="saa"/>
	Shift Accumulator a Algebraic	saa
	_____________________________	___

				_________________________________________________________
				|							|
				|	the value in accumulator a is shifted		|
				|	algebraically rightwards for EA bit positions	|
				|	the initial value of bit 23 is replicated	|
				|	in each vacated high order bit position		|
				|_______________________________________________________|

	assembler syntax	saa	BIT_POSITIONS[, {x|y|a|b|fp|sp}]
				saa	*shift_distance_variable

				_________________________________________________________
	Instruction Code 16.6	| 1 0 0 0 0 | 1 1 0 |		<a style="color:#00AF6F">  address</a>		|
				|___________|_______|___________________________________|






	<a	name="sba"/>
	Shift Accumulator b Algebraic	sba
	_____________________________	___

				_________________________________________________________
				|							|
				|	the value in accumulator b is shifted right	|
				|	algebraically for EA bit positions		|
				|	the initial value of bit 23 is replicated		|
				|	in each vacated high order bit position		|
				|_______________________________________________________|


	assembler syntax	sba	BIT_POSITIONS[, {x|y|a|b|fp|sp}]
				sba	*shift_distance_variable

				_________________________________________________________
	Instruction Code 17.6	| 1 0 0 0 1 | 1 1 0 |		<a style="color:#00AF6F">  address</a>		|
				|___________|_______|___________________________________|





	<a	name="dsa"/>
	Double Shift Algebraic	dsa
	______________________	___
				_________________________________________________________
				|							|
				|	the 48-bit value in accumulators a b is shifted	|
				|	right algebraically for EA bit positions	|
				|	the initial value of bit 47 is replicated	|
				|	in each vacated high order bit position		|
				|_______________________________________________________|

	assembler syntax	dsa	BIT_POSITIONS[, {x|y|a|b|fp|sp}]
				dsa	*shift_distance_variable

				_________________________________________________________
	Instruction Code 18.6	| 1 0 0 1 0 | 1 1 0 |		<a style="color:#00AF6F">  address</a>		|
				|___________|_______|___________________________________|





	<a	name="jao"/>
	Jump a Odd		jao
	__________		___
	
				_________________________________________________________
				|							|
				|	instruction path jumps to EA 			|
				|	if bit 0 of Accumulator a = 1			|
				|_______________________________________________________|


	assembler syntax	jao	jump_address[, {x|y|a|b|fp|sp}]
				jao	*jump_pointer

				_________________________________________________________
	Instruction Code 19.6	| 1 0 0 1 1 | 1 1 0 |		<a style="color:#00AF6F">  address</a>		|
				|___________|_______|___________________________________|




	<a	name="jae"/>
	Jump a Even	macro	jae
	___________		___

	Jump a Even is a 2-instruction macro which jumps to EA if Accumulator a low-order bit is zero
	Target address and assembly syntax are as <a href="#jao">Jump a Odd</a> instruction



	<a	name="jpa"/>
	Jump Positive a		jpa
	_______________		___

				_________________________________________________________
				|							|
				|	instruction path jumps to EA			|
				|	if bit 23 of accumulator a = 0			|
				|_______________________________________________________|


	assembler syntax	jpa	jump_address[, {x|y|a|b|fp|sp}]
				jpa	*jump_pointer

				_________________________________________________________
	Instruction Code 20.6	| 1 0 1 0 0 | 1 1 0 |		<a style="color:#00AF6F">  address</a>		|
				|___________|_______|___________________________________|





	<a	name="jpb"/>
	Jump Positive b		jpb
	_______________		___

				_________________________________________________________
				|							|
				|	instruction path jumps to EA			|
				|	if bit 23 of accumulator b = 0			|
				|_______________________________________________________|


	assembler syntax	jpb	jump_address[, {x|y|a|b|fp|sp}]
				jpb	*jump_pointer

				_________________________________________________________
	Instruction Code 21.6	| 1 0 1 0 1 | 1 1 0 |		<a style="color:#00AF6F">  address</a>		|
				|___________|_______|___________________________________|




	<a	name="j"/>
	Jump			j
	____			_

				_________________________________________________________
				|							|
				|	instruction path jumps to EA			|
				|_______________________________________________________|


	assembler syntax	j	jump_address[, {x|y|a|b|fp|sp}]
				j	*jump_pointer

				_________________________________________________________
	Instruction Code 22.6	| 1 0 1 1 0 | 1 1 0 |		<a style="color:#00AF6F">  address</a>		|
				|___________|_______|___________________________________|






	<a	name="jpo"/>
	Jump Parity Odd		jpo
	_______________		___

				_________________________________________________________
				|							|
				|	instruction path jumps to EA			|
				|   if parity (accumulator a AND mask register k) is odd|
				|_______________________________________________________|



	assembler syntax	jpo	jump_address[, {x|y|a|b|fp|sp}]
				jpo	*jump_pointer


				_________________________________________________________
	Instruction Code 23.6	| 1 0 1 1 1 | 1 1 0 |		<a style="color:#00AF6F">  address</a>		|
				|___________|_______|___________________________________|



	<a	name="jpe"/>
	Jump Parity Even	macro	jpe
	________________		___

	Jump Parity Even is a 2-instruction macro which jumps to EA if parity (accumulator a AND mask register k) is even
	Target address and assembly syntax are as <a href="#jpo">Jump Parity Odd</a> instruction


	<a	name="jza"/>
	Jump Zero a		jza
	___________		___
	
				_________________________________________________________
				|							|
				|	instruction path jumps EA			|
				|	if all bits of accumulator a are 0		|
				|_______________________________________________________|


	assembler syntax	jza	jump_address[, {x|y|a|b|fp|sp}]
				jza	*jump_pointer

				_________________________________________________________
	Instruction Code 24.6	| 1 1 0 0 0 | 1 1 0 |		<a style="color:#00AF6F">  address</a>		|
				|___________|_______|___________________________________|






	<a	name="jzb"/>
	Jump Zero b		jzb
	___________		___

				_________________________________________________________
				|							|
				|	instruction path jumps to EA			|
				|	if all bits of accumulator b are 0		|
				|_______________________________________________________|


	assembler syntax	jzb	jump_address[, {x|y|a|b|fp|sp}]
				jzb	*jump_pointer

				_________________________________________________________
	Instruction Code 25.6	| 1 1 0 0 1 | 1 1 0 |		<a style="color:#00AF6F">  address</a>		|
				|___________|_______|___________________________________|






	<a	name="jnza"/>
	Jump NonZero a		jnza
	______________		____
	
				_________________________________________________________
				|							|
				|	instruction path jumps to EA			|
				|	if any bits of accumulator a are 1		|
				|_______________________________________________________|

	assembler syntax	jnza	jump_address[, {x|y|a|b|fp|sp}]
				jnza	*jump_pointer

				_________________________________________________________
	Instruction Code 26.6	| 1 1 0 1 0 | 1 1 0 |		<a style="color:#00AF6F">  address</a>		|
				|___________|_______|___________________________________|






	<a	name="jnzb"/>
	Jump NonZero b		jnzb
	______________		____

				_________________________________________________________
				|							|
				|	instruction path jumps to EA			|
				|	if any bits of accumulator b are 1		|
				|_______________________________________________________|

	assembler syntax	jnzb	jump_address[, {x|y|a|b|fp|sp}]
				jnzb	*jump_pointer

				_________________________________________________________
	Instruction Code 27.6	| 1 1 0 1 1 | 1 1 0 |		<a style="color:#00AF6F">  address</a>		|
				|___________|_______|___________________________________|





	<a	name="jna"/>
	Jump Negative a		jna
	_______________		___
	
				_________________________________________________________
				|							|
				|	instruction path jumps to EA			|
				|	if bit 23 of accumulator a = 1			|
				|_______________________________________________________|

	assembler syntax	jna	jump_address[, {x|y|a|b|fp|sp}]
				jna	*jump_pointer

				_________________________________________________________
	Instruction Code 28.6	| 1 1 1 0 0 | 1 1 0 |		<a style="color:#00AF6F">  address</a>		|
				|___________|_______|___________________________________|





	<a	name="jnb"/>
	Jump Negative b		jnb
	_______________		___

				_________________________________________________________
				|							|
				|	instruction path jumps to EA			|
				|	if bit 23 of accumulator b = 1			|
				|_______________________________________________________|

	assembler syntax	jnb	jump_address[, {x|y|a|b|fp|sp}]
				jnb	*jump_pointer

				_________________________________________________________
	Instruction Code 29.6	| 1 1 1 0 1 | 1 1 0 |		<a style="color:#00AF6F">  address</a>		|
				|___________|_______|___________________________________|





	<a	name="jxge"/>
	Jump x Greater or Equal	jxge
	_______________________	___

				_________________________________________________________
				|							|
				|	instruction path jumps to EA unless		|
				|	index register x < limit pointer register r	|
				|_______________________________________________________|

	assembler syntax	jxge	jump_address[, {x|y|a|b|fp|sp}]
				jxge	*jump_pointer




				_________________________________________________________
	Instruction Code 30.6	| 1 1 1 1 0 | 1 1 0 |		<a style="color:#00AF6F">  address</a>		|
				|___________|_______|___________________________________|



	<a	name="jxl"/>
	Jump x Lower	macro	jxl
	____________		___

	Jump x Lower is a 2-instruction macro which jumps to EA if index register x < limit pointer register r
	Target address and assembly syntax are as instruction <a href="#jxge">Jump x Greater or Equal</a>




	<a	name="jyge"/>
	Jump y Greater or Equal	jyge
	_______________________	____

				_________________________________________________________
				|							|
				|	instruction path jumps to EA unless		|
				|	index register y < limit pointer register r	|
				|_______________________________________________________|

	assembler syntax	jyge	jump_address[, {x|y|a|b|fp|sp}]
				jyge	*jump_pointer


				_________________________________________________________
	Instruction Code 31.6	| 1 1 1 1 1 | 1 1 0 |		<a style="color:#00AF6F">  address</a>		|
				|___________|_______|___________________________________|


	<a	name="jyl"/>
	Jump y Lower	macro	jyl
	___________		___

	Jump y Lower is a 2-instruction macro which jumps to EA if index register y < limit pointer register r
	Target address and assembly syntax are as instruction <a href="#jyge">Jump y Greater or Equal</a>




	<a	name="jdz"/>
	Jump Double Zero	jdz
	________________	___

				_________________________________________________________
				|							|
				|	instruction path jumps to EA if all 48 bits 	|
				|	of accumulators a b are zero			|
				|_______________________________________________________|


	assembler syntax	jdz	jump_address[, {x|y|a|b|fp|sp}]
				jdz	*jump_pointer

				_________________________________________________________
	Instruction Code 15.4	| 0 1 1 1 1 | 1 0 0 |		<a style="color:#00AF6F">  address</a>		|
				|___________|_______|___________________________________|








	<a      name="modify"/>
	<div    style="margin-left:28pt;font-family:times-roman;font-size:12.75pt;color:0000FF">
	<i>3.6.13	Target Modify Instructions</i>
	</div>
	Eight instructions modify a single-word target operand

	The first modify instruction <a href="#ts">ts</a> operates on a storage operand not a register,
	and must execute atomically with storage lock

	The other seven modify instructions <a href="#n">n</a> <a href="#inc">inc</a> <a href="#dec">dec</a> <a href="#src">src</a> <a href="#slc">slc</a> <a href="#sim">sim</a> <a href="#popa">popA</a>
	can be usefully executed on registers or storage.
	Registers have no storage lock and are not shared between threads.
	It is not intended that <b>n inc dec src slc sim popA</b> instructions
	necessarily lock storage target operands or are used in arbitration



	<a	name="ts"/>
	Test and Set		ts
	____________		__

				_________________________________________________________
				|							|
				|	value at EA is atomically read and rewritten	|
				|	with value 1000 0000<sub>2</sub> in bits [ 23..16 ]		|
				|							|
				|	the next instruction is skipped if bit 23 was 0 |
				|	before the operation				|
				|_______________________________________________________|
				|	target operand is the storage word at EA	|
				|	and not a register. ts -> EA < 4096 faults	|
				|	because memory in window B0 may not be updated	|
				|_______________________________________________________|


					  23	 16		      0
					_________________________________
		operand word	before	| 0xxx xxxx xxxx xxxx xxxx xxxx	| -> skip one instructon
					|_______________________________|	
				after	| 1000 0000 xxxx xxxx xxxx xxxx	|
					|_______________________________|



					  23	 16		      0
					_________________________________
		operand word	before	| 1xxx xxxx xxxx xxxx xxxx xxxx	| -> skip no instruction
					|_______________________________|
				 after	| 1000 0000 xxxx xxxx xxxx xxxx	|
					|_______________________________|




	assembler		ts	lock_cell[, {x|y|a|b|fp|sp}]
	syntax/example		j	$-1

				ts	*pointer_to_lock_cell
				lcal	wait_and_try_again


				_________________________________________________________
	Instruction Code 0.7	| 0 0 0 0 0 | 1 1 1 |		<a style="color:#00AF6F">  address</a>		|
				|___________|_______|___________________________________|







	<a	name="n"/>
	Negate			n
	______			_

				_________________________________________________________
				|							|
				|	the value at EA is rewritten in ones complement	|
				|_______________________________________________________|
				|	target is the register or storage word at EA	|
				|_______________________________________________________|	



	assembler syntax	n	mantissa[, {x|y|a|b|fp|sp}]

				n	*pointer_to_switch



				_________________________________________________________
	Instruction Code 1.7	| 0 0 0 0 1 | 1 1 1 |		<a style="color:#00AF6F">  address</a>		|
				|___________|_______|___________________________________|







	<a	name="inc"/>
	Increment		inc
	_________		___

				_________________________________________________________
				|							|
				|	+1 is added to the 24-bit value at EA		|
				|	 <a href="#nonar">carry$</a> is not affected				|
				|_______________________________________________________|
				|	target is the register or storage word at EA	|
				|_______________________________________________________|	



	assembler syntax	inc	tally[, {x|y|a|b|fp|sp}]

				inc	*pointer2uptozerocounter



				_________________________________________________________
	Instruction Code 2.7	| 0 0 0 1 0 | 1 1 1 |		<a style="color:#00AF6F">  address</a>		|
				|___________|_______|___________________________________|






	<a	name="dec"/>
	Decrement		dec
	_________		___

				_________________________________________________________
				|							|
				|	-1 is added to the 24-bit value at EA		|
				|	<a href="#nonar">carry$</a> is not affected				|
				|_______________________________________________________|
				|	target is the register or storage word at EA	|
				|_______________________________________________________|	



	assembler syntax	dec	counter[, {x|y|a|b|fp|sp}]

				dec	*pointer_to_counter



				_________________________________________________________
	Instruction Code 3.7	| 0 0 0 1 1 | 1 1 1 |		<a style="color:#00AF6F">  address</a>		|
				|___________|_______|___________________________________|






	<a	name="sim"/>
	Switch Interrupt Mask	sim
	_____________________	___

				_________________________________________________________
				|							|
				|	interrupt mask from PSR bits 18..16 is switched	|
				|	with the word at EA. Bits 23..3 of the storage	|
				|	word are dropped on read and zero on write	|
				|_______________________________________________________|
				|	PSR		I000 0iii 0xxx xxxx Hyyy 000C	|
				|_______________________________________________________|
				|	storage		0000 0000 0000 0000 0000 0iii	|
				|_______________________________________________________|
				|	target is the register or storage word at EA	|
				|_______________________________________________________|	




	assembler syntax	sim	aside_location[, {x|y|a|b|fp|sp}]

				sim	*pointer_to_imask_save


	assembler example	push	MAXIMUM_IMASK,,xi
				sim	0, sp
				.
				.
				sim	0, sp
				inc	sp


				_________________________________________________________
	Instruction Code 4.7	| 0 0 1 0 0 | 1 1 1 |		<a style="color:#00AF6F">  address</a>		|
				|___________|_______|___________________________________|





	<a	name="popa"/>
	Pop and AddTo		popA
	_____________		____

				_________________________________________________________
				|							|
				|	the value at the internal stack top is added to |
				|	the word at EA. <a href="#nonar">carry$</a> = the carry out of bit 23|
				|	of the addition. sp is incremented		|
				|							|
                                |       on internal stack overflow / underflow		|
                                |       [sp < 24 | sp > 127] before operation           |
                                |       guard interrupt 95 is raised                    |
                                |                                                       |
				|_______________________________________________________|
				|	target is the register or storage word at EA	|
				|_______________________________________________________|	



	assembler syntax	popA	storage_total[, {x|y|a|b|fp|sp}]

				popA	*pointer_to_storage_total



				_________________________________________________________
	Instruction Code 5.7	| 0 0 1 0 1 | 1 1 1 |		<a style="color:#00AF6F">  address</a>		|
				|___________|_______|___________________________________|






	<a	name="src"/>
	Shift Right through Carry	src
	_________________________	___

				_________________________________________________________
				|							|
				|	the word at EA and <a href="#nonar">carry$</a> are rotated in	|
				|	a 25-bit ring rightwards one bit position	|
				|_______________________________________________________|
				|	target is the register or storage word at EA	|
				|_______________________________________________________|	



	assembler syntax	src	rounding_overflow[, {x|y|a|b|fp|sp}]

				src	*bit_race_indirectly



				_________________________________________________________
	Instruction Code 6.7	| 0 0 1 1 0 | 1 1 1 |		<a style="color:#00AF6F">  address</a>		|
				|___________|_______|___________________________________|





	<a	name="slc"/>
	Shift Left through Carry	slc
	________________________	___

				_________________________________________________________
				|							|
				|	the word at EA and <a href="#nonar">carry$</a> are rotated in 	|
				|	a 25-bit ring leftwards one bit position	|
				|_______________________________________________________|
				|	target is the register or storage word at EA	|
				|_______________________________________________________|	



	assembler syntax	slc	attention_flags[, {x|y|a|b|fp|sp}]

				slc	*pointer_to_ring



				_________________________________________________________
	Instruction Code 7.7	| 0 0 1 1 1 | 1 1 1 |		<a style="color:#00AF6F">  address</a>		|
				|___________|_______|___________________________________|



	<a      name="scala"/>
	<div    style="margin-left:28pt;font-family:times-roman;font-size:12.75pt;color:0000FF">
	<i>3.6.14	Double and Quadword Load and Store, Masked, Execute and Scale Operations, Large Integer Arithmetic</i>
	</div>
	Large integer operations have a source or target operand of one, two or four registers or storage words


	instructions		<a href="#ds">Double Store</a>			<a href="#dl">Double Load</a>
				<a href="#dpop">Double Pop (macro)</a>		<a href="#dpush">Double Push</a>

				<a href="#qs">Quadruple Store</a>			<a href="#ql">Quadruple Load</a>
				<a href="#qpop">Quadruple Pop</a>			<a href="#qpush">Quadruple Push</a>

				<a href="#mta">Masked Test Equal a</a>		<a href="#mta">Masked Test Not Equal a (macro)</a>
				<a href="#dte">Double Test Equal</a>		<a href="#mlb">Masked Load B</a>

				<a href="#da">Double Add</a> 			<a href="#dan">Double Add Negative</a>
				<a href="#sc">Store Carry</a>
				<a href="#lsc">Load Shift and Count</a> 		<a href="#dlsc">Double Load Shift and Count</a>

				<a href="#ex">Execute</a>				<a href="#rex">Repeat Execute</a>

	<a	name="qs"/>
	Quadruple Store		qs
	_______________		__

				_________________________________________________________
				|							|
				|	4 accumulators					|
				|	a b mantissa2 mantissa3	are stored to EA	|
				|							|
				|		a  is stored at register / storage EA	|
				|		b  is stored at register / storage EA+1	|
				|	mantissa2  is stored at register / storage EA+2	|
				|	mantissa3  is stored at register / storage EA+3	|
				|_______________________________________________________|
				|	target is four registers or storage words at EA	|
				|	EA is any word address				|
				|_______________________________________________________|



	assembler syntax	qs	sum[, {x|y|a|b|fp|sp}]

				qs	*pointer_to_sum



				_________________________________________________________
	Instruction Code 8.7	| 0 1 0 0 0 | 1 1 1 |		<a style="color:#00AF6F">  address</a>		|
				|___________|_______|___________________________________|







	<a	name="ql"/>
	Quadruple Load		ql
	______________		__

				_________________________________________________________
				|							|
				|	a 96-bit value at EA is loaded to		|
				|	4 accumulators a b mantissa2 mantissa3		|
				|							|
				|	register / storage at EA   loads to a		|
				|	register / storage at EA+1 loads to b		|
				|	register / storage at EA+2 loads to mantissa2	|
				|	register / storage at EA+3 loads to mantissa3	|
				|_______________________________________________________|
				|	source is four registers or storage words at EA	|
				|	EA is any word address				|
				|_______________________________________________________|



	assembler syntax	ql	sum[, {x|y|a|b|fp|sp}]

				ql	*pointer_to_sum

				ql	(250600004700003450.630*+1262001)


				_________________________________________________________
	Instruction Code 9.7	| 0 1 0 0 1 | 1 1 1 |		<a style="color:#00AF6F">  address</a>		|
				|___________|_______|___________________________________|




	<a	name="qpop"/>
	Quadruple Pop		qpop
	_____________		____

				_________________________________________________________
				|							|
				|	four words are stored				|
				|	from the internal stack top			|
				|	store order is as stack order 	0, sp -> EA	|
				|					1, sp -> EA+1	|
				|					2, sp -> EA+2	|
				|					3, sp -> EA+3	|
				|							|
				|	internal stack pointer sp is incremented by 4	|
				|							|
                                |       on internal stack overflow / underflow		|
                                |       [sp < 24 | sp > 124] before operation           |
                                |       guard interrupt 95 is raised                    |
				|							|
				|_______________________________________________________|
				|	target is four registers or storage words at EA	|
				|	EA is any word address				|
				|_______________________________________________________|



	assembler syntax	qpop	buffer[, {x|y|a|b|fp|sp}]

				qpop	*pointer_to_buffer



				_________________________________________________________
	Instruction Code 16.7	| 1 0 0 0 0 | 1 1 1 |		<a style="color:#00AF6F">  address</a>		|
				|___________|_______|___________________________________|








	<a	name="qpush"/>
	Quadruple Push		qpush
	______________		_____

				_________________________________________________________
				|							|
				|	internal stack pointer sp is decremented by 4	|
				|							|
				|	a 96-bit value at EA is read to the internal	|
				|	stack top at [sp]				|
				|							|
				|	the word read from EA is at the stack top  0,sp	|
				|	the word read from EA+1 is at stack top+1  1,sp	|
				|	the word read from EA+2 is at stack top+2  2,sp	|
				|	the word read from EA+3 is at stack top+3  3,sp	|
				|							|
                                |       on internal stack overflow / underflow		|
                                |       [sp < 28 | sp > 128] before operation           |
                                |       guard interrupt 95 is raised                    |
                                |                                                       |
				|_______________________________________________________|
				|	source is four registers or storage words at EA	|
				|	EA is any word address				|
				|_______________________________________________________|




	assembler syntax	qpush	buffer[, {x|y|a|b|fp|sp}]

				qpush	*pointer_to_buffer

				qpush	(623600004700003450.630*+1262001)


				_________________________________________________________
	Instruction Code 17.7	| 1 0 0 0 1 | 1 1 1 |		<a style="color:#00AF6F">  address</a>		|
				|___________|_______|___________________________________|








	<a	name="ex"/>
	Execute			ex
	_______			__

				_________________________________________________________
				|							|
				|	a data word is read from memory, decoded	|
				|	and executed as an instruction			|
				|							|
				|	if the target instruction is not a jump, call,  |
				|	skip or	interrupt, execution continues at the	|
				|	instruction after the execute instruction	|
				|							|
				|	if the target instruction decides to jump, call,|
				|	skip or interrupt, execution continues at the	|
				|	jump target. If the target instruction is a call|
				|	or interrupt, return is to the instruction	|
				|	after the execute instruction			|
				|_______________________________________________________|
				|	execute target is the storage word at EA	|
				|	and not a register				|
				|	operand address < 256 resolves to a location in	|
				|	current B0 memory block				|
				|_______________________________________________________|



	assembler syntax	ex	instruction[, {x|y|a|b|fp|sp}]

				ex	*instruction_indirectly


	assembler example


		next_column	jxge		frame_scanned
				ex		key_difference, x
				ax, xi		1
				and, xi		4095
				aa		crc12_table_pointer
				la		0, a
				j		next_column


		key_difference
		column		$do		ARRAY_LIMIT,    ;
				xor		frame+(column-1)/2, b, h1+(column-1)///2

		........................................................................

				lx		bytes
				lb, xi		0
				on		b$streamZR

		next_digit	rsr		BYTE
				ax, xi		-1
				ex		raise,x 
				tz		x
				j		next_digit

				

		raise		ab		units-'0', a
				ab		tens-'0', a
				ab		hundreds-'0', a
				ab		thousands-'0', a
				ab		ten_thousands-'0', a
				ab		hundred_thousands-'0', a



					


				_________________________________________________________
	Instruction Code 18.7	| 1 0 0 1 0 | 1 1 1 |		<a style="color:#00AF6F">  address</a>		|
				|___________|_______|___________________________________|




	<a	name="rex"/>
	Repeat Execute		rex
	______________		___

	_________________________________________________________________________________
	|										|
	|_______________________________________________________________________________|
	|										|
	|	repeat execute iterates a single operation on tabled information	|
	|	multiple times on multiple data points					|
	|										|
        |	the storage operand of rex instruction is an instruction constant	|
        |										|
        |		rex	(fm	array, x)					|
        |                                                                               |
        |	operations are either							|
	|										|
	|		integer and floating instructions				|
	|		in up to 104 internal stack registers as accumulators		|
	|		second operand via effective address&plusmn;&plusmn; of repeated instruction	|
	|										|
	|		<a style="color:#00AF6F" href="#fa">fa</a>	<a style="color:#00AF6F" href="#fan">fan</a>	<a style="color:#00AF6F" href="#fm">fm</a>	<a style="color:#00AF6F" href="#fd">fd</a>					|
	|										|
	|		<a style="color:#00AF6F" href="#aa">aa</a>	<a style="color:#00AF6F" href="#ana">ana</a>	<a style="color:#00AF6F" href="#or">or</a>	<a style="color:#00AF6F" href="#and">and</a>	<a style="color:#00AF6F" href="#xor">xor</a>				|
	|		<a style="color:#00AF6F" href="#sar">sar</a>	<a style="color:#00AF6F" href="#sal">sal</a>	<a style="color:#00AF6F" href="#rar">rar</a>	<a style="color:#00AF6F" href="#ral">ral</a>	<a style="color:#00AF6F" href="#saa">saa</a>				|
	|										|
	|		<a style="color:#00AF6F" href="#ab">ab</a>	<a style="color:#00AF6F" href="#anb">anb</a>	<a style="color:#00AF6F" href="#orB">orB</a>	<a style="color:#00AF6F" href="#andB">andB</a>	<a style="color:#00AF6F" href="#xorB">xorB</a>				|
	|		<a style="color:#00AF6F" href="#sbr">sbr</a>	<a style="color:#00AF6F" href="#sbl">sbl</a>	<a style="color:#00AF6F" href="#rbr">rbr</a>	<a style="color:#00AF6F" href="#rbl">rbl</a>	<a style="color:#00AF6F" href="#sba">sba</a>				|
	|										|
	|		<a style="color:#00AF6F" href="#da">da</a>	<a style="color:#00AF6F" href="#dan">dan</a>	<a style="color:#00AF6F" href="#m">m</a>	<a style="color:#00AF6F" href="#mf">mf</a>	<a style="color:#00AF6F" href="#d">d</a>				|
	|		<a style="color:#00AF6F" href="#dsr">dsr</a>	<a style="color:#00AF6F" href="#dsl">dsl</a>	<a style="color:#00AF6F" href="#drr">drr</a>	<a style="color:#00AF6F" href="#drl">drl</a>	<a style="color:#00AF6F" href="#dsa">dsa</a>				|
	|										|
	|		<a style="color:#00AF6F" href="#sa">sa</a>	<a style="color:#00AF6F" href="#sb">sb</a>	<a style="color:#00AF6F" href="#la">la</a>	<a style="color:#00AF6F" href="#lb">lb</a>					|
	|		<a style="color:#00AF6F" href="#ds">ds</a>	<a style="color:#00AF6F" href="#dl">dl</a>	<a style="color:#00AF6F" href="#qs">qs</a>	<a style="color:#00AF6F" href="#ql">ql</a>					|						
	|										|
	|	or 	they are searches based on successive test and skip operations	|
	|		on tables of any size in registers or storage			|
	|										|
	|		<a style="color:#00AF6F" href="#tz">tz</a>	<a style="color:#00AF6F" href="#tp">tp</a>	<a style="color:#00AF6F" href="#mta">mta</a>	<a style="color:#00AF6F" href="#dte">dte</a>					|
	|										|
	|	operands obtained by effective address may be				|
	|	at scattered locations in storage					|
	|										|
	|	the number and address intervals of array operations is configured	|
	|	and self-reconfiguring in four registers at addresses 20..23 which	|
	|	are also bit-stream staging registers					|
	|	<a	name="rex_regs"/>									|
	|	registers 20..23 [ RDATAC RDATA WDATAC WDATA ]				|
	|	are programmed for repeat execute with macro SIMD_CONTROL		|
	|										|
	|	RDATAC is repeat final count and may start at count-expired value -1	|
	|	to trip initialisation of accumulator vector and restart final count	|
	|										|
	|		SIMD_CONTROL	(-1, <a href="#size" style="color:#00AF6F">SIZE</a>, OBJECTS-1, <a href="#distance" style="color:#00AF6F">DISTANCE</a>:q)		|
	|										|
	|			<a style="color:#00AF6F">. q here means a 4-word literal -------^</a>		|
	|			<a style="color:#00AF6F">. and has nothing to do with SIMD accumulator vector</a>	|
	|										|
        |       if final count is (-1 = expired) at start of rex instruction		|
	|	  accumulator vector q is initialised to internal stack pointer sp	|
	|	  and final count is restarted to OBJECTS-1 <a href="#sim_d2"style="color:#00AF6F"> diagram and description</a>	|
	|										|
	|	operation increments accumulator vector q by <a href="#size" style="color:#00AF6F">SIZE</a> and the		|
        |       effective address by <a href="#distance" style="color:#00AF6F">DISTANCE</a> until final count again reaches -1	|
        |                                                       			|
        |       SIMD_CONTROL does need to be iterated except to change SIMD parameters 	|
	|										|
	|	repeat operations stop at final count expiry and reconfigure at next	|
        |       rex instruction which encounters expired final count in RDATAC     	|
	|										|
	|	<a name="size" style="color:#00AF6F">SIZE</a> is the increment to accumulator vector q, normally the number of 	|
	|	registers used in the repeated operation: for floating operations	|
	|	four registers and for integer operations one, two, or when storing	|
	|	remainders of division, three registers					|
	|										|
	|	SIZE is zero if repeat operations target one internal stack accumulator	|
	|	or in <a href="#A2_5" style="color:#00AF6F">test and skip</a> operations which use no internal stack accumulators	|
	|										|
	|	________________________________________________________________________|
	|	|	<a name="rex_lane"/>								|
	|	|	SIZE may be 2 for 1-word operands treated in left /right pairs	|
	|	|	because repeated instructions notionally operating accumulator a|
	|	|									|	
	|	|		<a style="color:#00AF6F">aa ana or and xor accumulator a shifts la sa</a>		|
	|	|									|		_________________________
	|	|	operate in a left lane of registers at vector  [q] --------------------------->	|    register lane A	|
	|	|									|		|_______________________|
	|	|	and repeated instructions notionally accumulator b		|	------>	|    register lane B	|
	|	|									|	|	|_______________________|
	|	|		<a style="color:#00AF6F">ab anb orB andB xorB accumulator b shifts lb sb</a>		|	|	.		   A	.
	|	|									|	|	.........................
	|	|	operate in a right lane of registers at vector [q + 1] -----------------	.		   B	.
	|	|									|		.........................
	|	|		SIMD_CONTROL	(-1, 2, 50-1, 0q)			|		.		   A	.
	|	|									|		.........................
	|	|				. 50 register pairs			|		.		   B	.
	|	|									|
	|	|		rex		(xor	(KEY_CONSTANT_LEFT))		|
	|	|		rex		(xorB	(KEY_CONSTANT_RIGHT))		|
	|	|_______________________________________________________________________|
	|										|
	|										|
	|	<a name="distance" style="color:#00AF6F">DISTANCE</a> is the increment to any index register in an effective address	|
	|										|
	|	this is often the size of a repeated structure containing the operand	|
	|										|
	|		SIMD_CONTROL	(-1, 4, 25, 12q)				|
	|										|
	|			. 25 * 12-word structure, floating number at offset 8	|
	|			. data point 1 / dest 25 * 4 internal stack registers	|
	|										|
	|		lx		table,,xi					|
	|	  	rex		(fa	8, x)					|
	|										|
	|	[ RDATAC RDATA WDATAC WDATA ] are not volatile to the application thread|
	|										|
	|	threads are started with a default SIMD_CONTROL value			|
	|										|
	|		SIMD_CONTROL	(-1, 0, 0, 0q)					|		
	|										|
	|	this allows the application to have a <a href="rta.html#A2_2">alternative accumulators</a>	|
	|	at the internal stack top by constructing a SIMD array one object deep	|
	|_______________________________________________________________________________|



	diagrams and assembly language examples are at <a href="#sim_d" style="color:#00AF6F">Appendix A: SIMD and Instruction Repeat</a>


				_________________________________________________________
	instruction code 14.4	| 0 1 1 1 0 | 1 0 0 |	<a style="color:#00AF6F">ea -> instruction for repeat</a>	|
				|___________|_______|___________________________________|




				
	<a	name="dpop"/>
	Double Pop	macro	dpop
	_________		____

	Double Pop is a 2-instruction macro which pops two words from the internal stack top to registers or storage

				_________________________________________________________
				|	two words are stored at EA from the registers	|
				|	at the internal stack top			|
				|	internal stack pointer sp is incremented by 2	|
				|							|
				|		*sp++ is stored at EA			|
				|	   next *sp++ is stored at EA+1			|
				|							|
				|	if [sp < 24 | sp > 126] before operation	|
				|	guard interrupt 96 is raised			|
				|							|
				|_______________________________________________________|
				|	target is two registers or storage words at EA	|
				|	EA is any word address				|
				|_______________________________________________________|


	assembler syntax	dpop	store_target[, {x|y|a|b|fp|sp}]

				dpop	*store_target_indirectly

	assembler_example

		?		do	STRUCTURES_IN_TABLE,	dpop	table+CONTAINER_SIZE*?-CONTAINER_SIZE+OFFSET_IN_CONTAINER






	<a	name="dpush"/>
	Double Push		dpush
	___________		_____

				_________________________________________________________
				|							|
				|	internal stack pointer sp is decremented by 2	|
				|	a 48-bit value at EA is loaed to the		|
				|	internal stack top at [sp]			|
				|							|
				|	the word read from EA is at the stack top  0,sp	|
				|	the word read from EA+1 is at stack top+1  1,sp	|
				|							|
                                |       on internal stack overflow / underflow		|
                                |       [sp < 26 | sp > 128] before operation           |
                                |       guard interrupt 95 is raised                    |
                                |                                                       |
				|_______________________________________________________|
				|	source is two registers or storage words at EA 	|
				|	EA is any word address				|
				|_______________________________________________________|



	assembler syntax	dpush	preload48[, {x|y|a|b|fp|sp}]

				dpush	*preload48_indirectly

				dpush	(258000000000000:d)



				_________________________________________________________
	Instruction Code 19.7	| 1 0 0 1 1 | 1 1 1 |		<a style="color:#00AF6F">  address</a>		|
				|___________|_______|___________________________________|








	<a	name="lsc"/>
	Load Shift and Count	lsc
	____________________	___

				_________________________________________________________
				|							|
				|	a value at EA is retrieved, rotated to scale	|
				|	and stored in Accumulator a			|
				|							|
				|	the value is rotated left counting		|
				|	until bit 23 changes or the count reaches 24	|
				|							|
				|	the shift count is stored in accumulator b	|
				|							|
				|_______________________________________________________|
				|	source is the register or storage word at EA	|
				|_______________________________________________________|




	assembler syntax	lsc	short_mantissa[, {x|y|a|b|fp|sp}]

				lsc	*short_mantissa_indirectly



				_________________________________________________________
	Instruction Code 20.7	| 1 0 1 0 0 | 1 1 1 |		<a style="color:#00AF6F">  address</a>		|
				|___________|_______|___________________________________|







	<a	name="mta"/>
	Masked Test Equal a	mta
	___________________	___

				_________________________________________________________
				|							|
				|	the next instruction is skipped  if		|
				|	(accumulator a AND mask register k) equals		|
				|	(register / storage at EA) AND mask register k 	|
				|_______________________________________________________|
				|	comparand is register or storage word at EA	|
				|_______________________________________________________|
				|	<a href="#rex_mta">repeat execute</a> instruction			|
				|	can iterate mta instruction as a search		|
				|_______________________________________________________|


	assembler syntax	mta	comparand[, {x|y|a|b|fp|sp}]

				mta	*comparand_indirectly


	assembler_example	lk	(0FFFF00:s)
				mta	(00D0A00:s)
				j	not_cr_lf



				_________________________________________________________
	Instruction Code 21.7	| 1 0 1 0 1 | 1 1 1 |		<a style="color:#00AF6F">  address</a>		|
				|___________|_______|___________________________________|



	<a	name="mtane"/>
	Masked Test Not Equal a		macro	mtane
	_______________________			_____

	Masked Test Not Equal a	is a 2-instruction macro which skips the next instruction
	if (accumulator a AND mask register k) is unequal to (operand AND k)

	Operand type and assembly syntax are as <a href="#mta">Masked Test Equal a</a> 
	


	<a	name="dte"/>
	Double Test Equal ab	dte
	____________________	___

				_________________________________________________________
				|							|
				|	the next instruction is skipped
				|	if accumulators a b = 2 operand words		|
				|							|
				|	a is compared with register or storage at EA	|
				|	b is compared with register or storage ar EA+1	|
				|_______________________________________________________|
				|	<a href="#rex_dte">repeat execute</a> instruction			|
				|	can iterate dte instruction as a search		|
				|_______________________________________________________|


	assembler syntax	dte	comparand[, {x|y|a|b|fp|sp}]

				dte	*comparand_indirectly



	assembler example	dl	key_48bits
				dte	storage
				j	not_equal
				j	equal

				_________________________________________________________
	instruction code 10.7	| 0 1 0 1 0 | 1 1 1 |		<a style="color:#00AF6F">  address</a>		|
				|___________|_______|___________________________________|




	<a	name="sc"/>
	Store Carry		sc
	___________		__

				_________________________________________________________
				|							|
				|	<a href="#nonar">Processor State Register</a> AND 1 is stored	|
				|	at the target register / storage word		|
				|_______________________________________________________|
				|	target is the register or storage word at EA	|
				|_______________________________________________________|



	assembler syntax	sc	next_add_word[, {x|y|a|b|fp|sp}]

				sc	*pointer_to_next_add_word



				_________________________________________________________
	Instruction Code 22.7	| 1 0 1 1 0 | 1 1 1 |		<a style="color:#00AF6F">  address</a>		|
				|___________|_______|___________________________________|








	<a	name="mlb"/>
	Masked Load b		mlb
	_____________		___

				_________________________________________________________
				|							|
				|	accumulator b is loaded with	 		|
				|	   (register / storage AND mask register k)	|
				|	OR (b AND (NOT mask register k))		|
				|_______________________________________________________|
				|	source is the register or storage word at EA	|
				|_______________________________________________________|



	assembler syntax	mlb	word2merge[, {x|y|a|b|fp|sp}]

				mlb	*pointer_to_word2merge



				_________________________________________________________
	Instruction Code 23.7	| 1 0 1 1 1 | 1 1 1 |		<a style="color:#00AF6F">  address</a>		|
				|___________|_______|___________________________________|







	<a	name="ds"/>
	Double Store		ds
	____________		__

				_________________________________________________________
				|							|
				|	the 48-bit value in accumulators a b		|
				|	is stored at EA					|
				|							|
				|	accumulator a is stored at EA			|
				|	accumulator b is stored at EA+1			|
				|_______________________________________________________|
				|	target is two registers or storage words at EA	|
				|	EA is any word address				|
				|_______________________________________________________|




	assembler syntax	ds	destination48[, {x|y|a|b|fp|sp}]

				ds	*pointer_to_destination48



				_________________________________________________________
	Instruction Code 24.7	| 1 1 0 0 0 | 1 1 1 |		<a style="color:#00AF6F">  address</a>		|
				|___________|_______|___________________________________|







	<a	name="dl"/>
	Double Load		dl
	___________		__

				_________________________________________________________
				|							|
				|	a 48-bit value is loaded from EA		|
				|	to accumulators a b				|
				|							|
				|	the word at EA is loaded to accumulator a	|
				|	the word at EA+1 is loaded to accumulator b	|
				|_______________________________________________________|
				|	source is two registers or storage words at EA	|
				|	EA is any word address				|
				|_______________________________________________________|




	assembler syntax	dl	from48[, {x|y|a|b|fp|sp}]

				dl	*pointer_to_from48

				dl	(258000000000000:d)


				_________________________________________________________
	Instruction Code 25.7	| 1 1 0 0 1 | 1 1 1 |		<a style="color:#00AF6F">  address</a>		|
				|___________|_______|___________________________________|







	<a	name="da"/>
	Double Add		da
	__________		__

				_________________________________________________________
				|							|
				|	a 48-bit integer at EA is added to		|
				|	accumulators a b				|
				|							|
				|	the word at EA contains high-order bits 47..24	|
				| 	of the addend					|
				|							|
				|	the word at EA+1 contains low-order bits 23..0	|
				|	of the addend					|
				|							|
				|	<a href="#nonar">carry$</a> = the carry from bit 47 of the addition	|
				|_______________________________________________________|
				|	2nd addend is 2 registers or storage words at EA|
				|	EA is any word address				|
				|_______________________________________________________|



	assembler syntax	da	addend48[, {x|y|a|b|fp|sp}]

				da	*addend48_indirectly

				da	(-120000000000000)

				_________________________________________________________
	Instruction Code 26.7	| 1 1 0 1 0 | 1 1 1 |		<a style="color:#00AF6F">  address</a>		|
				|___________|_______|___________________________________|







	<a	name="dan"/>
	Double Add Negative	dan
	__________________	___

				_________________________________________________________
				|							|
				|	the 2s complement of a 48-bit integer at EA 	|
				|	is added to accumulators a and b		|
				|							|
				|	the word at EA contains high-order bits 47..24	|
				| 	of the subtrahend				|
				|							|
				|	the word at EA+1 contains low-order bits 23..0	|
				|	of the subtrahend				|
				|							|
				|	<a href="#nonar">carry$</a> = the carry from bit 47 of the addition	|
				|_______________________________________________________|
				|	subtrahend is 2 registers or storage words at EA|
				|	EA is any word address				|
				|_______________________________________________________|



	assembler syntax	dan	subtrahend48[, {x|y|a|b|fp|sp}]

				dan	*subtrahend48_indirectly

				dan	(120000000000000)


				_________________________________________________________
	Instruction Code 27.7	| 1 1 0 1 1 | 1 1 1 |		<a style="color:#00AF6F">  address</a>		|
				|___________|_______|___________________________________|







	<a	name="dlsc"/>
	Double Load Shift and Count	dlsc
	___________________________	____

				_________________________________________________________
				|							|
				|	2 words read from EA are rotated to scale	|
				|	and stored in accumulators a b			|
				|							|
				|	48-bit value is rotated left counting		|
				|	until bit 47 changes or the count reaches 48	|
				|							|
				|	shift count is stored in accumulator  mantissa2	|
				|							|
				|_______________________________________________________|
				|	source is two registers or storage words at EA	|
				|	EA is any word address				|
				|_______________________________________________________|



	assembler syntax	dlsc	mantissa[, {x|y|a|b|fp|sp}]

				dlsc	*mantissa_indirectly


				_________________________________________________________
	Instruction Code 28.7	| 1 1 1 0 0 | 1 1 1 |		<a style="color:#00AF6F">  address</a>		|
				|___________|_______|___________________________________|











        <a      name="fp"/>
        <div    style="margin-left:28pt;font-family:times-roman;font-size:12.75pt;color:0000FF">
        <i>3.6.15       <a href="#fp96">96-bit</a> and <a href="#fp192">192-bit</a> Floating Point, <a href="#fpround">Rounding Setting</a>, <a href="#fpoflo">Exponent Underflow and Overflow Handling</a>, <a href="#fpcompress">Floating 48-Bit Compression</a></i>
        </div>
	instructions	<a href="#fa">Floating Add</a>			<a href="#fm">Floating Multiply</a>
			<a href="#fan">Floating Add Negative</a>		<a href="#fd">Floating Divide</a>


	<div	style="font-size:11pt"><a name="fp96"/>
	_________________________________________________________________________________________________________________
	|														|
	|														|
	|	The 96-bit Floating Architecture									|
	|_______________________________________________________________________________________________________________|
	|														|
	|														|
	|	RTA1 floating arithemetic is ones complement								|
	|	Sign bit 95 = 1 indicates that all 96 bits are inverse to the positive magnitude of the number		|
	|														|
	|	RTA1 has four floating operation instructions								|
	|														|
	|	Four consecutive computer words form a 96-bit floating number						|
	|														|
	|	the 72-bit mantissa is a simple fraction in bits 71..0							|
	|														|
	|	The mantissa has no integer part either represented or unrepresented					|
	|														|
	|	The binary point is between the normalising bit 71 and the characteristic field in bits 94..72 		|
	|														|
	|	An integer value is obtained by hauling the mantissa upwards through the binary point by the number	|
	|	of shift positions with which the characteristic exceeds the midpoint value of 400000 hexadecimal	|
	|														|
	|	The midpointed 23-bit characteristic covers the range of decimal exponents -1262611 to +1262611		|
	|														|
	|	A characteristic of zero expresses the lowest possible exponent						|
	|														|
	|	A characteristic at midpoint 400000 expresses the zero exponent. The normalised number is >= 0.5 and < 1|
	|														|
	|	A maximum characteristic 7FFFFF expresses the highest possible exponent					|
	|														|
	|	A number is normalised if bit 71 is different from sign bit 95						|
	|														|
	|	All unnormalised numbers have the algebraic value of zero						|
	|														|
	|_______________________________________________________________________________________________________________|
	|	<a name="fpround"/>													|
	|														|
	|	Rounding Setting											|
	|_______________________________________________________________________________________________________________|
	|														|
	|	Rounding is determined by the pattern of high-order bits in register <b>fp$guard</b> at address 147		|
	|	(hex 93). <b>fp$guard</b> can only be written by interrupt code. Prototype kernel smaragd7 assigns a	 	|
	|	default value C00000 hex to <b>fp$guard</b> for every thread. <b>fp$guard</b> value is part of thread			|
	|	context and each thread may change its value with the system call					|
	|														|
	|			la	(<i>NEW_PATTERN</i>)									|
	|			ii	FP_GUARD$									|
	|														|
	|	This system call returns the rounding pattern from before in application accumulator a			|
	|														|
	|														|
	|														|
	|														|
	|														|
	|	The format of an RTA1 floating number									|
	|	_____________________________________									|
	|														|
	|	95  94			 71								       0	|
	|	_________________________________________________________________________________________________	|
	|	|s|    characteristic	|				mantissa				|	|
	|	|_|_____________________|_______________________________________________________________________|	|
	|														|
	|														|
	|														|
	|_______________________________________________________________________________________________________________|
	|	<a name="fp192"/>													|
	|														|
	|	192-Bit Floating Point		see also <a style="color:FFFFFF;background-color:#0000FF;border-radius:5px;font-size:14pt" href="#simd_fp">192-Bit Single-Instruction Floating Point in SIMD</a>	|
	|_______________________________________________________________________________________________________________|
	|														|
	|														|
	|	PSR Flag <b>fp$r</b> signals floating instructions to store a minor result in accumulators 8..11		|
	|	giving this overall format in the eight accumulators a:b:mantissa2:mantissa3::8:9:10:11			|
	|														|
	|														|
	|      191|190			 167								      96	|
	|	__|______________________________________________________________________________________________	|
	|	|s|	characteristic	|				mantissa				|	|
	|	|_|_____________________|_______________________________________________________________________|	|
	|	|s|	characteristic	|				mantissa				|	|
	|	|_|_____________________|_______________________________________________________________________|	|
	|	95 94			 71								       0	|
	|														|
	|	The minor characteristic (exponent) is the major characteristic minus 72				|
	|	minus the normalising count of the minor mantissa							|
	|														|
	|	If the minor mantissa cannot be normalised because it is either positive zero or negative zero then 	|
	|	the minor result characteristic is all signs and the algebraic value of the minor result is zero	|
	|														|
	|	The minor mantissa is used in further operations to determine the low-order part 			|
	|	of 192-bit floating values										|
	|														|
	|	If a minor result is stored in registers 8..11 in compliance with <b>fp$r</b> then rounding per		|
	|	guard pattern register <b>fp$guard</b> takes place on the minor result and not the major result		|
	|														|
	|_______________________________________________________________________________________________________________|
	|	<a name="fpoflo"/>													|
	|														|
	|	Exponent Underflow and Overflow Handling								|
	|		see also <a style="color:FFFFFF;background-color:#0000FF;border-radius:5px;font-size:14pt" href="#simd_resume">Resuming a SIMD Sequence of Floating Operations after Fault Handling</a>	|
	|_______________________________________________________________________________________________________________|
	|														|
	|														|
	|	If a floating point operation borrows or carries from the 23-bit exponent field, a true	result		|
	|	is not stored. These conditions are called exponent underflow and exponent overflow			|
	|														|
	|	Interrupt FP_XPO$ is raised and OR-sums the event in the thread control block				|
	|														|
	|	Applications may check that no underflow/overflow has happened with call FP_XPO$FLAG <a href="kernel.html#fp_xpo_flag_ii">FP_XPO$FLAG</a>	|
	|	at any time after exponent underflow/overflow may have been raised					|
	|														|
	|	service call ii FP_XPO$FLAG :										|
	|														|
	|		returns + 1 instruction: exponent overflow/underflow has not been raised since last examined	|
	|														|
	|		returns + 0 : overflow/underflow has been asserted and assertion has been cleared		|
	|														|
        |       Call sequence FP_XPO$FLAG is                                            				|
        |                                                                                                               |
        |               ii      FP_XPO$FLAG                                                                             |
        |               j       <i>react</i>		. or lcal <i>react</i>								|
        |					. application continue or resume					|
        |                                                                                                               |
	|	ISR FP_XPO$ changes the floating instruction result to -0.0 which may indicate which operation failed	|
	|	although -0.0 may also be a genuine result								|
	|														|	
	|	FP_XPOS$FLAG return + 1 indicates with certainty that no outflow has taken place			|
	|	FP_XPOS$FLAG return + 0 indicates with certainty that 1+ floating instructions have outflowed		|
	|	since any previous FP_XPO$FLAG call									|
	| 														|
	|	The reasons why ISR FP_XPO$FLAG accumulates underflow/overflow event for later examination are		|
	|														|
	|		RTA1 23-bit floating exponent field is so large that exponent overflow/underflow		|
	|		is not expected as a result of correct operation						|
	|														|
	|		An application development misunderstanding could cause	the outflow event			|
	|														|
	|		Realtime routines should not need to check continually for exponent overflow errors		|
	|		A check event after multiple operations may prompt step for step testing with ii FP_XPO$FLAG	|
	|														|
	|		If routines process values within the range							|
	|														|
	|			&plusmn;9.999999999999999999999e+1262610							|
	|														|
	|			&plusmn;9.999999999999999999999e-1262611							|
	|														|
	|		or in 192-bit floating arithmetic, the range							|
	|														|
	|			&plusmn;9.999999999999999999999999999999999999999999e+1262610					|
	|														|
	|			&plusmn;9.999999999999999999999999999999999999999999e-1262566					|
	|														|
	|		then exponent underflow/overflow is not raised.							|
	|														|
	|_______________________________________________________________________________________________________________|
	|	<a name="fpcompress"/>													|
	|														|
	|	Floating Compression for Storage									|
	|_______________________________________________________________________________________________________________|
	|														|
	|	Macro language compresses 96-bit floating values to 48-bit and other formats for storage if required	|
	|	and re-expands for computation. 48-bit compressed format has 11 exponent bits and 36 mantissa bits	|
	|														|
	|	See macros <a href="masmx7r3.html#fp48data">floating pop and pack</a> / <a href="masmx7r3.html#fp48data">floating push and expand</a>						| 
	|														|
	|	Negative floating numbers are 1s-complement. The range of compressed decimal exponent is &plusmn;307		|
	|														|
	|		  												|
	|	_________________________________________________							|
	|	|s| exponent |	         mantissa	    	|							|
	|	|_|__________|__________________________________|							|
	|          46         35                               0							|
	|														|
	|														|
	|														|
	|	On expansion of compressed floating values 36 trailing signs are added to the mantissa			|
	|	and 12 bits of inverse value to the bit at midpoint position are inserted after midpoint position	|
	|														|
	|														|
	|		    compressed format										|
	|		    11-bit exponent										|
	|		    _____________										|
	|		    |1|   10    |										|
	|          	    |_|_________|      										|
	|		     |		|										|
	|		     |		|										|
	|		     |		|										|
 	|	  |<---------    	|										|
	|	__|______________________________________________________________________________________________	|
	|	|s|.| inserts |  10 bits|   mantissa from compressed value  |  		    signs		|	|
	|	|_|_|_________|_exponent|___________________________________|___________________________________|	|
	|	   | 93     ^  81        71                                  35                                0	|
	|	   |	    |												|
	|	   |________|												|
	|	    inverted												|
	|														|
	|	Twelve assembled values with exponent closely above and below midpoint 400000<sub>16</sub> demonstrate		|
	|	the expansion of midpointed exponent with inserts the inverse of the bit value at midpoint position to	|
	|	preserve the proximity of the expanded exponent to exponent &plusmn;zero = 400000<sub>16</sub> for values  0.5 .. < 1.0	|
	|														|
	|		00:000000  401C00 000000        +1  1.5d							|
	|		00:000002  400001 C00000 000000 000000								|
	|		                                +2  1.5								|
	|		00:000006  400800 000000        +3  0.5d							|
	|		00:000008  400000 800000 000000 000000								|
	|		                                +4  0.5								|
	|		00:00000C  3FF800 000000        +5  0.25d							|
	|		00:00000E  3FFFFF 800000 000000 000000								|
	|		                                +6  0.25							|
	|		00:000012  BFE3FF FFFFFF        +7  -1.5d							|
	|		00:000014  BFFFFE 3FFFFF FFFFFF FFFFFF								|
	|		                                +8  -1.5							|
	|		00:000018  BFF7FF FFFFFF        +9  -0.5d							|
	|		00:00001A  BFFFFF 7FFFFF FFFFFF FFFFFF								|
	|		                                +10  -0.5							|
	|		00:00001E  C007FF FFFFFF        +11  -0.25d							|
	|		00:000020  C00000 7FFFFF FFFFFF FFFFFF								|
	|		                                +12  -0.25							|
	|														|
	|_______________________________________________________________________________________________________________|
	</div>




	<a	name="fa"/>
	Floating Add		fa
	_____________		__

				_________________________________________________________
				|							|
				|	the four-word floating-point number at EA	|
				|	is added to the four-word floating-point number	|
				|	in accumulators a b mantissa2 mantissa3		|
				|							|
				|	accumulator a contains sign and characteristic	|
				|	bits 95..72 of one addend and of the sum	|
				|							|
				|	accumulators b mantissa2 mantissa3 contain the	|	
				|	mantissa of one addend and of the sum with	|
				|	highest order bits in accumulator b and lowest	|
				|	order bits in accumulator mantissa3		|
				|							|
				|	the word at EA contains sign and characteristic	|
				|	bits of the other addend. The highest order	|
				|	mantissa bits are at EA+1, bits 47..24 at EA+2	|
				|	and the lowest order mantissa bits are at EA+3	|
				|							|
				|_______________________________________________________|
				|	2nd addend is 4 registers or storage words at EA|
				|	EA is any word address				|
				|_______________________________________________________|



	assembler syntax	fa	addend[, {x|y|a|b|fp|sp}]

				fa	*pointer_to_addend

				fa	(2.50600004700003450630*+1262600)


				_________________________________________________________
	Instruction Code 12.7	| 0 1 1 0 0 | 1 1 1 |		<a style="color:#00AF6F">  address</a>		|
				|___________|_______|___________________________________|

<a	name="fpexa"/>

<div	style="left:400pt;position:absolute;width:400pt;border-radius:3px;color:#000080;background-color:#E0FFFF80">
.	192-bit operation
.	<a href="#simd_fp">SIMD_CONTROL</a> = (-1, 0, 0, 0q) = 1 object, default

	$include	array.app/array.def
	$include	lib/octopop.def

	octopush	first_addend
	on		fp$r
	rex		(fa	second_addend)
	octopop		sum

.	super-normalisation is not necessary
</div>	<a	style="color:#00000060">
.	approximate steps of equivalent library routine
.	192-bit value calculated in 96-bit steps
.	in regular accumulators

		ql	first_addend
		on	fp$r
		fa	second_addend
		qs	sum
		off	fp$r
		ql	first_addend+4
		fa	$residue
		fa	second_addend+4
			on	fp$r
			fa	sum
			off	fp$r		. force super-normalisation
			qs	sum		. between major and minor numbers
			ql	$residue	. if necessary
		qs	sum+4</a>





	<a	name="fan"/>
	Floating Add Negative		fan
	_____________________		___

				_________________________________________________________
				|							|
				|	the 1s complement of the four-word		|
				|	floating-point number at EA is added to		|
				|	the four-word floating-point number		|
				|	in accumulators a b mantissa2 mantissa3		|
				|							|
				|	accumulator a contains sign and characteristic	|
				|	bits 95..72 of the minuend and of the difference|
				|							|
				|	accumulators b mantissa2 mantissa3 contain the	|	
				|	mantissa of the minuend and of the difference	|
				|	with highest order bits in accumulator b and	|
				|	lowest order bits in accumulator mantissa3	|
				|							|
				|	the word at EA contains sign and characteristic	|
				|	bits of the subtrahend. The highest order	|
				|	mantissa bits are at EA+1, bits 47..24 at EA+2	|
				|	ans the lowest order mantissa bits are at EA+3	|
				|							|
				|_______________________________________________________|
				|	subtrahend is 4 registers or storage words at EA|
				|	EA is any word address				|
				|_______________________________________________________|




	assembler syntax	fan	subtrahend[, {x|y|a|b|fp|sp}]

				fan	*subtrahend_indirectly

				fan	(457600004700003450.630*+1262001)


				_________________________________________________________
	Instruction Code 13.7	| 0 1 1 0 1 | 1 1 1 |		<a style="color:#00AF6F">  address</a>		|
				|___________|_______|___________________________________|


<a	name="fpexan"/>

<div	style="left:400pt;position:absolute;width:400pt;border-radius:3px;color:#000080;background-color:#E0FFFF80">
.	192-bit operation
.	<a href="#simd_fp">SIMD_CONTROL</a> = (-1, 0, 0, 0q) = 1 object, default

	$include	array.app/array.def
	$include	lib/octopop.def

	octopush	minuend
	on		fp$r
	rex		(fan	subtrahend)
	octopop		difference

.	super-normalisation is not necessary
</div>	<a	style="color:#00000060">
.	approximate steps of equivalent library routine
.	192-bit value calculated in 96-bit steps
.	in regular accumulators

		ql	minuend
		on	fp$r
		fan	subtrahend
		qs	difference
		off	fp$r
		ql	minuend+4
		fan	subtrahend+4
		fa	$residue
			on	fp$r
			fa	difference
			off	fp$r		. force super-normalisation
			qs	difference	. between major and minor numbers
			ql	$residue	. if necessary
		qs	difference+4</a>
				






	<a	name="fm"/>
	Floating Multiply	fm
	_________________	__

				_________________________________________________________
				|							|
				|	the four-word floating-point number		|
				|	in accumulators a b mantissa2 mantissa3		|
				|	is multiplied by				|
				|	the four-word floating-point number at EA	|
				|							|
				|	accumulator a contains sign and characteristic	|
				|	bits 95..72 of multiplicand and product		|
				|							|
				|	accumulators b mantissa2 mantissa3 contain the	|	
				|	mantissa of the multiplicand and of the product	|
				|	with highest order bits in accumulator b and	|
				|	lowest oder bits in accumulator mantissa3	|
				|							|
				|	the word at EA contains sign and characteristic	|
				|	bits of the multiplier. The highest order	|
				|	mantissa bits are at EA+1, bits 47..24 at EA+2	|
				|	ans the lowest order mantissa bits are at EA+3	|
				|							|
				|_______________________________________________________|
				|	multiplier is 4 registers or storage words at EA|
				|	EA is any word address				|
				|_______________________________________________________|



	assembler syntax	fm	multiplier[, {x|y|a|b|fp|sp}]

				fm	*multiplier_indirectly

				fm	(250600004700003450.630*-1262001)


				_________________________________________________________
	Instruction Code 14.7	| 0 1 1 1 0 | 1 1 1 |		<a style="color:#00AF6F">  address</a>		|
				|___________|_______|___________________________________|


<a	<a name="fpexm"/>

<div	style="left:400pt;position:absolute;width:400pt;border-radius:3px;color:#000080;background-color:#E0FFFF80">
.	192-bit multiplicand * 192-bit multiplier
.	<a href="#simd_fp">SIMD_CONTROL</a> = (-1, 0, 0, 0q) = 1 object, default

	$include	array.app/array.def
	$include	lib/octopop.def

	octopush	multiplicand
	on		fp$r
	rex		(fm	multiplier)
	octopop		product

.	super-normalisation is not necessary
</div>	<a	style="color:#00000060">
.	approximate steps of equivalent library routine
.	192-bit multiplicand * 96-bit multiplier
.	in 96-bit steps in regular accumulators

	ql	multiplicand
	on	fp$r
	fm	multiplier
	off	fp$r
	qs	product
	ql	multiplicand+4
	fm	multiplier
	fa	$residue
		on	fp$r
		fa	product
		off	fp$r		. force super-normalisation
		qs	product		. between major and minor numbers
		ql	$residue	. if necessary
	qs	product+4</a>





	<a	name="fd"/>
	Floating Divide		fd
	_______________		__

				_________________________________________________________
				|							|
				|	the four-word floating-point number 		|
				|	in accumulators a b mantissa2 mantissa3		|
				|	is divided by					|
				|	the four-word floating-point number at EA 	|
				|							|
				|	accumulator a contains sign and characteristic	|
				|	bits 95..72 of the dividend and of the quotient	|
				|							|
				|	accumulators b mantissa2 mantissa3 contain the	|
				|	mantissa of the dividend and of the quotient	|
				|	with highest order bits in accumulator b and	|
				|	lowest oder bits in accumulator mantissa3	|
				|							|
				|	the word at EA contains sign and characteristic	|
				|	bits of the divisor. The highest order		|
				|	mantissa bits are at EA+1, bits 47..24 at EA+2	|
				|	ans the lowest order mantissa bits are at EA+3	|
				|							|
				|_______________________________________________________|
				|	divisor is four registers or storage words at EA|
				|	EA is any word address				|
				|_______________________________________________________|



	assembler syntax	fd	divisor[, {x|y|a|b|fp|sp}]

				fd	*divisor_indirectly

				fd	(458.600004700003450630*+1262001)


				_________________________________________________________
	Instruction Code 15.7	| 0 1 1 1 1 | 1 1 1 |		<a style="color:#00AF6F">  address</a>		|
				|___________|_______|___________________________________|


<a	name="fpexd"/>

<div	style="left:400pt;position:absolute;width:400pt;border-radius:3px;color:#000080;background-color:#E0FFFF80">
.	192-bit dividend / 192-bit divisor
.	<a href="#simd_fp">SIMD_CONTROL</a> = (-1, 0, 0, 0q) = 1 object, default

	$include	array.app/array.def
	$include	lib/octopop.def

	octopush	dividend
	on		fp$r
	rex		(fd	divisor)
	octopop		quotient

.	super-normalisation is not necessary
</div>	<a	style="color:#00000060">
.	approximate steps of equivalent library routine
.	192-bit dividend / 96-bit divisor
.	in 96-bit steps in regular accumulators

	ql	dividend
	on	fp$r
	fd	divisor
	off	fp$r
	qs	quotient
	ql	dividend+4
	fd	divisor
	fa	$residue
		on	fp$r
		fa	quotient
		off	fp$r		. force super-normalisation
		qs	quotient	. between major and minor numbers
		ql	$residue	. if necesssary
	qs	quotient+4</a>




	<a	name="gocall"/>
	<div	style="margin-left:28pt;font-family:times-roman;font-size:12.75pt;color:0000FF">	
	<i>3.6.16	Far Go and Call</i>
	</div>

	<div	style="font-size:11pt">
	Extensive system images may be constructed using only 4K iframes for [kernel and] applications

	Fixed iframes one 4K-word page in size may be called without a gate
	if they are at a location less than 256 Megawords

	Dynamically loadable iframes can only be located with a gate

	Iframes larger than one 4K-word page only be located with a gate

	Gates can address any offset location in fixed or dynamic iframes of any size anywhere in executable space



	_________________________________________________________
	|	go and call between instruction frames		|
	|_______________________________________________________|
	|							|
	|	Inter-iframe jumps <b>go</b> and <b>call</b>			|
	|	read a single word operand of format		|	<a	name="gate"/>
	|							|
	|							|	48-bit gate to executable space location
	|	   22                         0			|
	|	________________________________		|	________________________________________________________________
	|	|1|	  gate address	       |---------------------->	|pagehx|   instruction offset  |ff|  iframe start page index   |
	|	|_|____________________________|		|	|______|_______________________|__|____________________________|
	|	  23-bit pointer to gate constant or variable	|	|47  42			     24| 22
	|							|	|			       |
	|							|	|page high index	       |00: page high index = 0 = pages 1
	|							|	|= iframe pages - 1	       |10: page high index in bits 47:42
	|			OR of format			|
	|							|
	|							|
        |	    21                6       0			|
	|	________________________________		|
        |	|00|bbbb bbbb bbbb bbbb| vector|		|
	|	|__|___________________|_______|		|
        |           16-bit pointer       6-bit			|
	|	    to 4K iframe edge    vector			|
	|							|_______________________________
	|											|
	|											|
	|											|
	|											|
	|	<b>call</b> instruction								|
	|	pushes program-counter minus B0 * 4096 on the internal stack			|
	|	then pushes Iframe Name = B0 OR size flag					|
	|	________________________________						|
	|	|	    saved offset       |						|
	|	|______________________________|						|
	|	|F0| 	    saved B0	       |						|
	|	|__|___________________________| <------------- updated internal stack pointer	|
	|											|
	|											|
	|											|
	|	<b>go</b> and <b>call</b> update the program counter						|
	|											|
	|											|
	|       B0 = operand[21..6] >> 6							|
        |	PC = B0 * 4096 + operand[5..0]							|
	|											|
	|											|
	|											|
	|	                        _____________________					|
        |		                go / call destination					|
        |       		        _____________________					|
        |               		        |						|
	|                       	        |						|
	|      			 	        |                               		|
	|			       	________|________               			|
	|			        | B0 =          |               			|
        |				| operand >> 6  |               			|
	|			        |_______________|               			|
        |				        |                              			|
	| 				________|________               			|
	|			        | offset =      |               			|
        |				| operand AND 63|              				|
	|       			|_______________|               			|
	|       	        		|                     				|
	|	                        ________|________					|
        |		                | PC = B0 */ 12 |					|
        |       		        | OR offset     |					|
        |               		|_______________|					|
	|											|
	|											|
	|											|
	|											|
	|$ masmx ibj -ln									|
	|MASMX 7r3										|
	|3/ibj.msm										|
	|freeware/RTA1/rta/fs/fs.txo:$(0) 477 words decimal from hexadecimal 000000 to 0001DD	|
	|*EOF*											|
	|  :                            1							|
	|  :                            2:       $include        freeware/RTA1/rta/def/rta.def	|
	|  :                            3        $include,$void freeware/RTA1/rta/fs/fs.txo $(0)|
	|  :                            4 $(0:64)						|
	|00:000040 FF0100              +5        call            (seg$load)			|
	|  :                            6							|
	|  :                            7							|
	|  :                            8        $do             $<256,$(0:256)			|
	|  :                            9							|
	|*EOF*											|
	|00:000100+000187									|
	|:$(00):000040:000101									|
	|											|
	|_______________________________________________________________________________________|
	</div>





	<a	name="go"/>
	Go			go
	__			__

<div	style="font-size:11pt">

	_________________________________________________________
	|							|
	|	Jump to Iframe					|
        |                                                       |       indirect operand pointing to gate constant or variable
        |       operand is storage word or register at EA       |
        |                                                       |        23                                                    0
        |                                                       |       _________________________________________________________
        |       if operand bit 23 = 1 --------------------------------> | 1 |               address of gate                     |_______
        |       bits 22:0 point to a constant or variable       |       |___|___________________________________________________|       |
        |       containing a 48-bit gate value                  |            22                                                0        |
        |                                                       |                                                                       |
        |       if operand bit 23 = 0                           |                                                                       |
        |                                                       |                                                                       |
        |               bit 22 is reserved                      |                                                                       |
        |                                                       |                                                                       |
        |               16 bits 21:6 are the Page Index		|                                                                       |
        |               of a 4096-word target iframe            |        gate to target iframe:offset					|
        |                                                       |                                                                       |
        |               bits 5:0 are an entry point vector      |        47          42                                       24        |
        |               to locations 0..63 of the target iframe |       _________________________________________________________       |
        |                                                       |       | page high idx|        target instruction offset       |<------+ 
        |_______________________________________________________|       |______________|________________________________________|
        | 00 |		Page Index of 4K Iframe	  |   vector	|       | F 0 |                 iframe start page index         |
        |____|____________________________________|_____________|       |_____|_________________________________________________|
        |     21                                   5           0|              21                                              0
        |                                                       |
        |               B0 = operand bits 21..6 >> 6            |              B0 = gate bits 21..0 Start Page Index
        |               Page High Index = 0                     |              Page High Index = bits 47..42 of gate
        |               Iframe Name = B0                        |              Iframe Name = B0 OR (iframe pages > 1) 1 << 23
        |               B64 = B0                                |              B64 = B0 + Page High Index
        |               PC = B0 * 4096 + operand 5..0 offset    |              PC = B0 * 4096 + gate bits 41..24 offset
        |                                                       |
        |                                                       |
        |_______________________________________________________|________________________________________________________________
        |                                                                                                                       |
        |       operand is the  register or storage word at EA                                                                  |
        |_______________________________________________________________________________________________________________________|

</div>


	assembler syntax	go	target_identifier[, {x|y|a|b|fp|sp}]

				go	*target_identifier_indirectly

				go	(MEMORY/4096*64++VECTOR_0_63)

				go	(0800000++LITERALS_TAG(page_high_index*/18++offset, start_page_index:d)s)

					for large and dynamically loadable iframes see <a href="#iframe">iframe</a> and <a href="#gate">gate</a>



				_________________________________________________________
	Instruction Code 30.7	| 1 1 1 1 0 | 1 1 1 |		<a style="color:#00AF6F">  address</a>		|
				|___________|_______|___________________________________|







	<a	name="call"/>
	Call			call
	____			____

<div	style="font-size:11pt">
												return address -> internal stack

									 23						       0
	_________________________________________________________	_________________________________________________________
	|							|	|			saved offset			| sp + 1
	|	Call Iframe					|	|_______________________________________________________|
	|							|	| F 0 |			saved Start Page Index		| <-- sp
	|	Program Counter minus B0 * 4096			|	|_____|_________________________________________________|
	|	is pushed to internal stack			|	      |21					       0
	|							|
	|	Iframe Name pushed to Internal Stack		|	  0 0 | <- B64 = B0 : Page High Index on return = 0
	|	= B0 -> bits 21:0 Start Page Index		|	  1 0 | <- B64 > B0 : Page High Index on return
	|	+ iframe size flags -> bits 23:22		|			      = gate bits 47:42 @ iframe + 64
	|							|
	|							|
	|_______________________________________________________|_______________________________________________________________
	|							|
	|							|
	|							|	indirect target operand pointing to gate constant or variable
	|	operand is storage word or register at EA 	|
	|							|	 23						       0
	|							|	_________________________________________________________
	|	if operand bit 23 = 1 -------------------------------->	| 1 |		    address of gate			|_______
	|	bits 22:0 point to a constant or variable	|	|___|___________________________________________________|	|
	|	containing a 48-bit gate value			|	     22						       0	|
	|							|									|
	|	if operand bit 23 = 0				|									|
	|							|									|
	|		bit 22 is reserved			|									|
        |                                                      	|									|
        |       	16 bits 21:6 are the Page Index		|									|
        |       	of a 4096-word target iframe         	|	 gate to target iframe:offset					|
        |                                                       |									|
        |       	bits 5:0 are an entry point vector	|	 47          42                                       24	|
        |       	to locations 0..63 of the target iframe |	_________________________________________________________	|
	|							|	| page high idx|        target instruction offset       |<------+
	|_______________________________________________________|	|______________|________________________________________|
	| 00 |		Page Index of 4K Iframe   |   vector	|	| F 0 |                 iframe Start Page Index         |
	|____|____________________________________|_____________|	|_____|_________________________________________________|
	|     21				   5	       0|	       21					       0
	|							|
	|		B0 = operand bits 21..6	>> 6		|		B0 = gate bits 21..0 Start Page Index
	|		Page High Index = 0			|		Page High Index = bits 47..42 of gate
	|		Iframe Name = B0			|		Iframe Name = B0 OR (iframe pages > 1) 1 << 23
	|		B64 = B0				|		B64 = B0 + Page High Index
	|		PC = B0 * 4096 + operand 5..0 offset	|		PC = B0 * 4096 + gate bits 41..24 offset
	|							|
	|							|
	|_______________________________________________________|________________________________________________________________
	|															|
        |       on internal stack overflow / underflow [sp < 26 | sp > 128] before operation guard interrupt 95 is raised	|
	|	operand is the  register or storage word at EA									|
	|_______________________________________________________________________________________________________________________|

</div>


	assembler syntax	call		target_identifier[, {x|y|a|b|fp|sp}]

				call		*target_identifier_indirectly

				call		(LOCATION/4096*64++VECTOR_0_63)

				call	(0800000++LITERALS_TAG(page_high_index*/18++offset, start_page_index:d)s)

						for large and dyamically loadable iframes see <a	href="#iframe">iframe</a> and <a href="#gate">gate</a>



				_________________________________________________________
	Instruction Code 31.7	| 1 1 1 1 1 | 1 1 1 |		<a style="color:#00AF6F">  address</a>		|
				|___________|_______|___________________________________|


</pre>
	<a	name="sim_d"/>
	<h1>Appendix A: SIMD and Instruction Repeat</h1>
	
	Repeat Execute feature in all RTA1 emulators<br>
	Stepping 01.01.2024 [USA 01.01.2024]
	<div	style="font-size:14pt">
	<pre href="#A1" style="text-decoration:none;color:0000FF;font-family:times-roman;">A1	Description</a>
		<a href="#A1" style="text-decoration:none;color:0000FF">A1.1	Outline</a>
		<a href="#simd_frame" style="text-decoration:none;color:0000FF">A1.2	SIMD Frame and Accumulator Vector</a>
		<a href="#simd_i" style="text-decoration:none;color:0000FF">A1.3	Instructions in Scope of Repeat Execute</a>
		<a href="#simd_fp" style="text-decoration:none;color:0000FF">A1.4	192-Bit Single-Instruction Floating Point in SIMD

		<a href="#simd_fx" style="text-decoration:none;color:0000FF">A1.5	Fixed Point Multiply and Divide in SIMD	

		<a href="#simd_iho" style="text-decoration:none;color:0000FF">A1.6	Data Points held for Successive Operations</a>
		<a href="#sim_d2" style="text-decoration:none;color:0000FF">A1.7	Repeat Execute Instruction</a>
		<a href="#simd_c" style="text-decoration:none;color:0000FF">A1.8	Programming SIMD Frame and Accumulator Vector</a>

	<a href="#A2" style="text-decoration:none;color:0000FF">A2	Examples</a>
		<a href="#A2_1" style="text-decoration:none;color:0000FF">A2.1	Loading / Storing the Internal Stack with Unrolled Push and Pop Operations</a>
		<a href="#A2_2" style="text-decoration:none;color:0000FF">A2.2	Alternative Accumulators at the Internal Stack Top</a>
		<a href="#A2_3" style="text-decoration:none;color:0000FF">A2.3	Loading / Storing the Internal Stack with Repeat Load and Store Operations</a>
		<a href="#A2_4" style="text-decoration:none;color:0000FF">A2.4	Loading / Storing the Internal Stack with with Datafile Read and Write</a>
		<a href="#A2_5" style="text-decoration:none;color:0000FF">A2.5	Table Searches with Repeat Test and Skip Instructions</a>
		<a href="#A2_6" style="text-decoration:none;color:0000FF">A2.6	SIMD_TARGET: Single Target within SIMD Frame<a/>
		<a href="#A2_7" style="text-decoration:none;color:0000FF">A2.7	SIMD_TARGET: Target Group within SIMD Frame</a>
		<a href="#simd_resume" style="text-decoration:none;color:0000FF">A2.8   Resuming a SIMD Sequence of Floating Operations after Fault Handlng</a>
	</pre>
	<a	name="A1"/>
	<h2>A1	Description</h2>
	<h3>A1.1	Outline</h3>

An instruction repeat model using as accumulators some or all of the 104 internal stack registers
iterates these operations on tables of data points
<pre	style="font-family:times-roman;color:0000FF">

	96-bit floating point operations

	<a href="#simd_fp">192-bit floating operations</a>

	<a href="#simd_fx">24-bit and and 48-bit integer arithmetic operations</a>

	boolean algebra operations

	24-bit and 48-bit shift operations

	24-bit, 48-bit, and 96-bit load and store operations

</pre>
Repeat Execute instruction <a href="#sim_d2">rex</a> iterates an operation on Data Points 1 in internal stack accumulators
with Data Point 2 operands obtained from a variable effective address
<pre	style="font-size:12pt">

	rex	(fm	offset[, x ])	. index may be [ x y a b fp sp ] or none
</pre>

Data Points 1 and results are in the same internal stack accumulators
<pre	style="font-family:times-roman;color:0000FF">

	repeat instructions also execute <a href="#A2_5">search operations</a> on storage tables of any size

	Semicondictor implementations <i>may</i> support these operations with simultaneous execution hardware
	under <i>some</i> circumstances

	Multiple execution is modelled as an instruction repeat paradigm

		in order to be available whether whether any parallel hardware is present or not

		and because not all Data Point 2 operands are necessarily within the internal stack
		or even near each other in memory, which would be a minimal requirement for simultaneous operations

		The repeat execute model allows Data Point 2 operands to be gathered from dispersed locations
		typically as structure members


	Instruction repeat model also has the effect of making the registers at the stack top available
	as <a href="rta.html#A2_2">alternative accumulators</a>

	Instruction repeat is only available in application mode and not in interrupt mode

	Instruction repeat with no simultaneous operation is interruptible between instruction repeats

</pre>


<a	name="simd_frame">
<h3>A1.2	SIMD Frame and Accumulator Vector</h3>

SIMD Frame is a number of Data Point 1 objects at the internal stack top. SIMD Frame is programmed by macro <a href="#simd_c">SIMD_CONTROL</a>

<p>
SIMD Frame remains programmed until the thread updates it and can be used for successive multiple operations until a parameter change is needed
<pre	style="font-size:12pt">

	SIMD_CONTROL	(-1, ACCUMULATOR_UPDATE, RESTART_COUNT-1, EA_INCREMENT:q)

</pre>
RESTART_COUNT is the number of objects loaded in the frame where
<pre	style="font-family:times-roman;color:0000FF">

	integer objects occupy one or two registers

	integer dividend / quotient may have a third register reserved for storing remainder

	floating objects occupy four or eight regosters

	SIMD_RESTART register 22 is the value RESTART_COUNT-1

</pre>
Accumulater update (register 21 SIMD_AU) is the increment to accumulator vector q and is in most cases the size in words of the object

<p>
Accumulator update is zero if multiple Data Point 2 operands are applied to one Data Point 1 accumulator

<p>
&plusmn; EA increment (register 23 SIMD_XU) is applied to an <a style="color:#0000FF">index register</a> generating operand effective address of the repeated instruction
<pre	style="font-size:12pt">

	rex	(da	OFFSET_IN_CONTAINER, <a style="color:#0000FF">x</a>)

</pre>
EA increment corresponds to the the structure size of an array object containing Data Point 2

<p>
EA increment is zero if one Data Point 2 operand is applied to multiple Data Point 1 accumulators

<p>
Register 20 SIMD_RUNCOUNT is final count set at -1 = expired / awaiting initialisation
in order to trip initialisation of operations to the start of SIMD frame

<p>
Initialisation steps are
<pre	style="font-size:12pt">

	register q accumulator vector	&lt;-	internal stack pointer

	register 20 SIMD_RUNCOUNT	&lt;-	register 22 SIMD_RESTART

</pre>
SIMD_RESTART contains objects count minus one

<p>
Kernels start all process threads with a <a href="rta.html#A2_2">default SIMD Frame</a> of one object to allow calculations on the internal stack top
as alternatives to regular accumulators [ a b mantissa2 mantissa3 ] 

<p>
A <a href="#simd_target">subset</a> of one or more objects within the frame can be selected for operation 

<a	name="simd_i"/>
<h3>A1.3	Instructions in Scope of Repeat Execute</h3>

Most instructions which are otherwise executed on the accumulator registers 4..11 are in the repeat model. 

See also <a href="rta.html#rex">rex instruction: operations</a>

<p>
Repeated instructions shall not necessarily operate with the exact behaviour of the instructions which they mirror

<a	name="simd_fp"/>

<h3>A1.4	192-Bit Single-Instruction Floating Point in SIMD</h3>

The four-function floating point instructions behave in repeat context as they behave executed directly,
except when PSR residue flag fp$r is set

<p>
Outwith SIMD, floating instructions have 96-bit inputs, store a 96-bit result, and if fp$r is set,
a 96-bit floating residue is also stored for constructing long floating results

<p>
Within SIMD, flag fp$r selects 192-bit single-instruction floating operations
with sources-1 arrayed in the internal stack and sources-2 either in memory or in registers
<pre	style="font-size:10pt">

	source-1			 191		 167					      96
	_________________		_________________________________________________________________
	|	q 	|  ----------->	|s|  exponent	|		   mantissa			|
	|_______________|		|_|_____________|_______________________________________________|
					|s|  exponent	|		   mantissa			|
	accumulator vector		|_|_____________|_______________________________________________|
					 95		 71					       0
	<a	style="color:#00000060">
					   |
					   |	source-1 + 
					   |______________________________________________________________

					      |
					      |	   source-1 + +
					      |_______________________________________________________________
	</a>


	source-2			 191		 167					      96
	_________________		_________________________________________________________________
	|	ea	| ------------> |s|  exponent	|		   mantissa			|
	|_______________|		|_|_____________|_______________________________________________|
					|s|  exponent	|		   mantissa			|
	effective address		|_|_____________|_______________________________________________|
					 95		 71					       0
	<a	style="color:#00000060">
			  ----------------> |
				ea next	    |   source-2 next
					    |_______________________________________________________________

			  -------------------> |
				ea next +      |   source-2 next +
					       |______________________________________________________________
	</a>

	<a	style="font-family:times-roman;font-size:14pt;color:#0000FF">

	source-1 registers are also result registers

	source-2 operands may be registers or widely distributed structure members in memory

	each operation is a calculation on 144 mantissa bits

	mantissa is joined for operation by rolling sign bits into the normalising field of each minor number

	minor normalising field is major exponent minus minor exponent minus 72

	major and minor results are individually normalised at the end of each operation

	minor exponent is major exponent minus 72 minus minor normalising count</a>

</pre>
<a href="#simd_c">SIMD_RESTART + 1  operations</a> take place

<p>
by default that is one operation at the internal stack top

<p>
<a	name="simd_mmor"/>
floating representation is 1s complement as all RTA1 floating arithmetic

<p>
constants of 192-bit format can be generated with macro major_minor
<pre	style="font-size:12pt">

		$include	lib/144.def

		major_minor	4.848484848484848484848484848484848484848484e+1200000

</pre>


<a	name="simd_fx"/>
<h3>A1.5	Fixed Point Multiply and Divide in SIMD</h3>

Integer multiplies and divides have the same instruction code assignments in repeat (SIMD) as in ordinary context
but are slightly different instructions in repeat context
<pre	style="font-size:12pt">


	<a	name="rex_m"/>
	Multiply <a href="#m" style="color:#00AF6F">m</a> is

	in ordinary context					in repeat context
	___________________					_________________

	24-bit signed accumulator b				48-bit signed multiplicand in two internal stack registers
	* 24-bit signed multiplier				* 24-bit signed multiplier
	= 48-bit signed product in accumulators a b		= 48-bit signed product


	<a	name="rex_mf"/>
	Multiply Fractional <a href="#mf" style="color:#00AF6F">mf</a> is in repeat context
	a 24-bit signed multiply with 24-bit signed product

	in ordinary context					in repeat context
	___________________					_________________

	unsigned 24-bit multiplicand in accumulator b		24-bit signed multiplicand in one internal stack register
	* signed 24-bit multiplier				* 24-bit signed multiplier = 24-bit signed product
	= signed 48-bit product in accumulators a:b		in the same internal stack register

	<a	name="rex_d"/>
	Divide <a href="#d" style="color:#00AF6F">d</a> stores results differently in repeat context

	in ordinary context					in repeat context
	___________________					_________________

	signed 48-bit dividend in accumulators a:b		48-bit signed dividend in two internal stack registers
	/ signed 24-bit divisor					/= 24-bit signed divisor
	= signed 48-bit quotient				giving 48-bit signed quotient in the same two registers
	in [HIGH] register mantissa2 : [LOW] accumulator a	remainder is by default discarded
	remainder in accumulator b is either zero		if PSR flag fp$r 24-bit remainder -> target registers + 2
	or has the sign of the dividend				remainder is either zero or has the sign of the dividend

</pre>
Instructions with a right / left / both  [ a b ab ] sense 
<pre>

	<a href="#rex" style="color:#00AF6F">sa sb ds qs la lb dl ql or orB and andB xor xorB</a>
	<a href="#rex" style="color:#00AF6F">sar sbr dsr sal sbl dsl rar rbr drr ral rbl drl saa sba dsa</a>
	<a href="#rex" style="color:#00AF6F">aa ab ana anb da dan</a>

</pre>
are as ordinary context except in repeat context they address internal stack register
<a href="#rex_lane" style="color:#00AF6F">[q] -> or [q + 1] -&gt;</a>

<p>						  
Test and skip instructions in repeat context <a href="#tz" style="color:#00AF6F">tz</a> <a href="#tp" style="color:#00AF6F">tp</a> <a href="#mta" style="color:#00AF6F">mta</a> <a href="#dte" style="color:#00AF6F">dte</a> <a href="#A2_5">Examples</a>
<pre	style="font-family:times-roman;color:0000FF">

	skip and stop repeating when the tested condition is met

	or reach table end and do not skip

</pre>

<a	name="simd_iho">
<h3>A1.6	Data Points held for Successive Operations</h3>

Although operations on large arrays mostly cannot process faster than data can be transferred in and out of the core,
multiple operation has the advantages
<pre	style="font-family:times-roman;color:0000FF">
	values may reside for successive operations in many destination registers

	the arrays of accumulators and Data Point 2 operands are traversed
	without extra instructions to count or to advance indexing

</pre>
Each repeated instruction generates a new effective address for the Data Point 2 operand on each repeat
if an index component of the effective address has been incremented

<p>
Automatic index register increment may be widely spaced either forward or back so that
structure members may be gathered as Data Point 2 operands

<p>
Data Point 1 operands are loaded to internal stack accumulators and results stored
<pre	style="font-family:times-roman;color:0000FF">
	<a href="#A2_1" style="text-decoration:none">by unrolled single, double or quadword push and pop instructions
	source and store addresses may be very dispersed</a>

	<a href="#A2_3" style="text-decoration:none">by repeat execution of a single, double or quadword load / store instruction
	source and store addresses may be very dispersed</a>

	<a href="#A2_4" style="text-decoration:none">by datafile pipe or stream read to and write from the internal stack</a>
 
</pre>
Data Points 1 are concentrated on acquisition and results are distributed on storage

<p>
Data Points 2 are acquired on computation from locations which may be widely spaced

<p>
Repeat operations traversing the internal register stack update the accumulator vector
with the &plusmn;increment programmed in register <a style="color:#FF0000">SIMD_AU</a>, most frequently
<pre	style="font-size:10pt">

	+1 * object size in words

	for example <a style="color:#FF0000">increment +4</a> is for a list of 4-word floating numbers in the internal stack

			
	+ ----------------------------- + <----------------------------------- 	SIMD_RESTART copied -> SIMD_RUNCOUNT
	|									at operation start when runcount < 0
	_________________________________________________________________	simultaneously accumulator vector q restarted
	| running count	| <a style="color:#FF0000">increment +4</a>	|
	|_______________|_______________|_______________|_______________|
	  SIMD_RUNCOUNT	|    SIMD_AU	|  SIMD_RESTART	|  SIMD_XU 
	    		|				+---------------------> updates index register of source-2 operand
			+-----------------------------------------------------> updates [ register q ] accumulator vector 

</pre>
Accumulator vector increment SIMD_AU zero is correct when the same internal stack register remains source-1 operand iteratively,
for example
<pre	style="font-family:times-roman;color:0000FF">

	the value in one internal stack register is stored to many locations

	many values read from dispersed locations are accumulated in one internal stack register

</pre>
Accumulator vector increment SIMD_AU +2 is correct when
<pre	style="font-size:12pt">

	pairs of single registers are treated as <a href="#rex_lane">left and right lanes</a> with for example

	instruction [ <a href="#rex" style="color:#00AF6F">sa la or and xor aa ana sar sal rar ral saa</a> ] to the left register of each pair
	instruction [ <a href="#rex" style="color:#00AF6F">sb lb orB andB xorB ab anb sbr sbl rbr rbl sba</a> ] to the right register of each pair

</pre>
<a	name="sim_d2"/>
<div	style="right:50pt;width:400pt;position:absolute;font-size:9pt;color:#00AF6F">
<pre>

			_________________
			|      rex	|
			|_______________|
				|
				|	interrupt mode
				|------------------------------------->	no-op
				|
			________|________
			|  read <- [EA]	|
			|  	 target	|
			|   instruction	|
			|_______________|
				|
				|	non-repeat instruction
				|------------------------------------->	no-op
				|
				|	final count 0+
				|-------------------------------------->	
				|					|
			________|________	_________________	|
			|  final count	| <-----| restart count	|	|
			|_______________|	|_______________|	|
				|					|
			________|________	_________________	|
			|  dest vector	| <-----|      sp	|	|
			|_______________|	|_______________|	|
				|					|
				|<--------------------------------------
			________|________
			| resolve target|
			| instruction EA|
			|_______________|
				|
	 --------------------->	|
	|			|
	|			|	dest register[s] < 24 OR > 127  
	|			|------------------------------------->	fault
	|			|
	|		________|________
	|		|XQT instruction|
	|		|_______________|
	|			|
	|		________|________
	|		| increment dest|
	|		|register vector|
	|		|_______________|
	|			|
	|		________|________
	|		|increment source
	|		| index register|
	|		|_______________|
	|			|
	|		________|________
	|		|     decrement	|
	|		|   final count	|
	|		|_______________|
	|			|
	|			|
	|			|	final count < 0
	|			|------------------------------------->	complete
	|			|
	|			|		_________________
	|			|		|      decrement|
	|			|------------->	|program counter|----->	complete
	|			|    	unmasked|_______________|
	|			|    	interrupt
	|			|
	|			|
	|		________|________
	 <--------------|   revise EA	|
			|_______________|

</pre>
</div>	

<h3>A1.7	Repeat Execute Instruction</h3>

The repeat execute instruction is implemented as follows
<pre	style="font-size:12pt">

	rex			Repeat Execute
	___			______________

				_________________________________________________________
	Instruction Code 14.4	| 0 1 1 1 0 | 1 0 0 |	<a style="color:#00AF6F">   EA -> target instruction</a>	|
				|___________|_______|___________________________________|


	If PSR Interrupt Mode is set then rex instruction no-ops

	The target instruction for repeat operation is read via rex instruction effective address

	If the acquired instruction is not in the repeatable set then rex instruction no-ops

	If register 20 SIMD_RUNCOUNT is negative two initialisation steps take place

		counter restart value in register 22 SIMD_RESTART is copied to final count SIMD_RUNCOUNT

		register 15 internal stack pointer is copied to
		accumulator vector q

	Initial Data Point 2 effective address is generated from
	the address fields of the acquired instruction

	X. The acquired instruction is executed using as accumulator[s]
	the internal stack register[s] pointed by q <a href="#watch_it" style="color:#FF0000">**</a>

	Register 21 SIMD_AU is added to q

	If the acquired instruction uses an index register in the set [ x y a b fp sp ]
	then register 23 SIMD_XU is added to the index register

	Final count register 20 SIMD_RUNCOUNT is decremented
	If SIMD_RUNCOUNT becomes negative repeat operation is complete and ceases

	If an interrupt request with urgency > interrupt mask is pending

		absolute program counter is decremented
		to cause rex instruction to start again at the next repeat instance
		without initialising accumulator vector q or final count SIMD_RUNCOUNT

		repeat operation concludes and the interrupt is enabled

	otherwise

	If the index register was incremented a new effective address is generated

	Execution at step X. continues

	______________________________


</pre>
<a	name="simd_c"/>
<h3>A1.8	Programming SIMD Frame and Accumulator Vector</h3>


<p>
rex instruction uses registers <a style="font-family:courier">[ q SIMD_RUNCOUNT SIMD_AU SIMD_RESTART SIMD_XU ]</a>

<p>
Registers <a style="font-family:courier">[ q SIMD_RUNCOUNT SIMD_AU SIMD_RESTART SIMD_XU ]</a> are nonvolatile to the application
<pre	style="font-family:times-roman">
<p>
	because <a style="font-family:courier">[ SIMD_RUNCOUNT SIMD_AU SIMD_RESTART SIMD_XU ]</a> are the same registers as <a style="font-family:courier">[ RDATAC RDATA WDATAC WDATA ]</a>
	filestream libraries save and restore <a style="font-family:courier">[ RDATAC RDATA WDATAC WDATA ]</a>
</pre>
Kernels launch all threads with <a href="#A2_2" style="text-decoration:none">SIMD array one object deep at the stack top</a>
so that the application has <a href="rta.html#A2_2">alternative accumulators</a> to <a style="font-family:courier">[ a b mantissa2 mantissa3 ]</a>
<pre	style="color:#00AF6F;font-size:12pt">

	<a style="color:#00AF6F">SIMD_CONTROL	(-1, 0, 0, 0q)</a>

</pre>
If accumulator vector q designates any register outside the range 24..127
the thread faults with interrupt GUARD$ latent parameter permission

<p>
Macro SIMD_CONTROL takes a quadword argument containing <a style="font-family:courier">[ SIMD_RUNCOUNT SIMD_AU SIMD_RESTART SIMD_XU ]</a>

<p>
The frame defined by SIMD_CONTROL is the <a href="#A2_7">default accumulator vector</a> starting internal stack top with length RESTART_COUNT = SIMD_RESTART+1 objects
<pre	style="color:#00AF6F;font-size:12pt">

	<a style="color:#00AF6F">SIMD_CONTROL	(-1, ACCUMULATOR_UPDATE, RESTART_COUNT-1, EA_INCREMENT:q)</a>

</pre>
where -1 causes accumulator vector initialisation and final count restart

<p>
ACCUMULATOR_UPDATE is the operand size in words unless
<pre	style="font-family:times-roman;color:#0000FF">

	the operation is executed once and an accumulator vector update is never used

	the operation is repeated on one destination and accumulator vector update is zero

	internal stack registers are organised in differently treated <a href="#rex_lane">lanes</a>
	accumulator vector update is the number of registers in a tuple

	the repeated operation is <a href="#A2_5">test / skip</a> and does not use internal stack accumulators

</pre> 
RESTART_COUNT-1 in register SIMD_RESTART restarts final count when <a href="#sim_d2">rex</a> instruction starts with final count = -1 = EXPIRED

<p>
RESTART_COUNT-1 is one less than iterations, which stop when final count RDATAC reaches -1 = EXPIRED

<p>
EA_INCREMENT is the &plusmn; index register update which may be widely dispersed to gather structure members

<p>

<a	name="simd_target"/>

To operate on an object inside the stack top frame,
a macro <a href="#A2_6" style="text-decoration:none">SIMD_TARGET</a> updates accumulator vector q 1st argument
and writes zero or 2nd argument - 1 to final count register RDATAC

<p>
Accumulator argument is the base+displacement name of a dynamic variable or a parameter in the internal stack

<p>
Optional second argument is how many iterations, default 1
<pre	style="color:#00AF6F;font-size:12pt">

		<a href="#A2_6" style="text-decoration:none">SIMD_TARGET</a>	single_dynamic_object_name			. no 2nd argument needed

		<a href="#A2_7" style="text-decoration:none">SIMD_TARGET<a>	first_dynamic_object_name	HOW_MANY	. 2nd argument = objects

</pre>


<a	name="A2"/>
<h2>A2	Examples</h2>
<a	name="A2_1"/>
<h3>A2.1	Loading / Storing the Internal Stack with Unrolled Push and Pop Operations</h3>
<pre	style="color:#00AF6F;font-size:12pt">

	LANES	$equ	25				. use 100 registers

		<a href="#rex_regs" style="color:00AF6F;text-decoration:none">SIMD_CONTROL	(-1, 4, LANES-1, 12q)</a>	. floating dest = 4-word blocks, Data Point 2 index increment 12 words

	?	$do	LANES,	qpush	source_table(1)+LANES*12-?*12+8	. load multiple Data Point 1 to multiple dest
									. from last 4 words of 12-word structures
		lx	source_table(2),,xi
		rex	(fm	8, x)					. 25 multiplications
		lx	source_table(3),,xi
		rex	(fa	8, x)					. 25 additions
		lx	source_table(4),,xi
		rex	(fan	8, x)					. 25 subtractions
									. store multiple results
	?	$do	LANES,	qpop	dest_table+?*12-12+8		. to last 4 words of new 12-word structures

	. the unrolled quad pushes and pops are standard instructions not repeat instructions
	. implementation depending it should be possible to read and write memory as fast as the data bus can go
	. RTA1 internal stack is an array of registers loaded by push operations and stored by pop operations
</pre>
<a	name="A2_2"/>
<h3>A2.2	Alternative Accumulators at the Internal Stack Top</h3>

macro <a href="#rex_regs" style="color:#00AF6F;text-decoration:none">SIMD_CONTROL (-1, 0, 0, 0q)</a> sets a SIMD array one object deep at the internal stack top.

<p>
The one-deep SIMD array is available as alternative accumulators. Kernels launch all threads with this setting
<pre	style="color:#00AF6F;font-size:12pt">

		<a href="#rex_regs" style="color:#00AF6F;text-decoration:none">SIMD_CONTROL	(-1, 0, 0, 0q)</a>

		rex	(fm	left)	. compute on stack top
		fm	right		. compute in regular accumulators 4..7
		rex	(fa	a)	. add the products on the stack top

</pre>
<a	name="A2_3"/>
<h3>A2.3	Loading / Storing the Internal Stack with Repeat Load and Store Operations</h3>

Loads and stores may be repeat-executed instead of coding <a href="#A2_1">multiple unrolled push and pop</a> instructions

<p>
Repeated loads and stores process all in the same direction as repeated calculations and may operate with the same
SIMD_CONTROL parameters if the storage density of Data Points 1 and Data Points 2 is identical

<p>
Registers used as table pointers increment seamlessly through input and store tables however many SIMD passes are needed
<pre	style="color:#00AF6F;font-size:12pt">

		SIMD_CONTROL	(-1, REGISTERS2, LANES-1, CONTAINER_SIZE:q)
		lx	source1_table,,xi
		ly	source2_table,,xi
		la	output_table,,xi
		lr	TABLE_SIZE//LANES-1,,xi

	keep_going
		rex	(dl	OFFSET_IN_CONTAINER, x)		. LANES * load
		rex	(da	OFFSET_IN_CONTAINER, y)		. LANES * update
		rex	(ds	OFFSET_IN_CONTAINER, a)		. LANES * store
		jdr	keep_going

</pre>
<a	name="A2_4"/>
<h3>A2.4	Loading / Storing the Internal Stack with Datafile Reads and Writes</h3>

Loading and storing the internal stack with pipes or datafiles maintains arrays of
densely packed Data Point 1 and output datapoints on fixed storage

<p>
Source2 datapoints may be packed or scattered
<pre	style="color:#00AF6F;font-size:12pt">
	routine	$head_near	 params(input1_fd,	int		;
					output_fd,	int		;
					datapoints2p,	int	)	;
									;
				scalars(array,	LANES*4			)

		SIMD_CONTROL	(-1, REGISTERS4, LANES-1, CONTAINER_SIZE:q)

	keep_going
		c	(read)	input1_fd	array,,i	LANES*4,,xi	. length in data words
		jna	read_problem
		jza	end_of

		lx	datapoints2p
		rex	(fm	OFFSET_IN_CONTAINER, x)
		sx	datapoints2p

		c	(write)	output_fd	array,,i	LANES*4,,xi	. length in data words
		jna	write_problem
		j	keep_going

	end_of
	read_problem
	write_problem

		$ret	. return whatever status you have

</pre>

<a	name="A2_5"/>
<h3>A2.5	Table Searches with Repeat Test and Skip Instructions</h3>

<pre	style="color:#00AF6F;font-size:12pt">

<a	name="rex_tz"/>
	. tz repeat execution example

		SIMD_CONTROL	(-1, 0, STRUCTURES_IN_SEARCH-1, CONTAINER_SIZE:q)
		lx	table,,xi
		rex	(tz	OFFSET_IN_CONTAINER, x[, {t1|t2|t3}|{h1|h2}])
		j	zero_not_found
				j	zero_slot_found

<a	name="rex_tp"/>
	. tp repeat execution example

		SIMD_CONTROL	(-1, 0, STRUCTURES_IN_SEARCH-1, CONTAINER_SIZE:q)
		lx	table,,xi
		rex	(tp	OFFSET_IN_CONTAINER, x[, {t1|t2|t3}|{h1|h2}])	. bytes are sign extended
		j	all_slots_marked_negative
		j	positive_slot_found


<a	name="rex_mta"/>
	. mta repeat execution example

		lk	MASK
		la	search_value
		SIMD_CONTROL	(-1, 0, STRUCTURES_IN_SEARCH-1, CONTAINER_SIZE:q)
		lx	table,,xi
		rex	(mta	OFFSET_IN_CONTAINER, x)
		j	not_present
		j	found

<a	name="rex_dte"/>
        . dte repeat execution example

	       dl      search_key
               SIMD_CONTROL    (-1, 0, STRUCTURES_IN_SEARCH-1, CONTAINER_SIZE:q)
               lx      table,,xi
               rex     (dte    OFFSET_IN_CONTAINER, x)
               j       not_in_table
               j       hit

</pre>
<a	name="A2_6"/>
<h3>A2.6	Single Target within SIMD Frame</h3>

macro SIMD_TARGET updates Accumulator Vector q to one or more adjacent objects
anywhere in the internal stack for the next Repeat Execute instruction
<pre	style="color:#00AF6F;font-size:12pt">
	SIMD_TARGET	single_target_name 

</pre>
The default count of objects is one. The running count is -1 after the targeted operation,
prompting reinitialisation to the SIMD_CONTROL parameter at a subsequent <a href="#rex">SIMD operation</a>

<p>
In this example macro <a style="color:#FF0000">SIMD_TARGET</a> updates accumulator vector q to an object
<a style="color:#FF0000">another1</a> at internal stack top + one float displacement for a single operation

<pre	style="color:#00AF6F;font-size:12pt">
                                summary	$head_near	 params(along,	float)	;
                                						;
                                			scalars(<a style="color:#FF0000">another1</a>,	float,	(2.0),,float		;
(+04)0f
00:000018  8F0005              +35 				one_off,	float,	along			)
00:000019  8FF006              +35 
  :                            36 
(+04)0f
00:00001A  8F0009              +37 	SIMD_CONTROL	(-1, 0, 0, 0q)		. single operation at internal stack top
00:00001B  870014              +37 						. no source-2 index register increment
  :                            38 						. no accumulator vector increment
  :                            39						. kernels launch all threads with this setting
(+04)0f
00:00001C  740011              +40 	rex	(fd	(3.0e-60000))		. divide on stack top [object called one_off]
  :                            41 
(+04)0f
00:00001D  4F0012              +42 	ql	(0.333333333333333333333e50000)
00:00001E  77F00A              +43 	fm	along				. multiply in regular accumulators [ 4..7 ]
  :                            44 
<a style="color:#FF0000">00:00001F  FCF004              +45 	SIMD_TARGET	another1		. single operation inside the internal stack</a>
00:000020  38000D              +45 
00:000021  300014              +45 
(+04)0f
00:000022  740016              +46 	rex	(fm	a)			. multiply next object after stack top
  :                            47 
  :                            48 						. return 3 results in available scalar registers
00:000023  870008              +49 	qpop	OUTPUT(2)			. object one_off from internal stack top
00:000024  870010              +50 	qpop	OUTPUT(3)			. object another1 next on internal stack
00:000025  350000              +51 	lret	0				. regular accumulators [ 4..7 ] also contain a result

</pre>

<a	name="A2_7"/>
<h3>A2.7	Target Group within SIMD Frame</h3>

Macro SIMD_TARGET updates accumulator vector to stack top + 6 floats for 12 floats
<pre	style="color:#00AF6F;font-size:12pt">

	SIMD_TARGET	<a style="color:#FF0000">6*4, sp</a>	12

</pre>

<p>
SIMD_RUNCOUNT decrements to -1.
Subsequent Repeat Execute instructions reinitialise Accumulator Vector to SIMD_CONTROL setting

<p>	
<pre	style="color:#00AF6F;font-size:12pt">

00:00050A  FDFFA1              +827 	push	-95,,xi				. 96-word frame
00:00050B  2F000F              +828 	popA	sp
  :                            829 
00:00050C  8F0738              +830 	SIMD_CONTROL	(-1, 4, 24-1, 4q)	. default vector is frame of 24 floats
00:00050D  870014              +830 
  :                            831 
                                	lx	(zlist	1.0, 2.0, 3.0, 4.0, 5.0, 6.0,		;
                                			7.0, 8.0, 9.0, 10.0, 11.0, 12.0,	;
                                			13.0, 14.0, 15.0, 16.0, 17.0, 18.0,	;
00:00050E  55073C              +835 			19.0, 20.0, 21.0, 22.0, 23.0, 24.0),,xi
  :                            836 
00:00050F  74079C              +837 	rex	(ql	0, x)		. load SIMD Frame 24 * 96-bit float
  :                            838 					. register increment and ea increment are both 1 float
  :                            839 					. 12 floats in storage to add
  :                            840 
00:000510  55079D              +841 	lx	(zlist	20.0, 21.0, 22.0, 23.0, 24.0, 25.0, 26.0, 27.0, 28.0, 29.0, 30.0, 31.0),,xi
  :                            842 
  :                            843 						. vector is 12 floats (48 words)
00:000511  FCF018              +844 	<a style="color:#FF0000">SIMD_TARGET	6*4, sp	12</a>		. @ frame + 6 floats (24 words)
00:000512  38000D              +844 
00:000513  FD000B              +844 
00:000514  380014              +844 
00:000515  7407CD              +845 	rex	(fa	0, x)			. 12 floating operations
  :                            846 
00:000516  553094              +847 	lx	outline,,xi			. start print stream
00:000517  FF07CE              +848 	call	(wstream_starta)		. this overwrites SIMD control registers
  :                            849 						. but SIMD default controls are restored after
  :                            850 
00:000518  450003              +851 	lr	4-1,,xi				. 4 lines
  :                            852 
  :                            853 publish_line
00:000519  003093              +854 	sr	count1	
00:00051A  450005              +855 	lr	6-1,,xi				. * 6 floats
  :                            856 
00:00051B  003092              +857 publish	sr	count
00:00051C  6007CF              +858 	la	(' '*/16)
00:00051D  1D0008              +859 	wsr	$byte
00:00051E  170010              +860 	inc	BYTES
00:00051F  870004              +861 	qpop	a				. take a float off the internal stack top
00:000520  FF07D0              +862 	call	(feditia)			. compose it into the display line
00:000521  403092              +863 	lr	count
00:000522  1E051B              +864 	jdr	publish
  :                            865 
00:000523  6007D1              +866 	la	(LF*/16)
00:000524  1D0008              +867 	wsr	$byte
00:000525  170010              +868 	inc	BYTES
00:000526  403093              +869 	lr	count1
00:000527  1E0519              +870 	jdr	publish_line
  :                            871 
00:000528  1D0010              +872 	wsr	$word-$byte			. push out last bytes
  :                            873 
00:000529  F80010              +874 	c	(write)	stdout	outline,,xi	BYTES
00:00052A  FD3094              +874 
00:00052B  FD0001              +874 
00:00052C  FCF003              +874 
00:00052D  FF07D2              +874 
00:00052E  38000F              +874 
00:00052F  FD0001              +875 	c	(fsync)	stdout
00:000530  FCF001              +875 
00:000531  FF07D3              +875 
00:000532  38000F              +875 
  :                            876 
00:000533  8F067F              +877 	SIMD_CONTROL	(-1, 0, 0, 0q)		. restore SIMD default controls
00:000534  870014              +877 
00:000535  350000              +878 	lret	0


	<a style="color:#0000FF">telnet	172.29.7.7</a>
	RTA1 smaragd7 OS shared console

	<a style="color:#0000FF">r load /util/tal</a>
	00001d
	loader: load /util/tal

	[000050000018:001000003238]
	000022 

	<a style="color:#0000FF">test rex_vector</a>
	 +1.000 +2.000 +3.000 +4.000 +5.000 +6.000
	<a style="color:#FF0000"> +27.000 +29.000 +31.000 +33.000 +35.000 +37.000
	 +39.000 +41.000 +43.000 +45.000 +47.000 +49.000</a>
	 +19.000 +20.000 +21.000 +22.000 +23.000 +24.000

</pre>

If default SIMD configuration is required again it must be set again as line 877
<pre	style="color:#00AF6F;font-size:12pt">>
		SIMD_CONTROL	(-1, 0, 0, 0q)

</pre>
<a	name="simd_resume"/>
<h3>A2.8	 Resuming a SIMD Sequence of Floating Operations after Fault Handling</h3>

<a href="kernel.html#xpo_ii">FP_XPO$</a> fault during a SIMD sequence leaves outstanding operations in the SIMD sequence not yet executed
but does not halt the execution of the thread. The event is instead OR-summed in the thread control block

<p>
service call interrupt <a href="kernel.html#fp_xpo_flag_ii">ii XPO$FLAG</a> can be applied to catch a faulted calculation and the SIMD sequence resumed 

<p>
If <a href="kernel.html#fp_xpo_flag_ii">FP_XPO$FLAG</a> returns + zero (no skip),
a jump or call can be made in the application to process the event

<p>
pointers and counters in SIMD control registers [ SIMD_RUNCOUNT SIMD_AU SIMD_RESTART SIMD_XU q ] identify
the faulted operation and how many remain

<p>
an application handler should update these registers to resume executing outstanding operations

<pre	style="font-family:times-roman;color:#0000FF">
	if the <a href="#simd_i">repeated instruction</a> uses an index register to generate its
	source-2 operand effective address, SIMD_XU must be added to the index register

	SIMD_AU must be added to accumulator vector q

	SIMD_RUNCOUNT is the outstanding count and must be decremented to count past the faulted operation

	If SIMD_RUNCOUNT becomes consequently negative, operations are already complete because the
	faulted operation is the last in the sequence

</pre>
In this example processing 192-bit floating numbers, the accumulator vector increment SIMD_AU
is eight words, and so in the example is the index register increment SIMD_XU
<pre	style="color:#00AF6F;font-size:12pt">

  :                            224 
  :                            225 island_coda		. exponent outflow. ISR stopped SIMD repeats
  :                            226 			. without updating accumulator vector / operand index register
  :                            227 			. both were left pointing at operands of failed operation
  :                            228 
  :                            229 			. if you want to do stuff like printf
  :                            230 			. save any index register used in the SIMD -> target instruction
  :                            231 
00:000155  800017              +232 	ax	SIMD-XU	. increment you must know which index register
00:000156  F80015              +233 	push	SIMD_AU	. advance accumulator vector
00:000157  2F000D              +234 	popA	q	. 
  :                            235 
00:000158  1F0014              +236 	dec	SIMD_RUNCOUNT	. outstanding count relative zero
00:000159  780014              +237 	tp	SIMD_RUNCOUNT	. if this transitions RDATAC to -1
00:00015A  350000              +238 	lret	0	. it means fault was on last operation in list
00:00015B  35FFFD              +239 	lret	-3	. otherwise restart SIMD operation to do outstanding operations
	

		--------------------------------------

  :                            205 
(+04)10
00:00013D  550000              +206 	lx	table2,,xi
(+04)0f
00:00013E  8F00FF              +207 	SIMD_CONTROL	(-1, 8, 12-1, 8q)	. primed to initialise, 12 objects, 
00:00013F  870014              +207 						. vector + source-2 increments 8 words
00:000140  050008              +208 	on	fp$r				. 192-bit floating operations
(+04)0f
00:000141  740103              +209 	rex	(fm	0, x)			. operate
00:000142  75004E              +210 	ii	FP_XPO$FLAG			. check
(+00)0f
00:000143  3E0155              +211 	lcal	island_coda			. there was a fault, react
(+04)0f
00:000144  8F0104              +212 	SIMD_CONTROL	(-1, 0, 0, 0q)		. reset SIMD defaults
00:000145  870014              +212 

</pre>
<hr/>

<pre><i>

    LICENCE NOTICE

    Copyright Tim Cox, 2012
    TimMilesCox@gmx.ch

    This processor programmable architecture specification
    is the principal and central work delivered here.

    It is the specification of the freeware processor architecture

                RTA1

    RTA1 is a free processor architecture specification. It is licensed
    under the GNU General Public Licence Version 3

    The executable emulation of RTA1 is free software.

    Instruction code for the target RTA1 architecture is free software
    if it is delivered with this software

    Software programs delivered with this software to connect the
    emulated RTA1 with real network interfaces in the emulator host
    are free software

    Scripts and programs delivered with this software for running
    on other computers and interacting with the RTA1 are free software

    Scripts and utility programs for constructing RTA1 target
    executable software are free software

    You can redistribute it and/or modify RTA1
    under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    RTA1 is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with RTA1.  If not, see &lt;http://www.gnu.org/licenses/&gt;.

</i>
</pre>
</div>
</html>
