<html>
<div	style="font-size:14pt">
<center>
<h1>
	The RTA1 Processor Architecture
</h1>
<i>
Copyright Tim Cox, 2012<br>
RTA1 Architecture is freeware licensed with the GNU General Public Licence Version 3<br>
This processor programmable architecture specification is the principal and central subject of the licence<br>
The same licence encompasses all accompanying software and documentation <br>
The full licence text is included with these materials<br>
See also the licensing notice at the foot of this document
</i>
<h2>
	Programmable Architecture Specification
</h2>
</center>

<a	name="oview"/>
<div	style="margin-left:60pt">
<i>

<p>
RTA1 is a computer processor architecture which has run in emulation on Unix host computers since January 2012
<p>
Scalability is claimed for the RTA1 architecture. It can run simple dedicated
microcontroller applications in a few dozen words of storage,<br> and it can run 
as a major system maintaining some millions of TCP connections simultaneously

<p>
RTA1 is designed for symmetric multiprocessing, an important plane of scalability

<p>
A compact internal stack gathers operands as functions are traversed, eliminating level-1 operand cache

<p>
RTA  I/O space is a further plane of scalability<br><br>

I/O ports<br>
  &nbsp;&nbsp;&nbsp;&nbsp;multicast and unicast interrupts between SMP instruction processors
  for true synchronisation and exact realtime response<br>

  &nbsp;&nbsp;&nbsp;&nbsp;organise memory space<br>

  &nbsp;&nbsp;&nbsp;&nbsp;manage energy<br>

  &nbsp;&nbsp;&nbsp;&nbsp;add system functionality flexibly<br>

<p>
Excellent code density is claimed for RTA1. The emulated prototype runs
IP, UDP and TCP in 3750 instructions

<p>
Another 4000 instructions run Telnet, MIB-II and snmp v1, a simple HTTP 
server,<br>and a floating point server program for online interaction with
RTA1 96-bit / 192-bit floating architecture

<p>
IP in the emulated prototype is interfaced to real networks.<br>RTA1 Telnet,
SNMP, HTTP, ICMP and floating point server interact with other computers


</i>
</div>

	<a	name="index"/>
	<ol>
		<li><a href="#quoview">Overview</a></li>
		<ol>
			<li><a href="#geometry">Geometry</a></li>
			<li><a href="#glossary">Essential Glossary</a></li>
		</ol>
		<li><a href="#spaces">Address Spaces</a></li>
		<ol>
			<li><a href="#exar">Executable Space and Array Space</a></li>
			<li><a href="#aspace">Address Space</a></li>
			<li><a href="#ospace">Operand Address Space</a></li>
			<li><a href="#ispace">Instruction Frame and IFrame Name</a></li>
			<li><a href="#istack">The Internal Stack</a></li>
			<li><a href="#asum">Address Space Summary and Diagram</a></li>
			<ol>
				<li><a href="#space_summary">Summary of Instruction and Operand Address Spaces</a></li>
				<li><a href="#address_array">Addressing Arrays</a></li>
				<li><a href="#large_array">Large Arrays</a></li>
				<li><a href="#ultra_array">Ultra-Large and Distributed Arrays</a></li>
				<li><a href="#multi_word">Multi-Word Write Operands straddling Address Windows</a></li>
			</ol>
			<li><a href="#protection">Protection and Safety</a></li>
			<ol>
				<li><a href="#xlimit">Execution Protection</a></li>
				<li><a href="#safety">Operand Protection</a></li>
				<li><a href="#optimal_safe">Optimal Safe Storage Practice</a></li>
				<li><a href="#device">Device Array Protection</a></li>
			</ol>
			<li><a href="#thread">Thread Switch and Address Space</a></li>
			<li><a href="#ioport">I/O Ports for Inter-Processor Signaling / Memory and Peripheral Configuration / Timer Restart</a></li>
			<ol>
				<li><a href="#iosignal">I/O Ports for Inter-Processor Signaling</a></li>
				<li><a href="#iomem">I/O Ports for Memory and Peripheral Configuration</a></li>
				<li><a href="#iotimer">I/O Port for Timer Interval Restart</a></li>
				<li><a href="#iolist">I/O Port Assignments List</a></li>
			</ol>
			<li><a href="#iassign">Interrupt Assignments</a></li>
		</ol>
		<li><a href="#regisi">Registers and Instruction Set</a></li>
		<ol>
			<li><a href="#nonar">Non-Addressable Registers</a></li>
			<li><a href="#register">Addressable Application and Interrupt Registers</a></li>
			<li><a href="#iset">Instruction Set Summary</a> and <a href="#lookup">Lookup Panel</a></li>
			<li><a href="#ifield">Instruction Layout and Effective Address Generation</a></li>
			<ol>
				<li><a href="#layout">Instruction Layout</a></li>
				<li><a href="#ea">Effective Address Generation</a></li>
				<li><a href="#ocodes">Operand Codes and Instruction Files</a></li>
			</ol>
			<li><a href="#isymbol">Instruction Field Summary and Programming Symbols</a></li>
			<li><a href="#instru">Instructions</a></li>
			<ol>
				<li><a href="#i24s"><i>Integer Store Instructions</i></a></li>
				<li><a href="#i24l"><i>Integer Load Instructions</i></a></li>
				<li><a href="#i24t"><i>Integer Test Instructions</i></a></li>
				<li><a href="#i24x"><i>Index Register Add Instructions</i></a></li>
				<li><a href="#i24b"><i>Boolean Instructions</i></a></li>
				<li><a href="#i24a"><i>Integer Arithmetic Instructions</i></a></li>
				<li><a href="#io"><i>I/O Ports Input and Output Instructions</i></a></li>
				<li><a href="#relo"><i>Process and Thread Memory Switch Instructions</i></a></li>
				<li><a href="#onoff"><i>PSR Flags Update Instructions</i></a></li>
				<li><a href="#bstream"><i>Bit Stream Read and Write Channels</i></a></li>
				<li><a href="#lfiret"><i>Return Instructions and Internal Interrupt</i></a></li>
				<li><a href="#shijo"><i>Shift and Jump Instructions</i></a></li>
				<li><a href="#modify"><i>Target Modify Instructions</i></a></li><br>
				<li><a href="#scala"><i>Double and Quadword Load and Store<br>
					Masked, Execute, and Scale Operations<br>
					Large Integer Arithmetic</i></a></li><br>
				<li><a href="#fp"><i>96-Bit and 192-Bit Floating-Point<br>
					Rounding Setting<br>
					Exponent Underflow and Overflow Handling<br>
					Floating 48-Bit Compression</i></a></li><br>
				<li><a href="#gocall"><i>Far Go and Call</i></a></li>
			</ol>
		</ol>
	</ol>

	<ul	type="none">

	<li><a href="#sim_d">Appendix A: Quasi-Simultaneous Instruction Repeat Model</a></li>

	</ul>

<a	name="quoview"/>
<h2>1. Overview</h2>

<a	name="geometry"/>
<h3>1.1 Geometry</h3>
<p>
RTA1 is a 24-bit word-addressing architecture with 24- 48- and 96-bit arithmetic.<br>
For unusual requirements RTA1 can calculate 192-bit floating values

<p>
The addressable storage location is the 24-bit computer word. Instructions are one computer word in size

<a	name="glossary"/>
<h3>1.1 Essential Glossary</h3>
<pre	style="font-size:11pt">

	<a	name="start_pagex"/>
	<a	style="color:#0000FF">
	Start Page Index</a>	Start Page Index is a 4096-word memory block number
				identifying the start of assigned memory

	<a	name="iframe"/>
	<a	style="color:#0000FF">
	instruction frame</a>	an instruction frame is one or more pages of memory containing instructions and constants
				an instruction frame is an callable entity with entry points
				and may contain a library or one or more applications in part or total

	<a	style="color:#0000FF">
	Iframe Name</a>		Iframe Name is the 22-bit Start Page Index of an instruction frame
				tagged by two flag bits valued

					00	for an instruction frame of one page

					10	for an instruction frame of more than one page

						_________________________________________
				iframe name	| 00 |		Start Page Index	|
						| 10 |__________________________________|
						     |21			       0


	<a	name="vector"/>
	<a	style="color:#0000FF">
	vector</a>			a vector is a 24-bit value identifying an entry point in
				a fixed one-page instruction frame in the first 256 Megawords of system memory

				Start Page Index in a vector is 16 bits in size. Six bits are a vector offset


						_________________________________________
				vector		| 00 |	   Start Page Index    | offset	|
						|____|_________________________|________|
						     |21		      6|5      0

	<a	name="gate"/>
	<a	style="color:#0000FF">
	gate</a>			a gate is the 48-bit descriptor of an entry point at any offset
				in a an instruction frame up to 64 pages in size
				at a fixed load image position or a dynamic loadable position

				bits 47 to 42 of a gate descriptor are the Page High Index of the gate
				Page High Index is instruction frame pages minus one

				a target instruction frame of one page therefore has Page High Index zero

				the second word of the gate descriptor is Iframe Name
				flag bits 23:22 of Iframe Name are 10 if Page High Index is nonzero



			_________________________________________________________________________________
	gate		| pppppp |		offset		| 00 |		Start Page Index	|
			|________|______________________________| 10 |__________________________________|
			       42|			      24|    |21			       0

</pre>

<a	name="spaces"/>
<h2>2. Address Spaces</h2>


<a	name="exar"/>
<h3>2.1	Executable Space and Array Space</h3>

<p>
RTA1 places blocks of 4096 words or 262144 words in 64 windows of address space

<p>
These documents sometimes call 4K a page and 256K a bank

<p>
The limit of executable space (or system memory) is 16 gigawords. Executable space
is not all in the address space at once

<p>
The primary objective of a compact address space is compression but there are also
gains in security and locality of reference

<p>
Additional arrays up to one teraword total which are not part of executable space
may be added

<p>
RTA1 documentation calls these additional arrays devices, and they may each contain up to<br>
16 gigawords of 8- 16- or 24-bit memory. Device arrays may include among other applications<br>
video RAMs, dual-ported 16-bit network buffers, and memory-addressable 24-bit filestores

<p>
The compressed layout of relocation registers allows one space of 16 gigawords<br>
to be organised in windows of 4K Words. 4K organisation is needed for executable space

<p>
64 * 16-gigaword device arrays may at the same time be organised in windows of 256K words.<br>
System memory or executable space is device array 0 and is is the only device array which<br>
may be organised in windows either of 4096 words or of 262144 words

<p>
Relocation registers are one word in size to minimise cycles at context switch and to make<br>
relocation values the width of I/O ports. Each relocation register is implemented in one I/O port
<pre	style="font-size:11pt">


				    executable space 16 gigawords
				    _____________________________

			 ________________________________________________
			 | 22 page select bits	        | 12 offset bits|
			 |______________________________|_______________|
			 | 16 bank select bits |          18 offset bits|
			 |_____________________|________________________|


				    array space 1 teraword
				    ______________________

		_________________________________________________________
		| device | 16 bank select bits |          18 offset bits|
		|________|_____________________|________________________|








				    relocation pointer value, 4K page 
				    _________________________________

				    _____________________________________
				    | 00 | 22 page select bits		|
				    |____|______________________________|




				    relocation pointer value, 256K bank
				    ___________________________________

				    _____________________________________
				    | 01 | 16 bank select bits | device	|
				    |____|_____________________|________|


</pre>
Bit 22 of the relocation pointer is "big" or "big bank".
Device 0 is system memory, so system memory is placed in the address space
in ranges of 4096-word blocks or in ranges of 262144-word blocks.

<p>
Device arrays can be placed in the address space in ranges of 262144-word blocks
<pre	style="font-size:11pt">

	_________________________________________________________________________________
	|										|
	|			ADDRESS SPACE AND EXECUTABLE SPACE			|
	|_______________________________________________________________________________|
	|										|
	|                                                                               |
	|										|
	|	Address space is the space which the effective address can reach	|
	|       i.e. the space which code can see at one moment             		|
	|										|
	|	Different memory can be in the address space at different times		|
	|										|
	|	Executable space is all configured memory that can be used for both	|
	|	code and data								|
	|										|
	|	In RTA1 case that's the maximum 16 Gigawords of Device 0		|
	|	which is 1024 times the address space					|
	|										|
	|	RTA1 needs program memory to be						|
	|										|
	|		relocation-register-selectable in 4K-word pages			|
	|		and in 256K-word banks						|
	|										|
	|		24-bit-word writable / readable					|
	|										|
	|			optimally readable in bursts of 1 / 2 / 4 / 8 words	|
	|			at any 24-bit word address				|
	|										|
	|			optimally writable in bursts of 1 / 2 / 4 words		|
	|			at any 24-bit word address				|
	|										|
	|		able to do atomic read-modify-write on a single word		|
	|		at least when in SMP configuration				|
	|										|
	|										|
	|	Arrays outside executable space cannot be based at 4K-word granularity	|
	|	and need not necessarily read-rewrite atomically			|
	|										|
	|_______________________________________________________________________________|


</pre>

<a	name="aspace">
<h3>2.2 Address Space</h3>

<p>
RTA1 has two 16-megaword address spaces, one each for instructions and operands

<p>
There is overlap between instruction and operand spaces to allow constants to be embedded in code

<p>
Instruction address space is one memory window which may move over all the 16-gigaword executable space

<p>
The operand address space has many simultaneous fixed and moving windows on the 16 gigaword executable space and the teraword array space


<a	name="ospace"/>
<h3>2.3 Operand Address Space</h3>
<p>
Operand address space starts with the 256 registers, except for instructions
<a href="#ts">Test and Set</a> and <a href="#ex">Execute</a>
<pre	style="font-size:11pt">

					__________________________________
					| 0000 0000 0000 0000 | register |
					|_____________________|__________|


</pre>
Above address 256, operand address space is 16 megawords in 64 windows

<p>
From effective address 256 to 262143, address bits 17..12 select window 0..63
<pre	style="font-size:11pt">

					__________________________________
					|000 000| window| 12 offset bits |
					|_______|_______|________________|
					| window|         18 offset bits |
					|_______|________________________|


</pre>
<p>
From effective address 262144, address bits 23..18 select window 1..63.

They are the same windows wider open

<p>
The 6-bit window index corresponds to a relocation pointer in I/O ports 0..63
(or to certain switchable alternatives in I/O ports 65..71)

<a	name="ispace"/>
<h3>2.4 Instruction Frame and IFrame Name</h3>

<p>
Instructions are read from the Instruction Frame window B0

<p>
Window B0 is memory starting at the 4K-word block-edge pointed by I/O Port 0

<p>
The last page of the the Instruction Frame is pointed in I/O Port 64

<p>
The simplest iframe is a single page

<p>
I/O port 64 contains [B0] + IFrame Pages - 1.

<p> 
I/O ports 0 and 64 are written by far call / far return instructions and interrupt / interrupt return

<p>
Instructions are read from the leading edge of window B0 and not from
registers or any different address window

<p>
The 48-bit program counter is absolute. B0 Page Index * 4096
is added to make jump addresses absolute and subtracted to make saved addresses relative

<p>
Words 256..4095 of window B0 are in the operand address space as well as the
instruction window

<p>
IFrame Name is the 22-bit Iframe Start Page Index and two flag bits determining IFrame Size.
<pre	style="font-size:11pt">

					__________________________________
					| ff |       B0 Page Index	 |
					|____|___________________________|
					   22|				0

</pre>
IFrame Name updates as an iframe is entered and is stacked for return when the iframe calls out or interrupts

<p>
IFrame Start Page Index stripped of flags is written to base B0 in I/O Port 0 for operand addressing,
and is used to form an absolute program counter address B0 * 4096 + offset on entry or return into the iframe

<p>
The way flag bits 23:22 determine IFrame Size is explained with instructions
<pre	style="font-size:11pt">

	<a	href="#gocall">far go and call</a>

	<a      href="#fret">far return</a>

	<a      href="#ir">interrupt return</a>

</pre>
<a	name="istack"/>
<h3>2.5 The Internal Stack</h3>
<p>
RTA1 is intended to work very fast without having operand cache

<p>
The large array of scratch registers is organised in an internal stack which gathers operands as functions are traversed

<p>
In the absence of operand cache, SMP configurations do not need cache coherency electronics

<p>
Software avoids double updates by recognising the scope of test-and-set locks

<p>
The internal stack has a logic footprint infinitessimally smaller than any level-one cache, 
but can produce a very large performance advantage

<p>
The part of the register stack available to an application is 128 words, and the part
of it organised in an internal stack is 104 words

<p>
At thread switch RTA1 swaps 128 application registers in 32 instructions

<p>
The working of the internal stack is somewhat inverse to an external stack.

<p>
Push and pop operands have an effective address in memory space

<p>
A push is a load into CPU registers in RTA1, and a pop is a store
<pre	style="font-size:11pt">


				A push is a load to the CPU in RTA1
				___________________________________


							_________________________________________
	________________________________		|					|
	|		|		|		|					|
	|		|		|		|					|
	|	CPU	|	scalar	|		|	total operand space
	|		|    registers	|		|	registers + storage + immediate values
	|		|		|		|
	|		|_______________|		|
	|		|	--sp	|		|
	|		|_______________|		|
	|				|		|
	|				|		|
	|				|		|
	|	________________________|				_________________
	|new stack top	|	+	|<------<--------<--------<-----|     data	|
	|		|_______________|				|_______________|
	|		|		|		|
	|		|   internal	|		|
	|		|      stack	|






				A pop is a store from the CPU in RTA1
				_____________________________________


							_________________________________________
	________________________________		|					|
	|		|		|		|					|
	|		|		|		|					|
	|	CPU	|	scalar	|		|	total operand space
	|		|    registers	|		|	registers + storage
	|		|		|		|
	|		|_______________|		|
	|		|	sp++	|		|
	|		|_______________|		|
	|				|		|
	|				|		|
	|				|		|
	|		_ _ _ _ _ _ _ _ |				_________________
	|				|------>------>-------->------->|     data	|
	|	________|_______________|				|_______________|
	|new stack top	|		|		|
	|		|   internal	|		|
	|		|      stack	|




</pre>


<a	name="asum"/>
<h3>2.6 Address Space Summary and Diagram</h3>

<pre	style="font-size:11pt">

	<a	name="space_summary"/>
	Summary of Instruction and Operand Address Spaces
	_________________________________________________


	Instructions are only obtained from window B0
	and B0 switches between instruction frames

	Operands may be obtained from the registers,
	from part of the actual instruction block in window B0,
	from the 63 actual application data blocks,
	from the seven alternative data blocks used by the kernel

	An application may have gigawords of storage
	in blocks from 4096 words to 16 gigawords in size

	Up to 63 blocks of 4096 words or 262144 words
	are at any time visible in 63 address windows

	Relocation Registers 1..63 are I/O ports 1..63

	Applications can change which blocks of storage
	are based in their 63 data address windows

	The thread current data spaces do not need to
	be saved at context switch. They are already
	mirrored in the Thread Control Block





	instruction address	|  operand address space
	space			|
	________________________|________________________				
	|0			|0			|
	|			|	registers	|
	|			|255____________________|				TCB and 6 kernel data windows B66..B71  
	|			 256			|				switch over application windows B1..B7
	|						| 
	|	  Window 0				|
	|						|
	|			 4095___________________|________________________
	|			|4096			|4096 alternative	|	thread control block B65
	|			|			|			|	is in adresses hex 001000..001FFF
	|			|	Window 1	|       Window 65	|	when PSR Flag see$1 = 1
	|			|			|	TCB		|
	|			|8191___________________|_______________________|
	|			|8192			|8192 alternative	|	kernel vector list B66
	|			|			|			|	is in adresses hex 002000..002FFF
	|			|	Window 2	|	Window 66	|	when PSR Flag see$2 = 1
	|			|	Vector List	|	Kernel Vectors	|
	|			|12287__________________|_______________________|
	|			|12288 or 786432	|12K / 768K alternative	|	kernel data windows B67..B71 
	|			|			|			|	populated with pages / banks
	|			|	Window 3	|	Window 67		as required
	|			|			|				and switch over windows B3..B7
	|			|16383_or_1048575_______|_______________________	in address space hex 003000..007FFF
	|			|16384 or 1048576	|16K / 1024K alternative|		   	  or 0C0000..1CFFFF
	|			|			|			|	per PSR flags see$3..see$7
	|			|	Window 4	|	Window 68
	|			|			|
	|			|_______________________|_______________________
	|			|20K or 1280K		|20K / 1280K alternative|
	|			|			|			|
	|			|	Window 5	|	Window 69
	|			|			|
	|			|_______________________|_______________________
	|			|24K or 1536K		|24K / 1536K alternative|
	|			|			|			|
	|			|	Window 6	|	Window 70	|
	|			|			|			|
	|			|_______________________|_______________________|
	|			|28K or 1792K		|28K / 1792K alternative|
	|			|			|			|
	|			|	Window 7	|	Window 71	|
	|			|			|			|
	|			|_______________________|_______________________|
	|			|32K or 2048K		|
	|			|			|
	|			|	Window 8	|
	|			|			|
	|			|_______________________|
	|			|36K or 2304K		|
	|			|			|
	|			|	Window 9	|
	|			|			|
	|			|_______________________|
	|			|40K or 2560K		|
	|			|			|
	|			|	Window 10	|
	|			|			|
	|			|_______________________|
	|			|44K or 2816K		|
	|			|			|
	


				|			|
				|			|
				|_______________________|
				|248K or 15872K		|
				|			|
				|	Window 62	|
				|			|
				|_______________________|
				|252K or 16128K		|
				|			|
				|	Window 63	|
				|			|
				|262143_or_16777215_____|




	<a	name="address_array"/>
	Addressing Arrays
	_________________

	Directly addressed application static data is in
	sequential address windows mapping continuous storage


	Arrays less than the address space in size can also be addressed all at once
	in one or more address windows

				_________________________
				|			|
		WINDOW n	|	.---------------|-------.
				|_______|_______________|	|
				|	|		|	|
		WINDOW n + 1	|	|		|	|
				|_______|_______________|	|<-----	array addressed
				|	|		|	|	in a range of
		WINDOW n + 2	|	|		|	|	address windows
				|_______|_______________|	|
				|	|		|	|
		WINDOW n + x	|	.---------------|-------.
				|_______________________|




	An array is one or more storage blocks each of any size up to 16 gigawords


	<a	name="large_array"/>
	Contiguous Large Arrays
	_______________________

	When an array is many times the address space in size, address windows
	are used as cursors in the array, fixing dynamically on buckets of one or
	two memory blocks

	For example

			dl		array_offset
			dsl		6		. separate the 262144-word block-id
							. from the word offset

			orB, xi		WINDOW		. tag the word offset
			rbr		6		. with an address window


		.	____________________________
		.	|WINDOW|    word offset    |	<- effective address
		.	|______|___________________|	   start of structure
		.					   in register b


			sal		6		. position the big-block index
			aa		array_start_bank. add the array start block-id

			sabr		WINDOW		. base the block where the structure
							. starts in the address window

			la, i		64, a		. identify the next big block
			sabr		WINDOW+1	. base that in the adjacent 
							. address window

							. register b is now a pointer to a
							. guaranteed 262145 words from the
							. leading edge of the structure

							. this array is any size up to
							. 16 gigawords


	<a	name="ultra_array"/>
	Ultra-Large and Distributed Arrays
	__________________________________

	Successive blocks of a large array need not be in physically continuous storage
	but if they are not, a list of lookup pointers is needed, in for example a vector block

	Applications may process arrays up to a teraword in size distributed over multiple device arrays



	<a	name="multi_word"/>
	Multi-Word Write Operands straddling Banks
	__________________________________________

	Burst reads and writes of two or four words are at any word address.
	There is no bus alignment larger than a word

	Instructions reading or writing an operand which straddles storage blocks
	serialise the operation to word pairs or to single words

	Base pointers are relocation registers addressed as I/O ports
	and select a block either of 4096 words (a "page") or 262144 words a (a "bank")


</pre>


<a	name="protection"/>
<h3>2.7 Protection and Safety</h3>
<pre	style="font-size:11pt">

	<a	name="xlimit"/>
	Execution Protection
	____________________

	Instruction code executes either as application code or interrupt service routines

	A kernel invariably contains both application code and ISRs

	Instruction execution advance or jump outside the current instruction frame raises interrupt GUARD$

	Instruction frame starts at the page indexed in Port B0. Port 64 points to the Instruction Frame final page

		Port 64 = B0 + Instruction Frame Pages - 1

	Some pages at memory start are reserved for interrupt code

	Applications cannot enter ISR space via far <a href="#call">call</a> or <a href="#go">go</a> instruction
	although ISRs can <a href="#call">call</a>, <a href="#go">go</a> and <a href="#fret">far return</a> in this space,
	and may call outside ISR space to ISR extensions in application space

	System call interrupts (<a href="#ii">ii instruction</a>), external and spontaneous interrupts enter ISR space

	ISR space is defined by start of memory and Application Threshold Page pointer I/O Port 72

		_________________________
		|	ISR space	|
		|_______________________|________application threshold
		|			|


	Application Threshold is set by the system image at startup

	Applications may not make service call interrupts to any pages except ISR space
	or into page zero termed the restart page

	The restart page is reserved for interrupts which are not service calls. These include

		restart

		soft restart elected by ISRs on serious anomaly

		<a href="kernel.html#external_i">external interrupts</a>

		floating exponent underflow / overflow

		time quantum incrementer overflow

		SMP core to core alert unicast / multicast raised by writing I/O Port 79 MCAST_TO$

	ISR space is the first part of NVRAM space

	The end of NVRAM space is defined by ROM / RAM threshold page pointer I/O Port 124

                _________________________
                |       ISR space       |
                |_______________________|________application threshold
                |                       |
		|	NVRAM continued	|
		|			|
		|			|
		|_______________________|________ROM / RAM threshold		
		|			|
		|	RAM		|


	<a	name="safety"/>
	Operand Protection
	__________________

	Applications may not place ISR space in operand address space with <a href="#sabr">sabr</a> instruction or <a href="#outA">outA |</a><a href="#outB"> outB</a> instructions

	Scope of sabr instruction is address space windows [ 2..63 ]

	outA|B instruction selects memory in address space windows [ 1, 65..71 ]
	but an application may not select memory in windows [ 65..71 ]

	An attempted write in NVRAM space raises the guard interrupt

	Reads and writes in unassigned address space windows are not possible. Windows may be set to a void state.
	Storage should only be placed in address windows of routines designated to access that storage

	Some writeable storage is for applications read-only. Prevented are

		reads and writes above WINDOW+4095 in an address window where a 4K memory block is based
		memory blocks in address space windows are 4096 or 262144 words in size

		writes from applications to

			interrupt registers

			the instruction window B0

			the application vector window B2

			the thread control block B65

			the kernel vector window B66

			kernel data windows B67..B71

		are stopped with guard interrupt
		interrupt code constructs these spaces

	Memory communicating between kernel and applications is placed in the address space during kernel routines

        Targets of the <a href="#ex">execute</a> and <a href="#ts">test and set</a> instructions may be anywhere in actual address space
	unless bus operation on the memory in window is, like network trunks and filestore, not as executable space



	<a	name="optimal_safe"/>
	Optimal Safe Storage Practice
	_____________________________

	Applications may place any block of executable memory except ISR space in an address space window

	Kernel and applications have the option of safe managed memory practice using the application vector list
	which the kernel may write and the application may read

	Every process has its own vector list common to all its threads

	Applications identify static memory from the vector list on initialisation

	A kernel links any subsequent dynamic memory grants to the application memory estate
	and may write dynamic or shared memory pointers in the application vector list to prevent accidental change

	Pointers to far <a href="#call">call</a> and <a href="#go">go</a> subjects identified at build time are already protected by inclusion
	in the instruction frame literal table which is finalised at system image generation or at <a href="kernel.html#iframe_load">load</a>



	<a	name="device"/>
	Device Array Protection
	_______________________


	Peripheral arrays outside system memory can only be based by interrupt code

	This is to prevent accidental damage or disruption to static RAM file systems and network frame trunks

	An inadvertant attempt to base a device from an application raises the guard interrupt
	See Section 2.10: <a href="#iassign">Interrupt Assignments</a>

	Applications may call ISRs to place a block of a peripheral device array in the address space.
	The application may subsequently read and write the based information without restriction.

	The primary reason for allowing only ISRs to base device array storage is to avoid accident

	ISRs which base device banks on user request may also include a credential check

</pre>

<a	name="thread"/>
<h3>2.8 Thread Switch and Address Space</h3>

Thread current memory block pointers are not saved on thread switch because they are
already mirrored in the thread control block at the point when the application selects memory

<p>
62 window pointers are reloaded in 31 instructions


<a	name="ioport"/>
<h3>2.9 I/O Ports for Inter-Processor Signalling / Memory and Peripheral Configuration / Timer Restart</h3>

<a	name="iosignal"/>
<h4>2.9.1: I/O Ports for Inter-Processor Signalling</h4>

<p>
I/O Port 79 MCAST_TO$ is written to multicast or unicast interrupts between SMP cores

<p>
Objective may be peripheral activation, realtime thread switch, dayclock update or other alignment, arrest of threads on process exit

<p>
SMP core / core multicast alert interrupt is driven with destination mask in MCAST_TO$ and source indication in I/O Port 78 MCAST_PENDING$

<p>
Source indications in MCAST_PENDING$ may be multiple, are reset on a single read, and are individually acknowledged in kernel storage
<pre	style="font-size:11pt">

	alert unicast/multicast		outA|B to Port 79 MCAST_TO$
					raises MCAST_PENDING$[ 1 << sending core ] at up to 24 cores
					parameters in kernel storage
</pre

<a	name="iomem"/>
<h4>2.9.2: I/O Ports for Memory and Peripheral Configuration</h4>


I/O ports function as relocation registers and also read out memory configuration values

<p>
Port 124 <b>ram$threshold</b> contains the Start Page Index of the first RAM page in executable space

<p>
ROM is at page locations before <b>ram$threshold</b> and contains an initial instruction code image
which may be a boot routine, an operating system or an complete application image

<p>
RTA1 machine detects the size of system memory from Port 128 <b>device$flags</b>

<p>
Port 128 is the first of 64 ports describing peripheral memory typed as [ system memory |  network frames trunk | filestore ]

<a	name="iotimer"/>
<h4>2.9.3: I/O Port for Timer Interval Restart</h4>


<p>
One core may be attached to a high-frequency time quantum incrementer which interrupts on overflow
The incrementer is restarted by writing Port 76

<a	name="iolist"/>
<h4>2.9.4: I/O Port Assignments</h4>
<pre	style="font-size:11pt">

	0			actual instruction frame start page		see <a href="#go">go</a> <a href="#call">call</a> <a href="#fret">fret</a> <a href="#ii">ii</a> <a href="#ir">ir</a> <a href="#sabr">sabr</a>
	1			application private data page pointer
	2:63			application data memory window pointers
	64			actual instruction frame highest page		see <a href="#go">go</a> <a href="#call">call</a> <a href="#fret">fret</a> <a href="#ii">ii</a> <a href="#ir">ir</a> <a href="#sabr">sabr</a>
	65			thread control block pointer
	66:71			kernel data window pointers
	72			<a name="thresho"/>application lower threshold page pointer	see <a href="#go">go</a> <a href="#call">call</a> <a href="#fret">fret</a> <a href="#ii">ii</a> <a href="#ir">ir</a> <a href="#sabr">sabr</a>
	74	XI_PENDING$	external interrupts pending readable indications
	75	XI_ACK$		external interrupts acknowledge writeable lines	
	76	INC$START	high-frequency timer incrementer restart write
	77	CORE_SOCKET$	core position on schematic	
	78	MCAST_PENDING$	cores -> core alert multicast pending interrupt indications
	79	MCAST_TO$	core -> core[s] alert multicast write (preemption, dayclock update, process exit->threads arrest)
	80..87	I$DATA		external devices data / status inputs
	88..95	O$DATA		external devices data / command outputs	
	101	time$zone	timezone seconds difference from GMT
	102	INDICATION$	hardware / firmware command pins
	103	chill$down	powersave programmable microseconds
	124	ram$threshold	ROM / RAM threshold
	128			system memory 4K-block high index
	129:191			devices 1:63 attributes / array size

</pre>

<a	name="iassign"/>
<h3>2.10: Interrupt Assignments</h3>

<p>
The first 4K-word block of storage or PAGE_0 contains ISR vectors:
<pre	style="font-size:11pt">

	0:0	restart
	0:1	soft restart elected by ISRs on serious anomaly
	0:2	up to eight <a href="kernel.html#external_i">external interrupts</a> distinguished by I/O port XI_PENDING$
	0:3	floating exponent underflow / overflow
	0:4	time quantum incrementer overflow restarted by writing I/O Port INC$START
	0:5	SMP core to core alert unicast / multicast interrupts
		raised by writing I/O Port 79 <a href="#iolist">MCAST_TO$</a>
		identified in I/O Port 78 <a href="#iolist">MCAST_PENDING$</a>

	plus optionally a boot routine

</pre>
The second 4K-word storage block PAGE_1 contains service call ISRs

<p>
Applications call these services with <a href="#ii">ii</a> instruction

<p>
Three service ISRs are raised automatically and also callable with <a href="#ii">ii</a> instruction
<pre	style="font-size:11pt">

	1:1	<a href="kernel.html#yield_ii">YIELD$</a>	is application callable and is also raised on expiry of timeslice
			timeslice applies when REALTIME$_CLOCK is nonzero and interrupt mask is zero
			and is a decrementing instruction ration graded by thread priority 

	1:6	<a href="kernel.html#exit_ii">EXIT$</a>	is application callable
			and is also raised by lret or fret instruction
			on internal stack empty sp = 128 in application mode

	1:31	<a href="kernel.html#guard_ii">GUARD$</a>	is raised automatically on instruction fault
			applications may also call GUARD$ diagnostically 

</pre>
<p>
PAGE_1 system call ISRs in the <a href="kernel.html">prototype kernel</a> are at these vectors
<pre	style="font-size:11pt">

	1:0
	1:1	<a href="kernel.html#yield_ii">YIELD$</a>		context switch
	1:2	<a href="kernel.html#spawn_ii">SPAWN$</a>		launch process
	1:3	<a href="kernel.html#bank_ii">BANK$</a>		acquire storage
	1:4	<a href="kernel.html#array_ii">ARRAY$</a>		acquire large storage
	1:5	<a href="kernel.html#bank_free_ii">BANK$FREE</a>	relinquish storage
	1:6	<a href="kernel.html#exit_ii">EXIT$</a>		terminate process or thread
	1:7	<a href="kernel.html#thread_ii">THREAD$</a>		launch thread

	1:8	<a href="kernel.html#total_free_ii">TOTAL$FREE</a>	amount of storage free 
	1:9	<a href="kernel.html#tag_ii">TAG$</a>		name a thread
<div style="background-color:#00FF00">	1:10	<a href="kernel.html#assign_xvector_ii">ASSIGN_XVECTOR$</a>	add memory to kernel, write vector
</div>	1:11	<a href="kernel.html#itable_ii">I$TABLE</a>		initialise thread interrupts table 
	1:12	<a href="kernel.html#affinity_ii">AFFINITY$</a>	thread attach to specific core[s]
	1:13
	1:14	<a href="kernel.html#fp_xpo_flag_ii">FP_XPO$FLAG</a>	read and clear floating exponent outflow event
	1:15	<a href="kernel.html#xint_bind_ii">XINT$BIND</a>	thread bind interrupt source

<div style="background-color:#00FF00">	1:16	<a href="kernel.html#handle_ii">HANDLE$</a>		acquire a handle
	1:17	<a href="kernel.html#free_handle_ii">FREE_HANDLE$</a>	relinquish a handle
	1:18	<a href="kernel.html#read_handle_ii">READ_HANDLE$</a>	read 1st word handle encoding
	1:19	<a href="kernel.html#read_xvector_ii">READ_XVECTOR$</a>	read a value from kernel vector list
	1:20	<a href="kernel.html#write_xvector_ii">WRITE_XVECTOR$</a>	write a value in kernel vector list
	1:21	<a href="kernel.html#read_socket_ii">READ_SOCKET$</a>	read both words handle encoding
	1:22	<a href="kernel.html#usocketc_ii">USOCKET$C</a>	connect/accept: attach transmission control block to handle
	1:23	<a href="kernel.html#kernel_b1_ii">KERNEL$B1</a>	switch B1 window to named kernel B1

	1:24	<a href="kernel.html#b1_ii">B1$</a>		switch B1 window to application actual B1
	1:25	<a href="kernel.html#kernel_b1_ii_1">KERNEL$B1_1</a>	switch B1 window to kernel initial B1
	1:26	<a href="kernel.html#dayclock_w_ii">DAYCLOCK$W</a>	write registers DAYCLOCK$U:DAYCLOCK$
</div>	1:27	<a href="kernel.html#twait_ii">TWAIT$</a>		wait milliseconds
	1:28	<a href="kernel.html#event_wait_ii">EVENT_WAIT$</a>	thread wait realtime event
	1:29	<a href="kernel.html#event_free_ii">EVENT_FREE$</a>	clear wait state of thread
	1:30	<a href="kernel.html#switch_fp_guard_ii">FP_GUARD$</a>	set floating point rounding guard pattern
	1:31	<a href="kernel.html#guard_ii">GUARD$</a>		diagnostic call to fault ISR

<div style="background-color:#00FF00">	1:32	<a href="kernel.html#xbase_ii">XBASE$32</a>	place peripheral memory array in address window
	1:33	<a href="kernel.html#xbase_ii">XBASE$33</a>
	1:34	<a href="kernel.html#xbase_ii">XBASE$34</a>
	1:35	<a href="kernel.html#xbase_ii">XBASE$35</a>
	1:36	<a href="kernel.html#xbase_ii">XBASE$36</a>
	1:37	<a href="kernel.html#xbase_ii">XBASE$37</a>
	1:38	<a href="kernel.html#xbase_ii">XBASE$38</a>
	1:39	<a href="kernel.html#xbase_ii">XBASE$39</a>

	1:40	<a href="kernel.html#xbase_ii">XBASE$40</a>
	1:41	<a href="kernel.html#xbase_ii">XBASE$41</a>
	1:42	<a href="kernel.html#xbase_ii">XBASE$42</a>
	1:43	<a href="kernel.html#xbase_ii">XBASE$43</a>
	1:44	<a href="kernel.html#cache_standard_netbuf_ii">CACHE_NETB$</a>	IP initialisation call
	1:45	<a href="kernel.html#base_standard_netbuf_ii">ON_NETB$</a>	place socket buffer array in application address space
	1:46	<a href="kernel.html#unbase_deviceb_ii">FREE_DEVB$</a>	void address space window 32 used for peripheral arrays 
	1:47	<a href="kernel.html#unbase_socketb_ii">FREE_SOCKB$</a>	void address space window 47 used for socket structure

	1:48	<a href="kernel.html#unbase_standard_netbuf_ii">FREE_NETB$</a>	void application address windows -> socket buffer array
	1:49	<a href="kernel.html#net2sym_ii">NET2SYM$</a>	assign TCP connection as process stdin stdout stderr
</div>	1:50	<a href="kernel.html#thread_state_ii">THREAD$STATE</a>	test state of thread
	1:51	<a href="kernel.html#storage_block_idxa_ii">A$IDX</a>		retrieve active page pointer [a]
	1:52	<a href="kernel.html#storage_block_idxb_ii">B$IDX</a>		retrieve active page pointer [b]
	1:53
	1:54
	1:55

<div style="background-color:#00FF00">	1:56	<a href="kernel.html#usocket_ii">USOCKET$</a>	bind: attach port socket structure to handle
	1:57	<a href="kernel.html#file_open_frame_ii">FO$FRAME</a>	file open: obtain file open block
	1:58	<a href="kernel.html#files_open_heap_ii">FO$HEAP</a>		thread start: initialise files open heap
	1:59	<a href="kernel.html#file_handle_ii">FILE$HANDLE</a>	file open: attach file open block attach to handle
</div>	1:60	<a href="kernel.html#zeta_ii">$ZETA</a>		terminate named process or thread
	1:61	<a href="kernel.html#send_alert_ii">ALERT$</a>		request core to core[s] multicast transmission
	1:62
	1:63
	
</pre>
<a style="background-color:#00FF00">Shaded entries</a> are ISRs mainly called from kernel routines. Some are kept to a closed ring of calling iframes for safety and screened from other callers

<a	name="regisi"/>
<h2>3. Registers and Instruction Set</h2>

<a	name="nonar"/>
<h3>3.1 Non-Addressable Registers</h3>

<p>
Two registers are not addressable. The program counter which contains an absolute address 48 bits in size, and the Processor State Register, which contains settings and the carry bit

<p>
The program counter is never stored as its absolute 48-bit value. Its value minus B0 * 4096 is pushed on the internal stack
on interrupts and calls.
Interrupts and calls between instruction frames also push Iframe Name

<p>
The Processor State Register is saved on interrupts

<p>
The layout of the Processor State Register is
<pre	style="font-size:11pt">

		23             18   16     14           8   7   6   5   4   3       0
		_______________________________________________________________________
		| I | 0 0 0 0 | i i i | 0 | see$          | H | R | R | W | F 0 0 | C |
		|   |         |       |   | 1 2 3 4 5 6 7 |   | Z |16 |16 | P     |   |
		|___|_________|_______|___|_______________|___|___|___|___|_R_____|___|

</pre>
The PSR flags shown as 0 are not currently used
<p>
PSR flags 15..0 are directly application programmable with instructions <b>on</b> and <b>off</b>

<p>
Flag 23 <b>I</b> is on during an interrupt. CPU-side registers, that is those which receive computation results
or are stack pointers, index registers, the target of load instructions or the source of store instructions, automatic
counter or mask register, are in interrupt mode in the range 128..255. The application registers are 0..127

<p>
Registers addressed as storage operands are absolute locations in a 256-word array
regardless of ISR / application mode. However applications cannot write the interrupt registers

<p>
Flags 18..16 <b>iii</b> are the interrupt mask. Both applications and ISRs can swap and restore the
interrupt mask with the <b>Switch Interrupt Mask</b> instruction <b>sim</b>

<p>
Flags 14..8 <b>see$1..see$7</b> individually place TCB and kernel storage in B65..B71 in address windows 1..7
where otherwise application data storage in B1..B7 is addressed

<p>
Flag 7 <b>half$w</b> concerns instructions which can take a byte operand as an alternative to a word operand.
RTA1 is not an octet-addressing machine, and any byte other than a 24-bit byte is a field of a storage location.

The 32 instructions in Instruction File 1 may take a storage word or part of a storage word as operand.
These bytes are either halfwords (12 bits) with sign extension on read
<pre	style="font-size:11pt">

		 23			 11		       0
		_________________________________________________
		|	    h1		|	  h2		|
		|_______________________|_______________________|

</pre>
<p>
or else they are thirdwords (8 bits) with sign extension on read
<pre	style="font-size:11pt">

		 23		 15		 7	       0
		_________________________________________________
		|	t1	|	t2	|	t3	|
		|_______________|_______________|_______________|

</pre>		
<p>

But it is very undesirable that the File 1 Instructions should all have five different encodings
for accessing bytes. There are three byte-select encodings available in those instructions,
and flag <b>half$w</b> = 1 = halfword access, otherwise the application may access thirdwords

<p>
Flags 6 5 and 4 adjust the <b>Bit Stream Read Channel</b> and <b>Bit Stream Write Channel</b>

<p>
Flag 6 <b>b$streamZR</b> affects the operation of the <b>Read Staging Register</b> instruction <b>rsr</b>,
which makes a stream of bits or bytes serially available to the arithmetic registers

<p>
<b>b$streamZR</b> states that bits from the staging register <b>RDATA</b> shall be shifted into a cleared arithmetic register,
saving an extra instruction to mask the desired field. Otherwise the previous arithmetic register contents are shifted towards
the high order bit positions as new bits are transferred from <b>RDATA</b>

<p>
Flag 5 <b>b$stream16r</b> also affects the operation of <b>Read Staging Register</b>.
Only 16 bits are delivered from each input data word if <b>b$stream16r</b> = 1.
The high-order bits 23..16 are discarded when <b>b$stream16r</b> = 1.
This allows efficient handling with network data and with 16-bit peripherals.
If <b>b$stream16r</b> = 0 successive <b>rsr</b> instructions deliver all the 24 bits read from storage.

<p>
Flag 4 <b>b$stream16w</b> affects the operation of <b>Write Staging Register</b> instruction <b>wsr</b>
which writes a stream of bits or bytes from the arithmetic registers. Bits shifted into Staging Register
<b>WDATA</b> are stored at 16 bits per data word when <b>b$stream16w</b> = 1.
This allows efficient handling with network data and with 16-bit peripherals.
If <b>b$stream16w</b> = 0 successive <b>wsr</b> instructions compose 24 bits for each storage write.

<p>
Flag 3 <b>fp$r</b> is used for teaming pairs of floating numbers to calculate 192-bit values.
When <b>fp$r</b> is asserted floating instructions store a minor result in registers
8..11. If the entire result is contained in the major result in registers a:b:mantissa2:mantiss3 then
the minor result is zero. The minor result is used in further floating operations on pairs of 96-bit
floating numbers for 192-bit values

<p>
Flag 0 <b>carry$</b> is set or cleared by this subset of the fixed point instructions
<pre	style="font-size:11pt">

	<a href="#aa">aa</a>	Add to Register a
	<a href="#ab">ab</a>	Add to Register b
	<a href="#ana">ana</a>	Add Negative to Register a
	<a href="#anb">anb</a>	Add Negative to Register b
	<a href="#da">da</a>	Double Length Add to a:b
	<a href="#dan">dan</a>	Double Length Add Negative to a:b
	<a href="#src">src</a>	circular Shift Right through Carry
	<a href="#slc">slc</a>	circular Shift Left through Carry
	<a href="#popA">popA</a>	Pop and AddTo

</pre>

<p>
The instructions which add the twos complement of the operand, <b>ana</b> <b>anb</b> <b>dan</b>,
have the same result in <b>carry$</b> as positive adds which have that twos complement as input operand.
Carry is set if addition at the register high order bit position carries, in all these instructions

<p>
There are no PSR condition bits other than <b>carry$</b>. All other conditions are available in the register
containing the instruction result. Many different results can be examined long after they are generated


<p>
The conditional jump instructions which examine carry or a register or storage word are
<pre	style="font-size:11pt">
	<a href="#jc">jc</a>	Jump Carry
	<a href="#jnc">jnc</a>	Jump No Carry
	<a href="#jza">jza</a>	Jump Zero a
	<a href="#jzb">jzb</a>	Jump Zero b
        <a href="#jnza">jnza</a>	Jump NonZero a
        <a href="#jnzb">jnzb</a> 	Jump NonZero b
	<a href="#jpa">jpa</a>	Jump Positive a
	<a href="#jpb">jpb</a>	Jump Positive b
	<a href="#jna">jna</a>	Jump Negative a
	<a href="#jnb">jnb</a>	Jump Negative b
	<a href="#jpo">jpo</a>	Jump Parity a<a style="color:FFFFFF;background-color:0000FF"> AND </a>k Odd
	<a href="#jao">jao</a>	Jump a Odd
	<a href="#jdz">jdz</a>	Jump a:b Double Zero
	<a href="#mta">mta</a>	Masked Test a skip equal
	<a href="#tz">tz</a>	Test Zero skip
	<a href="#tp">tp</a>	Test Positive skip
	<a href="#ts">ts</a>	Test and Set skip
	<a href="#jxge">jxge</a>	Jump x not less than r
	<a href="#jyge">jyge</a>	Jump y not less than r
	<a href="#jdr">jdr</a>	Jump Decrement Repeat Count
</pre>

<a	name="register"/>
<h3>3.2 Addressable Application and Interrupt Registers</h3>

<p>
RTA1 registers occur twice. The application has 128 registers and interrupts have 128 registers

<p>
All 256 registers are in the operand address space as one linear array

<p>
Some registers are implicitly addressed as the register operand of an instruction.
These register-side operands are compartmented by application / interrupt context

<p>
The interrupt register set is a replica of the application register set, and has the same arithmetic registers,
index registers and special-purpose registers, with some minor differences

<p>
Having one set of interrupt registers does not mean that interrupts are not nested.
It means that certain much-used ISRs which are never nested in execution have a set of registers which can be used without saving.
Other ISRs wich may run nested must save registers before they change them.
Interrupts also have an internal stack made from 104 of their 128 registers.

<p>
An important category of interrupts which are never nested is application-callable kernel routines
which are implemented as internal interrupts. These have a set of registers for immediate free use,
and they only need to touch the application registers in order to read parameters and write results

<p>
It is advisable to implement a kernel routine as an internal interrupt instead of a call if the routine
temporarily manipulates the address space via the PSR flags. On return from interrupt the the saved PSR
is reloaded and all flags are restored


<pre	style="font-size:11pt">



		Layout of the Register Stack
		____________________________

		Notes
		_____

		Only registers 0..127 switch with the thread

		The internal stack addressed with sp is only large enough for scalars and pointers
		Frame Pointer register fp is intended to be an external stack pointer for structures and arrays

		The application internal stack pointer is guarded from overflow (decrement
		below 24) and underflow (increment above 128). At sp = 128 the internal
		stack is completely empty. At sp = 24 the internal stack is completely full
		Stack range violation raises the guard interrupt at vector 1:31

		DAYCLOCK$U:DAYCLOCK$ are a millisecond counter in the interrupt register list
		All threads read the dayclock register pair atomically with 48-bit-operand instructions

		Interrupt TIMER$ is sprung for example from a nanosecond incrementer
		and one designated core updates the 48-bit millisecond dayclock and
		writes it to kernel storage

		The designated core writes I/O port DAYCLOCK$UPDATE$ to multicast
		interrupt TIME$POINT to the other cores. They update the dayclock
		value in their own registers

				dl	dayclock$	. read kernel storage
				ds	DAYCLOCK$U	. write registers
				ir	0		. return from TIME$POINT ISR

		The incrementer can be programmed for doubled, octupled or other power-2
		higher frequency than a millisecond, making the dayclock quantum a fraction
		of a millisecond and timer interrupt more frequent

		A negative number of beats is output to a high-frequency incrementer via
		I/O port OVERFLOWER$. TIMER$ interrupts when when the incrementer carries

		The processor executing ISR TIMER$ reprograms OVERFLOWER$

		The emulated machine retrieves millisecond time periodically from the emulator host

		PRIORITY$ is a copy of the running thread's priority stored by software for
		rapid retrieval at thread switch, and for instant evaluation of SMP inter-processor
		preemptive interrupt broadcasts

		REALTIME$_CLOCK is a decrementing timer count which switches the running
		thread on expiry. If the initial REALTIME$_CLOCK value assigned to the thread
		is zero, neither decrement nor switch interrupt takes place




			The Application Registers						  The Interrupt Registers
			_________________________						  _______________________


		 23			       0					 23			       0
		_________________________________					_________________________________
	0	|		r		|  repeat count + limit pointer	128	|		r_x		|
		|_______________________________|					|_______________________________|
	1	|		k		|	mask register		129	|		k_x		|
		|_______________________________|					|_______________________________|
	2	|		x		|	index register		130	|		x_x		|
		|_______________________________|					|_______________________________|
	3	|		y		|	index register		131	|		y_x		|
		|_______________________________|					|_______________________________|
	4	|		a		|  arithmetic + index register	132	|		a_x		|
		|_______________________________|					|_______________________________|
	5	|		b		|  arithmetic + index register	133	|		b_x		|
		|_______________________________|					|_______________________________|
	6	|	mantissa2		|	arithmetic register	134	|	mantissa2_x		|
		|_______________________________|					|_______________________________|
	7	|	mantissa3		|	arithmetic register	135	|	mantissa3_x		|
		|_______________________________|					|_______________________________|
	8	|		aA		|	arithmetic register	136	|		aA_x		|
		|_______________________________|					|_______________________________|
	9	|		bA		|	arithmetic register	137	|		bA_x		|
		|_______________________________|					|_______________________________|
	10	|	mantissa2A		|	arithmetic register	138	|	mantissa2A_x		|
		|_______________________________|					|_______________________________|
	11	|	mantissa3A		|	arithmetic register	139	|	mantissa3A_x		|
		|_______________________________|					|_______________________________|
	12	|	    	 p		|	bitstream pointer write	140	|		p_x		|
		|_______________________________|					|_______________________________|
	13	|	   	 q		|	bitstream pointer read	141	|		q_x		|
		|_______________________________|					|_______________________________|
	14	|	  	 fp		|	index register		142	|		fp_x		|
		|_______________________________|					|_______________________________|
	15	|	  	 sp		|	index register		143	|		sp_x		|
		|_______________________________|					|_______________________________|
	16	|				|	scratch			144	|				|
		|_______________________________|					|_______________________________|
	17	|				|	scratch			145	|				|
		|_______________________________|					|_______________________________|
	18	|				|	scratch			146	|				|
		|_______________________________|					|_______________________________|
	19	|				|     < scratch	| rounding >	147	|	fp$guard		|
		|_______________________________|					|_______________________________|
	20	|	   RDATAC		|	bitstream counter read	148	|	REALTIME$_CLOCK		|
		|_______________________________|					|_______________________________|
	21	|	    RDATA		|	bitstream data read	149	|	PRIORITY$		|
		|_______________________________|					|_______________________________|
	22	|	   WDATAC		|	bitstream counter write	150	|	DAYCLOCK$U		|
		|_______________________________|					|_______________________________|
	23	|	    WDATA		|	bitstream data write	151	|	DAYCLOCK$		|
		|_______________________________|					|_______________________________|
	24	| maximum internal stack top	|				152	|				|
		|_______________________________|					|_______________________________|
	25	|				|				153	|				|
		|_______________________________|					|_______________________________|
	26	|				|				154	|				|
		|_______________________________|					|_______________________________|
	27	|				|				155	|				|
		|_______________________________|					|_______________________________|
	28	|				|				156	|				|
		|_______________________________|					|_______________________________|
	29	|				|				157	|				|








	118									246
		|_______________________________|					|_______________________________|
	119	|				|				247	|				|
		|_______________________________|					|_______________________________|
	120	|				|				248	|				|
		|_______________________________|					|_______________________________|
	121	|				|				249	|				|
		|_______________________________|					|_______________________________|
	122	|				|				250	|				|
		|_______________________________|					|_______________________________|
	123	|				|				251	|				|
		|_______________________________|					|_______________________________|
	124	|				|				252	|				|
		|_______________________________|					|_______________________________|
	125	|				|				253	|				|
		|_______________________________|					|_______________________________|
	126	|				|				254	|				|
		|_______________________________|					|_______________________________|
	127	|				|	first pushed word	255	|				|
		|_______________________________|					|_______________________________|




	bit stream channel control registers in the user register set

	        RDATAC
		RDATA
        	WDATAC
		WDATA

        are not duplicated in the interrupt register set as other registers are

        their equivalent positions 148..151 are taken by clock and timer registers

		REALTIME$_CLOCK
		PRIORITY$
		DAYCLOCK$U
		DAYCLOCK$

        Few ISRs are expected to program bit streams. An ISR which programs RDATAC RDATA 
	or WDATAC WDATA must first save them. Instructions rsr wsr in interrupt mode use
	application RDATAC RDATA WDATAC WDATA at absolute addresses 20..23

	storage read pointer q used by rsr instruction is replicated in application and
	interrupt register sets. rsr instruction in interrupt mode uses q_x. ISRs may
	otherwise use q_x as a general purpose pointer

	storage write pointer p used by wsr instruction is replicated in application and
	and interrupt register sets. wsr instruction in interrupt mode uses p_x. ISRs may
	otherwise use p_x as a general purpose pointer


</pre>



<a	name="iset"/>
<h3>3.3 Instruction Set Summary and <a href="#lookup">Lookup Panel</a></h3>

<p>
RTA1 instructions are grouped in 5 columns called instruction files.
The five instruction files map to eight operand characteristics.

<p>
Instruction File 1 spans six of the eight operand types. Instruction File 1 is integer operations
with single word operand. The 24-bit operand may be read from a word, a half or third word,
the immediate value of the effective address, or a sign-extended immediate value

<p>
Instruction Files 4A and 5A are a small number of special instructions which only need an effective address immediate or a sign-extended immediate.

<p>
Instruction File 6 contains shifts and jumps which use the effective address as an immediate operand.

<p>
Instruction File 7 contains arithmetic instructions which have an operand of one, two or four words

<pre	style="font-size:11pt">


	<a	name="lookup"/>
	Instructions Lookup Panel		Instruction File 4a			Instruction File 5A
	_________________________		___________________			___________________

						<a href="#ina">inA</a>	In Port to A			<a href="#on">on</a>	PSR Flags On
						<a href="#inb">inB</a>	In Port to B			<a href="#off">off</a>	PSR Flags Off

						<a href="#outa">outA</a>	Out A to Port			<a href="#rsr">rsr</a>	Read Staging Register
						<a href="#outb">outB</a>	Out B to Port			<a href="#wsr">wsr</a>	Write Staging Register

						<a href="#reload">reload</a>	switch application memory


						<a href="#sabr">sabr</a>	Store a to Base Register	<a href="#lret">lret</a>	local return
											<a href="#fret">fret</a>	far return

											<a href="#ii">ii</a>	Internal Interrupt
						<a href="#jdz">jdz</a>	Jump Double Zero		<a href="#ir">ir</a>	Interrupt Return



	Instruction File 1			Instruction File 6			Instruction File 7
	__________________			__________________			__________________


	<a href="#sr">sr</a>	Store Repeat Count		<a href="#sar">sar</a>	Shift a Right			<a href="#ts">ts</a>	Test and Set
	<a href="#sk">sk</a>	Store Mask Register		<a href="#sbr">sbr</a>	Shift b Right			<a href="#n">n</a>	Negate

	<a href="#sx">sx</a>	Store Index Pointer x		<a href="#dsr">dsr</a>	Double Shift Right		<a href="#inc">inc</a>	Increment
	<a href="#sy">sy</a>	Store Index Pointer y		<a href="#jdr">jdr</a>	Jump Decrement Repeat Count	<a href="#dec">dec</a>	Decrement

	<a href="#sa">sa</a>	Store Accumulator a		<a href="#sbl">sal</a>	Shift a Left			<a href="#sim">sim</a>	Switch Interrupt Mask
	<a href="#sb">sb</a>	Store Accumulator b		<a href="#sbl">sbl</a>	Shift b Left			<a href="#popa">popA</a>	Pop and AddTo

	<a href="#z">z</a>	Store Zero			<a href="#dsl">dsl</a>	Double Shift Left		<a href="#src">src</a>	Shift Circular Right through Carry
	<a href="#pop">pop</a>	Pop				<a href="#lcal">lcal</a>	Local Call			<a href="#slc">slc</a>	Shift Circular Left through Carry

	<a href="#lr">lr</a>	Load Repeat Count		<a href="#rar">rar</a>	Rotate a Right			<a href="#qs">qs</a>	Quadruple Store
	<a href="#lk">lk</a>	Load Mask Register		<a href="#rbr">rbr</a>	Rotate b Right			<a href="#ql">ql</a>	Quadruple Load

	<a href="#lx">lx</a>	Load Index Pointer x		<a href="#drr">drr</a>	Double Rotate Right		<a href="#fpp">fpp</a>	Floating Pop and Pack
	<a href="#ly">ly</a>	Load Index Pointer y		<a href="#jnc">jnc</a>	Jump No Carry			<a href="#fpx">fpx</a>	Floating Push and Expand

	<a href="#la">la</a>	Load Accumulator a		<a href="#ral">ral</a>	Rotate a Left			<a href="#fa">fa</a>	Floating Add
	<a href="#lb">lb</a>	Load Accumulator b		<a href="#rbl">rbl</a>	Rotate b Left			<a href="#fan">fan</a>	Floating Add Negative

	<a href="#tz">tz</a>	Test Zero			<a href="#drl">drl</a>	Double Rotate Left		<a href="#fm">fm</a>	Floating Multiply
	<a href="#tp">tp</a>	Test Positive			<a href="#jc">jc</a>	Jump on Carry			<a href="#fd">fd</a>	Floating Divide

	<a href="#ax">ax</a>	Add to Index Pointer x		<a href="#saa">saa</a>	Shift a Algebraic		<a href="#qpop">qpop</a>	Quadruple Pop
	<a href="#ay">ay</a>	Add to Index Pointer y		<a href="#sba">sba</a>	Shift b Algebraic		<a href="#qpush">qpush</a>	Quadruple Push

	<a href="#or">or</a>	OR Accumulator a		<a href="#dsa">dsa</a>	Double Shift Algebraic		<a href="#ex">ex</a>	Execute
	<a href="#orb">orB</a>	OR Accumulator b		<a href="#jao">jao</a>	Jump a Odd			<a href="#dpush">dpush</a>	Double Push

	<a href="#and">and</a>	AND Accumulator a		<a href="#jpa">jpa</a>	Jump Positive a			<a href="#lsc">lsc</a>	Load Shift and Count
	<a href="#andb">andB</a>	AND Accumulator b		<a href="#jpb">jpb</a>	Jump Positive b			<a href="#mta">mta</a>	Masked Test a

	<a href="#xor">xor</a>	XOR Accumulator a		<a href="#j">j</a>	Jump				<a href="#sc">sc</a>	Store Carry
	<a href="#xorb">xorB</a>	XOR Accumulator b		<a href="#jpo">jpo</a>	Jump Parity Odd			<a href="#mlb">mlb</a>	Masked Load b

	<a href="#aa">aa</a>	Add To Accumulator a		<a href="#jza">jza</a>	Jump Zero a			<a href="#ds">ds</a>	Double Store
	<a href="#ab">ab</a>	Add To Accumulator b		<a href="#jzb">jzb</a>	Jump Zero b			<a href="#dl">dl</a>	Double Load

	<a href="#ana">ana</a>	Add Negative To Accumulator a	<a href="#jnza">jnza</a>	Jump NonZero a			<a href="#da">da</a>	Double Add
	<a href="#anb">anb</a>	Add Negative To Accumulator b	<a href="#jnzb">jnzb</a>	Jump NonZero b			<a href="#dan">dan</a>	Double Add Negative

	<a href="#m">m</a>	Multiply			<a href="#jna">jna</a>	Jump Negative a			<a href="#dlsc">dlsc</a>	Double Load Shift and Count
	<a href="#mf">mf</a>	Multiply Fractional		<a href="#jnb">jnb</a>	Jump Negative b

	<a href="#d">d</a>	Divide				<a href="#jxge">jxge</a>	Jump x Not Less Than r		<a href="#go">go</a>	Jump to Iframe
	<a href="#push">push</a>	Push				<a href="#jyge">jyge</a>	Jump y Not Less Than r		<a href="#call">call</a>	Call Iframe




</pre>

<a	name="ifield"/>
<h3>3.4 Instruction Layout, Effective Address Generation and Operand Codes</h3>
<a	name="layout"/>
<h4>3.4.1 Instruction Layout</h4>

<p>
The operand code is marked J and determines the operand type
and which instruction file the instruction F is from

<p>
The instruction stem code is marked F and determines an instruction within the instruction file

<p>
Instructions in File 1 derive a single 24-bit operand from a register, a storage word or byte, the effective address as immediate operand, or a sign-extended-immediate

<p>
Instructions in File 4A take the effective address as immediate operand

<p>
Instructions in File 5A take a sign-extended immediate operand

<p>
Instructions in File 6 take the effective address as immediate operand

<p>
Instructions in File 7 take a one-word two-word or four-word operand in registers or storage

<pre	style="font-size:11pt">


		 23         18   15                            0
		_________________________________________________
		|     F    | J  |            address            |       instruction word
		|__________|____|_______________________________|       ________________



</pre>
<a	name="ea"/>
<h4>3.4.2 Effective Address Generation</h4>
<pre	style="font-size:11pt">



	effective address generation
	____________________________


	If the operand code J is other than 5, an effective address is
	generated according to fields I X U of the address as shown here




		 23         18     14    11                    0
		_________________________________________________
		|     F    | J  |I|  X  |           U           |       instruction word
		|__________|____|_|_____|_______________________|       ________________
				|
				|15




	if I = 0 the effective address is 15 bits X U

	if I = 1

		if X = 0
			the effective address is indirect and found in in the storage word at 0 + U

			if U < 256 the indirect 24-bit address is the value in a register 
			otherwise the 24-bit indirect address is the value in a storage word
			in Window 0 locations 256..4095


		if X = 1
			the effective address is indirect and found in the storage word at 
			4096 + U which is in Window 1 (Window 65 if see$1 is on)





		Base + Displacement Addressing I=1 and X = [2|3|4|5|6|7]
		________________________________________________________


		 23					       0
		_________________________________________________		
		|		index value 24 bits		|	index register [x|y|a|b|fp|sp]
		|_______________________________________________|	______________________________
					|			|
					|    + displacement	|
					|    12 bits unsigned	|
		 23         18     14	 11	               0
	  	_________________________________________________
		|     F    | J  |I|  X  |	    U		|	instruction word
		|__________|____|_|_____|_______________________|	________________
				|
				|15			


		if X = 2
			the effective address is the sum of
			index register x plus the 12 unsigned bits U


		if X = 3
			the effective address is the sum of
			index register y plus the 12 unsigned bits U


		if X = 4
			the effective address is the sum of
			arithmetic register a plus the 12 unsigned bits U


		if X = 5
			the effective address is the sum of
			arithmetic register b plus the 12 unsigned bits U


		if X = 6
			the effective address is the sum of
			frame pointer register fp plus the 12 unsigned bits U


		if X = 7
			the effective address is the sum of
			stack pointer register sp plus the 12 unsigned bits U



</pre>
<a	name="ocodes"/>
<h4>3.4.3 Operand Codes and Instruction Files</h4>
<pre	style="font-size:11pt">



	The meanings of operand code J
	______________________________


	000	The instruction is in Instruction File 1			mnemonic w0
		and the storage operand is the computer word
		at the effective address I X U					assembler syntax example
										________________________

										la		this_word
										sx		that_word, y, w0
										push		a_word

										ly		*indirectly

										________________________

										operand W0 = word is the default
										the mnemonic W0 need not be typed
										________________________


		 23					       0
		_________________________________________________
		|						|	register
		|_______________________________________________|	________
		|						|

		|						|

		|						|

		|_______________________________________________|
		|		       w0			|	storage
		|_______________________________________________|	_______
		 23					       0




 





	operand codes J 001..011 when PSR Flag half$w = 0
	_________________________________________________

	Partial words are only written and read in system memory

	Bytes are sign extended to a 24-bit word on load, including
	push to the internal stack from a byte of system memory

	Byte writes to storage are from the low-order bits of the
	source register, including byte writes to system memory
	from the register at the internal stack top----------------->		pop[,t1|t2|t3]	target

	Only 24-bit words are read from registers addressed as storage
	Only 24-bit words are written to registers addressed as storage

 


	001	The instruction is in Instruction File 1			mnemonic t1
		and the storage operand is bits 23..16 of
		the word at effective address I X U				assembler syntax example
										________________________

		load and store are to bits 7..0 of the CPU			lb, t1		structure, fp		
		register with sign extension on load				pop		outside,,t1

		bits 15..0 of the memory word are unchanged on store





		 23					       0
		_________________________________________________
		|<------- sign extension on read:		|	register
		|_______________________________________________|	________
						|		|
								|		
		<------------------------------->		|
		|						
								|
		|		<------------------------------->
		|		|		
		|_______________|_______________________________
		|	t1	|		|		|	storage
		|_______________|_______________|_______________|	_______
				 23	      16










	010	The instruction is in Instruction File 1			mnemonic t2
		and the storage operand is bits 15..8 of
		the word at effective address I X U				assembler syntax example
										________________________

		load and store are to bits 7..0 of the CPU			andB, t2	record, y		
		register with sign extension on load				tp		reaction, fp, t2
										sr, t2		latent_parameter
		bits 23..16, 7..0 of the memory word
		are unchanged on store



 



 


		 23					       0
		_________________________________________________
		|<------- sign extension on read:		|	register
		|_______________________________________________|	________
						|		|
						|		|
				<--------------->		|
				|				
								|
				|		<--------------->
				|		|		
		________________|_______________|_______________
		|		|	t2	|		|	storage
		|_______________|_______________|_______________|	_______
				 15	       8








	011	The instruction is in Instruction File 1			mnemonic t3
		and the storage operand is bits 7..0 of
		the word at effective address I X U				assembler syntax example
										________________________

		load and store are to bits 7..0 of the CPU			d, t3		divisor_array, x
		register with sign extension on load				push		everyone,,t3

		bits 23..8 are unchanged on store

		PARTIAL WORDS MAY ONLY BE READ FROM SYSTEM			xor, t3		keyvalue
		MEMORY AND WRITTEN TO SYSTEM MEMORY

		REGISTERS ARE 24-BIT WORD SCALARS
		OR MULTI-WORD-SCALARS






		 23					       0
		_________________________________________________
		|<------- sign extension on read:		|	register
		|_______________________________________________|	________
						|		|
						|		|
						|		|
								
						|		|
						|		|				
		________________________________|_______________|
		|		|		|	t3	|	storage
		|_______________|_______________|_______________|	_______
						 7	       0








	operand codes J 010..011 when PSR Flag half$w = 1
	_________________________________________________

	Partial words are only written and read in system memory

	Bytes are sign extended to a 24-bit word on load, including
	push to the internal stack from a byte of system memory

	Byte writes to storage are from the low-order bits of the
	source register, including byte writes to system memory
	from the register at the internal stack top----------------->		pop[,h1|h2]	 target

	Only 24-bit words are read from registers addressed as storage
	Only 24-bit words are written to registers addressed as storage




	010	The instruction is in Instruction File 1			mnemonic h1
		and the storage operand is bits 23..12 of
		the word at effective address I X U				assembler syntax example
										________________________

		load and store are to bits 11..0 of the CPU			lb, h1		katakana_table, a
		register with sign extension on load				z		restart_counter,,h1

		bits 11..0 of the memory word are unchanged on store



 


		 23					       0
		_________________________________________________
		|<------- sign extension:			|	register
		|_______________________________________________|	________
					|			|
					|			|
		<----------------------->			|
		|						
								|
		|			<----------------------->
		|			|		
		|_______________________|_______________________
		|	    h1		|			|	storage
		|_______________________|_______________________|	_______
		 23		      12




 







	011	The instruction is in Instruction File 1			mnemonic h2
		and the storage operand is bits 11..0 of
		the word at effective address I X U				assembler syntax example
										________________________

		load and store are to bits 11..0 of the CPU			tz, h2		restart_counter
		register with sign extension on load				pop		along, b, h2

		bits 23..12 of the memory word are unchanged on store





		 23					       0
		_________________________________________________
		|<------- sign extension:			|	register
		|_______________________________________________|	________
					|			|
								|
					|			|
					|			
					|			|		
		________________________|_______________________|
		|			|	   h2		|	storage
		|_______________________|_______________________|	_______
					 11		       0








	Operand Codes J 100..111
	________________________

	100	The instruction is in Instruction File 1			mnemomic i
		and the immediate operand is the effective
		address with or without indirection or indexing			assembler syntax example
										________________________

										lr, i		4, x

										lx, i		frame_size, sp
										aa, i		63



		instructions in Instruction File 4A also have J			sabr		BASE_REGISTER_33
		code 100 and the effective address as operand			inB		PORT_131A






	101	The instruction is in Instruction File 1			mnemonic xi
		and the sign extended immediate operand
		is I X U = bits 15..0 of the instruction word			assembler syntax example
										________________________

										ax, xi		-FRAME_SIZE

										ly, xi		$literal("ISBN %s ":;
													 "Title %s ":;
													 "Author %s\n")

										push, xi	-12500



		 23					       0
	 	_________________________________________________
		|+sign extension+				|	register
		|_______________________________________________|	_______
				|				|
				|				|		
								|
				|						
				|				|
		________________|_______________________________|
		| ffff f  | 101	|	   immediate		|	instruction
		|_________|_____|_______________________________|	___________
				 15			       0





		instructions in Instruction File 5A also have J = 101		rsr		BYTE_SIZE
		nd the sign extended 16-bit immediate operand I X U		on		see$6++see$7
										lret		+1



	110	The instruction is in Instruction File 6 and the		assembler syntax example
		operand is the effective address after any			________________________
		indirection or indexing
										drl		BYTE_SIZE
										dsr		15, x
										j		*somewhere
										jc		not_less
										sal		*PAGE_SIZE_LOG
										lcal		0, a



	111	The instruction is in Instruction File 7 and the		assembler syntax example
		operand is one or two or four words at the			________________________
		effective address I X U

										fm	$literals_B3(1.633*-1200009)

										qpush		segment:sequence
												

										dlsc		mantissa
										ds		normalised

										popA		byte_count, x



</pre>

<a	name="isymbol"/>
<h3>3.5 Instruction Field Summary and Programming Symbols</h3>

All instructions at present have one operand field and most may have subfields

<p>
The first subfield is the operand address or value, the second a possible index register, the third an operand type, for example
<pre	style="font-size:12pt">

	andB	table, x, h1

</pre>
<p>
The third subfield, operand type [w0 | h1 | h2 | t1 | t2 | t3 | i | xi] is only for the single-integer instructions
in Instruction File 1 and has the default w0. A File 1 instruction may alternatively mark the operand type
on the instruction field
<pre	style="font-size:12pt">

	ly, i	buffer+10
	aa,t2	matrix, b

</pre>
<p>
An instruction may have operand indirection marked with unary * but then may not also have indexing
<pre	style="font-size:12pt">

	j	*pointer
	lx	*pointer2,,t1

</pre>

<p>
Operand type sign-extended-immediate <b>xi</b> may be designated on File 1 instructions and is automatic on File 5A instructions.
<b>xi</b> operand precludes both indirection and indexing
<pre	style="font-size:12pt">

	ax	-12,,xi
	lret	1

</pre>

Designation <b>i</b> immediate is the effective address used as an immediate operand and may have indirection or indexing.
<b>i</b> operand may be designated for a File 1 instruction and is automatic for File 4A (I/O) and File 6 (jump and shift) instructions
<pre	style="font-size:12pt">

	ab	1,a,i		. add one more than the value in a to b
	inB	*port_table_pointer
	ral	*page_size_log
	j	along

</pre>
<p>
The large arithmetic instructions in Instruction File 7 have storage operands one, two or four words in size,
and may use indirection or indexing to address them
<pre	style="font-size:12pt">

	ql	running_total
	fa	parameter, sp
	
</pre>

<a	name="instru"/>
<h3>3.6 Instructions</h3>

See <a href="#iset">Lookup Panel</a> to find an instruction by name

<pre	style="font-size:12pt">

	<a      name="i24s"/>
	<div    style="margin-left:28pt;font-family:times-roman;font-size:12.75pt;color:0000FF">
	<i>3.6.1	Integer Store Instructions</i>
	</div>
	instructions	<a href="#sr">sr</a>	<a href="#sk">sk</a>	 see also double word store	<a href="#ds">ds</a>
			<a href="#sx">sx</a>	<a href="#sy">sy</a>				and
			<a href="#sa">sa</a>	<a href="#sb">sb</a>	quadword store instructions	<a href="#qs">qs</a>	<a href="#qpop">qpop</a>
			<a href="#z">z</a>	<a href="#pop">pop</a>


	Integer store instructions write a word, or a third or halfword


	An operand mode J mnemonic may be typed either after the instruction mnemonic
	or after the index position:

                sa, t1          record_control_word, y

	Integer store instructions write thirdwords when PSR Flag <b>half$w</b> = 0
	and halfwords when PSR Flag <b>half$w</b> = 1:

		pop		sense_record,,h2








	<a	name="sr"/>
	Store Repeat Count	sr
	__________________	__

				_________________________________________________________
				|							|
				|	repeat count and limit pointer register r	|
				|	is stored					|
				|_______________________________________________________|
				|	destination is memory/register at EA		|
				|	memory target may be a word, half or thirdword	|
				|_______________________________________________________|



	assembler syntax	sr[, {w0|h1|h2}]		target[, {x|y|a|b|fp|sp}] 	

				sr[, {w0|t1|t2|t3}]		target[, {x|y|a|b|fp|sp}]

				sr[, {w0|h1|h2}]		*ptarget	

				sr[, {w0|t1|t2|t3}]		*ptarget

				sr				target[, {x|y|a|b|fp|sp}][, {w0|h1|h2}] 	

				sr				target[, {x|y|a|b|fp|sp}][, {w0|t1|t2|t3}]

				sr				*ptarget[,, {w0|h1|h2}] 	

				sr				*ptarget[,, {w0|t1|t2|t3}]


	assembler examples	sr		target
				sr, h2		target
				sr		target,b,t1
				sr		*ptarget,,h1

				_________________________________________________________
	Instruction Code 0	| 0 0 0 0 0 | 0 . . |		<a style="color:#00FF00">  address</a>		|
				|___________|_______|___________________________________|
				




	<a	name="sk"/>
	Store Mask Register	sk
	___________________	__

				_________________________________________________________
				|							|
				|	mask register k is stored			|
				|_______________________________________________________|
				|	destination is memory/register at EA		|
				|	memory target may be a word, half or thirdword	|
				|_______________________________________________________|



	assembler syntax	sk[, {w0|h1|h2}]		target[, {x|y|a|b|fp|sp}] 	

				sk[, {w0|t1|t2|t3}]		target[, {x|y|a|b|fp|sp}]

				sk[, {w0|h1|h2}]		*ptarget	

				sk[, {w0|t1|t2|t3}]		*ptarget

				sk				target[, {x|y|a|b|fp|sp}][, {w0|h1|h2}] 	

				sk				target[, {x|y|a|b|fp|sp}][, {w0|t1|t2|t3}]

				sk				*ptarget[,, {w0|h1|h2}] 	

				sk				*ptarget[,, {w0|t1|t2|t3}]


	assembler examples	sk		target
				sk, h2		target, x
				sk		target,,t1
				sk		*ptarget,,h1

				_________________________________________________________
	Instruction Code 1	| 0 0 0 0 1 | 0 . . |		<a style="color:#00FF00">  address</a>		|
				|___________|_______|___________________________________|
				




	<a	name="sx"/>
	Store Index Register x	sx
	______________________	__


				_________________________________________________________
				|							|
				|	index register x is stored			|
				|_______________________________________________________|
				|	destination is memory/register at EA		|
				|	memory target may be a word, half or thirdword	|
				|_______________________________________________________|


	assembler syntax	sx[, {w0|h1|h2}]		target[, {x|y|a|b|fp|sp}] 	

				sx[, {w0|t1|t2|t3}]		target[, {x|y|a|b|fp|sp}]

				sx[, {w0|h1|h2}]		*ptarget	

				sx[, {w0|t1|t2|t3}]		*ptarget

				sx				target[, {x|y|a|b|fp|sp}][, {w0|h1|h2}] 	

				sx				target[, {x|y|a|b|fp|sp}][, {w0|t1|t2|t3}]

				sx				*ptarget[,, {w0|h1|h2}] 	

				sx				*ptarget[,, {w0|t1|t2|t3}]


	assembler examples	sx		target, a
				sx, h2		target
				sx		target,,t1
				sx		*ptarget,,h1

				_________________________________________________________
	Instruction Code 2	| 0 0 0 1 0 | 0 . . |		<a style="color:#00FF00">  address</a>		|
				|___________|_______|___________________________________|
				


	<a	name="sy"/>
	Store Index Register y	sy
	______________________	__

				_________________________________________________________
				|							|
				|	index register y is stored			|
				|_______________________________________________________|
				|	destination is memory/register at EA		|
				|	memory target may be a word, half or thirdword	|
				|_______________________________________________________|


	assembler syntax	sy[, {w0|h1|h2}]		target[, {x|y|a|b|fp|sp}] 	

				sy[, {w0|t1|t2|t3}]		target[, {x|y|a|b|fp|sp}]

				sy[, {w0|h1|h2}]		*ptarget	

				sy[, {w0|t1|t2|t3}]		*ptarget

				sy				target[, {x|y|a|b|fp|sp}][, {w0|h1|h2}] 	

				sy				target[, {x|y|a|b|fp|sp}][, {w0|t1|t2|t3}]

				sy				*ptarget[,, {w0|h1|h2}] 	

				sy				*ptarget[,, {w0|t1|t2|t3}]


	assembler examples	sy		target
				sy, h2		target
				sy		target,b,t1
				sy		*ptarget,,h1

				_________________________________________________________
	Instruction Code 3	| 0 0 0 1 1 | 0 . . |		<a style="color:#00FF00">  address</a>		|
				|___________|_______|___________________________________|
				


	<a	name="sa"/>
	Store Arithmetic Register a	sa
	___________________________	__


				_________________________________________________________
				|							|
				|	arithmetic register a is stored			|
				|_______________________________________________________|
				|	destination is memory/register at EA		|
				|	memory target may be a word, half or thirdword	|
				|_______________________________________________________|



	assembler syntax	sa[, {w0|h1|h2}]		target[, {x|y|a|b|fp|sp}] 	

				sa[, {w0|t1|t2|t3}]		target[, {x|y|a|b|fp|sp}]

				sa[, {w0|h1|h2}]		*ptarget	

				sa[, {w0|t1|t2|t3}]		*ptarget

				sa				target[, {x|y|a|b|fp|sp}][, {w0|h1|h2}] 	

				sa				target[, {x|y|a|b|fp|sp}][, {w0|t1|t2|t3}]

				sa				*ptarget[,, {w0|h1|h2}] 	

				sa				*ptarget[,, {w0|t1|t2|t3}]


	assembler examples	sa		target, x
				sa		*(31*/18++OFFSET)
				sa, h2		target
				sa		target,,t1
				sa		*ptarget,,h1

				_________________________________________________________
	Instruction Code 4	| 0 0 1 0 0 | 0 . . |		<a style="color:#00FF00">  address</a>		|
				|___________|_______|___________________________________|
				


	<a	name="sb"/>
	Store Arithmetic Register b	sb
	___________________________	__


				_________________________________________________________
				|							|
				|	arithmetic register b is stored			|
				|_______________________________________________________|
				|	destination is memory/register at EA		|
				|	memory target may be a word, half or thirdword	|
				|_______________________________________________________|


	assembler syntax	sb[, {w0|h1|h2}]		target[, {x|y|a|b|fp|sp}] 	

				sb[, {w0|t1|t2|t3}]		target[, {x|y|a|b|fp|sp}]

				sb[, {w0|h1|h2}]		*ptarget	

				sb[, {w0|t1|t2|t3}]		*ptarget

				sb				target[, {x|y|a|b|fp|sp}][, {w0|h1|h2}] 	

				sb				target[, {x|y|a|b|fp|sp}][, {w0|t1|t2|t3}]

				sb				*ptarget[,, {w0|h1|h2}] 	

				sb				*ptarget[,, {w0|t1|t2|t3}]


	assembler examples	sb		target
				sb, h2		target
				sb		target,y,t1
				sb		*ptarget,,h1

				_________________________________________________________
	Instruction Code 5	| 0 0 1 0 1 | 0 . . |		<a style="color:#00FF00">  address</a>		|
				|___________|_______|___________________________________|
				



	<a	name="z"/>
	Store Zero		z
	__________		_


				_________________________________________________________
				|							|
				|	value zero is written at the operand address	|
				|_______________________________________________________|
				|	destination is memory/register at EA		|
				|	memory target may be a word, half or thirdword	|
				|_______________________________________________________|


	assembler syntax	z[, {w0|h1|h2}]			target[, {x|y|a|b|fp|sp}] 	

				z[, {w0|t1|t2|t3}]		target[, {x|y|a|b|fp|sp}]

				z[, {w0|h1|h2}]			*ptarget	

				z[, {w0|t1|t2|t3}]		*ptarget

				z				target[, {x|y|a|b|fp|sp}][, {w0|h1|h2}] 	

				z				target[, {x|y|a|b|fp|sp}][, {w0|t1|t2|t3}]

				z				*ptarget[,, {w0|h1|h2}] 	

				z				*ptarget[,, {w0|t1|t2|t3}]


	assembler examples	z		target, fp
				z, h2		target
				z		target,,t1
				z		*ptarget,,h1

				_________________________________________________________
	Instruction Code 6	| 0 0 1 1 0 | 0 . . |		<a style="color:#00FF00">  address</a>		|
				|___________|_______|___________________________________|
				



	<a	name="pop"/>
	pop			pop
	___			___

				_________________________________________________________
				|							|
				|	the data word at the internal stack top is 	| 
				|	stored the operand address			|
				|	internal stack pointer sp is incremented	|
				|_______________________________________________________|
                                |       on internal stack overflow / underflow		|
                                |       [sp < 24 | sp > 127] before operation           |
                                |       guard interrupt 95 is raised                    |
				|_______________________________________________________|
				|	destination is memory/register at EA		|
				|	memory target may be a word, half or thirdword	|
				|_______________________________________________________|


	assembler syntax	pop[, {w0|h1|h2}]		target[, {x|y|a|b|fp|sp}] 	

				pop[, {w0|t1|t2|t3}]		target[, {x|y|a|b|fp|sp}]

				pop[, {w0|h1|h2}]		*ptarget

				pop[, {w0|t1|t2|t3}]		*ptarget

				pop				target[, {x|y|a|b|fp|sp}][, {w0|h1|h2}] 	

				pop				target[, {x|y|a|b|fp|sp}][, {w0|t1|t2|t3}]

				pop				*ptarget[,, {w0|h1|h2}] 	

				pop				*ptarget[,, {w0|t1|t2|t3}]


	assembler examples	pop		target
				pop, h2		target
				pop		target,b,t1
				pop		*ptarget,,h1

				_________________________________________________________
	Instruction Code 7	| 0 0 1 1 1 | 0 . . |		<a style="color:#00FF00">  address</a>		|
				|___________|_______|___________________________________|
				




        <a      name="i24l"/>
        <div    style="margin-left:28pt;font-family:times-roman;font-size:12.75pt;color:0000FF">
        <i>3.6.2	Integer Load Instructions</i>
        </div>
	instructions	<a href="#lr">lr</a>		<a href="#lk">lk</a>		see also double word	<a href="#dl">dl</a>	<a href="#dpush">dpush</a>
			<a href="#lx">lx</a>		<a href="#ly">ly</a>				 and
			<a href="#la">la</a>		<a href="#lb">lb</a>	  quadword load instructions	<a href="#ql">ql</a>	<a href="#qpush">qpush</a>
			<a href="#push">push</a>


        Integer load instructions read a one-word operand, a third or halfword,
        the effective address itself as an immediate operand, or a sign-extended immediate operand.


        An operand mode J mnemonic may be typed either after the instruction mnemonic
        or after the index position:

                ly, i           4, b

                lx              4, b, i

                push            -640,,xi

                la, t1          record_control_word, y

        Integer load instructions can read thirdwords when PSR Flag <b>half$w</b> = 0
        and halfwords when PSR Flag <b>half$w</b> = 1:

		lk		masks, y, h1








	<a	name="lr"/>
	Load Repeat Count	lr
	_________________	__


				_________________________________________________________
				|							|
				|	repeat count and limit pointer register r 	|
				|	is loaded					|
				|_______________________________________________________|
				|	source is memory/register value at EA		|
				|	or the value EA or a signed immediate		|
				|	memory source may be a word, half or thirdword	|
				|_______________________________________________________|




	assembler syntax	lr[, {w0|h1|h2|i}]		target[, {x|y|a|b|fp|sp}] 	

				lr[, {w0|t1|t2|t3|i}]		target[, {x|y|a|b|fp|sp}]

				lr[, {w0|h1|h2|i}]		*ptarget

				lr[, {w0|t1|t2|t3|i}]		*ptarget

				lr, i				VALUE[, {x|y|a|b|fp|sp}]

				lr, xi				VALUE

				lr				target[, {x|y|a|b|fp|sp}][, {w0|h1|h2|i}] 	

				lr				target[, {x|y|a|b|fp|sp}][, {w0|t1|t2|t3|i}]

				lr				*ptarget[,, {w0|h1|h2|i}] 	

				lr				*ptarget[,, {w0|t1|t2|t3|i}]

				lr				VALUE[, {x|y|a|b|fp|sp}], i

				lr				VALUE,, xi


	assembler examples	lr			target, sp
				lr			(5000000)
				lr, h2			target
				lr			target,,t1
				lr			*ptarget,,h1

				lr, xi			-48000/2
				lr			12, y, i
				lr, i			apointer
				lr, i			*apointer	[ = lr	apointer ]

				_________________________________________________________
	Instruction Code 8	| 0 1 0 0 0 | . . . |		<a style="color:#00FF00">  address</a>		|
				|___________|_______|___________________________________|
				





	<a	name="lk"/>
	Load Mask Register	lk
	__________________	__


				_________________________________________________________
				|							|
				|	mask register k is loaded	 		|
				|_______________________________________________________|
				|	operand is memory/register value at EA		|
				|	or the value EA or a signed immediate		|
				|	memory source may be a word, half or thirdword	|
				|_______________________________________________________|




	assembler syntax	lk[, {w0|h1|h2|i}]		mask[, {x|y|a|b|fp|sp}] 	

				lk[, {w0|t1|t2|t3|i}]		mask[, {x|y|a|b|fp|sp}]

				lk[, {w0|h1|h2|i}]		*pmask

				lk[, {w0|t1|t2|t3|i}]		*pmask

				lk, i				MASK[, {x|y|a|b|fp|sp}]

				lk, xi				MASK

				lk				mask[, {x|y|a|b|fp|sp}][, {w0|h1|h2|i}] 	

				lk				mask[, {x|y|a|b|fp|sp}][, {w0|t1|t2|t3|i}]

				lk				*pmask[,, {w0|h1|h2|i}] 	

				lk				*pmask[,, {w0|t1|t2|t3|i}]

				lk				MASK[, {x|y|a|b|fp|sp}], i

				lk				MASK,, xi


	assembler examples	lk			mask
				lk			(0FC0000:s)
				lk, h2			mask, y
				lk			mask,,t1
				lk			*ptarget,,h1

				lk, xi			-48000/2
				lk			12, y, i
				lk, i			apointer
				lk, i			*apointer	[ = lk	apointer ]

				_________________________________________________________
	Instruction Code 9	| 0 1 0 0 1 | . . . |		<a style="color:#00FF00">  address</a>		|
				|___________|_______|___________________________________|
				





	<a	name="lx"/>
	Load Index Register x	lx
	_____________________	__


				_________________________________________________________
				|							|
				|	index register x is loaded	 		|
				|_______________________________________________________|
				|	operand is memory/register value at EA		|
				|	or the value EA or a signed immediate		|
				|	memory source may be a word, half or thirdword	|
				|_______________________________________________________|



	assembler syntax	lx[, {w0|h1|h2|i}]		target[, {x|y|a|b|fp|sp}] 	

				lx[, {w0|t1|t2|t3|i}]		target[, {x|y|a|b|fp|sp}]

				lx[, {w0|h1|h2|i}]		*ptarget

				lx[, {w0|t1|t2|t3|i}]		*ptarget

				lx, i				VALUE[, {x|y|a|b|fp|sp}]

				lx, xi				VALUE

				lx				target[, {x|y|a|b|fp|sp}][, {w0|h1|h2|i}] 	

				lx				target[, {x|y|a|b|fp|sp}][, {w0|t1|t2|t3|i}]

				lx				*ptarget[,, {w0|h1|h2|i}] 	

				lx				*ptarget[,, {w0|t1|t2|t3|i}]

				lx				VALUE[, {x|y|a|b|fp|sp}], i

				lx				VALUE,, xi


	assembler examples	lx			target, b
				lx			(47*/18++240:s)
				lx, h2			target
				lx			target,,t1
				lx			*ptarget,,h1

				lx, xi			-48000/2
				lx			12, y, i
				lx, i			apointer
				lx, i			*apointer	[ = lx	apointer ]

				_________________________________________________________
	Instruction Code 10	| 0 1 0 1 0 | . . . |		<a style="color:#00FF00">  address</a>		|
				|___________|_______|___________________________________|
				





	<a	name="ly"/>
	Load Index Register y	ly
	_____________________	__


				_________________________________________________________
				|							|
				|	index register y is loaded			|
				|_______________________________________________________|
				|	operand is memory/register value at EA		|
				|	or the value EA or a signed immediate		|
				|	memory source may be a word, half or thirdword	|
				|_______________________________________________________|



	assembler syntax	ly[, {w0|h1|h2|i}]		target[, {x|y|a|b|fp|sp}] 	

				ly[, {w0|t1|t2|t3|i}]		target[, {x|y|a|b|fp|sp}]

				ly[, {w0|h1|h2|i}]		*ptarget

				ly[, {w0|t1|t2|t3|i}]		*ptarget

				ly, i				VALUE[, {x|y|a|b|fp|sp}]

				ly, xi				VALUE

				ly				target[, {x|y|a|b|fp|sp}][, {w0|h1|h2|i}] 	

				ly				target[, {x|y|a|b|fp|sp}][, {w0|t1|t2|t3|i}]

				ly				*ptarget[,, {w0|h1|h2|i}] 	

				ly				*ptarget[,, {w0|t1|t2|t3|i}]

				ly				VALUE[, {x|y|a|b|fp|sp}], i

				ly				VALUE,, xi


	assembler examples	ly			target
				ly			*(HIGH_ORDER_ADDRESS:s)
				ly, h2			target, a
				ly			target,,t1
				ly			*ptarget

				ly, xi			-48000/2
				ly			12, y, i
				ly, i			apointer
				ly, i			*apointer	[ = ly	apointer ]

				_________________________________________________________
	Instruction Code 11	| 0 1 0 1 1 | . . . |		<a style="color:#00FF00">  address</a>		|
				|___________|_______|___________________________________|
				





	<a	name="la"/>
	Load Arithmetic Register a	la
	__________________________	___


				_________________________________________________________
				|							|
				|	arithmetic register a is loaded			|
				|_______________________________________________________|
				|	operand is memory/register value at EA		|
				|	or the value EA or a signed immediate		|
				|	memory source may be a word, half or thirdword	|
				|_______________________________________________________|





	assembler syntax	la[, {w0|h1|h2|i}]		target[, {x|y|a|b|fp|sp}] 	

				la[, {w0|t1|t2|t3|i}]		target[, {x|y|a|b|fp|sp}]

				la[, {w0|h1|h2|i}]		*ptarget

				la[, {w0|t1|t2|t3|i}]		*ptarget

				la, i				VALUE[, {x|y|a|b|fp|sp}]

				la, xi				VALUE

				la				target[, {x|y|a|b|fp|sp}][, {w0|h1|h2|i}] 	

				la				target[, {x|y|a|b|fp|sp}][, {w0|t1|t2|t3|i}]

				la				*ptarget[,, {w0|h1|h2|i}] 	

				la				*ptarget[,, {w0|t1|t2|t3|i}]

				la				VALUE[, {x|y|a|b|fp|sp}], i

				la				VALUE,, xi


	assembler examples	la			target, sp
				la, h2			target
				la			target,,t1
				la			*ptarget,,h1

				la, xi			-48000/2
				la			12, y, i
				la, i			apointer
				la, i			*apointer	[ = la	apointer ]

				_________________________________________________________
	Instruction Code 12	| 0 1 1 0 0 | . . . |		<a style="color:#00FF00">  address</a>		|
				|___________|_______|___________________________________|
				





	<a	name="lb"/>
	Load Arithmetic Register b	lb
	__________________________	___


				_________________________________________________________
				|							|
				|	arithmetic register b is loaded			|
				|_______________________________________________________|
				|	operand is memory/register value at EA		|
				|	or the value EA or a signed immediate		|
				|	memory source may be a word, half or thirdword	|
				|_______________________________________________________|



	assembler syntax	lb[, {w0|h1|h2|i}]		target[, {x|y|a|b|fp|sp}] 	

				lb[, {w0|t1|t2|t3|i}]		target[, {x|y|a|b|fp|sp}]

				lb[, {w0|h1|h2|i}]		*ptarget

				lb[, {w0|t1|t2|t3|i}]		*ptarget

				lb, i				VALUE[, {x|y|a|b|fp|sp}]

				lb, xi				VALUE

				lb				target[, {x|y|a|b|fp|sp}][, {w0|h1|h2|i}] 	

				lb				target[, {x|y|a|b|fp|sp}][, {w0|t1|t2|t3|i}]

				lb				*ptarget[,, {w0|h1|h2|i}] 	

				lb				*ptarget[,, {w0|t1|t2|t3|i}]

				lb				VALUE[, {x|y|a|b|fp|sp}], i

				lb				VALUE,, xi


	assembler examples	lb			target, a
				lb, h2			target
				lb			target,,t1
				lb			*ptarget,,h1

				lb, xi			-48000/2
				lb			12, y, i
				lb, i			apointer
				lb, i			*apointer	[ = lb	apointer ]

				_________________________________________________________
	Instruction Code 13	| 0 1 1 0 1 | . . . |		<a style="color:#00FF00">  address</a>		|
				|___________|_______|___________________________________|
				




	<a	name="push"/>
	push			push
	____			____

				_________________________________________________________
				|							|
				|	internal stack pointer sp is decremented	| 
				|	operand is copied to the new internal stack top	|
				|_______________________________________________________|
                                |       on internal stack overflow / underflow		|
                                |       [sp < 25 | sp > 128] before operation           |
                                |       guard interrupt 95 is raised                    |
				|_______________________________________________________|
				|	operand is memory/register value at EA		|
				|	or the value EA or a signed immediate		|
				|	memory source may be a word, half or thirdword	|
				|_______________________________________________________|


	assembler syntax	push[, {w0|h1|h2|i}]		target[, {x|y|a|b|fp|sp}] 	

				push[, {w0|t1|t2|t3|i}]		target[, {x|y|a|b|fp|sp}]

				push[, {w0|h1|h2|i}]		*ptarget

				push[, {w0|t1|t2|t3|i}]		*ptarget

				push, i				VALUE[, {x|y|a|b|fp|sp}]

				push, xi			VALUE

				push				target[, {x|y|a|b|fp|sp}][, {w0|h1|h2|i}] 	

				push				target[, {x|y|a|b|fp|sp}][, {w0|t1|t2|t3|i}]

				push				*ptarget[,, {w0|h1|h2|i}] 	

				push				*ptarget[,, {w0|t1|t2|t3|i}]

				push				VALUE[, {x|y|a|b|fp|sp}], i

				push				VALUE,, xi


	assembler examples	push			target
				push			(45*262144+OFFSET:s)
				push			(45*/18++OFFSET:s)
				push, h2		target
				push			target,,t1
				push			*ptarget,,h1

				push, xi		-48000/2
				push			12, y, i
				push, i			apointer
				push, i			*apointer	[ = 	push	apointer ]

				_________________________________________________________
	Instruction Code 31	| 1 1 1 1 1 | . . . |		<a style="color:#00FF00">  address</a>		|
				|___________|_______|___________________________________|
				





        <a      name="i24t"/>
        <div    style="margin-left:28pt;font-family:times-roman;font-size:12.75pt;color:0000FF">
        <i>3.6.3        Integer Test Instructions</i>
        </div>
	instructions	<a href="#tz">Test Zero</a>		<a href="#tp">Test Positive</a>


        Integer test instructions sample a word, or a third or halfword


        An operand mode J mnemonic may be typed either after the instruction mnemonic
        or after the index position:

                tz, t1		record_control_word, y

        Integer test instructions sample thirdwords when PSR Flag <b>half$w</b> = 0
        and halfwords when PSR Flag <b>half$w</b> = 1:

                tp		sense_record,,h2








	<a	name="tz"/>
	Test Zero		tz
	_________		__


				_________________________________________________________
				|							|
				|	next instruction is skipped if operand is zero 	|
				|_______________________________________________________|
				|	operand is memory/register value at EA		|
				|	memory target may be a word, half or thirdword	|
				|_______________________________________________________|


	assembler syntax	tz[, {w0|h1|h2}]		target[, {x|y|a|b|fp|sp|}] 	

				tz[, {w0|t1|t2|t3}]		target[, {x|y|a|b|fp|sp}]

				tz[, {w0|h1|h2}]		*ptarget	

				tz[, {w0|t1|t2|t3}]		*ptarget

				tz				target[, {x|y|a|b|fp|sp|}][, {w0|h1|h2}] 	

				tz				target[, {x|y|a|b|fp|sp}][, {w0|t1|t2|t3}]

				tz				*ptarget[,, {w0|h1|h2}] 	

				tz				*ptarget[,, {w0|t1|t2|t3}]


	assembler examples	tz		target
				tz, h2		target, fp
				tz		target,,t1
				tz		*ptarget,,h1

				_________________________________________________________
	Instruction Code 14	| 0 1 1 1 0 | 0 . . |		<a style="color:#00FF00">  address</a>		|
				|___________|_______|___________________________________|
				



	<a	name="tp"/>
	Test Positive		tp
	_____________		__

				_________________________________________________________
				|							|
				|	next instruction is skipped if operand bit 23	|
				|	is zero						|
				|	half and thirdwords have sign extension		|
				|_______________________________________________________|
				|	operand is memory/register value at EA		|
				|	memory target may be a word, half or thirdword	|
				|_______________________________________________________|



	assembler syntax	tp[, {w0|h1|h2}]		target[, {x|y|a|b|fp|sp|}] 	

				tp[, {w0|t1|t2|t3}]		target[, {x|y|a|b|fp|sp}]

				tp[, {w0|h1|h2}]		*ptarget	

				tp[, {w0|t1|t2|t3}]		*ptarget

				tp				target[, {x|y|a|b|fp|sp|}][, {w0|h1|h2}] 	

				tp				target[, {x|y|a|b|fp|sp}][, {w0|t1|t2|t3}]

				tp				*ptarget[,, {w0|h1|h2}] 	

				tp				*ptarget[,, {w0|t1|t2|t3}]


	assembler examples	tp		target, y
				tp		*(HIGH_ADDRESS:s)
				tp, h2		target
				tp		target,,t1
				tp		*ptarget

				_________________________________________________________
	Instruction Code 15	| 0 1 1 1 1 | 0 . . |		<a style="color:#00FF00">  address</a>		|
				|___________|_______|___________________________________|
				




        <a      name="i24x"/>
        <div    style="margin-left:28pt;font-family:times-roman;font-size:12.75pt;color:0000FF">
        <i>3.6.4        Index Register Add Instructions</i>
        </div>
	instructions	<a href="#ax">ax</a>	<a href="#ay">ay</a>


        Index register add instructions read a one-word operand, a third or halfword,
        the effective address itself as an immediate operand, or a sign-extended immediate operand.


        An operand mode J mnemonic may be typed either after the instruction mnemonic
        or after the index position:

                ay, i           4, b

                ax              4, b, i

                ax		-640,,xi

                ay, t1          record_control_word, y

        Index register add instructions can read thirdwords when PSR Flag <b>half$w</b> = 0
        and halfwords when PSR Flag <b>half$w</b> = 1:

                ax              displacements, y, h1










	<a	name="ax"/>
	Add to Index Register x	ax
	_______________________	__


				_________________________________________________________
				|							|
				|	operand is added to index register x		|
				|	carry$ is not affected				|
				|_______________________________________________________|
				|	operand is memory/register value at EA		|
				|	or the value EA or a signed immediate		|
				|	memory source may be a word, half or thirdword	|
				|_______________________________________________________|



	assembler syntax	ax[, {w0|h1|h2|i}]		address_update[, {x|y|a|b|fp|sp}] 	

				ax[, {w0|t1|t2|t3|i}]		address_update[, {x|y|a|b|fp|sp}]

				ax[, {w0|h1|h2|i}]		*paddress_update

				ax[, {w0|t1|t2|t3|i}]		*paddress_update

				ax, i				ADDRESS_UPDATE[, {x|y|a|b|fp|sp}]

				ax, xi				ADDRESS_UPDATE

				ax				address_update[, {x|y|a|b|fp|sp}][, {w0|h1|h2|i}] 	

				ax				address_update[, {x|y|a|b|fp|sp}][, {w0|t1|t2|t3|i}]

				ax				*paddress_update[,, {w0|h1|h2|i}] 	

				ax				*paddress_update[,, {w0|t1|t2|t3|i}]

				ax				ADDRESS_UPDATE[, {x|y|a|b|fp|sp}], i

				ax				ADDRESS_UPDATE,, xi


	assembler examples	ax			address_update
				ax, h2			address_update, b
				ax			address_update,,t1
				ax			*paddress_update,,h1

				ax, xi			-48000/2
				ax			12, y, i
				ax, i			apointer
				ax, i			*apointer	[ =	ax	apointer ]

				_________________________________________________________
	Instruction Code 16	| 1 0 0 0 0 | . . . |		<a style="color:#00FF00">  address</a>		|
				|___________|_______|___________________________________|
				








	<a	name="ay"/>
	Add to Index Register y	ay
	______________________	__


				_________________________________________________________
				|							|
				|	operand is added to index register y		|
				|	carry$ is not affected				|
				|_______________________________________________________|
				|	operand is memory/register value at EA		|
				|	or the value EA or a signed immediate		|
				|	memory source may be a word, half or thirdword	|
				|_______________________________________________________|



	assembler syntax	ay[, {w0|h1|h2|i}]		address_update[, {x|y|a|b|fp|sp}] 	

				ay[, {w0|t1|t2|t3|i}]		address_update[, {x|y|a|b|fp|sp}]

				ay[, {w0|h1|h2|i}]		*paddress_update

				ay[, {w0|t1|t2|t3|i}]		*paddress_update

				ay, i				ADDRESS_UPDATE[, {x|y|a|b|fp|sp}]

				ay, xi				ADDRESS_UPDATE

				ay				address_update[, {x|y|a|b|fp|sp}][, {w0|h1|h2|i}] 	

				ay				address_update[, {x|y|a|b|fp|sp}][, {w0|t1|t2|t3|i}]

				ay				*paddress_update[,, {w0|h1|h2|i}] 	

				ay				*paddress_update[,, {w0|t1|t2|t3|i}]

				ay				ADDRESS_UPDATE[, {x|y|a|b|fp|sp}], i

				ay				ADDRESS_UPDATE,, xi


	assembler examples	ay			address_update, x
				ay, h2			address_update
				ay			address_update,,t1
				ay			*paddress_update,,h1

				ay, xi			-48000/2
				ay			12, y, i
				ay, i			apointer
				ay, i			*apointer	[ =	ay	apointer ]

				_________________________________________________________
	Instruction Code 17	| 1 0 0 0 1 | . . . |		<a style="color:#00FF00">  address</a>		|
				|___________|_______|___________________________________|
				








        <a      name="i24b"/>
        <div    style="margin-left:28pt;font-family:times-roman;font-size:12.75pt;color:0000FF">
        <i>3.6.5        Boolean Instructions</i>
        </div>
	instructions	<a href="#or">or</a>		<a href="#orb">orB</a>
			<a href="#and">and</a>		<a href="#andb">andB</a>
			<a href="#xor">xor</a>		<a href="#xorb">xorB</a>


        Boolean instructions read a one-word operand, a third or halfword,
        the effective address itself as an immediate operand, or a sign-extended immediate operand.


        An operand mode J mnemonic may be typed either after the instruction mnemonic
        or after the index position:

                orB, i		4, b

                xor		4, b, i

                and		-640,,xi

                xorB, t1	record_control_word, y

        Boolean instructions can read thirdwords when PSR Flag <b>half$w</b> = 0
        and halfwords when PSR Flag <b>half$w</b> = 1:

                andB		masks, y, h1








	<a	name="or"/>
	Or Arithmetic Register a	or
	________________________	__


				_________________________________________________________
				|							|
				|	arithmetic register a OR operand -> a		|
				|_______________________________________________________|
				|	operand is memory/register value at EA		|
				|	or the value EA or a signed immediate		|
				|	memory source may be a word, half or thirdword	|
				|_______________________________________________________|



	assembler syntax	or[, {w0|h1|h2|i}]		mask[, {x|y|a|b|fp|sp}] 	

				or[, {w0|t1|t2|t3|i}]		mask[, {x|y|a|b|fp|sp}]

				or[, {w0|h1|h2|i}]		*pmask

				or[, {w0|t1|t2|t3|i}]		*pmask

				or, i				MASK[, {x|y|a|b|fp|sp}]

				or, xi				MASK

				or				mask[, {x|y|a|b|fp|sp}][, {w0|h1|h2|i}] 	

				or				mask[, {x|y|a|b|fp|sp}][, {w0|t1|t2|t3|i}]

				or				*pmask[,, {w0|h1|h2|i}] 	

				or				*pmask[,, {w0|t1|t2|t3|i}]

				or				MASK[, {x|y|a|b|fp|sp}], i

				or				MASK,, xi


	assembler examples	or			mask
				or, h2			mask, b
				or			mask,,t1
				or			*pmask,,h1

				or, xi			-48000/2
				or			12, y, i
				or, i			apointer
				or, i			*apointer	[ =	or	apointer ]

				_________________________________________________________
	Instruction Code 18	| 1 0 0 1 0 | . . . |		<a style="color:#00FF00">  address</a>		|
				|___________|_______|___________________________________|
				








	<a	name="orb"/>
	Or Arithmetic Register b	orB
	________________________	___


				_________________________________________________________
				|							|
				|	arithmetic register b OR operand -> b		|
				|_______________________________________________________|
				|	operand is memory/register value at EA		|
				|	or the value EA or a signed immediate		|
				|	memory source may be a word, half or thirdword	|
				|_______________________________________________________|




	assembler syntax	orB[, {w0|h1|h2|i}]		mask[, {x|y|a|b|fp|sp}] 	

				orB[, {w0|t1|t2|t3|i}]		mask[, {x|y|a|b|fp|sp}]

				orB[, {w0|h1|h2|i}]		*pmask

				orB[, {w0|t1|t2|t3|i}]		*pmask

				orB, i				MASK[, {x|y|a|b|fp|sp}]

				orB, xi				MASK

				orB				mask[, {x|y|a|b|fp|sp}][, {w0|h1|h2|i}] 	

				orB				mask[, {x|y|a|b|fp|sp}][, {w0|t1|t2|t3|i}]

				orB				*pmask[,, {w0|h1|h2|i}] 	

				orB				*pmask[,, {w0|t1|t2|t3|i}]

				orB				MASK[, {x|y|a|b|fp|sp}], i

				orB				MASK,, xi


	assembler examples	orB			mask
				orB, h2			mask
				orB			mask,a,t1
				orB			*pmask,,h1

				orB, xi			-48000/2
				orB			12, y, i
				orB, i			apointer
				orB, i			*apointer	[ =	orB	apointer ]

				_________________________________________________________
	Instruction Code 19	| 1 0 0 1 1 | . . . |		<a style="color:#00FF00">  address</a>		|
				|___________|_______|___________________________________|
				








	<a	name="and"/>
	And Arithmetic Register a	and
	_________________________	___


				_________________________________________________________
				|							|
				|	arithmetic register a AND operand -> a		|
				|_______________________________________________________|
				|	operand is memory/register value at EA		|
				|	or the value EA or a signed immediate		|
				|	memory source may be a word, half or thirdword	|
				|_______________________________________________________|




	assembler syntax	and[, {w0|h1|h2|i}]		mask[, {x|y|a|b|fp|sp}] 	

				and[, {w0|t1|t2|t3|i}]		mask[, {x|y|a|b|fp|sp}]

				and[, {w0|h1|h2|i}]		*pmask

				and[, {w0|t1|t2|t3|i}]		*pmask

				and, i				MASK[, {x|y|a|b|fp|sp}]

				and, xi				MASK

				and				mask[, {x|y|a|b|fp|sp}][, {w0|h1|h2|i}] 	

				and				mask[, {x|y|a|b|fp|sp}][, {w0|t1|t2|t3|i}]

				and				*pmask[,, {w0|h1|h2|i}] 	

				and				*pmask[,, {w0|t1|t2|t3|i}]

				and				MASK[, {x|y|a|b|fp|sp}], i

				and				MASK,, xi


	assembler examples	and			mask
				and, h2			mask, x
				and			mask,,t1
				and			*pmask,,h1

				and, xi			-48000/2
				and			12, y, i
				and, i			apointer
				and, i			*apointer	[ =	and	apointer ]

				_________________________________________________________
	Instruction Code 20	| 1 0 1 0 0 | . . . |		<a style="color:#00FF00">  address</a>		|
				|___________|_______|___________________________________|
				








	<a	name="andb"/>
	And Arithmetic Register b	andB
	_________________________	___


				_________________________________________________________
				|							|
				|	arithmetic register b AND operand -> b		|
				|_______________________________________________________|
				|	operand is memory/register value at EA		|
				|	or the value EA or a signed immediate		|
				|	memory source may be a word, half or thirdword	|
				|_______________________________________________________|



	assembler syntax	andB[, {w0|h1|h2|i}]		mask[, {x|y|a|b|fp|sp}] 	

				andB[, {w0|t1|t2|t3|i}]		mask[, {x|y|a|b|fp|sp}]

				andB[, {w0|h1|h2|i}]		*pmask

				andB[, {w0|t1|t2|t3|i}]		*pmask

				andB, i				MASK[, {x|y|a|b|fp|sp}]

				andB, xi			MASK

				andB				mask[, {x|y|a|b|fp|sp}][, {w0|h1|h2|i}] 	

				andB				mask[, {x|y|a|b|fp|sp}][, {w0|t1|t2|t3|i}]

				andB				*pmask[,, {w0|h1|h2|i}] 	

				andB				*pmask[,, {w0|t1|t2|t3|i}]

				andB				MASK[, {x|y|a|b|fp|sp}], i

				andB				MASK,, xi


	assembler examples	andB			(MASK_VALUE)
				andB, h2		mask
				andB			mask,,t1
				andB			*pmask,,h1

				andB, xi		-48000/2
				andB			12, y, i
				andB, i			apointer
				andB, i			*apointer	[ =	andB	apointer ]

				_________________________________________________________
	Instruction Code 21	| 1 0 1 0 1 | . . . |		<a style="color:#00FF00">  address</a>		|
				|___________|_______|___________________________________|
				








	<a	name="xor"/>
	Exlusive Or Arithmetic Register a	xor
	_________________________________	___


				_________________________________________________________
				|							|
				|	arithmetic register a XOR operand -> a		|
				|_______________________________________________________|
				|	operand is memory/register value at EA		|
				|	or the value EA or a signed immediate		|
				|	memory source may be a word, half or thirdword	|
				|_______________________________________________________|


	assembler syntax	xor[, {w0|h1|h2|i}]		mask[, {x|y|a|b|fp|sp}] 	

				xor[, {w0|t1|t2|t3|i}]		mask[, {x|y|a|b|fp|sp}]

				xor[, {w0|h1|h2|i}]		*pmask

				xor[, {w0|t1|t2|t3|i}]		*pmask

				xor, i				MASK[, {x|y|a|b|fp|sp}]

				xor, xi				MASK

				xor				mask[, {x|y|a|b|fp|sp}][, {w0|h1|h2|i}] 	

				xor				mask[, {x|y|a|b|fp|sp}][, {w0|t1|t2|t3|i}]

				xor				*pmask[,, {w0|h1|h2|i}] 	

				xor				*pmask[,, {w0|t1|t2|t3|i}]

				xor				MASK[, {x|y|a|b|fp|sp}], i

				xor				MASK,, xi


	assembler examples	xor			mask
				xor, h2			mask
				xor			mask,,t1
				xor			*pmask,,h1

				xor, xi			-48000/2
				xor			12, y, i
				xor, i			apointer
				xor, i			*apointer	[ =	xor	apointer ]

				_________________________________________________________
	Instruction Code 22	| 1 0 1 1 0 | . . . |		<a style="color:#00FF00">  address</a>		|
				|___________|_______|___________________________________|
				








	<a	name="xorb"/>
	Exlusive Or Arithmetic Register b	xorB
	_________________________________	____


				_________________________________________________________
				|							|
				|	arithmetic register b XOR operand -> b		|
				|_______________________________________________________|
				|	operand is memory/register value at EA		|
				|	or the value EA or a signed immediate		|
				|	memory source may be a word, half or thirdword	|
				|_______________________________________________________|


	assembler syntax	xorB[, {w0|h1|h2|i}]		mask[, {x|y|a|b|fp|sp}] 	

				xorB[, {w0|t1|t2|t3|i}]		mask[, {x|y|a|b|fp|sp}]

				xorB[, {w0|h1|h2|i}]		*pmask

				xorB[, {w0|t1|t2|t3|i}]		*pmask

				xorB, i				MASK[, {x|y|a|b|fp|sp}]

				xorB, xi			MASK

				xorB				mask[, {x|y|a|b|fp|sp}][, {w0|h1|h2|i}] 	

				xorB				mask[, {x|y|a|b|fp|sp}][, {w0|t1|t2|t3|i}]

				xorB				*pmask[,, {w0|h1|h2|i}] 	

				xorB				*pmask[,, {w0|t1|t2|t3|i}]

				xorB				MASK[, {x|y|a|b|fp|sp}], i

				xorB				MASK,, xi


	assembler examples	xorB			mask
				xorB, h2		mask
				xorB			mask,a,t1
				xorB			*pmask,,h1

				xorB, xi		-48000/2
				xorB			12, y, i
				xorB, i			apointer
				xorB, i			*apointer	[ =	xorB	apointer ]

				_________________________________________________________
	Instruction Code 23	| 1 0 1 1 1 | . . . |		<a style="color:#00FF00">  address</a>		|
				|___________|_______|___________________________________|
				




        <a      name="i24a"/>
        <div    style="margin-left:28pt;font-family:times-roman;font-size:12.75pt;color:0000FF">
        <i>3.6.6        Integer Arithmetic Instructions</i>
        </div>
	instructions	<a href="#aa">aa</a>		<a href="#ana">ana</a>		see also double word	<a href="#da">da</a>
			<a href="#ab">ab</a>		<a href="#anb">anb</a>		  add &plusmn; instructions	<a href="#dan">dan</a>
			<a href="#m">m</a>		<a href="#d">d</a>
			<a href="#mf">mf</a>


        Integer arithmetic instructions read a one-word operand, a third or halfword,
        the effective address itself as an immediate operand, or a sign-extended immediate operand.


        An operand mode J mnemonic may be typed either after the instruction mnemonic
        or after the index position:

                aa, i		4, b

                m		4, b, i

                d		-640,,xi

                mf, t1		record_control_word, y

        Integer arithmetic instructions can read thirdwords when PSR Flag <b>half$w</b> = 0
        and halfwords when PSR Flag <b>half$w</b> = 1:

                anb		masks, y, h1








	<a	name="aa"/>
	Add to Arithmetic Register a	aa
	____________________________	__

				_________________________________________________________
				|							|
				|	arithmetic register a + operand -> a		|
				|	carry$ = the carry from bit 23 of the addition	|
				|_______________________________________________________|
				|	operand is memory/register value at EA		|
				|	or the value EA or a signed immediate		|
				|	memory source may be a word, half or thirdword	|
				|_______________________________________________________|


	assembler syntax	aa[, {w0|h1|h2|i}]		addend[, {x|y|a|b|fp|sp}] 	

				aa[, {w0|t1|t2|t3|i}]		addend[, {x|y|a|b|fp|sp}]

				aa[, {w0|h1|h2|i}]		*paddend

				aa[, {w0|t1|t2|t3|i}]		*paddend

				aa, i				ADDEND[, {x|y|a|b|fp|sp}]

				aa, xi				ADDEND

				aa				addend[, {x|y|a|b|fp|sp}][, {w0|h1|h2|i}] 	

				aa				addend[, {x|y|a|b|fp|sp}][, {w0|t1|t2|t3|i}]

				aa				*paddend[,, {w0|h1|h2|i}] 	

				aa				*paddend[,, {w0|t1|t2|t3|i}]

				aa				ADDEND[, {x|y|a|b|fp|sp}], i

				aa				ADDEND,, xi


	assembler examples	aa			addend
				aa			(2000000)
				aa, h2			addend
				aa			addend,,t1
				aa			*paddend,,h1

				aa, xi			-48000/2
				aa			12, y, i
				aa, i			apointer
				aa, i			*apointer	[ =	aa	apointer ]

				_________________________________________________________
	Instruction Code 24	| 1 1 0 0 0 | . . . |		<a style="color:#00FF00">  address</a>		|
				|___________|_______|___________________________________|
				








	<a	name="ab"/>
	Add to Arithmetic Register b	ab
	____________________________	__

				_________________________________________________________
				|							|
				|	arithmetic register b + operand -> b		|
				|	carry$ = the carry from bit 23 of the addition	|
				|_______________________________________________________|
				|	operand is memory/register value at EA		|
				|	or the value EA or a signed immediate		|
				|	memory source may be a word, half or thirdword	|
				|_______________________________________________________|


	assembler syntax	ab[, {w0|h1|h2|i}]		addend[, {x|y|a|b|fp|sp}] 	

				ab[, {w0|t1|t2|t3|i}]		addend[, {x|y|a|b|fp|sp}]

				ab[, {w0|h1|h2|i}]		*paddend

				ab[, {w0|t1|t2|t3|i}]		*paddend

				ab, i				ADDEND[, {x|y|a|b|fp|sp}]

				ab, xi				ADDEND

				ab				addend[, {x|y|a|b|fp|sp}][, {w0|h1|h2|i}] 	

				ab				addend[, {x|y|a|b|fp|sp}][, {w0|t1|t2|t3|i}]

				ab				*paddend[,, {w0|h1|h2|i}] 	

				ab				*paddend[,, {w0|t1|t2|t3|i}]

				ab				ADDEND[, {x|y|a|b|fp|sp}], i

				ab				ADDEND, xi


	assembler examples	ab			addend, x
				ab			(-3000000)
				ab, h2			addend
				ab			addend,,t1
				ab			*paddend,,h1

				ab, xi			-48000/2
				ab			12, y, i
				ab, i			apointer
				ab, i			*apointer	[ =	ab	apointer ]

				_________________________________________________________
	Instruction Code 25	| 1 1 0 0 1 | . . . |		<a style="color:#00FF00">  address</a>		|
				|___________|_______|___________________________________|
				








	<a	name="ana"/>
	Add Negative to Arithmetic Register a	ana
	_____________________________________	___

				_________________________________________________________
				|							|
				|	arithmetic register a += 2scomplement(operand)	|
				|	carry$ = the carry from bit 23 of the addition	|
				|_______________________________________________________|
				|	operand is memory/register value at EA		|
				|	or the value EA or a signed immediate		|
				|	memory source may be a word, half or thirdword	|
				|_______________________________________________________|


	assembler syntax	ana[, {w0|h1|h2|i}]		subtrahend[, {x|y|a|b|fp|sp}] 	

				ana[, {w0|t1|t2|t3|i}]		subtrahend[, {x|y|a|b|fp|sp}]

				ana[, {w0|h1|h2|i}]		*psubtrahend

				ana[, {w0|t1|t2|t3|i}]		*psubtrahend

				ana, i				SUBTRAHEND[, {x|y|a|b|fp|sp}]

				ana, xi				SUBTRAHEND

				ana				subtrahend[, {x|y|a|b|fp|sp}][, {w0|h1|h2|i}] 	

				ana				subtrahend[, {x|y|a|b|fp|sp}][, {w0|t1|t2|t3|i}]

				ana				*psubtrahend[,, {w0|h1|h2|i}] 	

				ana				*psubtrahend[,, {w0|t1|t2|t3|i}]

				ana				SUBTRAHEND[, {x|y|a|b|fp|sp}], i

				ana				SUBTRAHEND,, xi


	assembler examples	ana			subtrahend
				ana, h2			subtrahend
				ana			subtrahend,,t1
				ana			*psubtrahend,,h1

				ana, xi			-48000/2
				ana			12, y, i
				ana, i			apointer
				ana, i			*apointer	[ =	ana	apointer ]

				_________________________________________________________
	Instruction Code 26	| 1 1 0 1 0 | . . . |		<a style="color:#00FF00">  address</a>		|
				|___________|_______|___________________________________|
				






	<a	name="anb"/>
	Add Negative to Arithmetic Register b	anb
	_____________________________________	___

				_________________________________________________________
				|							|
				|	arithmetic register b += 2scomplement(operand)	|
				|	carry$ = the carry from bit 23 of the addition	|
				|_______________________________________________________|
				|	operand is memory/register value at EA		|
				|	or the value EA or a signed immediate		|
				|	memory source may be a word, half or thirdword	|
				|_______________________________________________________|


	assembler syntax	anb[, {w0|h1|h2|i}]		subtrahend[, {x|y|a|b|fp|sp}] 	

				anb[, {w0|t1|t2|t3|i}]		subtrahend[, {x|y|a|b|fp|sp}]

				anb, {w0|h1|h2|i}]		*psubtrahend

				anb[, {w0|t1|t2|t3|i}]		*psubtrahend

				anb, i				SUBTRAHEND[, {x|y|a|b|fp|sp}]

				anb, xi				SUBTRAHEND

				anb				subtrahend[, {x|y|a|b|fp|sp}][, {w0|h1|h2|i}] 	

				anb				subtrahend[, {x|y|a|b|fp|sp}][, {w0|t1|t2|t3|i}]

				anb				*psubtrahend[,, {w0|h1|h2|i}] 	

				anb				*psubtrahend[,, {w0|t1|t2|t3|i}]

				anb				SUBTRAHEND[, {x|y|a|b|fp|sp}], i

				anb				SUBTRAHEND,, xi


	assembler examples	anb			subtrahend, a
				anb, h2			subtrahend
				anb			subtrahend,,t1
				anb			*psubtrahend,,h1

				anb, xi			-48000/2
				anb			12, y, i
				anb, i			apointer
				anb, i			*apointer	[ =	anb	apointer ]

				_________________________________________________________
	Instruction Code 27	| 1 1 0 1 1 | . . . |		<a style="color:#00FF00">  address</a>		|
				|___________|_______|___________________________________|
				








	<a	name="m"/>
	Multiply		m
	________		_


				_________________________________________________________
				|							|
				|	operand and arithmetic register b are		|
				|	multiplied algebraically. The 48-bit product	|					
				|	is stored in arithmetic registers a and b	|
				|_______________________________________________________|
				|	operand is memory/register value at EA		|
				|	or the value EA or a signed immediate		|
				|	memory source may be a word, half or thirdword	|
				|_______________________________________________________|


	assembler syntax	m[, {w0|h1|h2|i}]		multiplier[, {x|y|a|b|fp|sp}] 	

				m[, {w0|t1|t2|t3|i}]		multiplier[, {x|y|a|b|fp|sp}]

				m[, {w0|h1|h2|i}]		*pmultiplier

				m[, {w0|t1|t2|t3|i}]		*pmultiplier

				m, i				MULTIPLIER[, {x|y|a|b|fp|sp}]

				m, xi				MULTIPLIER

				m				multiplier[, {x|y|a|b|fp|sp}][, {w0|h1|h2|i}] 	

				m				multiplier[, {x|y|a|b|fp|sp}][, {w0|t1|t2|t3|i}]

				m				*pmultiplier[,, {w0|h1|h2|i}] 	

				m				*pmultiplier[,, {w0|t1|t2|t3|i}]

				m				MULTIPLIER[, {x|y|a|b|fp|sp}], i

				m				MULTIPLIER,, xi


	assembler examples	m			multiplier
				m			(-1250000)
				m, h2			multiplier
				m			multiplier,,t1
				m			*pmultiplier,,h1

				m, xi			-48000/2
				m			12, y, i
				m, i			apointer
				m, i			*apointer	[ =	m	apointer ]

				_________________________________________________________
	Instruction Code 28	| 1 1 1 0 0 | . . . |		<a style="color:#00FF00">  address</a>		|
				|___________|_______|___________________________________|
				








	<a	name="mf"/>
	Multiply Fractional	mf
	___________________	__

				_________________________________________________________
				|							|
				|	unsigned integer in register b is multiplied.	|
				|	multiplier is signed. 48-bit product		|
				|	is stored in arithmetic registers a and b	|
				|							|
				|	multiply fractional is used for			|
				|							|
				|	   display edit of floating fractions		|
				|							|
				|	   integer multiplication with multiplicands of	|
				|	   2 or more words				|
				|_______________________________________________________|
				|	multiplier is memory/register value at EA	|
				|	or the value EA or a signed immediate.		|
				|	memory source may be a word, half or thirdword	|
				|_______________________________________________________|


	assembler syntax	mf[, {w0|h1|h2|i}]		multiplier[, {x|y|a|b|fp|sp}] 	

				mf[, {w0|t1|t2|t3|i}]		multiplier[, {x|y|a|b|fp|sp}]

				mf[, {w0|h1|h2|i}]		*pmultiplier

				mf[, {w0|t1|t2|t3|i}]		*pmultiplier

				mf, i				MULTIPLIER[, {x|y|a|b|fp|sp}]

				mf, xi				MULTIPLIER

				mf				multiplier[, {x|y|a|b|fp|sp}][, {w0|h1|h2|i}] 	

				mf				multiplier[, {x|y|a|b|fp|sp}][, {w0|t1|t2|t3|i}]

				mf				*pmultiplier[,, {w0|h1|h2|i}] 	

				mf				*pmultiplier[,, {w0|t1|t2|t3|i}]

				mf				MULTIPLIER[, {x|y|a|b|fp|sp}], i

				mf				MULTIPLIER,, xi


	assembler examples	mf			multiplier, x
				mf, h2			multiplier
				mf			multiplier,,t1
				mf			*pmultiplier,,h1

				mf, xi			-48000/2
				mf			12, y, i
				mf, i			apointer
				mf, i			*apointer	[ =	mf	apointer ]

				_________________________________________________________
	Instruction Code 29	| 1 1 1 0 1 | . . . |		<a style="color:#00FF00">  address</a>		|
				|___________|_______|___________________________________|
				








	<a	name="d"/>
	Divide			d
	______			_

				_________________________________________________________
				|							|
				|	the 48-bit integer in arithmetic registers	|
				|	a and b is divided algebraically by the operand	|
				|	giving a 48-bit integer quotient and 24-bit	|
				|	integer remainder				|
				|							|
				|	quotient low-order 24 bits are in register a	|
				|	and high-order 24-bits in register mantissa2	|
				|							|
				|	remainder is in register b			|
				|							|
				|_______________________________________________________|
				|	operand is memory/register value at EA		|
				|	or the value EA or a signed immediate		|
				|	memory source may be a word, half or thirdword	|
				|_______________________________________________________|


	assembler syntax	d[, {w0|h1|h2|i}]		divisor[, {x|y|a|b|fp|sp}] 	

				d[, {w0|t1|t2|t3|i}]		divisor[, {x|y|a|b|fp|sp}]

				d[, {w0|h1|h2|i}]		*pdivisor

				d[, {w0|t1|t2|t3|i}]		*pdivisor

				d, i				DIVISOR[, {x|y|a|b|fp|sp}]

				d, xi				DIVISOR

				d				divisor[, {x|y|a|b|fp|sp}][, {w0|h1|h2|i}] 	

				d				divisor[, {x|y|a|b|fp|sp}][, {w0|t1|t2|t3|i}]

				d				*pdivisor[,, {w0|h1|h2|i}] 	

				d				*pdivisor[,, {w0|t1|t2|t3|i}]

				d				DIVISOR[, {x|y|a|b|fp|sp}], i

				d				value,, xi


	assembler examples	d			divisor
				d			(1000000)
				d, h2			divisor
				d			divisor,,t1
				d			*pdivisor,,h1

				d, xi			-48000/2
				d			12, y, i
				d, i			apointer
				d, i			*apointer	[ =	d	apointer ]

				_________________________________________________________
	Instruction Code 30	| 1 1 1 1 0 | . . . |		<a style="color:#00FF00">  address</a>		|
				|___________|_______|___________________________________|
				










	<a	name="io"/>
	<div    style="margin-left:28pt;font-family:times-roman;font-size:12.75pt;color:0000FF">
	<i>3.6.7	I/O Ports Input and Output Instructions</i>
	</div>
	instructions	<a href="#ina">inA</a>		<a href="#outa">outA</a>
			<a href="#inb">inB</a>		<a href="#outb">outB</a>


	Input and Output Instructions identify the target port by effective address
	with or without indirection or indexing:


		inA		SOURCE_PORT
		outB		*target_port_pointer

		inB		RELATIVE_PORT_NUMBER, a






	<a	name="ina"/>
	I/O In to Arithmetic Register a		inA
	_______________________________		___

				_________________________________________________________
				|							|
				|	I/O port[EA] is read to arithmetic register a	|
				|_______________________________________________________|
				|	source is the I/O port EA			|
				|_______________________________________________________|

	assembler syntax	inA		PORT_NUMBER[, {x|y|a|b|fp|sp}]
				inA		*port_number_variable

				_________________________________________________________
	Instruction Code 0.4	| 0 0 0 0 0 | 1 0 0 | . . . .  . . . . . . . . . . . .	|
				|___________|_______|___________________________________|





	<a	name="inb"/>
	I/O In to Arithmetic Register b		inB
	_______________________________		___

				_________________________________________________________
				|							|
				|	I/O port[EA] is read to arithmetic register b	|
				|_______________________________________________________|
				|	source is the I/O port EA			|
				|_______________________________________________________|


	assembler syntax	inB		PORT_NUMBER[, {x|y|a|b|fp|sp}]
				inB		*port_number_variable

				_________________________________________________________
	Instruction Code 1.4	| 0 0 0 0 1 | 1 0 0 | . . . .  . . . . . . . . . . . .	|
				|___________|_______|___________________________________|





	<a	name="outa"/>
	I/O Out from Arithmetic Register a	outA
	__________________________________	____

				_________________________________________________________
				|							|
				|	value is written from register a to I/O port[EA]|
				|_______________________________________________________|
				|	target is the I/O port EA			|
				|_______________________________________________________|

	assembler syntax	outA		PORT_NUMBER[, {x|y|a|b|fp|sp}]
				outA		*port_number_variable

				_________________________________________________________
	Instruction Code 2.4	| 0 0 0 1 0 | 1 0 0 | . . . .  . . . . . . . . . . . .	|
				|___________|_______|___________________________________|






	<a	name="outb"/>
	I/O Out from Arithmetic Register b	outB
	__________________________________	____

				_________________________________________________________
				|							|
				|	value is written from register b to I/O port[EA]|
				|_______________________________________________________|
				|	target is the I/O port EA			|
				|_______________________________________________________|


	assembler syntax	outB		PORT_NUMBER[, {x|y|a|b|fp|sp}]
				outB		*port_number_variable

				_________________________________________________________
	Instruction Code 3.4	| 0 0 0 1 1 | 1 0 0 | . . . .  . . . . . . . . . . . .	|
				|___________|_______|___________________________________|






        <a      name="relo"/>
        <div    style="margin-left:28pt;font-family:times-roman;font-size:12.75pt;color:0000FF">
        <i>3.6.8        Process and Thread Memory Switch Instructions</i>
        </div>
	Applications issue <a href="#sabr">sabr</a> instruction to select memory blocks B2..B63

	Kernel issues <a href="#reload">reload</a> instruction to switch application memory space

	<a href="#b1">B1</a> is a private stack frame organised with I/O instructions




	<a	name="sabr"/>
	Store Arithmetic Register a to Base Register	sabr
	____________________________________________	____


				_________________________________________________________
				|							|
				|	the absolute pointer part of the storage	|
				|	block identified in register a is written 	|
				|	to data window pointer I/O Port[EA]		|
				|							|
				|	the storage block symbolic identifier is copied	|
				|	from register a to memory window 65 (thread	|
				|	control block) offset 64 + EA			|
				|							|
				|	value of EA may be 2..63			|
				|							|
				|	symbolic identifier and absolute storage pointer|
				|	are identical. There are no translated pointer	|
				|	values in the scope of sabr instruction		|
				|							|
				|	sabr is an instruction for application use	|
				|	but only interrupt code may place a block	|
				|	of a filestore or network relay device array	|
				|	in a data address space window			|
				|							|
				|	applications may place executable memory	|
				|	and device arrays with the same bus behaviour as|
				|	executable space in data address space windows	|
				|							|
				|	neither applications nor interrupt code may base|
				|	executable pages below the <a href="#thresho">application threshold</a>|
				|							|
				|	sabr operations which are not permitted	raise	|
				|	interrupt GUARD$ 				|
				|							|
				|	if the target device array does not have the	|
				|	requested page then sabr instruction assigns	|
				|	the pointer value C00001 to the address window	|
				|							|
				|	pointer value C00001 raises interrupt GUARD$	|
				|	on memory read or write	in the assigned window	|
				|							|
				|	C00001 is the unique member of a range of	|
				|	functional storage base pointer values		|
				|							|
				|	the unused address windows of threads		|	 
				|	have the pointer value C00001			|
				|_______________________________________________________|




	assembler syntax	sabr		RELOCATION_REGISTER_ID[, {x|y|a|b|fp|sp}]
				sabr		*base_register_id_variable

				_________________________________________________________
	Instruction Code 6.4	| 0 0 1 1 0 | 1 0 0 | . . . .  . . . . . . . . . . . .	|
				|___________|_______|___________________________________|







	<a	name="reload"/>
	Reload			reload
	______			______

				_________________________________________________________
				|							|
				|	two storage block identifiers are read from	|
				|	memory at the address in Register a		|
				|							|
				|	the two retrieved storage pointers are written	|
				|	to relocation registers				|
				|							|
				|		I/O Port[EA]				|
				|		I/O Port[EA + 1]			|
				|							|
				|	Register a is incremented by 2			|
				|							|
				|	value of EA can be 2..62			|
				|_______________________________________________________|
				|							|
				|	reload instruction is used in the loadup beat	|
				|	of thread/process switch			|
				|							|
				|	it reads the list of identifiers which is stored|
				|	in the thread control block as the application	|
				|	obtains memory					|
				|_______________________________________________________|
				|	source is two storage words at [a]		|
				|	target is memory block pointer ports[EA, EA + 1]|
				|_______________________________________________________|


	assembler syntax	reload			RELOCATION_REGISTER_PAIR[, {x|y|a|b|fp|sp}]
				reload			*base_register_id_variable


	assembler example	la, xi		TCB_BASE_REGISTER_TABLE+B2
			?	$do		USER_WINDOWS/2,	reload	?*2

				_________________________________________________________
	Instruction Code 4.4	| 0 0 1 0 0 | 1 0 0 | . . . .  . . . . . . . . . . . .	|
				|___________|_______|___________________________________|




	<a	name="b1"/>
	<div	style="font-size:11pt">
	_________________________________________________________________________________________________________________
	|					   BANK B1 PRIVATE STORAGE FRAME					|
	|_______________________________________________________________________________________________________________|
	|														|
	|	window B1 is a frame in a private stack. B1 is outside the scope of sabr and reload instructions	|
	|														|
	|	<a href="#sabr">sabr</a> and <a href="#reload">reload</a> instructions concern windows B2..B63				|
	|														|
	|	applications execute sabr instruction to base memory blocks in B2..B63					|
	|	sabr also copies the relocation values through to the TCB						|
	|														|
	|	reload instruction bases some or all of B2..B63 in pairs on the loadup beat of thread switch		|
	|														|
	|	Applications manipulate and restore B1 pointer in a different dynamic from B2..63			|
	|														|
	|	Thread switch inputs B1 from I/O Port 1 and saves it individually					|
	|	Thread switch outputs B1 of the loading thread to I/O Port 1 individually				|
	|														|
	|_______________________________________________________________________________________________________________|
	|														|
	|														|
	|	A process has at least one B1 frame or 4K block								|
        |														|
        |	a B1 frame contains private data at addresses 4096..8191						|
	|														|
	|	divisions of a process may have separate B1 frames							|
	|														|
	|	the owning entity of a B1 frame may be a thread, a service, a function,					|
	|	or a recursive execution of a function									|
	|														|
	|	services base a B1 frame temporarily to use private data on behalf of calling routines			|
	|														|
	|	it may not be assumed that a called entity may reference addresses in the caller B1 framea		|
	|	so call parameters by reference are not in the adresses 001000..001FFF					|
	|														|
	|	the private data in B1 may include mechanical information underlying a service and compiler-generated	|
	|	information like database subschemas									|
	|														|
	|														|
	|_______________________________________________________________________________________________________________|
	</div>





        <a      name="onoff"/>
        <div    style="margin-left:28pt;font-family:times-roman;font-size:12.75pt;color:0000FF">
        <i>3.6.9	PSR Flags Update Instructions</i>
        </div>
	<a	name="on"/>
	<a href="#on">On</a> and <a href="#off">Off</a> instructions switch PSR flags according to bits 15..0 of
	the sign-extended immediate operand


	PSR Flags On		on
	____________		__

				_________________________________________________________
				|							|
				|	1 is written to PSR flags designated by 1 in the|
				|	immediate operand. Only Flags 15..0 are affected|
				|_______________________________________________________|
				|	MASK is 16-bit immediate with sign extension	|
				|_______________________________________________________|


	assembler syntax	on	PSR_FLAGS_MASK

	assembler example	on	see$1++see$6++see$7


				_________________________________________________________
	Instruction Code 0.5	| 0 0 0 0 0 | 1 0 1 |		   MASK			|
				|___________|_______|___________________________________|





	<a	name="off"/>
	PSR Flags Off		off
	_____________		___


				_________________________________________________________
				|							|
				|	0 is written to PSR flags designated by 1 in the|
				|	immediate operand. Only Flags 15..0 are affected|
				|_______________________________________________________|
				|	MASK is 16-bit immediate with sign extension	|
				|_______________________________________________________|


	assembler syntax	off	PSR_FLAGS_MASK

	assembler example	off	half$w++carry$

				_________________________________________________________
	Instruction Code 1.5	| 0 0 0 0 1 | 1 0 1 | 		    MASK		|
				|___________|_______|___________________________________|




	<a      name="bstream"/>
	<div    style="margin-left:28pt;font-family:times-roman;font-size:12.75pt;color:0000FF">
	<i>3.6.10	Bit Stream Read and Write Channels</i>
	</div>
	instructions	<a href="#rsr">Read Staging Register</a>	<a href="#wsr">Write Staging Register</a>


<div	style="font-size:11pt">
        _________________________________________________________________________________________________________________
        |					    The Bit Stream Read Channel						|
        |_______________________________________________________________________________________________________________|
        |														|
	|	The Bit Stream Read Channel allows storage to be read in bit fields up to 24 bits			|
	|	Bit fields may be read across word boundaries transparently						|
	|														|
	|	Successive reads may be field of equal or irregular size				 		|
	|	Alternatively successive reads may be an irregular number of bits					|
	|														|
	|	24 bits may be read from each storage word, or 16 bits to accommodate 16-bit input devices		|
	|														|
	|	Read Staging Register instruction drives the Bit Stream Read Channel					|
	|_______________________________________________________________________________________________________________|
<a	style="color:0000FF">
	_________________________________________________________________________________________________________________
	|						   Multiplexing							|
	|_______________________________________________________________________________________________________________|
	|														|
	|	The Bit Stream Read Channel is within application context, so every thread has one			|
	|														|
	|	Many applications only scan one read stream, stdin							|
	|														|
	|	The prototype kernel smaragd7 has a system call for switching stream states				|
	|	so that an application may scan many ANSI filestreams and other arrays in overlapped time		|
	|_______________________________________________________________________________________________________________|
</a>
</div>


	<a	name="rsr"/>
	Read Staging Register	rsr
	_____________________	___

	rsr instruction shifts BITS bits from storage stream *q to arithmetic register a
	controlled by counter register RDATAC and buffered in data register RDATA

	BITS is the sign extended immediate operand

				_________________________________________________________
				|							|
				|	shift BITS bits left from Staging Register	|
				|	RDATA to Arithmetic Register a			|
				|							|
				|	reload RDATA from storage on empty		|
				|							|
				|_______________________________________________________|
				|							|
				|	if RDATAC < BITS				|
				|							|
				|		subtract RDATAC	from BITS		|
				|							|
				|		shift RDATAC bits to Register a		|
				|							|
				|		read memory/register to RDATA with	|
				|		Pointer Register *q			|
				|							|
				|		increment Pointer Register q		|
				|							|
				|		restart RDATAC = RSTREAM_WORD		|
				|							|
				|	shift BITS bits from RDATA to Register a	|
				|							|
				|	subtract BITS from RDATAC			|
				|_______________________________________________________|
				|							|
				|	if PSR Flag b$streamZR = 0 displace the prior	|
				|	value in Register a leftwards			|
				|							|
				|	if PSR Flag b$streamZR = 1 clear Register a	|
				|	before shifting from RDATA			|
				|							|
				|	if PSR Flag b$stream16r = 0 RSTREAM_WORD = 24	|
				|							|
				|	if PSR Flag b$stream16r = 1 RSTREAM_WORD = 16	|
				|	and RDATA is shifted left 8 bits on memory read	|
				|							|
				|_______________________________________________________|
				|							|
				|	RDATAC RDATA and q are registers		|
				|							|
				|	RSTREAM_WORD is a term not a register		|
				|_______________________________________________________|
				|	BITS is 16-bit immediate with sign extension  	|
				|_______________________________________________________|
				|							|
				|	RDATAC and RDATA are application registers	|
				|	not replicated as interrupt registers		|
				|							|
				|	if ISRs program bit read streams they use	|
				|	application registers RDATAC and RDATA and	|
				|	must first save them				|
				|							|
				|	storage read pointer q is replicated in		|
				|	application and interrupt register sets		|
				|							|
				|	rsr instruction in interrupt mode uses q_x	|
				|_______________________________________________________|

	assembler syntax	rsr	BITS_TO_READ

	assembler example	rsr	BYTE_SIZE

				_________________________________________________________
	Instruction Code 2.5	| 0 0 0 1 0 | 1 0 1 | 		    BITS		|
				|___________|_______|___________________________________|





	<div	style="font-size:11pt">
        _________________________________________________________________________________________________________________
        |					The Bit Stream Write Channel						|
        |_______________________________________________________________________________________________________________|
        |														|
        |       The Bit Stream Write Channel allows storage to be written as a stream of bits in fields up 24 bits	|
        |       Bit fields may be written across word boundaries transparently                                          |
        |														|
        |       Successive writes may each be bit fields of equal or irregular size					|
        |														|
        |       write thru is data words of 24 bits, or 16 bits for 16-bit output devices				|
        |														|
        |       Write Staging Register instruction drives the Bit Stream Write Channel					|
        |_______________________________________________________________________________________________________________|

	<a      style="color:0000FF">
        _________________________________________________________________________________________________________________
        |						Multiplexing							|
        |_______________________________________________________________________________________________________________|
        |														|
        |       The Bit Stream Write Channel is within application context, so every thread has one			|
        |														|
        |       Many applications only format one write stream, stdout							|
        |														|
        |       The prototype kernel smaragd7 has a system call for switching stream states				|
        |       so that an application may format many ANSI filestreams and other arrays in overlapped time		|
	|_______________________________________________________________________________________________________________|
	</a>
	</div>



	<a	name="wsr"/>
	Write Staging Register	wsr
	______________________	___


	wsr instruction shifts BITS bits from arithmetic register a to storage stream *p
	controlled by counter register WDATAC and buffered in data register WDATA

	BITS is the sign extended immediate operand 


				_________________________________________________________
				|							|
				|	shift BITS bits left from Register a		|
				|	to Staging Register WDATA			|
				|							|
				|	write WDATA to storage on full			|
				|							|
				|_______________________________________________________|
				|							|
				|	WSPACE = WSTREAM_WORD - WDATAC			|
				|							|
				|	if BITS >= WSPACE				|
				|							|
				|		subtract WSPACE from BITS		|
				|							|
				|		shift WSPACE bits to WDATA		|
				|							|
				|		write WDATA to memory/register with	|
				|		Pointer Register *p			|
				|							|
				|		increment Pointer Register p		|
				|							|
				|		restart WDATAC = 0			|
				|							|
				|		restart WDATA = 0			|
				|							|
				|	shift BITS bits from Register a to WDATA	|
				|							|
				|	add BITS to WDATAC				|
				|_______________________________________________________|
				|							|
				|	if PSR Flag b$stream16w = 0 WSTREAM_WORD = 24	|
				|							|
				|	if PSR Flag b$stream16r = 1 WSTREAM_WORD = 16	|
				|							|
				|_______________________________________________________|
				|							|
				|	WDATAC WDATA and p are registers		|
				|							|
				|	WSPACE and WSTREAM_WORD are terms not registers	|
				|_______________________________________________________|
				|	BITS is 16-bit immediate with sign extension	|
				|_______________________________________________________|
				|							|
				|	WDATAC and WDATA are application registers	|
				|	not replicated as interrupt registers		|
				|							|
				|	if ISRs program bit write streams they use	|
				|	application registers WDATAC and WDATA and	|
				|	must first save them				|
				|							|
				|	storage write pointer p is replicated in	|
				|	application and interrupt register sets		|
				|							|
				|	wsr instruction in interrupt mode uses p_x	|
				|_______________________________________________________|


	assembler syntax	wsr		BITS_TO_WRITE

	assembler example	sal		24-BYTE_SIZE
				wsr		BYTE_SIZE


				_________________________________________________________
	Instruction Code 3.5	| 0 0 0 1 1 | 1 0 1 | 		    BITS		|
				|___________|_______|___________________________________|


				_________________________________________________________
				|	at the end of a stream of wsr writes software	|
				|	intervention may be needed to write outstanding	|
				|	bits of an incomplete data word			|
				|_______________________________________________________|
				|	if zero-padding is required, an unconditional	|
				|	write instruction drives a conditional write	|
				|_______________________________________________________|


				wsr		$word-$byte


				_________________________________________________________
				|	if the unwritten values in the last written word|
				|	must be unchanged, conditional masking is needed|
				|_______________________________________________________| 


										write_last_bits	lb	*p	
												la	WDATA
				tz		WDATAC						sbl	*WDATAC
				lcal		write_last_bits					dsr	*WDATAC
												sb	*p
												lret	0




	<a      name="lfiret"/>
	<div    style="margin-left:28pt;font-family:times-roman;font-size:12.75pt;color:0000FF">
	<i>3.6.11	Return Instructions and Internal Interrupt</i>
	</div>
	instructions	<a href="#lret">Local Return</a>		<a href="#ii">Internal Interrupt</a>
			<a href="#fret">Far Return</a>		<a href="#ir">Interrrupt return</a>

	Return instructions increment the stacked return address with the sign extended immediate operand
 



	<a	name="lret"/>
	Local Return		lret
	____________		____

				_________________________________________________________
				|							|
				|	return address relative to current instruction	|
				|	window B0 is popped from the internal stack	|
				|							|
				|	sign extended immediate operand of the return	|
				|	instruction is added to the relative address	|
				|							|
				|	B0 * 4096 is added to the relative address	|
				|							|
				|	the resulting absolute address is transferred	|
				|	to the program counter				|
				|							|
				|	if sp = 128 before lret				|
				|	thread exit interrupt 70 is raised		|
				|							|
				|	on internal stack overflow / underflow		|
				|	[sp < 24 | sp > 128] before operation		|
				|	guard interrupt 95 is raised			|
				|							|
				|_______________________________________________________|
				|	DISPLACEMENT is 16-bit sign extended immediate	|
				|_______________________________________________________|


	assembler syntax	lret		SKIP_STEPS

	assembler examples	lret		0
				lret		1
				lret		-1
				lret		2

				_________________________________________________________
	Instruction Code 6.5	| 0 0 1 1 0 | 1 0 1 | 		  DISPLACEMENT		|
				|___________|_______|___________________________________|






	<a	name="fret"/>
	Far Return		fret
	__________		____
	<div	style="font-size:11pt">
									 internal stack frame

									 23						       0
	_________________________________________________________	_________________________________________________________
	|							|	|			offset				| sp + 1
	|	Iframe Name is popped from the internal stack	|	|_______________________________________________________|
	|	and bits 21:0 Start Page Index written to B0	|	| F 0 |			iframe Start Page Index		| <-- sp 
	|							|	|_____|_________________________________________________|
	|	return address offset in retrieved instruction	|	|   22|						       0
	|	frame is popped from the internal stack		|	|     |
	|							|	|
	|	sign extended immediate operand of the return	|	|
	|	instruction is added to iframe relative offset	|	|
	|							|	|
	|	B0 * 4096 is added to iframe relative offset	|	|
	|							|	| 0 0 | Page High Index = 0 : iframe pages 1
	|	the resulting absolute address is transferred	|	|     | B64 = B0
	|	to the program counter				|	| 
	|							|	| 1 0 |	gate descriptor @ target iframe + 64
        |       if sp = 128 before fret                         |	|     |	Page High Index <- gate descriptor bits 47:42
        |       thread exit interrupt 70 is raised		|	|     | B64 = B0 + Page High Index
        |                                                       |
        |       on internal stack overflow / underflow		|
        |       [sp < 24 | sp > 126 ^ 128] before operation	|
	|	guard interrupt 95 is raised			|
        |_______________________________________________________|
	|	I/O Port 64 is updated to new highest page for 	|
	|	instruction execution = B0 + Page High Index - 1|
	|							|
	|	Page High Index is derived from flag values	|
	|	{ 00 | 10 } in bits  23:22 of new Iframe Name	|
	|							|
	|	flags value 00:					|
	|	gives Page High Index 0: iframe size 1 page	|	sample gate @ target iframe + 64
	|							|
	|	flags value 10:					|	 47	     42					      24
	|	Page High Index is read from bits 47:42 of the	|	_________________________________________________________
	|	sample gate at location 64 of target the iframe	|	| Page High Idx| 	offset 0    			| 
	|_______________________________________________________|	|______________|________________________________________|
	|	DISPLACEMENT is 16-bit sign extended immediate	|	| x 0 |			iframe Start Page Index		|
	|_______________________________________________________|	|_____|_________________________________________________|
									       21					       0
	</div>


	assembler syntax	fret		SKIP_STEPS

	assembler examples	fret		0
				fret		-1
				fret		1
				fret		2

				_________________________________________________________
	Instruction Code 7.5	| 0 0 1 1 1 | 1 0 1 | 		DISPLACEMENT		|
				|___________|_______|___________________________________|





	<div	style="font-size:11pt">
	_________________________________________________________________________________________________________________
	|					   	INTERRUPTS							|
	|_______________________________________________________________________________________________________________|
	|														|
	|	on external or internal interrupt									|
	|	_________________________________									|
	|														|
	|	absolute Program Counter minus B0 * 4096 is pushed onto the Interrupt Internal Stack			|
	|														|
	|	iframe name (ff:B0) is pushed onto the Interrupt Internal Stack						|
	|														|
	|	PSR is pushed onto the Interrupt Internal Stack								|
	|														|
	|	a latent parameter word is pushed onto the Interrupt Internal Stack					|
	|	when instruction ii raises the interrupt, the latent parameter word = 0					|
	|														|
	|	if PSR Flag 23 = 0 then Interrupt Stack Pointer sp_x is copied to Interrupt Frame Pointer fp_x		|
	|	this marks which Interrupt Stack Frame is the interrupted application					|
	|	the absolute address of the application Interrupt Stack Frame should always be 252			|
	|														|
	|	1 is written to PSR Flag 23										|
	|														|
	|_______________________________________________________________________________________________________________|
	|														|
	|			The Interrupt Stack Frame at Interrupt Stack Pointer sp_x is				|
	|			____________________________________________________________				|
	|														|
	|														|
	|	 95			 71			 47			 23		       0	|
	|	_________________________________________________________________________________________________	|
	|	|    latent parameter	|	saved PSR	|   saved iframe name	| 	saved offset	|	|
	|	|_______________________|_______________________|_______________________|_______________________|	|
	|	 *sp			 +1,sp		 	 +2,sp			 +3,sp				|
	|_______________________________________________________________________________________________________________|
	</div>



	<a	name="ii"/>
	Internal Interrupt	ii					 interrupt frame -> internal stack
	__________________	__
	<div	style="font-size:11pt">

									 23						       0
	_________________________________________________________	_________________________________________________________
	|							|	|			saved offset			|	
	|	B0 * 4096 is subtracted from the value of	|	|_______________________________________________________|
	|	the absolute program counter			|	| F 0 |			saved iframe Start Page Index	|
	|							|	|_____|_________________________________________________|
	|	the resulting instruction frame relative value	|	|   22			saved PSR			|
	|	is pushed on the interrupt internal stack	|	|			________________________________|
	|							|	|			latent parameter		|
	|	Iframe Name = Start Page Index + size flags	|	|			________________________________|
	|	is pushed on the interrupt internal stack	|	|
	|							|	|
	|	PSR is pushed on the interrupt internal stack 	|	| 0 0 | B64 = B0 Page High Index on i-return = 0
	|							|	| 1 0 | B64 > B0 Page High Index on i-return
	|	latent parameter 0				|				= gate bits 47:42 @ iframe + 64
	|	is pushed on the interrupt internal stack	|
	|-------------------------------------------------------|
	|							| 
	|	PSR Flag 23 = 1					|
	|							|
	|	the high-order 18 bits of the immediate operand	|
	|	designate a VECTOR_BANK				|
	|							|
	|	the low-order 6 bits if the immediate operand	|
	|	designate a VECTOR_OFFSET			|
	|							|
	|	B0 = VECTOR_BANK				|
	|							|
	|	program counter = VECTOR_BANK*4096+VECTOR_OFFSET|
	|_______________________________________________________|
	|	VECTOR_BANK			  |VECTOR_OFFSET|
	|23______________________________________6|5___________0|
	|	VECTOR is 16-bit sign extended immediate	|
	|_______________________________________________________|
	</div>


	assembler syntax	ii	INTERRUPT_VECTOR

	assembler examples	ii	BANK_1*/6++2
				ii	BANK_1*/6++11

				_________________________________________________________
	Instruction Code 14.5	| 0 1 1 1 0 | 1 0 1 |		  VECTOR		|
				|___________|_______|___________________________________|






	<a	name="ir"/>
	Interrupt Return	ir
	________________	__
	<div	style="font-size:11pt">

												interrupt / return internal stack frame

									 23						       0
	_________________________________________________________	_________________________________________________________
	|							|	|			saved offset			| sp + 3
	|							|	|_______________________________________________________|
	|	saved PSR is retrieved from			|	| F 0 |			saved iframe Start Page Index	| sp + 2
	|	[interrupt internal stack pointer + 1]		|	|_____|_________________________________________________|
	|							|	|   22|			saved PSR			| sp + 1
	|	saved Iframe Name is retrieved from		|	|			________________________________|
	|	[interrupt internal stack pointer + 2]		|	|			latent parameter		| <-- sp
	|	and bits 21:0 Start Page Index transferred to B0|	|			________________________________|
	|							|	|
	|	saved address offset in instruction frame	|	|
	|	is retrieved from				|	|
	|	[interrupt internal stack pointer + 3]		|	| 0 0 |	page high index = 0 : iframe pages 1
	|							|	|     |	B64 = B0
	|	the sign extended immediate operand of the ir	|	|
	|	instruction is added to iframe relative address	|	| 1 0 |	gate descriptor @ target iframe + 64
	|							|	|     |	page high index <- gate descriptor bits 47:42
	|	B0 * 4096 is added to iframe relative address	|	|     |	B64 = B0 + Page High Index 
	|							|
	|	the resulting absolute address is transferred	|
	|	to the program counter				|
	|							|
	|	interrupt internal stack pointer		|
	|	is incremented by 4				|
        |_______________________________________________________|
        |       I/O Port 64 is updated to new highest page for  |
        |       instruction execution = B0 + Page High Index - 1|
        |                                                       |
        |       Page High Index is derived from flag values     |
        |       { 00 | 10 } in bits  23:22 of new Iframe Name   |
        |                                                       |
        |       flags value 00:                                 |
        |       gives Page High Index 0: iframe size 1 page     |       sample gate @ target iframe + 64
        |                                                       |
        |       flags value 10:                                 |        47          42                                       24
        |       Page High Index is read from bits 47:42 of the  |       _________________________________________________________
        |       sample gate at location 64 of the target iframe |       | Page High Idx|        offset 0                        | 
        |_______________________________________________________|       |______________|________________________________________|
        |       DISPLACEMENT is 16-bit sign extended immediate  |       | x 0 |                 iframe Start Page Index         | 
        |_______________________________________________________|       |_____|_________________________________________________|

	assembler syntax	ir	SKIP_STEPS

	assembler examples	ir	0
				ir	-1
				ir	2

				_________________________________________________________
	Instruction Code 15.5	| 0 1 1 1 1 | 1 0 1 | 		DISPLACEMENT		|
				|___________|_______|___________________________________|







	<a      name="shijo"/>
	<div    style="margin-left:28pt;font-family:times-roman;font-size:12.75pt;color:0000FF">
	<i>3.6.12      Shift and Jump Instructions</i>
	</div>
	Shift instructions and jump instructions use the effective address
	with or without indirection or indexing as an immediate operand

	instructions	<a href="#sar">Shift a Right</a>			<a href="#j">Jump</a>
			<a href="#sbr">Shift b Right</a>			<a href="#lcal">Local Call</a>
			<a href="#dsr">Double Shift Right</a>		<a href="#jc">Jump Carry</a>
			<a href="#sal">Shift a Left</a>			<a href="#jnc">Jump No Carry</a>
			<a href="#sbl">Shift b Left</a>			<a href="#jza">Jump Zero a</a>
			<a href="#dsl">Double Shift Left</a>		<a href="#jzb">Jump Zero b</a>
			<a href="#rar">Rotate a Right</a>			<a href="#jnza">Jump NonZero a</a>
			<a href="#rbr">Rotate b Right</a>			<a href="#jnzb">Jump NonZero b</a>
			<a href="#drr">Double Rotate Right</a>		<a href="#jpa">Jump Positive a</a>
			<a href="#ral">Rotate a Left</a>			<a href="#jpb">Jump Positive b</a>
			<a href="#rbl">Rotate b Left</a>			<a href="#jna">Jump Negative a</a>
			<a href="#drl">Double Rotate Left</a>		<a href="#jnb">Jump Negative b</a>
			<a href="#saa">Shift a Algebraic</a>		<a href="#jao">Jump a Odd</a>
			<a href="#sba">Shift b Algebraic</a>		<a href="#jpo">Jump Parity k**a Odd</a>
			<a href="#dsa">Double Shift Algebraic</a>		<a href="#jdr">Jump Decrement Counter Register</a>
							<a href="#jxge">Jump x NOT < r</a>
							<a href="#jyge">Jump y NOT < r</a>
							<a href="#jdz">Jump Double Zero</a>


			see also	target modify instructions	<a href="#src">src</a> and <a href="#slc">slc</a>
					scale instructions		<a href="#lsc">lsc</a> and <a href="#dlsc">dlsc</a>
					far jump instructions		<a href="#go">go</a>  and <a href="#call">call</a>		


	<a	name="sar"/>
	Shift Arithmetic Register a Right	sar
	_________________________________	___

				_________________________________________________________
				|							|
				|	the value in arithmetic register a is shifted	|
				|	rightward for EA bit positions			|
				|	0 is written to vacated high-order bit positions|
				|_______________________________________________________|


	assembler syntax	sar	BIT_POSITIONS[, {x|y|a|b|fp|sp}]
				sar	*shift_distance_variable

				_________________________________________________________
	Instruction Code 0.6	| 0 0 0 0 0 | 1 1 0 | . . . .  . . . . . . . . . . . .	|
				|___________|_______|___________________________________|






	<a	name="sbr"/>
	Shift Arithmetic Register b Right	sbr
	_________________________________	___

				_________________________________________________________
				|							|
				|	the value in arithmetic register b is shifted 	|
				|	rightward for EA bit positions			|
				|	0 is written to vacated high-order bit positions|
				|_______________________________________________________|


	assembler syntax	sbr	BIT_POSITIONS[, {x|y|a|b|fp|sp}]
				sbr	*shift_distance_variable

				_________________________________________________________
	Instruction Code 1.6	| 0 0 0 0 1 | 1 1 0 |		<a style="color:#00FF00">  address</a>		|
				|___________|_______|___________________________________|






	<a	name="dsr"/>
	Double Shift Right	dsr
	__________________	___

				_________________________________________________________
				|							|
				|	the 48-bit value in arithmetic registers a and b|
				|	is shifted rightward for EA bit positions	|
				|	0 is written to vacated high-order bit positions|
				|_______________________________________________________|


	assembler syntax	dsr	BIT_POSITIONS[, {x|y|a|b|fp|sp}]
				dsr	*shift_distance_variable

				_________________________________________________________
	Instruction Code 2.6	| 0 0 0 1 0 | 1 1 0 |		<a style="color:#00FF00">  address</a>		|
				|___________|_______|___________________________________|





	<a	name="jdr"/>
	Jump Decrement Repeat Count	jdr
	___________________________	___


				_________________________________________________________
				|							|
				|	repeat count register r	is decremented.		|
				|	instruction path jumps to EA			|
				|	unless r changes from 0 to -1			|
				|_______________________________________________________|


	assembler syntax	jdr	jump_address[, {x|y|a|b|fp|sp}]
				jdr	*jump_pointer

				_________________________________________________________
	Instruction Code 3.6	| 0 0 0 1 1 | 1 1 0 |		<a style="color:#00FF00">  address</a>		|
				|___________|_______|___________________________________|





	<a	name="sal"/>
	Shift Arithmetic Register a Left	sal
	________________________________	___

				_________________________________________________________
				|							|
				|	the value in arithmetic register a is shifted	|
				|	leftward for EA bit positions			|
				|	0 is written to vacated low-order bit positions |
				|_______________________________________________________|


	assembler syntax	sal	BIT_POSITIONS[, {x|y|a|b|fp|sp}]
				sal	*shift_distance_variable

				_________________________________________________________
	Instruction Code 4.6	| 0 0 1 0 0 | 1 1 0 |		<a style="color:#00FF00">  address</a>		|
				|___________|_______|___________________________________|






	<a	name="sbl"/>
	Shift Arithmetic Register b Left	sbl
	________________________________	___

				_________________________________________________________
				|							|
				|	the value in arithmetic register b is shifted	|
				|	leftward for EA bit positions			|
				|	0 is written to vacated low-order bit positions	|
				|_______________________________________________________|


	assembler syntax	sbl	BIT_POSITIONS[, {x|y|a|b|fp|sp}]
				sbl	*shift_distance_variable

				_________________________________________________________
	Instruction Code 5.6	| 0 0 1 0 1 | 1 1 0 |		<a style="color:#00FF00">  address</a>		|
				|___________|_______|___________________________________|






	<a	name="dsl"/>
	Double Shift Left	dsl
	_________________	___

				_________________________________________________________
				|							|
				|	the 48-bit value in arithmetic registers a and b|
				|	is shifted leftward for EA bit positions	|
				|	0 is written to vacated low-order bit positions	|
				|_______________________________________________________|


	assembler syntax	dsl	BIT_POSITIONS[, {x|y|a|b|fp|sp}]
				dsl	*shift_distance_variable

				_________________________________________________________
	Instruction Code 6.6	| 0 0 1 1 0 | 1 1 0 |		<a style="color:#00FF00">  address</a>		|
				|___________|_______|___________________________________|






	<a	name="lcal"/>
	Local Call		lcal
	__________		____


				_________________________________________________________
				|							|
				|	absolute program counter minus B0 * 4096	|	
				|	is pushed onto the internal stack		|
				|							|
				|	new program counter = B0 * 4096 + EA:		|
				|	instruction path jumps to EA			|
				|							|
                                |       on internal stack overflow / underflow		|
                                |       [sp < 25 | sp > 128] before operation           |
                                |       guard interrupt 95 is raised			|
				|_______________________________________________________|



	assembler syntax	lcal	jump_address[, {x|y|a|b|fp|sp}]
				lcal	*jump_pointer

				_________________________________________________________
	Instruction Code 7.6	| 0 0 1 1 1 | 1 1 0 |		<a style="color:#00FF00">  address</a>		|
				|___________|_______|___________________________________|





	<a	name="rar"/>
	Rotate Arithmetic Register a Right	rar
	__________________________________	___

				_________________________________________________________
				|							|
				|	the value in arithmetic register a is rotated 	|
				|	rightward for EA bit positions			|
				|	values shifted out of the register are		|
				|	transferred to high-order bit positions 	|
				|_______________________________________________________|

	assembler syntax	rar	BIT_POSITIONS[, {x|y|a|b|fp|sp}]
				rar	*shift_distance_variable

				_________________________________________________________
	Instruction Code 8.6	| 0 1 0 0 0 | 1 1 0 |		<a style="color:#00FF00">  address</a>		|
				|___________|_______|___________________________________|





	<a	name="rbr"/>
	Rotate Arithmetic Register b Right	rbr
	__________________________________	___

				_________________________________________________________
				|							|
				|	the value in arithmetic begister b is rotated 	|
				|	rightward for EA bit positions			|
				|	values shifted out of the register are		|
				|	transferred to high-order bit positions		|
				|_______________________________________________________|


	assembler syntax	rbr	BIT_POSITIONS[, {x|y|a|b|fp|sp}]
				rbr	*shift_distance_variable

				_________________________________________________________
	Instruction Code 9.6	| 0 1 0 0 1 | 1 1 0 |		<a style="color:#00FF00">  address</a>		|
				|___________|_______|___________________________________|





	<a	name="drr"/>
	Double Rotate Right	drr
	___________________	___

				_________________________________________________________
				|							|
				|	the 48-bit value in arithmetic registers a and b|
				|	is rotated rightward for EA bit positions	|
				|	values shifted out of the register pair are	|
				|	transferred to high-order bit positions		|
				|_______________________________________________________|


	assembler syntax	drr	BIT_POSITIONS[, {x|y|a|b|fp|sp}]
				drr	*shift_distance_variable

				_________________________________________________________
	Instruction Code 10.6	| 0 1 0 1 0 | 1 1 0 |		<a style="color:#00FF00">  address</a>		|
				|___________|_______|___________________________________|





	<a	name="jnc"/>
	Jump No Carry		jnc
	_____________		___

				_________________________________________________________
				|							|
				|	instruction path jumps to EA if carry$ flag is 0|
				|_______________________________________________________|


	assembler syntax	jnc	jump_address[, {x|y|a|b|fp|sp}]
				jnc	*jump_pointer

				_________________________________________________________
	Instruction Code 11.6	| 0 1 0 1 1 | 1 1 0 |		<a style="color:#00FF00">  address</a>		|
				|___________|_______|___________________________________|






	<a	name="ral"/>
	Rotate Arithmetic Register a Left	ral
	_________________________________	___

				_________________________________________________________
				|							|
				|	the value in arithmetic register a is rotated 	|
				|	leftward for EA bit positions			|
				|	values shifted out of the register are		|
				|	transferred to low-order bit positions		|
				|_______________________________________________________|


	assembler syntax	ral	BIT_POSITIONS[, {x|y|a|b|fp|sp}]
				ral	*shift_distance_variable

				_________________________________________________________
	Instruction Code 12.6	| 0 1 1 0 0 | 1 1 0 |		<a style="color:#00FF00">  address</a>		|
				|___________|_______|___________________________________|






	<a	name="rbl"/>
	Rotate Arithmetic Register b Left	rbl
	_________________________________	___

				_________________________________________________________
				|							|
				|	the value in arithmetic register b is rotated 	|
				|	leftward for EA bit positions			|
				|	values shifted out of the register are		|
				|	transferred to low-order bit positions		|
				|_______________________________________________________|


	assembler syntax	rbl	BIT_POSITIONS[, {x|y|a|b|fp|sp}]
				rbl	*shift_distance_variable

				_________________________________________________________
	Instruction Code 13.6	| 0 1 1 0 1 | 1 1 0 |		<a style="color:#00FF00">  address</a>		|
				|___________|_______|___________________________________|






	<a	name="drl"/>
	Double Rotate Left	drl
	__________________	___

				_________________________________________________________
				|							|
				|	the 48-bit value in arithmetic registers a and b|
				|	is rotated leftward for EA bit positions	|
				|	values shifted out of the register pair are	|
				|	transferred to low-order bit positions		|
				|_______________________________________________________|


	assembler syntax	drl	BIT_POSITIONS[, {x|y|a|b|fp|sp}]
				drl	*shift_distance_variable

				_________________________________________________________
	Instruction Code 14.6	| 0 1 1 1 0 | 1 1 0 |		<a style="color:#00FF00">  address</a>		|
				|___________|_______|___________________________________|






	<a	name="jc"/>
	Jump on Carry		jc
	_____________		__

				_________________________________________________________
				|							|
				|	instruction path jumps to EA if carry$ flag is 1|
				|_______________________________________________________|



	assembler syntax	jc	jump_address[, {x|y|a|b|fp|sp}]
				jc	*jump_pointer

				_________________________________________________________
	Instruction Code 15.6	| 0 1 1 1 1 | 1 1 0 |		<a style="color:#00FF00">  address</a>		|
				|___________|_______|___________________________________|






	<a	name="saa"/>
	Shift Arithmetic Register a Algebraic	saa
	_____________________________________	___

				_________________________________________________________
				|							|
				|	the value in arithmetic Register a is shifted	|
				|	algebraically rightwards for EA bit positions	|
				|	the initial value of bit 23 is repeated in	|
				|	each vacated high order bit position		|
				|_______________________________________________________|

	assembler syntax	saa	BIT_POSITIONS[, {x|y|a|b|fp|sp}]
				saa	*shift_distance_variable

				_________________________________________________________
	Instruction Code 16.6	| 1 0 0 0 0 | 1 1 0 |		<a style="color:#00FF00">  address</a>		|
				|___________|_______|___________________________________|






	<a	name="sba"/>
	Shift Arithmetic Register b Algebraic	sba
	_____________________________________	___

				_________________________________________________________
				|							|
				|	the value in arithmetic Register b is shifted	|
				|	algebraically rightwards for EA bit positions	|
				|	the initial value of bit 23 is repeated in	|
				|	each vacated high order bit position		|
				|_______________________________________________________|


	assembler syntax	sba	BIT_POSITIONS[, {x|y|a|b|fp|sp}]
				sba	*shift_distance_variable

				_________________________________________________________
	Instruction Code 17.6	| 1 0 0 0 1 | 1 1 0 |		<a style="color:#00FF00">  address</a>		|
				|___________|_______|___________________________________|





	<a	name="dsa"/>
	Double Shift Algebraic	dsa
	______________________	___
				_________________________________________________________
				|							|
				|	the 48-bit value in arithmetic registers a and b|
				|	is shifted algebraically rightwards for EA bit	|
				|	positions. The value of bit 47 is repeated in	|
				|	each vacated high order bit position		|
				|_______________________________________________________|

	assembler syntax	dsa	BIT_POSITIONS[, {x|y|a|b|fp|sp}]
				dsa	*shift_distance_variable

				_________________________________________________________
	Instruction Code 18.6	| 1 0 0 1 0 | 1 1 0 |		<a style="color:#00FF00">  address</a>		|
				|___________|_______|___________________________________|





	<a	name="jao"/>
	Jump a Odd		jao
	__________		___
	
				_________________________________________________________
				|							|
				|	instruction path jumps to EA 			|
				|	if bit 0 of Arithmetic Register a = 1		|
				|_______________________________________________________|


	assembler syntax	jao	jump_address[, {x|y|a|b|fp|sp}]
				jao	*jump_pointer

				_________________________________________________________
	Instruction Code 19.6	| 1 0 0 1 1 | 1 1 0 |		<a style="color:#00FF00">  address</a>		|
				|___________|_______|___________________________________|






	<a	name="jpa"/>
	Jump Positive a		jpa
	_______________		___

				_________________________________________________________
				|							|
				|	instruction path jumps to EA			|
				|	if bit 23 of Arithmetic Register a = 0		|
				|_______________________________________________________|


	assembler syntax	jpa	jump_address[, {x|y|a|b|fp|sp}]
				jpa	*jump_pointer

				_________________________________________________________
	Instruction Code 20.6	| 1 0 1 0 0 | 1 1 0 |		<a style="color:#00FF00">  address</a>		|
				|___________|_______|___________________________________|





	<a	name="jpb"/>
	Jump Positive b		jpb
	_______________		___

				_________________________________________________________
				|							|
				|	instruction path jumps to EA			|
				|	if bit 23 of Arithmetic Register b = 0		|
				|_______________________________________________________|


	assembler syntax	jpb	jump_address[, {x|y|a|b|fp|sp}]
				jpb	*jump_pointer

				_________________________________________________________
	Instruction Code 21.6	| 1 0 1 0 1 | 1 1 0 |		<a style="color:#00FF00">  address</a>		|
				|___________|_______|___________________________________|




	<a	name="j"/>
	Jump			j
	____			_

				_________________________________________________________
				|							|
				|	instruction path jumps to EA			|
				|_______________________________________________________|


	assembler syntax	j	jump_address[, {x|y|a|b|fp|sp}]
				j	*jump_pointer

				_________________________________________________________
	Instruction Code 22.6	| 1 0 1 1 0 | 1 1 0 |		<a style="color:#00FF00">  address</a>		|
				|___________|_______|___________________________________|






	<a	name="jpo"/>
	Jump Parity Odd		jpo
	_______________		___

				_________________________________________________________
				|							|
				|	instruction path jumps to EA			|
				|	if register a AND mask register k has odd parity|
				|_______________________________________________________|



	assembler syntax	jpo	jump_address[, {x|y|a|b|fp|sp}]
				jpo	*jump_pointer


				_________________________________________________________
	Instruction Code 23.6	| 1 0 1 1 1 | 1 1 0 |		<a style="color:#00FF00">  address</a>		|
				|___________|_______|___________________________________|





	<a	name="jza"/>
	Jump Zero a		jza
	___________		___
	
				_________________________________________________________
				|							|
				|	instruction path jumps EA			|
				|	if all bits of Arithmetic register a are 0	|
				|_______________________________________________________|


	assembler syntax	jza	jump_address[, {x|y|a|b|fp|sp}]
				jza	*jump_pointer

				_________________________________________________________
	Instruction Code 24.6	| 1 1 0 0 0 | 1 1 0 |		<a style="color:#00FF00">  address</a>		|
				|___________|_______|___________________________________|






	<a	name="jzb"/>
	Jump Zero b		jzb
	___________		___

				_________________________________________________________
				|							|
				|	instruction path jumps to EA			|
				|	if all bits of arithmetic register b are 0	|
				|_______________________________________________________|


	assembler syntax	jzb	jump_address[, {x|y|a|b|fp|sp}]
				jzb	*jump_pointer

				_________________________________________________________
	Instruction Code 25.6	| 1 1 0 0 1 | 1 1 0 |		<a style="color:#00FF00">  address</a>		|
				|___________|_______|___________________________________|






	<a	name="jnza"/>
	Jump NonZero a		jnza
	______________		____
	
				_________________________________________________________
				|							|
				|	instruction path jumps to EA			|
				|	if any bits of arithmetic register a are 1	|
				|_______________________________________________________|

	assembler syntax	jnza	jump_address[, {x|y|a|b|fp|sp}]
				jnza	*jump_pointer

				_________________________________________________________
	Instruction Code 26.6	| 1 1 0 1 0 | 1 1 0 |		<a style="color:#00FF00">  address</a>		|
				|___________|_______|___________________________________|






	<a	name="jnzb"/>
	Jump NonZero b		jnzb
	______________		____

				_________________________________________________________
				|							|
				|	instruction path jumps to EA			|
				|	if any bits of arithmetic register b are 1	|
				|_______________________________________________________|

	assembler syntax	jnzb	jump_address[, {x|y|a|b|fp|sp}]
				jnzb	*jump_pointer

				_________________________________________________________
	Instruction Code 27.6	| 1 1 0 1 1 | 1 1 0 |		<a style="color:#00FF00">  address</a>		|
				|___________|_______|___________________________________|





	<a	name="jna"/>
	Jump Negative a		jna
	_______________		___
	
				_________________________________________________________
				|							|
				|	instruction path jumps to EA			|
				|	if bit 23 of arithmetic register a = 1		|
				|_______________________________________________________|

	assembler syntax	jna	jump_address[, {x|y|a|b|fp|sp}]
				jna	*jump_pointer

				_________________________________________________________
	Instruction Code 28.6	| 1 1 1 0 0 | 1 1 0 |		<a style="color:#00FF00">  address</a>		|
				|___________|_______|___________________________________|





	<a	name="jnb"/>
	Jump Negative b		jnb
	_______________		___

				_________________________________________________________
				|							|
				|	instruction path jumps to EA			|
				|	if bit 23 of arithmetic register b = 1		|
				|_______________________________________________________|

	assembler syntax	jnb	jump_address[, {x|y|a|b|fp|sp}]
				jnb	*jump_pointer

				_________________________________________________________
	Instruction Code 29.6	| 1 1 1 0 1 | 1 1 0 |		<a style="color:#00FF00">  address</a>		|
				|___________|_______|___________________________________|





	<a	name="jxge"/>
	Jump x Greater or Equal	jxge
	_______________________	___

				_________________________________________________________
				|							|
				|	instruction path jumps to EA unless		|
				|	index register x < limit pointer register r	|
				|_______________________________________________________|

	assembler syntax	jxge	jump_address[, {x|y|a|b|fp|sp}]
				jxge	*jump_pointer




				_________________________________________________________
	Instruction Code 30.6	| 1 1 1 1 0 | 1 1 0 |		<a style="color:#00FF00">  address</a>		|
				|___________|_______|___________________________________|





	<a	name="jyge"/>
	Jump y Greater or Equal	jyge
	_______________________	____

				_________________________________________________________
				|							|
				|	instruction path jumps to EA unless		|
				|	index register y < limit pointer register r	|
				|_______________________________________________________|

	assembler syntax	jyge	jump_address[, {x|y|a|b|fp|sp}]
				jyge	*jump_pointer


				_________________________________________________________
	Instruction Code 31.6	| 1 1 1 1 1 | 1 1 0 |		<a style="color:#00FF00">  address</a>		|
				|___________|_______|___________________________________|






	<a	name="jdz"/>
	Jump Double Zero	jdz
	________________	___

				_________________________________________________________
				|							|
				|	instruction path jumps to EA if all 48 bits 	|
				|	of arithmetic registers a and b are 0		|
				|_______________________________________________________|


	assembler syntax	jdz	jump_address[, {x|y|a|b|fp|sp}]
				jdz	*jump_pointer

				_________________________________________________________
	Instruction Code 15.4	| 0 1 1 1 1 | 1 0 0 |		<a style="color:#00FF00">  address</a>		|
				|___________|_______|___________________________________|








	<a      name="modify"/>
	<div    style="margin-left:28pt;font-family:times-roman;font-size:12.75pt;color:0000FF">
	<i>3.6.13	Target Modify Instructions</i>
	</div>
	Eight instructions modify a single-word target operand

	The first modify instruction <a href="#ts">ts</a> operates on a storage operand not a register,
	and must execute atomically with storage lock

	The other seven modify instructions <a href="#n">n</a> <a href="#inc">inc</a> <a href="#dec">dec</a> <a href="#src">src</a> <a href="#slc">slc</a> <a href="#sim">sim</a> <a href="#popa">popA</a>
	can be usefully executed on registers or storage.
	Registers have no storage lock and are not shared between threads.
	It is not intended that <b>n inc dec src slc sim popA</b> instructions
	necessarily lock storage target operands or are used in arbitration



	<a	name="ts"/>
	Test and Set		ts
	____________		__

				_________________________________________________________
				|							|
				|	value at EA is atomically read and rewritten	|
				|	with value 1 in bit 23				|
				|							|
				|	the next instruction is skipped if bit 23 was 0 |
				|	before the operation				|
				|_______________________________________________________|
				|	target operand is the storage word at EA	|
				|	and not a register				|
				|	EA < 256 resolves to a location in memory B0	|
				|_______________________________________________________|



	assembler		ts	lock_cell[, {x|y|a|b|fp|sp}]
	syntax/example		j	$-1

				ts	*pointer_to_lock_cell
				lcal	wait_and_try_again


				_________________________________________________________
	Instruction Code 0.7	| 0 0 0 0 0 | 1 1 1 |		<a style="color:#00FF00">  address</a>		|
				|___________|_______|___________________________________|







	<a	name="n"/>
	Negate			n
	______			_

				_________________________________________________________
				|							|
				|	the value at EA is rewritten in ones complement	|
				|_______________________________________________________|
				|	target is the register or storage word at EA	|
				|_______________________________________________________|	



	assembler syntax	n	mantissa[, {x|y|a|b|fp|sp}]

				n	*pointer_to_switch



				_________________________________________________________
	Instruction Code 1.7	| 0 0 0 0 1 | 1 1 1 |		<a style="color:#00FF00">  address</a>		|
				|___________|_______|___________________________________|







	<a	name="inc"/>
	Increment		inc
	_________		___

				_________________________________________________________
				|							|
				|	+1 is added to the 24-bit value at EA		|
				|	 carry$ is not affected				|
				|_______________________________________________________|
				|	target is the register or storage word at EA	|
				|_______________________________________________________|	



	assembler syntax	inc	tally[, {x|y|a|b|fp|sp}]

				inc	*pointer2uptozerocounter



				_________________________________________________________
	Instruction Code 2.7	| 0 0 0 1 0 | 1 1 1 |		<a style="color:#00FF00">  address</a>		|
				|___________|_______|___________________________________|






	<a	name="dec"/>
	Decrement		dec
	_________		___

				_________________________________________________________
				|							|
				|	-1 is added to the 24-bit value at EA		|
				|	carry$ is not affected				|
				|_______________________________________________________|
				|	target is the register or storage word at EA	|
				|_______________________________________________________|	



	assembler syntax	dec	counter[, {x|y|a|b|fp|sp}]

				dec	*pointer_to_counter



				_________________________________________________________
	Instruction Code 3.7	| 0 0 0 1 1 | 1 1 1 |		<a style="color:#00FF00">  address</a>		|
				|___________|_______|___________________________________|






	<a	name="sim"/>
	Switch Interrupt Mask	sim
	_____________________	___

				_________________________________________________________
				|							|
				|	interrupt mask from PSR bits 18..16 is switched	|
				|	with the word at EA. Bits 23..3 of the storage	|
				|	word are dropped on read and zero on write	|
				|_______________________________________________________|
				|	PSR		I000 0iii 0xxx xxxx Hyyy 000C	|
				|_______________________________________________________|
				|	storage		0000 0000 0000 0000 0000 0iii	|
				|_______________________________________________________|
				|	target is the register or storage word at EA	|
				|_______________________________________________________|	




	assembler syntax	sim	aside_location[, {x|y|a|b|fp|sp}]

				sim	*pointer_to_imask_save


	assembler example	push	MAXIMUM_IMASK,,xi
				sim	0, sp
				.
				.
				sim	0, sp
				inc	sp


				_________________________________________________________
	Instruction Code 4.7	| 0 0 1 0 0 | 1 1 1 |		<a style="color:#00FF00">  address</a>		|
				|___________|_______|___________________________________|





	<a	name="popa"/>
	Pop and AddTo		popA
	_____________		____

				_________________________________________________________
				|							|
				|	the value at the internal stack top is added to |
				|	the word at EA. carry$ = the carry out of bit 23|
				|	of the addition. sp is incremented		|
				|							|
                                |       on internal stack overflow / underflow		|
                                |       [sp < 24 | sp > 127] before operation           |
                                |       guard interrupt 95 is raised                    |
                                |                                                       |
				|_______________________________________________________|
				|	target is the register or storage word at EA	|
				|_______________________________________________________|	



	assembler syntax	popA	storage_total[, {x|y|a|b|fp|sp}]

				popA	*pointer_to_storage_total



				_________________________________________________________
	Instruction Code 5.7	| 0 0 1 0 1 | 1 1 1 |		<a style="color:#00FF00">  address</a>		|
				|___________|_______|___________________________________|






	<a	name="src"/>
	Shift Right through Carry	src
	_________________________	___

				_________________________________________________________
				|							|
				|	the word at EA and carry$ are rotated in	|
				|	a 25-bit ring rightwards one bit position	|
				|_______________________________________________________|
				|	target is the register or storage word at EA	|
				|_______________________________________________________|	



	assembler syntax	src	rounding_overflow[, {x|y|a|b|fp|sp}]

				src	*bit_race_indirectly



				_________________________________________________________
	Instruction Code 6.7	| 0 0 1 1 0 | 1 1 1 |		<a style="color:#00FF00">  address</a>		|
				|___________|_______|___________________________________|





	<a	name="slc"/>
	Shift Left through Carry	slc
	________________________	___

				_________________________________________________________
				|							|
				|	the word at EA and carry$ are rotated in 	|
				|	a 25-bit ring leftwards one bit position	|
				|_______________________________________________________|
				|	target is the register or storage word at EA	|
				|_______________________________________________________|	



	assembler syntax	slc	attention_flags[, {x|y|a|b|fp|sp}]

				slc	*pointer_to_ring



				_________________________________________________________
	Instruction Code 7.7	| 0 0 1 1 1 | 1 1 1 |		<a style="color:#00FF00">  address</a>		|
				|___________|_______|___________________________________|



	<a      name="scala"/>
	<div    style="margin-left:28pt;font-family:times-roman;font-size:12.75pt;color:0000FF">
	<i>3.6.14	Double and Quadword Load and Store, Masked, Execute and Scale Operations, Large Integer Arithmetic</i>
	</div>
	Large integer operations have a source or target operand of one, two or four registers or storage words


	instructions		<a href="#ds">Double Store</a>			<a href="#dl">Double Load</a>
								<a href="#dpush">Double Push</a>
				<a href="#da">Double Add</a>			<a href="#dan">Double Add Negative</a>
				<a href="#lsc">Load Shift and Count</a>		<a href="#dlsc">Double Load Shift and Count</a>
				<a href="#mta">Masked Test A</a>			<a href="#mlb">Masked Load B</a>
				<a href="#sc">Store Carry</a>			<a href="#ex">Execute</a>
				<a href="#qs">Quadruple Store</a>			<a href="#ql">Quadruple Load</a>
				<a href="#qpop">Quadruple Pop</a>			<a href="#qpush">Quadruple Push</a>	


	<a	name="qs"/>
	Quadruple Store		qs
	_______________		__

				_________________________________________________________
				|							|
				|	four arithmetic registers			|
				|	a b mantissa2 mantissa3	are stored to EA	|
				|							|
				|	Register a is stored at register / storage EA	|
				|	Register b is stored at register / storage EA+1	|
				|	mantissa2  is stored at register / storage EA+2	|
				|	mantissa3  is stored at register / storage EA+3	|
				|_______________________________________________________|
				|	target is four registers or storage words at EA	|
				|	EA is any word address				|
				|_______________________________________________________|



	assembler syntax	qs	sum[, {x|y|a|b|fp|sp}]

				qs	*pointer_to_sum



				_________________________________________________________
	Instruction Code 8.7	| 0 1 0 0 0 | 1 1 1 |		<a style="color:#00FF00">  address</a>		|
				|___________|_______|___________________________________|







	<a	name="ql"/>
	Quadruple Load		ql
	______________		__

				_________________________________________________________
				|							|
				|	a 96-bit value at EA is loaded to four		|
				|	arithmetic registers a b mantissa2 mantissa3	|
				|							|
				|	register / storage at EA   loads to Register a	|
				|	register / storage at EA+1 loads to Register b	|
				|	register / storage at EA+2 loads to mantissa2	|
				|	register / storage at EA+3 loads to mantissa3	|
				|_______________________________________________________|
				|	source is four registers or storage words at EA	|
				|	EA is any word address				|
				|_______________________________________________________|



	assembler syntax	ql	sum[, {x|y|a|b|fp|sp}]

				ql	*pointer_to_sum

				ql	(250600004700003450.630*+1262001)


				_________________________________________________________
	Instruction Code 9.7	| 0 1 0 0 1 | 1 1 1 |		<a style="color:#00FF00">  address</a>		|
				|___________|_______|___________________________________|




	<a	name="qpop"/>
	Quadruple Pop		qpop
	_____________		____

				_________________________________________________________
				|							|
				|	four words are stored				|
				|	from the internal stack top			|
				|	store order is as stack order 	0, sp -> EA	|
				|					1, sp -> EA+1	|
				|					2, sp -> EA+2	|
				|					3, sp -> EA+3	|
				|							|
				|	internal stack pointer sp is incremented by 4	|
				|							|
                                |       on internal stack overflow / underflow		|
                                |       [sp < 24 | sp > 124] before operation           |
                                |       guard interrupt 95 is raised                    |
				|							|
				|_______________________________________________________|
				|	target is four registers or storage words at EA	|
				|	EA is any word address				|
				|_______________________________________________________|



	assembler syntax	qpop	buffer[, {x|y|a|b|fp|sp}]

				qpop	*pointer_to_buffer



				_________________________________________________________
	Instruction Code 16.7	| 1 0 0 0 0 | 1 1 1 |		<a style="color:#00FF00">  address</a>		|
				|___________|_______|___________________________________|








	<a	name="qpush"/>
	Quadruple Push		qpush
	______________		_____

				_________________________________________________________
				|							|
				|	internal stack pointer sp is decremented by 4	|
				|							|
				|	a 96-bit value at EA is read to the internal	|
				|	stack top at [sp]				|
				|							|
				|	the word read from EA is at the stack top  0,sp	|
				|	the word read from EA+1 is at stack top+1  1,sp	|
				|	the word read from EA+2 is at stack top+2  2,sp	|
				|	the word read from EA+3 is at stack top+3  3,sp	|
				|							|
                                |       on internal stack overflow / underflow		|
                                |       [sp < 28 | sp > 128] before operation           |
                                |       guard interrupt 95 is raised                    |
                                |                                                       |
				|_______________________________________________________|
				|	source is four registers or storage words at EA	|
				|	EA is any word address				|
				|_______________________________________________________|




	assembler syntax	qpush	buffer[, {x|y|a|b|fp|sp}]

				qpush	*pointer_to_buffer

				qpush	(623600004700003450.630*+1262001)


				_________________________________________________________
	Instruction Code 17.7	| 1 0 0 0 1 | 1 1 1 |		<a style="color:#00FF00">  address</a>		|
				|___________|_______|___________________________________|








	<a	name="ex"/>
	Execute			ex
	_______			__

				_________________________________________________________
				|							|
				|	a data word is read from memory, decoded	|
				|	and execute as an instruction			|
				|							|
				|	if the target instruction is not a jump, call,  |
				|	skip or	interrupt, execution continues at the	|
				|	instruction after the execute instruction	|
				|							|
				|	if the target instruction decides to jump, call,|
				|	skip or interrupt, execution continues at the	|
				|	jump target. If the target instruction is a call|
				|	or interrupt, return is to the instruction	|
				|	after the execute instruction			|
				|_______________________________________________________|
				|	execute target is the storage word at EA	|
				|	and not a register				|
				|	operand address < 256 resolves to a location in	|
				|	current B0 memory block				|
				|_______________________________________________________|



	assembler syntax	ex	instruction[, {x|y|a|b|fp|sp}]

				ex	*instruction_indirectly


	assembler example


		next_column	jxge		frame_scanned
				ex		key_difference, x
				ax, xi		1
				and, xi		4095
				aa		crc12_table_pointer
				la		0, a
				j		next_column


		key_difference
		column		$do		ARRAY_LIMIT,    ;
				xor		frame+(column-1)/2, b, h1+(column-1)///2

		........................................................................

				lx		bytes
				lb, xi		0
				on		b$streamZR

		next_digit	rsr		BYTE
				ax, xi		-1
				ex		raise,x 
				tz		x
				j		next_digit

				

		raise		ab		units-'0', a
				ab		tens-'0', a
				ab		hundreds-'0', a
				ab		thousands-'0', a
				ab		ten_thousands-'0', a
				ab		hundred_thousands-'0', a



					


				_________________________________________________________
	Instruction Code 18.7	| 1 0 0 1 0 | 1 1 1 |		<a style="color:#00FF00">  address</a>		|
				|___________|_______|___________________________________|







	<a	name="dpush"/>
	Double Push		dpush
	___________		_____

				_________________________________________________________
				|							|
				|	internal stack pointer sp is decremented by 2	|
				|	a 48-bit value at EA is loaed to the		|
				|	internal stack top at [sp]			|
				|							|
				|	the word read from EA is at the stack top  0,sp	|
				|	the word read from EA+1 is at stack top+1  1,sp	|
				|							|
                                |       on internal stack overflow / underflow		|
                                |       [sp < 26 | sp > 128] before operation           |
                                |       guard interrupt 95 is raised                    |
                                |                                                       |
				|_______________________________________________________|
				|	source is two registers or storage words at EA 	|
				|	EA is any word address				|
				|_______________________________________________________|



	assembler syntax	dpush	preload48[, {x|y|a|b|fp|sp}]

				dpush	*preload48_indirectly

				dpush	(258000000000000:d)



				_________________________________________________________
	Instruction Code 19.7	| 1 0 0 1 1 | 1 1 1 |		<a style="color:#00FF00">  address</a>		|
				|___________|_______|___________________________________|








	<a	name="lsc"/>
	Load Shift and Count	lsc
	____________________	___

				_________________________________________________________
				|							|
				|	a value at EA is retrieved, rotated to scale	|
				|	and stored in arithmetic register a		|
				|							|
				|	the value is rotated left counting		|
				|	until bit 23 changes or the count reaches 24	|
				|							|
				|	the shift count is stored in register b		|
				|							|
				|_______________________________________________________|
				|	source is the register or storage word at EA	|
				|_______________________________________________________|




	assembler syntax	lsc	short_mantissa[, {x|y|a|b|fp|sp}]

				lsc	*short_mantissa_indirectly



				_________________________________________________________
	Instruction Code 20.7	| 1 0 1 0 0 | 1 1 1 |		<a style="color:#00FF00">  address</a>		|
				|___________|_______|___________________________________|







	<a	name="mta"/>
	Masked Test Equal a	mta
	___________________	___

				_________________________________________________________
				|							|
				|	the next instruction is skipped  if		|
				|	(Register a AND Mask Register k) equals		|
				|	(register / storage at EA) AND Mask Register k 	|
				|_______________________________________________________|
				|	comparand is register or storage word at EA	|
				|_______________________________________________________|



	assembler syntax	mta	comparand[, {x|y|a|b|fp|sp}]

				mta	*comparand_indirectly


	assembler_example	lk	(0FFFF00:s)
				mta	(00D0A00:s)
				j	not_cr_lf



				_________________________________________________________
	Instruction Code 21.7	| 1 0 1 0 1 | 1 1 1 |		<a style="color:#00FF00">  address</a>		|
				|___________|_______|___________________________________|







	<a	name="sc"/>
	Store Carry		sc
	___________		__

				_________________________________________________________
				|							|
				|	Processor State Register AND 1 is stored	|
				|	at the target register / storage word		|
				|_______________________________________________________|
				|	target is the register or storage word at EA	|
				|_______________________________________________________|



	assembler syntax	sc	next_add_word[, {x|y|a|b|fp|sp}]

				sc	*pointer_to_next_add_word



				_________________________________________________________
	Instruction Code 22.7	| 1 0 1 1 0 | 1 1 1 |		<a style="color:#00FF00">  address</a>		|
				|___________|_______|___________________________________|








	<a	name="mlb"/>
	Masked Load b		mlb
	_____________		___

				_________________________________________________________
				|							|
				|	arithmetic register b is loaded with 		|
				|	   (register / storage AND Mask Register k)	|
				|	OR (Register b AND (NOT Mask Register k))	|
				|_______________________________________________________|
				|	source is the register or storage word at EA	|
				|_______________________________________________________|



	assembler syntax	mlb	word2merge[, {x|y|a|b|fp|sp}]

				mlb	*pointer_to_word2merge



				_________________________________________________________
	Instruction Code 23.7	| 1 0 1 1 1 | 1 1 1 |		<a style="color:#00FF00">  address</a>		|
				|___________|_______|___________________________________|







	<a	name="ds"/>
	Double Store		ds
	____________		__

				_________________________________________________________
				|							|
				|	the 48-bit value in arithmetic registers a and b|
				|	is stored at EA					|
				|							|
				|	Register a is stored at EA			|
				|	Register b is stored at EA+1			|
				|_______________________________________________________|
				|	target is two registers or storage words at EA	|
				|	EA is any word address				|
				|_______________________________________________________|




	assembler syntax	ds	destination48[, {x|y|a|b|fp|sp}]

				ds	*pointer_to_destination48



				_________________________________________________________
	Instruction Code 24.7	| 1 1 0 0 0 | 1 1 1 |		<a style="color:#00FF00">  address</a>		|
				|___________|_______|___________________________________|







	<a	name="dl"/>
	Double Load		dl
	___________		__

				_________________________________________________________
				|							|
				|	a 48-bit value is loaded from EA		|
				|	to arithmetic registers a and b			|
				|							|
				|	the word at EA is loaded to Register a		|
				|	the word at EA+1 is loaded to Register b	|
				|_______________________________________________________|
				|	source is two registers or storage words at EA	|
				|	EA is any word address				|
				|_______________________________________________________|




	assembler syntax	dl	from48[, {x|y|a|b|fp|sp}]

				dl	*pointer_to_from48

				dl	(258000000000000:d)


				_________________________________________________________
	Instruction Code 25.7	| 1 1 0 0 1 | 1 1 1 |		<a style="color:#00FF00">  address</a>		|
				|___________|_______|___________________________________|







	<a	name="da"/>
	Double Add		da
	__________		__

				_________________________________________________________
				|							|
				|	a 48-bit integer at EA is added to		|
				|	arithmetic registers a and b			|
				|							|
				|	the word at EA contains high-order bits 47..24	|
				| 	of the addend					|
				|							|
				|	the word at EA+1 contains low-order bits 23..0	|
				|	of the addend					|
				|							|
				|	carry$ = the carry from bit 47 of the addition	|
				|_______________________________________________________|
				|	2nd addend is 2 registers or storage words at EA|
				|	EA is any word address				|
				|_______________________________________________________|



	assembler syntax	da	addend48[, {x|y|a|b|fp|sp}]

				da	*addend48_indirectly

				da	(-120000000000000)

				_________________________________________________________
	Instruction Code 26.7	| 1 1 0 1 0 | 1 1 1 |		<a style="color:#00FF00">  address</a>		|
				|___________|_______|___________________________________|







	<a	name="dan"/>
	Double Add Negative	dan
	__________________	___

				_________________________________________________________
				|							|
				|	the 2s complement of a 48-bit integer at EA 	|
				|	is added to arithmetic registers a and b	|
				|							|
				|	the word at EA contains high-order bits 47..24	|
				| 	of the subtrahend				|
				|							|
				|	the word at EA+1 contains low-order bits 23..0	|
				|	of the subtrahend				|
				|							|
				|	carry$ = the carry from bit 47 of the addition	|
				|_______________________________________________________|
				|	subtrahend is 2 registers or storage words at EA|
				|	EA is any word address				|
				|_______________________________________________________|



	assembler syntax	dan	subtrahend48[, {x|y|a|b|fp|sp}]

				dan	*subtrahend48_indirectly

				dan	(120000000000000)


				_________________________________________________________
	Instruction Code 27.7	| 1 1 0 1 1 | 1 1 1 |		<a style="color:#00FF00">  address</a>		|
				|___________|_______|___________________________________|







	<a	name="dlsc"/>
	Double Load Shift and Count	dlsc
	___________________________	____

				_________________________________________________________
				|							|
				|	a 48-bit value is loaded from two words at EA	|
				|	and rotated to scale then stored in arithmetic 	|
				|	registers a and b				|
				|							|
				|	the value is rotated left counting		|
				|	until bit 47 changes or the count reaches 48	|
				|							|
				|	the shift count is stored in register mantissa2	|
				|							|
				|_______________________________________________________|
				|	source is two registers or storage words at EA	|
				|	EA is any word address				|
				|_______________________________________________________|



	assembler syntax	dlsc	mantissa[, {x|y|a|b|fp|sp}]

				dlsc	*mantissa_indirectly


				_________________________________________________________
	Instruction Code 28.7	| 1 1 1 0 0 | 1 1 1 |		<a style="color:#00FF00">  address</a>		|
				|___________|_______|___________________________________|











        <a      name="fp"/>
        <div    style="margin-left:28pt;font-family:times-roman;font-size:12.75pt;color:0000FF">
        <i>3.6.15       96-bit and 192-bit Floating Point, Rounding Setting, Exponent Underflow and Overflow Handling, Floating 48-Bit Compression</i>
        </div>
	instructions	<a href="#fa">Floating Add</a>			<a href="#fpp">Floating Pop and Pack</a>
			<a href="#fan">Floating Add Negative</a>		<a href="#fpx">Floating Push and Expand</a>
			<a href="#fm">Floating Multiply</a>
			<a href="#fd">Floating Divide</a>

	<div	style="font-size:11pt">
	_________________________________________________________________________________________________________________
	|					The 96-bit Floating Architecture					|
	|_______________________________________________________________________________________________________________|
	|														|
	|														|
	|	RTA1 has four floating operation instructions and two instructions for					|
	|	storage compression and expansion of floating numbers							|
	|														|
	|	Four consecutive computer words form a 96-bit floating number						|
	|														|
	|	the 72-bit mantissa is a simple fraction in bits 71..0							|
	|														|
	|	The mantissa has no integer part either represented or unrepresented					|
	|														|
	|	The binary point is between the normalising bit 71 and the characteristic field in bits 94..72 		|
	|														|
	|	An integer value is obtained by hauling the mantissa upwards through the binary point by the number	|
	|	of shift positions with which the characteristic exceeds the midpoint value of 400000 hexadecimal	|
	|														|
	|	The midpointed 23-bit characteristic covers the range of decimal exponents -1262611 to +1262611		|
	|														|
	|	A characteristic of zero expresses the lowest possible exponent						|
	|														|
	|	A characteristic at midpoint 400000 expresses the zero exponent. The normalised number is >= 0.5 and < 1|
	|														|
	|	A maximum characteristic 7FFFFF expresses the highest possible exponent					|
	|														|
	|	Bit 95 = 1 indicates the the number is a ones complement negative number				|
	|														|
	|	Bit 95 is not a sign bit in the sense of indicating negative polarity over a following positive		|
	|	magnitude. It is an indication that all the bits of the positive magnitude are flipped to make		|
	|	a negative number											|
	|														|
	|	Internally addition and subtraction require no conditional inversions					|
	|	Subtraction is the addition of a ones complement							|
	|														|
	|	A number is normalised if bit 71 is different from sign bit 95						|
	|														|
	|	All unnormalised numbers have the algebraic value of zero						|
	|														|
	|														|
	|	Rounding Setting											|
	|	________________											|
	|														|
	|	Rounding is determined by the pattern of high-order bits in register <b>fp$guard</b> at address 147		|
	|	(hex 93). <b>fp$guard</b> can only be written by interrupt code. Prototype kernel smaragd7 assigns a	 	|
	|	default value C00000 hex to <b>fp$guard</b> for every thread. <b>fp$guard</b> value is part of thread			|
	|	context and each thread may change its value with the system call					|
	|														|
	|			la	(<i>NEW_PATTERN</i>)									|
	|			ii	FP_GUARD$									|
	|														|
	|	This system call returns the rounding pattern from before in application register a			|
	|														|
	|														|
	|														|
	|														|
	|														|
	|	The format of an RTA1 floating number									|
	|	_____________________________________									|
	|														|
	|	95  94			 71								       0	|
	|	_________________________________________________________________________________________________	|
	|	|s|    characteristic	|				mantissa				|	|
	|	|_|_____________________|_______________________________________________________________________|	|
	|														|
	|														|
	|														|
	|_______________________________________________________________________________________________________________|
	|														|
	|														|
	|														|
	|	192-bit floating values											|
	|	_______________________											|
	|														|
	|														|
	|	PSR Flag <b>fp$r</b> signals floating instructions to store a minor result in registers 8..11			|
	|	giving this overall format in the eight registers a:b:mantissa2:mantissa3::8:9:10:11			|
	|														|
	|														|
	|      191|190			 167								      96	|
	|	__|______________________________________________________________________________________________	|
	|	|s|	characteristic	|				mantissa				|	|
	|	|_|_____________________|_______________________________________________________________________|	|
	|	|s|	characteristic	|				mantissa				|	|
	|	|_|_____________________|_______________________________________________________________________|	|
	|	95 94			 71								       0	|
	|														|
	|	The minor characteristic (exponent) is the major characteristic minus 72				|
	|	minus the normalising count of the minor mantissa							|
	|														|
	|	If the minor mantissa cannot be normalised because it is either positive zero or negative zero then 	|
	|	the minor result characteristic is all signs and the algebraic value of the minor result is zero	|
	|														|
	|	The minor mantissa is used in further operations to determine the low-order part 			|
	|	of 192-bit floating values										|
	|														|
	|	If a minor result is stored in registers 8..11 in compliance with <b>fp$r</b> then rounding per		|
	|	guard pattern register <b>fp$guard</b> takes place on the minor result and not the major result		|
	|														|
	|_______________________________________________________________________________________________________________|
	|														|
	|														|
	|														|
	|	Exponent Underflow and Overflow	Handling								|
	|	________________________________________								|
	|														|
	|														|
	|	If a floating point operation borrows or carries from the 23-bit exponent field, a true	result		|
	|	is not stored. These conditions are called exponent underflow and exponent overflow			|
	|														|
	|	Exponent underflow and exponent overflow are detected in RTA1 floating instruction architecture.	|
	|	Interrupt FP_XPO$ is raised										|
	|														|
	|	ISR <a href="kernel.html#xpo_ii">FP_XPO$</a> in prototype kernel OR-sums the event in the thread control block				|
	|														|
	|	The application may issue system call internal interrupt <a href="kernel.html#fp_xpo_flag_ii">FP_XPO$FLAG</a> at any time after			|
	|	exponent underflow/overflow could have been raised							|
	|														|
	|	service call FP_XPO$FLAG :										|
	|														|
	|		returns indicating exponent overflow/underflow has or has not been raised			|
	|														|
	|		resets the assertion which remains reset until exponent overflow/underflow is next raised	|
	|														|
	|	The reasons for accumulating underflow/overflow event for later examination are				|
	|														|
	|		RTA1 23-bit floating exponent field is so large that exponent overflow/underflow		|
	|		is not expected as a result of correct operation						|
	|														|
	|		An oversight or	misunderstanding in machine programming could cause				|
	|		exponent underflow or overflow									|
	|														|
	|		Realtime routines should not need to check continually for exponent overflow errors		|
	|		since, especially, many calculations are multiple operations in subroutines and libraries	|
	|														|
	|		If routines process values within the range							|
	|														|
	|			&plusmn;9.999999999999999999999e+1262610							|
	|														|
	|			&plusmn;9.999999999999999999999e-1262611							|
	|														|
	|		or in 192-bit floating algebra, the range							|
	|														|
	|			&plusmn;9.999999999999999999999999999999999999999999e+1262610					|
	|														|
	|			&plusmn;9.999999999999999999999999999999999999999999e-1262566					|
	|														|
	|		then exponent underflow/overflow is not raised.							|
	|														|
	|	Possible diminishing exponent "only" reaches -1262566 in 192-bit floating algebra			|
	|	because 192-bit values are maintained in two 96-bit numbers each with an exponent			|
	|														|
	|	Applications may check that no underflow/overflow has happened with call FP_XPO$FLAG			|
	|	If exponent underflow/overflow has been raised, the affected instruction may be pinpointed by		|
	|	repositioning the call to FP_XPO$FLAG. Call sequence is							|
	|														|
	|		ii	FP_XPO$FLAG										|
	|		j	<i>react</i>	. return + 0: underflow/overflow raised since last ii FP_XPO$FLAG		|
	|			.		. return + 1: exponent underflow/overflow has not been raised		|
	|														|
	|	The default behaviour of ISR FP_XPO$ which executes when exponent underflow/overflow occurs		|
	|	is to change the value in destination registers to -0.0 represented as all binary 1s. This		|
	|	may indicate exponent underflow/overflow, although -0.0 can also be a legitimate instruction result	|
	|														|
	|	FP_XPO$FLAG indication remains available although instructions subsequent to the operation		|
	|	may overwrite any indication in target application registers						|
	|														|
	|	If any one instruction in a sequence or routine has raised exponent underflow or overflow		|
	|	then the results of the instruction sequence are unusable						|
	|														|
	|	FP_XPO$FLAG return + 0 is a reliable indication that floating exponent underflow/overflow happened	|
	|	during execution of instructions leading up to the FP_XPO$FLAG enquiry					|
	|														|
	|	FP_XPO$FLAG return + 1 is equally a reliable indication that floating exponent underflow/overflow	|
	|	did not happen since the last FP_XPO$FLAG enquiry							|
	|														|
	|_______________________________________________________________________________________________________________|	
	</div>


	<a	name="fpp"/>
	Floating Pop and Pack	fpp
	_____________________	___


				_________________________________________________________
				|							|
				|	the 96-bit floating point value at the		|
				|	internal stack top is compressed and stored	|
				|	as two words in registers or storage at EA	|
				|							|
				|	the high-order exponent bit and the		|
				|	10 low-order exponent bits are stored		|
				|							|
				|	the 36 high-order fraction bits are stored	|
				|							|
				|	no rounding takes place				|
				|							|
				|	internal stack pointer sp is incremented by 4	|
				|							|
				|_______________________________________________________|
				|	target is two registers or storage words at EA	|
				|	EA is any word address				|
				|_______________________________________________________|








                                 95                              71                           48
                                _________________________________________________________________
        4-word source from	| SXxx xxxx xxxx xxXX XXXX XXXX | MMMM MMMM MMMM MMMM MMMM MMMM |
        internal stack top      |_______________________________|_______________________________|
				| MMMM MMMM MMMM mmmm mmmm mmmm | mmmm mmmm mmmm mmmm mmmm mmmm |
				|_______________________________|_______________________________|
        			 47			         23     		       0


				
				compression to 48 bits retains	exponent bits 94,81..72
								fraction bits 71..36


                                _________________________________________________________________
        2-word stored		| SXXX XXXX XXXX MMMM MMMM MMMM | MMMM MMMM MMMM MMMM MMMM MMMM |
        pop target		|_______________________________|_______________________________|
 				 47				 23			      0


				midpoint exponent  XXX XXXX XXXX is stored in ranges 000..3FF:400..7FF
				equivalent to decimal scales -308..+308

				these example values are in 48-bit compressed format and range


				00:000000 3FF800000000         0.25d
				00:000002 C007FFFFFFFF        -0.25d
				00:000004 400800000000         0.5d
				00:000006 BFF7FFFFFFFF        -0.5d
				00:000000 7FFFFFFFFFFF         8.98846567418078014812d*+307
				00:000002 800000000000        -8.98846567418078014812d*+307
				00:000004 000FFFFFFFFF         5.56268464618705574232d*-309
				00:000006 FFF000000000        -5.56268464618705574232d*-309




	assembler syntax	fpp	floating_packed_storage[, {x|y|a|b|fp|sp}]

				fpp	*pointer_to_store



				_________________________________________________________
	Instruction Code 10.7	| 0 1 0 1 0 | 1 1 1 |		<a style="color:#00FF00">  address</a>		|
				|___________|_______|___________________________________|









	<a	name="fpx"/>
	Floating Push and Expand	fpx
	________________________	___


				_________________________________________________________
				|							|
				|	the internal stack pointer sp is		|
				|	decremented by 4				|
				|							|
				|	the 48-bit compressed floating number at EA	|
				|	is expanded to 96 bits and placed at the	|
				|	internal stack top				|
				|							|
				|	the high-order bit of the restored exponent	|
				|	is followed by 12 bits of reverse polarity	|
				|	then the 10 remaining exponent bits		|
				|							|
				|	the 12 inserted bits are therefore signs if	|
				|	the exponent is midpoint or higher otherwise	|
				|	reverse signs					|
				|							|
				|	36 sign bits are added to the mantissa		|
				|							|
				|_______________________________________________________|
				|	source is two registers or storage words at EA	|
				|	EA is any word address				|
				|_______________________________________________________|




				________________________________________________________________
        2-word push source	| SXXX XXXX XXXX MMMM MMMM MMMM | MMMM MMMM MMMM MMMM MMMM MMMM |
				|_______________________________|_______________________________|
				 47                                                            0



				11 available exponent values are written to exponent positions 94,81:72
				the polar reverse of bit 94 is written to exponent positions 93..82

				the 23 bit exponent is restored in ranges 3FFC00..3FFFFF:400000..4003FF
				equivalent to decimal scales -308..+308

				36 available fraction values are written to fraction positions 71..36
				signs are written to fraction positions 35..0



				 95				 71			      48
				_________________________________________________________________
	4-word result on	| SXxx xxxx xxxx xxXX XXXX XXXX	| MMMM MMMM MMMM MMMM MMMM MMMM	| 
	internal stack top	|_______________________________|_______________________________|
				| MMMM MMMM MMMM SSSS SSSS SSSS | SSSS SSSS SSSS SSSS SSSS SSSS |
				|_______________________________|_______________________________|
				 47				 23			       0
				

				these example values are in the range which may be compressed and subsequently
				expanded without loss


				00:000000 3FFFFF800000000000000000	 0.25
				00:000004 C000007FFFFFFFFFFFFFFFFF	-0.25
				00:000008 400000800000000000000000	 0.5
				00:00000C BFFFFF7FFFFFFFFFFFFFFFFF	-0.5
				00:000010 4003FFFFFFFFFFF000000000	 8.98846567418078014812*+307
				00:000014 BFFC00000000000FFFFFFFFF	-8.98846567418078014812*+307
				00:000018 3FFC00FFFFFFFFF000000008	 5.56268464618705574232*-309
				00:00001C C003FF000000000FFFFFFFF7	-5.56268464618705574232*-309





	assembler syntax	fpx	floating_packed_storage[, {x|y|a|b|fp|sp}]

				fpx	*pointer_to_floating_packed

				fpx	(4.4510310377d*+300)


				_________________________________________________________
	Instruction Code 11.7	| 0 1 0 1 1 | 1 1 1 |		<a style="color:#00FF00">  address</a>		|
				|___________|_______|___________________________________|







	<a	name="fa"/>
	Floating Add		fa
	_____________		__

				_________________________________________________________
				|							|
				|	the four-word floating-point number at EA	|
				|	is added to the four-word floating-point number	|
				|	in arithmetic registers a b mantissa2 mantissa3	|
				|							|
				|	Register a contains sign and characteristic bits|
				|	95..72 of one addend and of the sum		|
				|							|
				|	Registers b mantissa2 mantissa3 contain	the	|	
				|	mantissa of one addend and of the sum with	|
				|	highest order bits in Register b and lowest	|
				|	order bits in Register mantissa3		|
				|							|
				|	the word at EA contains sign and characteristic	|
				|	bits of the other addend. The highest order	|
				|	mantissa bits are at EA+1, bits 47..24 at EA+2	|
				|	and the lowest order mantissa bits are at EA+3	|
				|							|
				|_______________________________________________________|
				|	2nd addend is 4 registers or storage words at EA|
				|	EA is any word address				|
				|_______________________________________________________|



	assembler syntax	fa	addend[, {x|y|a|b|fp|sp}]

				fa	*pointer_to_addend

				fa	(2.50600004700003450630*+1262600)


				_________________________________________________________
	Instruction Code 12.7	| 0 1 1 0 0 | 1 1 1 |		<a style="color:#00FF00">  address</a>		|
				|___________|_______|___________________________________|



	operation sequence	ql	first_addend
	192-bit values		on	fp$r
				fa	second_addend
				qs	sum
				off	fp$r
				ql	first_addend+4
				fa	$residue
				fa	second_addend+4
				  on	fp$r		. force super-normalisation
				  fa	sum		. between major and minor numbers
				  off	fp$r
				  qs	sum
				  ql	$residue	. especially if this sequence is iterative
				qs	sum+4





	<a	name="fan"/>
	Floating Add Negative		fan
	_____________________		___

				_________________________________________________________
				|							|
				|	the 1s complement of the four-word		|
				|	floating-point number at EA is added to		|
				|	the four-word floating-point number		|
				|	in arithmetic registers a b mantissa2 mantissa3	|
				|							|
				|	Register a contains sign and characteristic bits|
				|	95..72 of the minuend and of the difference	|
				|							|
				|	Registers b mantissa2 mantissa3 contain the	|	
				|	mantissa of the minuend and of the difference	|
				|	with highest order bits in Register b and	|
				|	lowest order bits in Register mantissa3		|
				|							|
				|	the word at EA contains sign and characteristic	|
				|	bits of the subtrahend. The highest order	|
				|	mantissa bits are at EA+1, bits 47..24 at EA+2	|
				|	ans the lowest order mantissa bits are at EA+3	|
				|							|
				|_______________________________________________________|
				|	subtrahend is 4 registers or storage words at EA|
				|	EA is any word address				|
				|_______________________________________________________|




	assembler syntax	fan	subtrahend[, {x|y|a|b|fp|sp}]

				fan	*subtrahend_indirectly

				fan	(457600004700003450.630*+1262001)


				_________________________________________________________
	Instruction Code 13.7	| 0 1 1 0 1 | 1 1 1 |		<a style="color:#00FF00">  address</a>		|
				|___________|_______|___________________________________|



	operation sequence	ql	minuend
	192-bit values		on	fp$r
				fan	subtrahend
				qs	difference
				off	fp$r
				ql	minuend+4
				fan	subtrahend+4
				fa	$residue
				  on	fp$r		. force super-normalisation
				  fa	difference	. between major and minor numbers
				  off	fp$r
				  qs	difference
				  ql	$residue	. especially if this sequence is iterative
				qs	difference+4
				






	<a	name="fm"/>
	Floating Multiply	fm
	_________________	__

				_________________________________________________________
				|							|
				|	the four-word floating-point number		|
				|	in arithmetic registers a b mantissa2 mantissa3	|
				|	is multiplied by				|
				|	the four-word floating-point number at EA	|
				|							|
				|	Register a contains sign and characteristic bits|
				|	95..72 of the multiplicand and of the product	|
				|							|
				|	Registers b mantissa2 mantissa3 contain the	|	
				|	mantissa of the multiplicand and of the product	|
				|	with highest order bits in Register b and	|
				|	lowest oder bits in mantissa3			|
				|							|
				|	the word at EA contains sign and characteristic	|
				|	bits of the multiplier. The highest order	|
				|	mantissa bits are at EA+1, bits 47..24 at EA+2	|
				|	ans the lowest order mantissa bits are at EA+3	|
				|							|
				|_______________________________________________________|
				|	multiplier is 4 registers or storage words at EA|
				|	EA is any word address				|
				|_______________________________________________________|



	assembler syntax	fm	multiplier[, {x|y|a|b|fp|sp}]

				fm	*multiplier_indirectly

				fm	(250600004700003450.630*-1262001)


				_________________________________________________________
	Instruction Code 14.7	| 0 1 1 1 0 | 1 1 1 |		<a style="color:#00FF00">  address</a>		|
				|___________|_______|___________________________________|


	operation sequence	ql	multiplicand
	192-bit values		on	fp$r
				fm	multiplier
				off	fp$r
				qs	product
				ql	multiplicand+4
				fm	multiplier
				fa	$residue
				  on	fp$r		. force super-normalisation
				  fa	product		. between major and minor numbers
				  off	fp$r
				  qs	product
				  ql	$residue	. especially if this sequence is iterative
				qs	product+4

				If the multiplier is represented in more than 96 bits, then the
				192-bit multiplicand is also multiplied by the minor multiplier
				and the two long products summed. Minor result <b>$residue</b> is
				needed during both multiplication sequences and during the final
				long addition






	<a	name="fd"/>
	Floating Divide		fd
	_______________		__

				_________________________________________________________
				|							|
				|	the four-word floating-point number 		|
				|	in arithmetic registers a b mantissa2 mantissa3	|
				|	is divided by					|
				|	the four-word floating-point number at EA 	|
				|							|
				|	Register a contains sign and characteristic bits|
				|	95..72 of the dividend and of the quotient	|
				|							|
				|	Registers b mantissa2 mantissa3 contain the	|
				|	mantissa of the dividend and of the quotient	|
				|	with highest order bits in Register b and	|
				|	lowest oder bits in mantissa3			|
				|							|
				|	the word at EA contains sign and characteristic	|
				|	bits of the divisor. The highest order		|
				|	mantissa bits are at EA+1, bits 47..24 at EA+2	|
				|	ans the lowest order mantissa bits are at EA+3	|
				|							|
				|_______________________________________________________|
				|	divisor is four registers or storage words at EA|
				|	EA is any word address				|
				|_______________________________________________________|



	assembler syntax	fd	divisor[, {x|y|a|b|fp|sp}]

				fd	*divisor_indirectly

				fd	(458.600004700003450630*+1262001)


				_________________________________________________________
	Instruction Code 15.7	| 0 1 1 1 1 | 1 1 1 |		<a style="color:#00FF00">  address</a>		|
				|___________|_______|___________________________________|


	operation sequence	ql	dividend
	192-bit values		on	fp$r
				fd	divisor
				off	fp$r
				qs	quotient
				ql	dividend+4
				fd	divisor
				fa	$residue
				  on	fp$r		. force super-normalisation
				  fa	quotient	. between major and minor numbers
				  off	fp$r
				  qs	quotient
				  ql	$residue	. especially if this sequence is iterative
				qs	quotient+4


				If the divisor value is represented in more than 96 bits,
				a quotient precise to 192 bits is obtained by multiplying
				by the reciprocal of the divisor

				Divisor values with an equivalent decimal exponent less than zero
				or greater than 31 are represented in more than 96 bits
 







	<a	name="gocall"/>
	<div	style="margin-left:28pt;font-family:times-roman;font-size:12.75pt;color:0000FF">	
	<i>3.6.16	Far Go and Call</i>
	</div>

	<div	style="font-size:11pt">
	Extensive system images may be constructed using only 4K iframes for [kernel and] applications

	Fixed iframes one 4K-word page in size may be called without a gate
	if they are at a location less than 256 Megawords

	Dynamically loadable iframes can only be located with a gate

	Iframes larger than one 4K-word page only be located with a gate

	Gates can address any offset location in fixed or dynamic iframes of any size anywhere in executable space



	_________________________________________________________
	|	go and call between instruction frames		|
	|_______________________________________________________|
	|							|
	|	Inter-iframe jumps <b>go</b> and <b>call</b>			|
	|	read a single word operand of format		|	<a	name="gate"/>
	|							|
	|							|	48-bit gate to execution space location
	|	   22                         0			|
	|	________________________________		|	________________________________________________________________
	|	|1|	  gate address	       |---------------------->	|pagehx|   instruction offset  |ff|  iframe start page index   |
	|	|_|____________________________|		|	|______|_______________________|__|____________________________|
	|	  23-bit pointer to gate constant or variable	|	|47  42			     24| 22
	|							|	|			       |
	|							|	|page high index	       |00: page high index = 0 = pages 1
	|							|	|= iframe pages - 1	       |10: page high index in bits 47:42
	|			OR of format			|
	|							|
	|							|
        |	    21                6       0			|
	|	________________________________		|
        |	|00|bbbb bbbb bbbb bbbb| vector|		|
	|	|__|___________________|_______|		|
        |           16-bit pointer       6-bit			|
	|	    to 4K iframe edge    vector			|
	|							|_______________________________
	|											|
	|											|
	|											|
	|											|
	|	<b>call</b> instruction								|
	|	pushes program-counter minus B0 * 4096 on the internal stack			|
	|	then pushes Iframe Name = B0 OR size flag					|
	|	________________________________						|
	|	|	    saved offset       |						|
	|	|______________________________|						|
	|	|F0| 	    saved B0	       |						|
	|	|__|___________________________| <------------- updated internal stack pointer	|
	|											|
	|											|
	|											|
	|	<b>go</b> and <b>call</b> update the program counter						|
	|											|
	|											|
	|       B0 = operand[21..6] >> 6							|
        |	PC = B0 * 4096 + operand[5..0]							|
	|											|
	|											|
	|											|
	|	                        _____________________					|
        |		                go / call destination					|
        |       		        _____________________					|
        |               		        |						|
	|                       	        |						|
	|      			 	        |                               		|
	|			       	________|________               			|
	|			        | B0 =          |               			|
        |				| operand >> 6  |               			|
	|			        |_______________|               			|
        |				        |                              			|
	| 				________|________               			|
	|			        | offset =      |               			|
        |				| operand AND 63|              				|
	|       			|_______________|               			|
	|       	        		|                     				|
	|	                        ________|________					|
        |		                | PC = B0 */ 12 |					|
        |       		        | OR offset     |					|
        |               		|_______________|					|
	|											|
	|											|
	|											|
	|											|
	|$ masmx ibj -ln									|
	|MASMX 7r3										|
	|3/ibj.msm										|
	|freeware/RTA1/rta/fs/fs.txo:$(0) 477 words decimal from hexadecimal 000000 to 0001DD	|
	|*EOF*											|
	|  :                            1							|
	|  :                            2:       $include        freeware/RTA1/rta/def/rta.def	|
	|  :                            3        $include,$void freeware/RTA1/rta/fs/fs.txo $(0)|
	|  :                            4 $(0:64)						|
	|00:000040 FF0100              +5        call            (seg$load)			|
	|  :                            6							|
	|  :                            7							|
	|  :                            8        $do             $<256,$(0:256)			|
	|  :                            9							|
	|*EOF*											|
	|00:000100+000187									|
	|:$(00):000040:000101									|
	|											|
	|_______________________________________________________________________________________|
	</div>





	<a	name="go"/>
	Go			go
	__			__

<div	style="font-size:11pt">

	_________________________________________________________
	|							|
	|	Jump to Iframe					|
        |                                                       |       indirect operand pointing to gate constant or variable
        |       operand is storage word or register at EA       |
        |                                                       |        23                                                    0
        |                                                       |       _________________________________________________________
        |       if operand bit 23 = 1 --------------------------------> | 1 |               address of gate                     |_______
        |       bits 22:0 point to a constant or variable       |       |___|___________________________________________________|       |
        |       containing a 48-bit gate value                  |            22                                                0        |
        |                                                       |                                                                       |
        |       if operand bit 23 = 0                           |                                                                       |
        |                                                       |                                                                       |
        |               bit 22 is reserved                      |                                                                       |
        |                                                       |                                                                       |
        |               bits 21:6 are a 16-bit index of the 1st |                                                                       |
        |               4K page of the target iframe            |        gate to target iframe:offset					|
        |                                                       |                                                                       |
        |               bits 5:0 are an entry point vector      |        47          42                                       24        |
        |               to locations 0..63 of the target iframe |       _________________________________________________________       |
        |                                                       |       | page high idx|        target instruction offset       |	| 
        |_______________________________________________________|       |______________|________________________________________|<------+
        | 00 |       pointer to 4K-aligned page   |       vector|       | F 0 |                 iframe start page index         |
        |____|21__________________________________|5___________0|       |_____|_________________________________________________|
        |                                                       |              21                                              0
        |                                                       |
        |               B0 = operand bits 21..6 >> 6            |              B0 = gate bits 21..0 Start Page Index
        |               Page High Index = 0                     |              Page High Index = bits 47..42 of gate
        |               Iframe Name = B0                        |              Iframe Name = B0 OR (iframe pages > 1) 1 << 23
        |               B64 = B0                                |              B64 = B0 + Page High Index
        |               PC = B0 * 4096 + operand 5..0 offset    |              PC = B0 * 4096 + gate bits 41..24 offset
        |                                                       |
        |                                                       |
        |_______________________________________________________|________________________________________________________________
        |                                                                                                                       |
        |       operand is the  register or storage word at EA                                                                  |
        |_______________________________________________________________________________________________________________________|

</div>


	assembler syntax	go	target_identifier[, {x|y|a|b|fp|sp}]

				go	*target_identifier_indirectly

				go	(MEMORY/4096*64++VECTOR_0_63)

				go	(0800000++LITERALS_TAG(page_high_index*/18++offset, start_page_index:d)s)

					for large and dynamically loadable iframes see <a href="#iframe">iframe</a> and <a href="#gate">gate</a>



				_________________________________________________________
	Instruction Code 30.7	| 1 1 1 1 0 | 1 1 1 |		<a style="color:#00FF00">  address</a>		|
				|___________|_______|___________________________________|







	<a	name="call"/>
	Call			call
	____			____

<div	style="font-size:11pt">
												return address -> internal stack
									 23						       0
	_________________________________________________________	_________________________________________________________
	|							|	|			saved offset			|
	|	Call Iframe					|	|_______________________________________________________|
	|							|	| F 0 |			saved Start Page Index		|
	|	Program Counter minus B0 * 4096			|	|_____|_________________________________________________|
	|	is pushed to internal stack			|	      |21					       0
	|							|
	|	Iframe Name pushed to Internal Stack		|	  0 0 | <- B64 = B0 : Page High Index on return = 0
	|	= B0 -> bits 21:0 Start Page Index		|	  1 0 | <- B64 > B0 : Page High Index on return
	|	+ iframe size flags -> bits 23:22		|			      = gate bits 47:42 @ iframe + 64
	|							|
	|							|
	|_______________________________________________________|_______________________________________________________________
	|							|
	|							|
	|							|	indirect target operand pointing to gate constant or variable
	|	operand is storage word or register at EA 	|
	|							|	 23						       0
	|							|	_________________________________________________________
	|	if operand bit 23 = 1 -------------------------------->	| 1 |		    address of gate			|_______
	|	bits 22:0 point to a constant or variable	|	|___|___________________________________________________|	|
	|	containing a 48-bit gate value			|	     22						       0	|
	|							|									|
	|	if operand bit 23 = 0				|									|
	|							|									|
	|		bit 22 is reserved			|									|
        |                                                      	|									|
        |       	bits 21:6 are a 16-bit index of the 1st |									|
        |       	4K page of the target iframe         	|	 gate to target iframe:offset					|
        |                                                       |									|
        |       	bits 5:0 are an entry point vector	|	 47          42                                       24	|
        |       	to locations 0..63 of the target iframe |	_________________________________________________________	|
	|							|	| page high idx|        target instruction offset       |	|
	|_______________________________________________________|	|______________|________________________________________|<------+
	| 00 |       pointer to 4K-aligned page   |       vector|	| F 0 |                 iframe Start Page Index         |
	|____|21__________________________________|5___________0|	|_____|_________________________________________________|
	|							|	       21					       0
	|							|
	|		B0 = operand bits 21..6	>> 6		|		B0 = gate bits 21..0 Start Page Index
	|		Page High Index = 0			|		Page High Index = bits 47..42 of gate
	|		Iframe Name = B0			|		Iframe Name = B0 OR (iframe pages > 1) 1 << 23
	|		B64 = B0				|		B64 = B0 + Page High Index
	|		PC = B0 * 4096 + operand 5..0 offset	|		PC = B0 * 4096 + gate bits 41..24 offset
	|							|
	|							|
	|_______________________________________________________|________________________________________________________________
	|															|
        |       on internal stack overflow / underflow [sp < 26 | sp > 128] before operation guard interrupt 95 is raised	|
	|	operand is the  register or storage word at EA									|
	|_______________________________________________________________________________________________________________________|

</div>


	assembler syntax	call		target_identifier[, {x|y|a|b|fp|sp}]

				call		*target_identifier_indirectly

				call		(LOCATION/4096*64++VECTOR_0_63)

				call	(0800000++LITERALS_TAG(page_high_index*/18++offset, start_page_index:d)s)

						for large and dyamically loadable iframes see <a	href="#iframe">iframe</a> and <a href="#gate">gate</a>



				_________________________________________________________
	Instruction Code 31.7	| 1 1 1 1 1 | 1 1 1 |		<a style="color:#00FF00">  address</a>		|
				|___________|_______|___________________________________|



	<a	name="sim_d"/>
	<div	style="margin-left:28pt;font-family:times-roman;font-size:12.75pt;color:0000FF">
	<i>Appendix A: Quasi-Simultaneous Instruction-Repeat Model</i>
	</div>

	An instruction repeat model using as accumulators some or all of the 104 internal stack registers
	has been tested and rolled out for floating point processing in two emulator implementations and
	will be extended for integer processing in future emulated processor steppings

	Semicondictor implementations <i>may</i> support these operations with simultaneous execution hardware
	under <i>some</i> circumstances

	Multiple exececution is modelled as an instruction repeat paradigm

		in order to be available whether whether any parallel hardware is present or not

		and because not all source-2 operands are necessarily within the internal stack
		or even near each other in memory, which would be a minimal requirement for simultaneous operations

		The repeat execute model allows source-2 operands to be gathered from dispersed locations
		typically as structure members

	Instruction repeat model also has the effect of making the registers at the stack top available
	as a second set of accumulators

	Instruction repeat is only available in application mode and not in interrupt mode

	Instruction repeat with no simultaneous operation is interruptible between instruction repeats

	Most instructions which are otherwise executed on the accumulator registers 4..11 may be in the repeat model

	Repeated instructions shall not necessarily operate with the exact behaviour of the instructions which they mirror

	The initial rollout of four-function floating point instructions behaves as those instructions otherwise behave,
	but the working, within the repeat model, of PSR residue flag fp$r may be changed by future decision

	Initially all the instructions in the repeat repertoire are from the existing instruction set

	Although operations on large arrays mostly cannot process faster than data can be transferred in and out of the core
	an advantage is expected because

		values may reside for successive operations in many destination registers

		the array of destination registers is traversed without extra instructions to count
		or to advance indexing either of the destination registers or other source operands

	when multiple operation on smaller objects than 96-bit floating point is rolled out
	then an extra advantage is expected where the unrolled quad-word pushes which currently load
	the destination / source-1 registers shall each load two or four source-1 operands

	Each repeated instruction generates a new effective address for the source2 operand on each repeat
	if an index component of the effective address has been incremented

	The automatic index register increment may be widely spaced either forward or back so that
	structure members may be gathered as source-2 operands. This is a reason why true simultaneous
	operation would not always be possible. Parallel ALUs and FPUs per one core exist in many machines but are
	mostly not linked to multiple memory buses per core for simultaneous access to dispersed memory locations

	In the model released here unrolled quad push instructions load source-1 operands to the internal stack from source locations
	which may be dispersed, and unrolled quad pop instructions store the results to locations which also may be dispersed

	Source-1 data points are therefore concentrated on acquisition and results are distributed on storage
	Source-2 data points need never be concentrated at all

	Repeat operations traversing the register stack are unlikely to increment the destination / source-1 cursor other than by

 		1 * object size in words

	for example for floating numbers +4

<div	style="right:50pt;width:400pt;position:absolute;font-size:9pt;color:#00AF6F">
<pre>

			_________________
			|      rex	|
			|_______________|
				|
				|	interrupt mode
				|------------------------------------->	no-op
				|
			________|________
			|  read <- [EA]	|
			|  	 target	|
			|   instruction	|
			|_______________|
				|
				|	non-repeat instruction
				|------------------------------------->	no-op
				|
				|	running count 0+
				|-------------------------------------->	
				|					|
			________|________	_________________	|
			| running count	| <-----| restart count	|	|
			|_______________|	|_______________|	|
				|					|
			________|________	_________________	|
			|  dest cursor	| <-----|      sp	|	|
			|_______________|	|_______________|	|
				|					|
				|<--------------------------------------
			________|________
			| resolve target|
			| instruction EA|
			|_______________|
				|
	 --------------------->	|
	|			|
	|			|	dest register[s] < 24 OR > 127  
	|			|------------------------------------->	fault
	|			|
	|		________|________
	|		|XQT instruction|
	|		|_______________|
	|			|
	|		________|________
	|		| increment dest|
	|		|register cursor|
	|		|_______________|
	|			|
	|		________|________
	|		|increment source
	|		| index register|
	|		|_______________|
	|			|
	|		________|________
	|		|     decrement	|
	|		| running count	|
	|		|_______________|
	|			|
	|			|
	|			|	running count < 0
	|			|------------------------------------->	complete
	|			|
	|			|		_________________
	|			|		|      decrement|
	|			|------------->	|program counter|----->	complete
	|			|    	unmasked|_______________|
	|			|    	interrupt
	|			|
	|			|
	|		________|________
	 <--------------|   revise EA	|
			|_______________|

</pre>
</div>	


	The repeat execute instruction is implemented as follows


	rex			Repeat Execute
	___			______________

				_________________________________________________________
	Instruction Code 14.4	| 0 1 1 1 0 | 1 0 0 |	<a style="color:#00AF6F">   EA -> target instruction</a>	|
				|___________|_______|___________________________________|


	If PSR Interrupt Mode is set then rex instruction no-ops

	The target instruction for repeat operation is read via rex instruction effective address

	If the acquired instruction is not in the repeatable set then rex instruction no-ops

	If register 20 RDATAC is negative two initialisation steps take place

		counter restart value in register 22 WDATAC is copied to running counter RDATAC

		register 15 internal stack pointer is copied to
		destination/source-1 register cursor, register q

	Initial source-2 effective address is generated from
	the address fields of the acquired instruction

	X. The acquired instruction is executed using as accumulator[s]
	the internal stack register[s] pointed by q <a href="#watch_it" style="color:#FF0000">**</a>

	Register 21 RDATA is added to q

	If the acquired instruction uses an index register in the set [ x y a b fp sp ]
	then register 23 WDATA is added to the index register

	Running counter register 20 RDATAC is decremented
	If RDATAC becomes negative repeat operation is complete and ceases

	If an interrupt request with urgency > interrupt mask is pending

		absolute program counter is decremented
		to cause rex instruction to start again at the next repeat instance
		without initialising destination register cursor or running counter

		repeat operation concludes and the interrupt is enabled

	otherwise

	If the index register was incremented a new effective address is generated

	Execution at step X. continues

	______________________________



	rex instruction uses registers [ q RDATAC RDATA WDATAC WDATA ]
	which are also used programming bit stream read and write

	Therefore registers [ q RDATAC RDATA WDATAC WDATA ] do not remain undisturbed
	if the thread intersperses repeat execute sequences with filestream calls
	and should be reprogrammed with the SIM_CONTROL macro after the stream activity

	Register q does not usually need to be directly programmed for repeat execute sequences

	If destination cursor q designates any register outside the range 24..127	<a name="watch_it" style="color:#FF0000">**</a>
	the thread faults with interrupt GUARD$ latent parameter permission

	Macro SIM_CONTROL takes a quadword argument

		SIM_CONTROL	(-1, DEST_REGISTERS_INCREMENT, REPEATS-1, SOURCE2_OPERAND_INCREMENT:q)

	where -1 causes destination register cursor initialisation and running count restart

	DEST_REGISTERS_INCREMENT is the operand size in words unless the operation is very unusual
	or is not repeated

	dest increment zero accumulates multiple operations in one destination

 	REPEATS-1 is the running count restart value, and takes effect without reprogramming
	if no other processing changes the registers between repeat sequences

	REPEATS-1 is one less than iterations, which stop when running count RDATAC reaches -1

	SOURCE2_OPERAND_INCREMENT is the &plusmn; index register update which may be
	widely dispersed to gather structure members

	A simple use can be made of Repeat Execute to have a second set of accumulators
	on the internal stack top. This is achieved with SIM_CONTROL values

		SIM_CONTROL	(-1, 0, 0, 0q)

	which have the effect that subsequent instructions executed by rex (<i>instruction</i>)
	operate singly on the stack top without intervening reconfiguration 

	In the case operation[s] are required starting other than at the stack top,
	a macro SIM_TARGET points destination cursor q to the required register stack offset <a href="#watch_it" style="color:#FF0000">**</a>
	and suppresses automatic initialisation to the stack top
	by writing running count zero = one operation to RDATAC

		SIM_TARGET	40, sp



	<a	name="lanes"/>
	Assembly Language Examples
	__________________________

	LANES	$equ	25				. use 100 registers

		SIM_CONTROL	(-1, 4, LANES-1, 12q)	. floating dest = 4-word blocks, source-2 index increment 12 words

	?	$do	LANES,	qpush	source_table(1)+LANES*12-?*12+8	. load multiple source-1 to multiple dest
									. from last 4 words of 12-word structures
		lx	source_table(2),,xi
		rex	(fm	8, x)					. 25 multiplications
		lx	source_table(3),,xi
		rex	(fa	8, x)					. 25 additions
		lx	source_table(4),,xi
		rex	(fan	8, x)					. 25 subtractions
									. store multiple results
	?	$do	LANES,	qpop	dest_table+?*12-12+8		. to last 4 words of new 12-word structures

	. the unrolled quad pushes and pops are standard instructions not repeat instructions
	. implementation depending it should be possible to read and write memory as fast as the data bus can go
	. RTA1 internal stack is an array of registers loaded by push operations and stored by pop operations


	Assembly Language Example of Stack Top as 2nd Set of Accumulators
	_________________________________________________________________

		SIM_CONTROL	(-1, 0, 0, 0q)

		rex	(fm	left)	. compute on stack top
		fm	right		. compute in regular accumulators 4..7
		rex	(fa	a)	. add the products on the stack top



<i>

    <hr/>



    LICENCE NOTICE



    Copyright Tim Cox, 2012
    TimMilesCox@gmx.ch

    This processor programmable architecture specification
    is the principal and central work delivered here.

    It is the specification of the freeware processor architecture

                RTA1

    RTA1 is a free processor architecture specification. It is licensed
    under the GNU General Public Licence Version 3

    The executable emulation of RTA1 is free software.

    Instruction code for the target RTA1 architecture is free software
    if it is delivered with this software

    Software programs delivered with this software to connect the
    emulated RTA1 with real network interfaces in the emulator host
    are free software

    Scripts and programs delivered with this software for running
    on other computers and interacting with the RTA1 are free software

    Scripts and utility programs for constructing RTA1 target
    executable software are free software

    You can redistribute it and/or modify RTA1
    under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    RTA1 is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with RTA1.  If not, see &lt;http://www.gnu.org/licenses/&gt;.

</i>
</pre>
</div>
</html>
