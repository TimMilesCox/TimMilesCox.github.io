<html>
<div>
<center>
<h1>
	The RTA1 Processor Architecture
</h1>
<i>
Copyright Tim Cox, 2012<br>
RTA1 Architecture is freeware licensed with the GNU General Public Licence Version 3<br>
This processor programmable architecture specification is the principal and central subject of the licence<br>
The same licence encompasses all accompanying software and documentation <br>
The full licence text is included with these materials<br>
See also the licensing notice at the foot of this document
</i>
<h2>
	Programmable Architecture Specification
</h2>
</center>

<a	name="oview"/>
<div	style="margin-left:60pt">
<i>

<p>
RTA1 is a computer processor architecture which has run in emulation on Unix host computers since January 2012
<p>
Scalability is claimed for the RTA1 architecture. It can run simple dedicated
microcontroller applications in a few dozen words of storage,<br> and it can run 
as a major system maintaining some millions of TCP connections simultaneously

<p>
RTA1 is designed for symmetric multiprocessing, an important plane of scalability

<p>
RTA  I/O space is a further plane of scalability.<br>
I/O ports multicast or unicast interrupts between SMP instruction processors for true
synchronisation and exact realtime response.<br>
I/O ports organise memory space<br>
I/O ports manage energy<br>
I/O ports add system functionality flexibly

<p>
Excellent code density is claimed for RTA1. The emulated prototype runs
IP, UDP and TCP in 3750 instructions

<p>
Another 4000 instructions run Telnet, MIB-II and snmp v1, a simple HTTP 
server,<br>and a floating point server program for online interaction with
RTA1 96-bit / 192-bit floating architecture

<p>
IP in the emulated prototype is interfaced to real networks.<br>RTA1 Telnet,
SNMP, HTTP, ICMP and floating point server interact with other computers


</i>
</div>

	<a	name="index"/>
	<ol>
		<li><a href="#quoview">Overview</a></li>
		<li><a href="#spaces">Address Spaces</a></li>
		<ol>
			<li><a href="#exar">Executable Space and Array Space</a></li>
			<li><a href="#aspace">Address Space</a></li>
			<li><a href="#ospace">Operand Address Space</a></li>
			<li><a href="#ispace">Instruction Address Space</a></li>
			<li><a href="#istack">The Internal Stack</a></li>
			<li><a href="#asum">Address Space Summary and Diagram</a></li>
			<ol>
				<li><a href="#space_summary">Summary of Instruction and Operand Address Spaces</a></li>
				<li><a href="#address_array">Addressing Arrays</a></li>
				<li><a href="#large_array">Large Arrays</a></li>
				<li><a href="#ultra_array">Ultra-Large and Distributed Arrays</a></li>
				<li><a href="#multi_word">Multi-Word Write Operands straddling Banks</a></li>
			</ol>
			<li><a href="#protection">Protection and Safety</a></li>
			<ol>
				<li><a href=<"#safety">System Data Protection</a></li>
				<li><a href="#device">Device Array Protection</a></li>
			</ol>
			<li><a href="#thread">Thread Switch and Address Space</a></li>
			<li><a href="#ioport">I/O Ports for Inter-Processor Signaling / Memory and Peripheral Configuration / Timer Restart</a></li>
			<ol>
				<li><a href="#iosignal">I/O Ports for Inter-Processor Signaling</a></li>
				<li><a href="#iomem">I/O Ports for Memory and Peripheral Configuration</a></li>
				<li><a href="#iotimer">I/O Port for Timer Interval Restart</a></li>
				<li><a href="#iolist">I/O Port Assignments List</a></li>
			</ol>
			<li><a href="#iassign">Interrupt Assignments</a></li>
		</ol>
		<li><a href="#regisi">Registers and Instruction Set</a></li>
		<ol>
			<li><a href="#nonar">Non-Addressable Registers</a></li>
			<li><a href="#register">Addressable Application and Interrupt Registers</a></li>
			<li><a href="#iset">Instruction Set Summary</a> and <a href="#lookup">Lookup Panel</a></li>
			<li><a href="#ifield">Instruction Layout and Effective Address Generation</a></li>
			<ol>
				<li><a href="#layout">Instruction Layout</a></li>
				<li><a href="#ea">Effective Address Generation</a></li>
				<li><a href="#ocodes">Operand Codes and Instruction Files</a></li>
			</ol>
			<li><a href="#isymbol">Instruction Field Summary and Programming Symbols</a></li>
			<li><a href="#instru">Instructions</a></li>
			<ol>
				<li><a href="#i24s"><i>Integer Store Instructions</i></a></li>
				<li><a href="#i24l"><i>Integer Load Instructions</i></a></li>
				<li><a href="#i24t"><i>Integer Test Instructions</i></a></li>
				<li><a href="#i24x"><i>Index Register Add Instructions</i></a></li>
				<li><a href="#i24b"><i>Boolean Instructions</i></a></li>
				<li><a href="#i24a"><i>Integer Arithmetic Instructions</i></a></li>
				<li><a href="#io"><i>I/O Ports Input and Output Instructions</i></a></li>
				<li><a href="#relo"><i>Process and Thread Memory Switch Instructions</i></a></li>
				<li><a href="#onoff"><i>PSR Flags Update Instructions</i></a></li>
				<li><a href="#bstream"><i>Bit Stream Read and Write Channels</i></a></li>
				<li><a href="#lfiret"><i>Return Instructions and Internal Interrupt</i></a></li>
				<li><a href="#shijo"><i>Shift and Jump Instructions</i></a></li>
				<li><a href="#modify"><i>Target Modify Instructions</i></a></li>
				<li><a href="#scala"><i>Double and Quadword Load and Store, Masked, Execute, and Scale Operations, Large Integer Arithmetic</i></a></li>
				<li><a href="#fp"><i>96-Bit and 192-Bit Floating-Point, Floating 48-Bit Compression</i></a></li>
				<li><a href="#gocall"><i>Far Go and Call</i></a></li>
			</ol>
		</ol>
	</ol>

<a	name="quoview"/>
<h2>1. Overview</h2>

<p>
RTA1 is a 24-bit word-addressing architecture with 24- 48- and 96-bit arithmetic.<br>
For unusual requirements RTA1 can calculate 192-bit floating values

<p>
The addressable storage location is the 24-bit computer word. Instructions are one computer word in size


<a	name="spaces"/>
<h2>2. Address Spaces</h2>

<a	name="exar"/>
<h3>2.1	Executable Space and Array Space</h3>

<p>
The limit of executable space (or system memory) is 16 gigawords.

<p>
Additional arrays up to one teraword total which are not part of executable space
may be added.<br>
RTA1 documentation calls these additional arrays devices, and they may each contain up to<br>
16 gigawords of 8- 16- or 24-bit memory. Device arrays may include among other applications<br>
video RAMs, dual-ported 16-bit network buffers, and memory-addressable 24-bit filestores

<p>
The compressed layout of relocation registers allows one space of 16 gigawords<br>
to be organised in windows of 4K Words. 4K organisation is needed for executable space

<p>
64 * 16-gigaword device arrays may at the same time be organised in windows of 256K words.<br>
System memory or executable space is device array 0 and is is the only device array which<br>
may be organised in windows either of 4096 words or of 262144 words

<p>
Relocation registers are one word in size to minimise cycles at context switch and to make<br>
relocation values the width of I/O ports. Each relocation register is implemented in one I/O port
<pre>


				    executable space 16 gigawords
				    _____________________________

			 ________________________________________________
			 | 22 page select bits	        | 12 offset bits|
			 |______________________________|_______________|
			 | 16 bank select bits |          18 offset bits|
			 |_____________________|________________________|


				    array space 1 teraword
				    ______________________

		_________________________________________________________
		| device | 16 bank select bits |          18 offset bits|
		|________|_____________________|________________________|








				    relocation pointer value, 4K bank 
				    _________________________________

				    _____________________________________
				    | 00 | 22 page select bits		|
				    |____|______________________________|




				    relocation pointer value, 256K bank
				    ___________________________________

				    _____________________________________
				    | 01 | 16 bank select bits | device	|
				    |____|_____________________|________|


</pre>
Bit 22 of the relocation pointer is "big" or "big bank".
Device 0 is system memory, so system memory is placed in the address space
in ranges of 4096-word blocks or in ranges of 262144-word blocks.

<p>
Device arrays can be placed in the address space in ranges of 262144-word blocks
<pre>

	_________________________________________________________________________________
	|										|
	|			ADDRESS SPACE AND EXECUTABLE SPACE			|
	|_______________________________________________________________________________|
	|										|
	|                                                                               |
	|										|
	|	Address space is the space which the effective address can reach	|
	|       i.e. the space which code can see at one moment             		|
	|										|
	|	Different memory can be in the address space at different times		|
	|										|
	|	Executable space is all configured memory that can be used for both	|
	|	code and data								|
	|										|
	|	In RTA1 case that's the maximum 16 Gigawords of Device 0		|
	|	which is 1024 times the address space					|
	|										|
	|	RTA1 needs program memory to be						|
	|										|
	|		relocation-register-selectable in 4K-word banks			|
	|		and in 256K-word banks						|
	|										|
	|		24-bit-word writable / readable					|
	|										|
	|			optimally readable in bursts of 1 / 2 / 4 / 8 words	|
	|			at any 24-bit word address				|
	|										|
	|			optimally writable in bursts of 1 / 2 / 4 words		|
	|			at any 24-bit word address				|
	|										|
	|		able to do atomic read-modify-write on a single word		|
	|		at least when in SMP configuration				|
	|										|
	|										|
	|	Arrays outside executable space cannot be based at 4K-word granularity	|
	|	and need not necessarily read-rewrite atomically			|
	|										|
	|_______________________________________________________________________________|


</pre>

<a	name="aspace">
<h3>2.2 Address Space</h3>

<p>
RTA1 has two 16-megaword address spaces, one each for instructions and operands

<p>
There is overlap between instruction and operand spaces to allow constants to be embedded in code

<p>
Instruction address space is one memory window which may move over all the 16-gigaword executable space

<p>
The operand address space has many simultaneous fixed and moving windows on the 16 gigaword executable space and the teraword array space


<a	name="ospace"/>
<h3>2.3 Operand Address Space</h3>
<p>
Operand address space starts with the 256 registers, except for instructions
<a href="#ts">Test and Set</a> and <a href="#ex">Execute</a>
<pre>

					__________________________________
					| 0000 0000 0000 0000 | register |
					|_____________________|__________|


</pre>
Above address 256, operand address space is 16 megawords in 64 windows

<p>
From effective address 256 to 262143, address bits 17..12 select window 0..63
<pre>

					__________________________________
					|000 000| window| 12 offset bits |
					|_______|_______|________________|
					| window|         18 offset bits |
					|_______|________________________|


</pre>
<p>
From effective address 262144, address bits 23..18 select window 1..63.

They are the same windows wider open

<p>
The 6-bit window index corresponds to a relocation pointer in I/O ports 0..63
(or to certain switchable alternatives in I/O ports 65..71)

<a	name="ispace"/>
<h3>2.4 Instruction Address Space</h3>

<p>
Instructions are read in window B0. Window B0 is the physical bank at
the 4K-word bank-edge pointed by relocation register B0 in I/O Port 0

<p>
B0 is switchable between different physical instruction banks

<p>
Instructions are read from the leading edge of window B0 and not from
registers or any different address window

<p>
Window B0 is any size in 4K-granularity. The 48-bit program counter is absolute, and B0 base value<br>
is added to make jump addresses absolute and subtracted to make saved addresses program-relative

<p>
Words 256..4095 of window B0 are in the operand address space as well as the
instruction window

<a	name="istack"/>
<h3>2.5 The Internal Stack</h3>
<p>
RTA1 is intended to work very fast without having operand cache. The large array of
scratch registers is organised in an internal stack.

<p>
In the absence of operand cache, SMP configurations do not need cache coherency electronics

<p>
Software avoids double updates by recognising the scope of test-and-set locks

<p>
The internal stack has a logic footprint infinitessimally smaller than any level-one cache, 
but can produce a very large performance advantage

<p>
The part of the register stack available to an application is 128 words, and the part
of it organised in an internal stack is 104 words

<p>
At task switch RTA1 swaps 128 application registers in 32 instructions

<p>
The working of the internal stack is somewhat inverse to an external stack.

<p>
Push and pop operands have an effective address in memory space

<p>
A push is a load into CPU registers in RTA1, and a pop is a store
<pre>


				A push is a load to the CPU in RTA1
				___________________________________


							_________________________________________
	________________________________		|					|
	|		|		|		|					|
	|		|		|		|					|
	|	CPU	|	scalar	|		|	total operand space
	|		|    registers	|		|	registers + storage + immediate values
	|		|		|		|
	|		|_______________|		|
	|		|	--sp	|		|
	|		|_______________|		|
	|				|		|
	|				|		|
	|				|		|
	|	________________________|				_________________
	|new stack top	|	+	|<------<--------<--------<-----|     data	|
	|		|_______________|				|_______________|
	|		|		|		|
	|		|   internal	|		|
	|		|      stack	|






				A pop is a store from the CPU in RTA1
				_____________________________________


							_________________________________________
	________________________________		|					|
	|		|		|		|					|
	|		|		|		|					|
	|	CPU	|	scalar	|		|	total operand space
	|		|    registers	|		|	registers + storage
	|		|		|		|
	|		|_______________|		|
	|		|	sp++	|		|
	|		|_______________|		|
	|				|		|
	|				|		|
	|				|		|
	|		_ _ _ _ _ _ _ _ |				_________________
	|				|------>------>-------->------->|     data	|
	|	________|_______________|				|_______________|
	|new stack top	|		|		|
	|		|   internal	|		|
	|		|      stack	|




</pre>


<a	name="asum"/>
<h3>2.6 Address Space Summary and Diagram</h3>

<pre>

	<a	name="space_summary"/>
	Summary of Instruction and Operand Address Spaces
	_________________________________________________


	Instructions are only obtained from window B0
	and B0 switches between instruction banks

	Operands may be obtained from the registers,
	from part of the actual instruction bank in window B0,
	from the 63 actual application data banks,
	from the seven alternative data banks used by the kernel

	An application may have gigawords of storage
	in blocks from 4096 words to 16 gigawords in size

	Up to 63 blocks of 4096 words or 262144 words
	are at any time visible in 63 address windows

	Relocation Registers 1..63 are I/O ports 1..63

	Applications can change which storage banks
	are based in their 63 data address windows

	The thread current data spaces do not need to
	be saved at context switch. They are already
	mirrored in the Thread Control Block





	instruction address	|  operand address space
	space			|
	________________________|________________________				
	|0			|0			|
	|			|	registers	|
	|			|255____________________|				TCB and six kernel banks can be
	|			 256			|				switched into address windows 1..7
	|						| 
	|	  Bank 0				|				their relocation base registers are
	|						|				I/O Ports 65..71
	|			 4095___________________|________________________
	|			|4096			|4096 alternative	|	TCB B65 holds an automatic copy of
	|			|			|			|	current relocation registers B2..B63
	|			|	Bank 1		|       Bank 65		|	B65 is visible instead of B1
	|			|			|	TCB		|	if PSR Flag see$1 = 1
	|			|8191___________________|_______________________|
	|			|8192			|8192 alternative	|	kernel banks 66..71 are populated
	|			|			|			|	to the extent of kernel requirement
	|			|	Bank 2		|	Bank 66		|	with either large or small banks
	|			|	Vector List	|	Kernel Vectors	|
	|			|12287__________________|_______________________|	kernel banks are visible instead
	|			|12288 or 786432	|12K / 768K alternative	|	of application data banks B2..B7
	|			|			|			|	as PSR Flags see$2..see$7 = 1
	|			|	Bank 3		|	Bank 67
	|			|			|
	|			|16383_or_1048575_______|_______________________
	|			|16384 or 1048576	|16K / 1024K alternative|
	|			|			|			|
	|			|	Bank 4		|	Bank 68
	|			|			|
	|			|_______________________|_______________________
	|			|20K or 1280K		|20K / 1280K alternative|
	|			|			|			|
	|			|	Bank 5		|	Bank 69
	|			|			|
	|			|_______________________|_______________________
	|			|24K or 1536K		|24K / 1536K alternative|
	|			|			|			|
	|			|	Bank 6		|	Bank 70		|
	|			|			|			|
	|			|_______________________|_______________________|
	|			|28K or 1792K		|28K / 1792K alternative|
	|			|			|			|
	|			|	Bank 7		|	Bank 71		|
	|			|			|			|
	|			|_______________________|_______________________|
	|			|32K or 2048K		|
	|			|			|
	|			|	Bank 8		|
	|			|			|
	|			|_______________________|
	|			|36K or 2304K		|
	|			|			|
	|			|	Bank 9		|
	|			|			|
	|			|_______________________|
	|			|40K or 2560K		|
	|			|			|
	|			|	Bank 10		|
	|			|			|
	|			|_______________________|
	|			|44K or 2816K		|
	|			|			|



				|			|
				|			|
				|_______________________|
				|248K or 15872K		|
				|			|
				|	Bank 62		|
				|			|
				|_______________________|
				|252K or 16128K		|
				|			|
				|	Bank 63		|
				|			|
				|262143_or_16777215_____|




	<a	name="address_array"/>
	Addressing Arrays
	_________________

	Directly addressed application static data is in
	sequential address windows mapping continuous storage


	Arrays less than the address space in size can also be adressed all at once
	in one or more address windows

				_________________________
				|			|
		WINDOW n	|	.---------------|-------.
				|_______|_______________|	|
				|	|		|	|
		WINDOW n + 1	|	|		|	|
				|_______|_______________|	|<-----	array addressed
				|	|		|	|	in a range of
		WINDOW n + 2	|	|		|	|	address windows
				|_______|_______________|	|
				|	|		|	|
		WINDOW n + x	|	.---------------|-------.
				|_______________________|




	An array is one linear storage block of any size up to 16 gigawords. The prototype
	RTOS smaragd7 responds to memory requests with a single pointer


	<a	name="large_array"/>
	Large Arrays
	____________

	When an array is many times the address space in size, address windows
	are used as cursors in the array, fixing dynamically on buckets of one or
	two memory blocks or banks

	If structures in the array straddle banks, the cursor should be two or more
	adjacent physical banks based in adjacent windows

	This allows the physical address of two or four word operands to be generated
	only once and data read or written in a single burst if memory supports that


	For example

			dl		array_offset
			dsl		6		. separate the bank-id from
							. the word offset

			orB, xi		WINDOW		. tag the word offset
			rbr		6		. with an address window


		.	____________________________
		.	|WINDOW|    word offset    |	<- effective adress
		.	|______|___________________|	   start of structure
		.					   in register b


			sal		6		. position the big-bank index
			aa		array_start_bank. add to array start for bank-id

			sabr		WINDOW		. base the bank where the structure
							. starts in the address window

			la, i		64, a		. identify the next big-bank id
			sabr		WINDOW+1	. base that in the adjacent 
							. address window

							. register b is now a pointer to a
							. guaranteed 262145 words from the
							. leading edge of the structure

							. this array is any size up to
							. 16 gigawords


	<a	name="ultra_array"/>
	Ultra-Large and Distributed Arrays
	__________________________________

	Alternatively, successive blocks of a large array need not be in physically continuous storage
	so long as storage operands of two or four words are aligned

	Applications may process arrays up to 64 gigawords in size distributed over
	multiple device arrays with the help of system calls to prototype kernel smaragd7



	<a	name="multi_word"/>
	Multi-Word Write Operands straddling Banks
	__________________________________________

	Burst reads and writes of two or four words are at any word address.
	There is no bus alignment larger than a word

	Instructions writing an operand which straddles storage banks snoop the next base pointer during execution

	If the pointer selects the bank physically next then the burst write proceeds.
	The entire burst write is otherwise abandoned

	Base pointers are relocation registers addressed as I/O ports
	and select a bank either of 4096 words or 262144 words

	No precaution is taken for multiword operand read over bank edge. Burst read is done uncritically.
	If the next physical bank is not linearly successive application data then the trailing readout is wrong.

	An array greater than a storage block must either have 2- and 4-word operands aligned
	or must be in physically continuous storage

	Alignment of 2- and 4-word write operands has an advantage in efficiency
	because the next-base-pointer-snoop is never necessary. It is rarely necessary to snoop the next base,
	but an unaligned address necessitates an extra check for bank-end and the consequent snoop


</pre>


<a	name="protection"/>
<h3>2.7 Protection and Safety</h3>
<pre>

	<a	name="safety"/>
	System Data Protection
	______________________


	Storage appears so far as possible only in the address space of routines designated to access it

	Some storage is read-only for applications

	prevented are

	all reads and writes in unassigned address space windows

	all reads and writes above the highest assigned address in a window
	i.e accesses at window+4096+
	where the assigned memory block is 4096 words and not 262144 words

	writes from applications to

		interrupt registers

		the instruction window B0

		the application vector window B2

		the thread control block B65

		the kernel vector window B66

		kernel data windows B67..B71

	are stopped with guard interrupt
	interrupt code constructs these spaces

	address space windows communicating between kernel and applications
	are only in application address space during kernel routines



	<a	name="device"/>
	Device Array Protection
	_______________________


	Banks in devices outside system memory can only be based by interrupt code

	This is to prevent accidental damage to anything like a static RAM file system.
	An inadvertant attempt to base a device from an application raises the guard interrupt

	Applications may call ISRs to place device banks in their address space and
	subsequently read and write each based bank without restriction.
	See Section 2.10: <a href="#iassign">Interrupt Assignments</a>

	The initial reason for allowing only ISRs to base device banks is to avoid accident

	ISRs which base device banks on user request may also include a credential check

</pre>

<a	name="thread"/>
<h3>2.8 Thread Switch and Address Space</h3>

Task current relocation pointers are not saved on task switch because they are
already mirrored in the TCB at the point when the application selects memory

<p>
Typically &frac34; of relocation registers are part of task context, OS depending

<p>
47 relocation registers are reloaded in 25 instructions


<a	name="ioport"/>
<h3>2.9 I/O Ports for Inter-Processor Signalling / Memory and Peripheral Configuration / Timer Restart</h3>

<a	name="iosignal"/>
<h4>2.9.1: I/O Ports for Inter-Processor Signalling</h4>

<p>
I/O ports are written to multicast or unicast interrupts between Instruction Processors
in order to obtain true synchronisation and exact realtime response. The bit positions
in the output value drive interrupt lines to individual cores

<p>
Interrupts driven via I/O ports include

	<blockquote>

	preemptive switch unicast<br><br>

	attention request unicast/multicast<br><br>

	dayclock update multicast advertisement

	</blockquote>

<p>

<a	name="iomem"/>
<h4>2.9.2: I/O Ports for Memory and Peripheral Configuration</h4>


I/O ports function as relocation registers and also read out memory configuration values
<p>
The emulated machine detects from Port 124 <b>ram$threshold</b> on system start how large its ROM is,
whether the ROM contains a system or just a boot page, and where RAM starts.

<p>
In the emulated machine, the boot ROM size is exactly the containing number of 4096-word blocks
where the emulator has loaded a complete system ROM image. RAM starts at the next page after that.

<p>
The emulated machine goes on to detect the size of system memory from Port 128 <b>device$flags</b>.
Devices like network interfaces and local file systems are detected by reading I/O ports 129 onwards.
These values are primed by the emulator to help the emulated machine to run.
Hardware implementations must wire the real memory and device information to I/O Ports 124, 128+ upwards

<a	name="iotimer"/>
<h4>2.9.3: I/O Port for Timer Interval Restart</h4>

A write to I/O Port 96 restarts the timer interrupt interval

<p>
One core is designated to interrupt at high-frequency incrementer overflow
and to restart the incrementer by writing Port 96

<a	name="iolist"/>
<h4>2.9.4: I/O Port Assignments</h4>
<pre>

	0		instruction window relocation
	1:63		data memory relocation windows
	65		thread control block relocation
	66:71		kernel data relocation windows
	96		high-frequency timer incrementer restart write
	97		dayclock update advertisement multicast
	98		preemptive thread switch unicast
	99		resource attention unicast/multicast
	124		ROM/RAM threshold
	128		system memory bank high index
	129:191		devices 1:63 attributes / array size

</pre>

<a	name="iassign"/>
<h3>2.10: Interrupt Assignments</h3>

<p>
The first 4K-word bank of storage or PAGE_0 contains the restart location and is
otherwise reserved for any future restart and image load firmware

<p>
The second 4K-word bank of storage or PAGE_1 populates certain of its 63 vector
locations PAGE_1:0 thru PAGE_1:63 with external and internal interrupt vectors

<p>
These interrupt vectors are assigned to external events. They are classed as external because I/O
activity or processor contingency raises them
<pre>


				Encoding of Interrupt Vector
				_________________________________

				_________________________________
	GUARD$		1:31	| 000000 000000 000001 | 011111	|	internal stack limit overstep
				|______________________|________|	device bank base attempt from application
									storage access outside address space
									software diagnostic

				_________________________________
	ATTENTION$	1:60	| 000000 000000 000001 | 111100 |	resource service request unicast/multicast
				|______________________|________|

				_________________________________
	ALERT$		1:61	| 000000 000000 000001 | 111101	|	preemptive thread switch unicast
				|______________________|________|

				_________________________________
	TIME$POINT	1:62	| 000000 000000 000001 | 111110 |	dayclock multicast
				|______________________|________|

				_________________________________
	TIMER$		1:63	| 000000 000000 000001 | 111111	|	high-frequency incrementer overflow
				|______________________|________|

</pre>

Prototype kernel smaragd7 assigns these vectors in PAGE_1 to kernel calls reached with the
Internal Interrupt instruction

<pre>


				Encoding of Interrupt Vector and
				Operand Value of ii Instruction
				_________________________________
				
				_________________________________
	YIELD$		1:1	| 000000 000000 000001 | 000001 |	switch context in response to
				|______________________|________|	preemptive or voluntary event

				_________________________________
	SPAWN$		1:2	| 000000 000000 000001 | 000010 |	start a process
				|______________________|________|

				_________________________________
	BANK$		1:3	| 000000 000000 000001 | 000011 |	obtain storage up to 16777215 words
				|______________________|________|

				_________________________________
	ARRAY$		1:4	| 000000 000000 000001 | 000100 |	obtain storage 16777216+ words
				|______________________|________|

				_________________________________
	BANK$FREE	1:5	| 000000 000000 000001 | 000101 |	return storage to kernel
				|______________________|________|

				_________________________________
	EXIT$		1:6	| 000000 000000 000001 | 000110 |	end process or thread
				|______________________|________|

				_________________________________
	THREAD$		1:7	| 000000 000000 000001 | 000111 |	start a thread
				|______________________|________|


				_________________________________
	HANDLE$		1:16	| 000000 000000 000001 | 010000 |	obtain a handle
				|______________________|________|

				_________________________________
	FREE_HANDLE$	1:17	| 000000 000000 000001 | 010001 |	free a handle for re-use
				|______________________|________|

				_________________________________
	READ_HANDLE$	1:18	| 000000 000000 000001 | 010010 |	retrieve handle encoding
				|______________________|________|

				_________________________________
	READ_XVECTOR$	1:19	| 000000 000000 000001 | 010011 |	retrieve a bank pointer
				|______________________|________|	from kernel vector bank

				_________________________________
	WRITE_XVECTOR$	1:20	| 000000 000000 000001 | 010100 |	write a bank pointer in
				|______________________|________|	kernel vector bank

				_________________________________
	READ_SOCKET$	1:21	| 000000 000000 000001 | 010101 |	retrieve network socket 
				|______________________|________|	information

				_________________________________
	UHANDLE$	1:22	| 000000 000000 000001 | 010110 |	map port informatiom
				|______________________|________|	into address space

				_________________________________
	KERNEL$B1	1:23	| 000000 000000 000001 | 010111 |	switch to kernel B1 frame[&nu;]
				|______________________|________|

				_________________________________
	B1$		1:24	| 000000 000000 000001 | 011000 |	switch to application
				|______________________|________|	current B1 frame

				_________________________________
	KERNEL$B1_1	1:25	| 000000 000000 000001 | 011001 |	switch to kernel
				|______________________|________|	primary B1 frame

				_________________________________
	DAYCLOCK$W	1:26	| 000000 000000 000001 | 011010 |	write an initial time from
				|______________________|________|	application to dayclock

				_________________________________
	TWAIT$		1:27	| 000000 000000 000001 | 011011 |	wait dayclock quanta
				|______________________|________|

				_________________________________
	EVENT_WAIT$	1:28	| 000000 000000 000001 | 011100 |	wait for event
				|______________________|________|

				_________________________________
	EVENT_FREE$	1:29	| 000000 000000 000001 | 011101 |	clear event wait status
				|______________________|________|	of target thread


				_________________________________
	XBASE$(32)	1:32	| 000000 000000 000001 | 100000 | 
		.		|______________________|________|	base a device bank 
		.							in window 32..43
		.		_________________________________
	XBASE$(43)	1:43	| 000000 000000 000001 | 101011 |
				|______________________|________|	

</pre>

<a	name="regisi"/>
<h2>3. Registers and Instruction Set</h2>

<a	name="nonar"/>
<h3>3.1 Non-Addressable Registers</h3>

<p>
Two registers are not addressable. The program counter which contains an absolute address 48 bits in size, and the Processor State Register, which contains settings and the carry bit

<p>
The program counter is never stored as its absolute 48-bit value. Its value relative to the start of Bank 0
is saved on interrupts and calls. On interrupts and far (inter-bank) calls Bank 0 identity is also saved

<p>
The Processor State Register is saved on interrupts

<p>
The layout of the Processor State Register is
<pre>
		23             18   16     14           8   7   6   5   4   3       0
		_______________________________________________________________________
		| I | 0 0 0 0 | i i i | 0 | see$          | H | R | R | W | F 0 0 | C |
		|   |         |       |   | 1 2 3 4 5 6 7 |   | Z |16 |16 | P     |   |
		|___|_________|_______|___|_______________|___|___|___|___|_R_____|___|

</pre>
The PSR flags shown as 0 are not currently used
<p>
PSR flags 15..0 are directly application programmable with instructions <b>on</b> and <b>off</b>

<p>
Flag 23 <b>I</b> is on during an interrupt. CPU-side registers, that is those which receive computation results
or are stack pointers, index registers, the target of load instructions or the source of store instructions, automatic
counter or mask register, are in interrupt mode in the range 128..255. The application registers are 0..127

<p>
Registers addressed as storage operands are absolute locations in a 256-word array
regardless of ISR / application mode. However applications cannot write the interrupt registers

<p>
Flags 18..16 <b>iii</b> are the interrupt mask. Both applications and ISRs can swap and restore the
interrupt mask with the <b>Switch Interrupt Mask</b> instruction <b>sim</b>

<p>
Flags 14..8 <b>see$1..see$7</b> individually make the TCB and kernel banks visible in address windows 1..7,
instead of application data banks B1..B7

<p>
Flag 7 <b>half$w</b> concerns instructions which can take a byte operand as an alternative to a word operand.
RTA1 is not a byte addressing machine, and any byte other than a 24-bit byte is a field of a storage location.

The 32 instructions in Instruction File 1 may take a storage word or part of a storage word as operand.
These bytes are either halfwords (12 bits) with sign extension on read
<pre>

		 23			 11		       0
		_________________________________________________
		|	    h1		|	  h2		|
		|_______________________|_______________________|

</pre>
<p>
or else they are thirdwords (8 bits) with sign extension on read
<pre>

		 23		 15		 7	       0
		_________________________________________________
		|	t1	|	t2	|	t3	|
		|_______________|_______________|_______________|

</pre>		
<p>

But it is very undesirable that the File 1 Instructions should all have five different encodings
for accessing bytes. There are three byte-select encodings available in those instructions,
and flag <b>half$w</b> = 1 = halfword access, otherwise the application may access thirdwords

<p>
Flags 6 5 and 4 adjust the <b>Bit Stream Read Channel</b> and <b>Bit Stream Write Channel</b>

<p>
Flag 6 <b>b$streamZR</b> affects the operation of the <b>Read Staging Register</b> instruction <b>rsr</b>,
which makes a stream of bits or bytes serially available to the arithmetic registers

<p>
<b>b$streamZR</b> states that bits from the staging register <b>RDATA</b> shall be shifted into a cleared arithmetic register,
saving an extra instruction to mask the desired field. Otherwise the previous arithmetic register contents are shifted towards
the high order bit positions as new bits are transferred from <b>RDATA</b>

<p>
Flag 5 <b>b$stream16r</b> also affects the operation of <b>Read Staging Register</b>.
Only 16 bits are delivered from each input data word if <b>b$stream16r</b> = 1.
The high-order bits 23..16 are discarded when <b>b$stream16r</b> = 1.
This allows efficient handling with network data and with 16-bit peripherals.
If <b>b$stream16r</b> = 0 successive <b>rsr</b> instructions deliver all the 24 bits read from storage.

<p>
Flag 4 <b>b$stream16w</b> affects the operation of <b>Write Staging Register</b> instruction <b>wsr</b>
which writes a stream of bits or bytes from the arithmetic registers. Bits shifted into Staging Register
<b>WDATA</b> are stored at 16 bits per data word when <b>b$stream16w</b> = 1.
This allows efficient handling with network data and with 16-bit peripherals.
If <b>b$stream16w</b> = 0 successive <b>wsr</b> instructions compose 24 bits for each storage write.

<p>
Flag 3 <b>fp$r</b> is used for teaming pairs of floating numbers to calculate 192-bit values.
When <b>fp$r</b> is asserted floating instructions store a minor result in registers
8..11. If the entire result is contained in the major result in registers a:b:mantissa2:mantiss3 then
the minor result is zero. The minor result is used in further floating operations on pairs of 96-bit
floating numbers for 192-bit values

<p>
Flag 0 <b>carry$</b> is set or cleared by this subset of the fixed point instructions
<pre>

	<b>aa</b></a>	Add to Register <b>a</b>
	<b>ab</b>	Add to Register <b>b</b>
	<b>ana</b>	Add Negative to Register <b>a</b>
	<b>anb</b>	Add Negative to Register <b>b</b>
	<b>da</b>	Double Length Add to <b>a:b</b>
	<b>dan</b>	Double Length Add Negative to <b>a:b</b>
	<b>src</b>	circular Shift Right through Carry
	<b>slc</b>	circular Shift Left through Carry
	<b>popA</b>	Pop and AddTo

</pre>

<p>
The instructions which add the twos complement of the operand, <b>ana</b> <b>anb</b> <b>dan</b>,
have the same result in <b>carry$</b> as positive adds which have that twos complement as input operand.
Carry is set if addition at the register high order bit position carries, in all these instructions

<p>
There are no PSR condition bits other than <b>carry$</b>. All other conditions are available in the register
containing the instruction result. Many different results can be examined long after they are generated


<p>
The conditional jump instructions which examine carry or a register or storage word are
<pre>
	<b>jc</b>	Jump Carry
	<b>jnc</b>	Jump No Carry
	<b>jza</b>	Jump Zero <b>a</b>
	<b>jzb</b>	Jump Zero <b>b</b>
        <b>jnza</b>	Jump NonZero <b>a</b>
        <b>jnzb</b> 	ump NonZero <b>b</b>
	<b>jpa</b>	Jump Positive <b>a</b>
	<b>jpb</b>	Jump Positive <b>b</b>
	<b>jna</b>	Jump Negative <b>a</b>
	<b>jnb</b>	Jump Negative <b>b</b>
	<b>jpo</b>	Jump Parity <b>a<a style="color:FFFFFF;background-color:000000">**</a>k</b> Odd
	<b>jao</b>	Jump <b>a</b> Odd
	<b>jdz</b>	Jump <b>a:b</b> Double Zero
	<b>mta</b>	Masked Test <b>a</b> skip equal
	<b>tz</b>	Test Zero location skip
	<b>tp</b>	Test Positive location skip
	<b>ts</b>	Test and Set location skip
	<b>jxge</b>	Jump <b>x</b> not less than <b>r</b>
	<b>jyge</b>	Jump <b>y</b> not less than <b>r</b>
	<b>jdr</b>	Jump Decrement Repeat Count
</pre>

<a	name="register"/>
<h3>3.2 Addressable Application and Interrupt Registers</h3>

<p>
RTA1 registers occur twice. The application has 128 registers and interrupts have 128 registers

<p>
All 256 registers are in the operand address space as one linear array

<p>
Some registers are implicitly addressed as the register operand of an instruction.
These register-side operands are compartmented by application / interrupt context

<p>
The interrupt register set is a replica of the application register set, and has the same arithmetic registers,
index registers and special-purpose registers, with some minor differences

<p>
Having one set of interrupt registers does not mean that interrupts are not nested.
It means that certain much-used ISRs which are never nested in execution have a set of registers which can be used without saving.
Other ISRs wich may run nested must save registers before they change them.
Interrupts also have an internal stack made from 104 of their 128 registers.

<p>
An important category of interrupts which are never nested is application-callable kernel routines
which are implemented as internal interrupts. These have a set of registers for immediate free use,
and they only need to touch the application registers in order to read parameters and write results

<p>
It is advisable to implement a kernel routine as an internal interrupt instead of a call if the routine
temporarily manipulates the address space via the PSR flags. On return from interrupt the the saved PSR
is reloaded and all flags are restored


<pre>



		Layout of the Register Stack
		____________________________

		Notes
		_____

		Only registers 0..127 switch with the task

		The internal stack addressed with sp is only large enough for scalars and pointers
		Frame Pointer register fp is intended to be an external stack pointer for structures and arrays

		The application internal stack pointer is guarded from overflow (decrement
		below 24) and underflow (increment above 128). At sp = 128 the internal
		stack is completely empty. At sp = 24 the internal stack is completely full
		Stack range violation raises the guard interrupt at vector 1:31

		DAYCLOCK$U:DAYCLOCK$ are a millisecond counter in the interrupt register list
		All tasks read the dayclock register pair atomically with 48-bit-operand instructions

		Interrupt TIMER$ is sprung for example from a nanosecond incrementer
		and one designated core updates the 48-bit millisecond dayclock and
		writes it to kernel storage

		The designated core writes I/O port DAYCLOCK$UPDATE$ to multicast
		interrupt TIME$POINT to the other cores. They update the dayclock
		value in their own registers

				dl	dayclock$	. read kernel storage
				ds	DAYCLOCK$U	. write registers
				ir	0		. return from TIME$POINT ISR

		The incrementer can be programmed for doubled, octupled or other power-2
		higher frequency than a millisecond, making the dayclock quantum a fraction
		of a millisecond and timer interrupt more frequent

		A negative number of beats is output to a high-frequency incrementer via
		I/O port OVERFLOWER$. TIMER$ interrupts when when the incrementer carries

		The processor executing ISR TIMER$ reprograms OVERFLOWER$

		The emulated machine retrieves millisecond time periodically from the emulator host

		PRIORITY$ is a copy of the running thread's priority stored by software for
		rapid retrieval at task switch, and for instant evaluation of SMP inter-processor
		preemptive interrupt broadcasts

		REALTIME$_CLOCK is a decrementing timer count which switches the running
		thread on expiry. If the initial REALTIME$_CLOCK value assigned to the thread
		is zero, neither decrement nor switch interrupt takes place




			The Application Registers						  The Interrupt Registers
			_________________________						  _______________________


		 23			       0					 23			       0
		_________________________________					_________________________________
	0	|		r		|  repeat count + limit pointer	128	|		r_x		|
		|_______________________________|					|_______________________________|
	1	|		k		|	mask register		129	|		k_x		|
		|_______________________________|					|_______________________________|
	2	|		x		|	index register		130	|		x_x		|
		|_______________________________|					|_______________________________|
	3	|		y		|	index register		131	|		y_x		|
		|_______________________________|					|_______________________________|
	4	|		a		|  arithmetic + index register	132	|		a_x		|
		|_______________________________|					|_______________________________|
	5	|		b		|  arithmetic + index register	133	|		b_x		|
		|_______________________________|					|_______________________________|
	6	|	mantissa2		|	arithmetic register	134	|	mantissa2_x		|
		|_______________________________|					|_______________________________|
	7	|	mantissa3		|	arithmetic register	135	|	mantissa3_x		|
		|_______________________________|					|_______________________________|
	8	|		aA		|	arithmetic register	136	|		aA_x		|
		|_______________________________|					|_______________________________|
	9	|		bA		|	arithmetic register	137	|		bA_x		|
		|_______________________________|					|_______________________________|
	10	|	mantissa2A		|	arithmetic register	138	|	mantissa2A_x		|
		|_______________________________|					|_______________________________|
	11	|	mantissa3A		|	arithmetic register	139	|	mantissa3A_x		|
		|_______________________________|					|_______________________________|
	12	|	    	 p		|	bitstream pointer write	140	|		p_x		|
		|_______________________________|					|_______________________________|
	13	|	   	 q		|	bitstream pointer read	141	|		q_x		|
		|_______________________________|					|_______________________________|
	14	|	  	 fp		|	index register		142	|		fp_x		|
		|_______________________________|					|_______________________________|
	15	|	  	 sp		|	index register		143	|		sp_x		|
		|_______________________________|					|_______________________________|
	16	|				|	scratch			144	|				|
		|_______________________________|					|_______________________________|
	17	|				|	scratch			145	|				|
		|_______________________________|					|_______________________________|
	18	|				|	scratch			146	|				|
		|_______________________________|					|_______________________________|
	19	|				|     < scratch	| rounding >	147	|	fp$guard		|
		|_______________________________|					|_______________________________|
	20	|	   RDATAC		|	bitstream counter read	148	|	REALTIME$_CLOCK		|
		|_______________________________|					|_______________________________|
	21	|	    RDATA		|	bitstream data read	149	|	PRIORITY$		|
		|_______________________________|					|_______________________________|
	22	|	   WDATAC		|	bitstream counter write	150	|	DAYCLOCK$U		|
		|_______________________________|					|_______________________________|
	23	|	    WDATA		|	bitstream data write	151	|	DAYCLOCK$		|
		|_______________________________|					|_______________________________|
	24	| maximum internal stack top	|				152	|				|
		|_______________________________|					|_______________________________|
	25	|				|				153	|				|
		|_______________________________|					|_______________________________|
	26	|				|				154	|				|
		|_______________________________|					|_______________________________|
	27	|				|				155	|				|
		|_______________________________|					|_______________________________|
	28	|				|				156	|				|
		|_______________________________|					|_______________________________|
	29	|				|				157	|				|








	118									246
		|_______________________________|					|_______________________________|
	119	|				|				247	|				|
		|_______________________________|					|_______________________________|
	120	|				|				248	|				|
		|_______________________________|					|_______________________________|
	121	|				|				249	|				|
		|_______________________________|					|_______________________________|
	122	|				|				250	|				|
		|_______________________________|					|_______________________________|
	123	|				|				251	|				|
		|_______________________________|					|_______________________________|
	124	|				|				252	|				|
		|_______________________________|					|_______________________________|
	125	|				|				253	|				|
		|_______________________________|					|_______________________________|
	126	|				|				254	|				|
		|_______________________________|					|_______________________________|
	127	|				|	first pushed word	255	|				|
		|_______________________________|					|_______________________________|




	bit stream channel control registers in the user register set

	        RDATAC
		RDATA
        	WDATAC
		WDATA

        are not duplicated in the interrupt register set as other registers are

        their equivalent positions 148..151 are taken by clock and timer registers

		REALTIME$_CLOCK
		PRIORITY$
		DAYCLOCK$U
		DAYCLOCK$

        Few ISRs are expected to program bit streams. An ISR which programs RDATAC RDATA 
	or WDATAC WDATA must first save them. Instructions rsr wsr in interrupt mode use
	application RDATAC RDATA WDATAC WDATA at absolute addresses 20..23

	storage read pointer q used by rsr instruction is replicated in application and
	interrupt register sets. rsr instruction in interrupt mode uses q_x. ISRs may
	otherwise use q_x as a general purpose pointer

	storage write pointer p used by wsr instruction is replicated in application and
	and interrupt register sets. wsr instruction in interrupt mode uses p_x. ISRs may
	otherwise use p_x as a general purpose pointer


</pre>



<a	name="iset"/>
<h3>3.3 Instruction Set Summary and <a href="#lookup">Lookup Panel</a></h3>

<p>
RTA1 instructions are grouped in 5 columns called instruction files.
The five instruction files map to eight operand characteristics.

<p>
Instruction File 1 spans six of the eight operand types. Instruction File 1 is integer operations
with single word operand. The 24-bit operand may be read from a word, a half or third word,
the immediate value of the effective address, or a sign-extended immediate value

<p>
Instruction Files 4A and 5A are a small number of special instructions which only need an effective address immediate or a sign-extended immediate.

<p>
Instruction File 6 contains shifts and jumps which use the effective address as an immediate operand.

<p>
Instruction File 7 contains arithmetic instructions which have an operand of one, two or four words

<pre>


	<a	name="lookup"/>
	Instructions Lookup Panel		Instruction File 4a			Instruction File 5A
	_________________________		___________________			___________________

						<a href="#ina">inA</a>	In Port to A			<a href="#on">on</a>	PSR Flags On
						<a href="#inb">inB</a>	In Port to B			<a href="#off">off</a>	PSR Flags Off

						<a href="#outa">outA</a>	Out A to Port			<a href="#rsr">rsr</a>	Read Staging Register
						<a href="#outb">outB</a>	Out B to Port			<a href="#wsr">wsr</a>	Write Staging Register

						<a href="#reload">reload</a>	switch application memory


						<a href="#sabr">sabr</a>	Store a to Base Register	<a href="#lret">lret</a>	local return
											<a href="#fret">fret</a>	far return

											<a href="#ii">ii</a>	Internal Interrupt
						<a href="#jdz">jdz</a>	Jump Double Zero		<a href="#ir">ir</a>	Interrupt Return



	Instruction File 1			Instruction File 6			Instruction File 7
	__________________			__________________			__________________


	<a href="#sr">sr</a>	Store Repeat Count		<a href="#sar">sar</a>	Shift a Right			<a href="#ts">ts</a>	Test and Set
	<a href="#sk">sk</a>	Store Mask Register		<a href="#sbr">sbr</a>	Shift b Right			<a href="#n">n</a>	Negate

	<a href="#sx">sx</a>	Store Index Pointer x		<a href="#dsr">dsr</a>	Double Shift Right		<a href="#inc">inc</a>	Increment
	<a href="#sy">sy</a>	Store Index Pointer y		<a href="#jdr">jdr</a>	Jump Decrement Repeat Count	<a href="#dec">dec</a>	Decrement

	<a href="#sa">sa</a>	Store Accumulator a		<a href="#sbl">sbl</a>	Shift a Left			<a href="#sim">sim</a>	Switch Interrupt Mask
	<a href="#sb">sb</a>	Store Accumulator b		<a href="#sbl">sbl</a>	Shift b Left			<a href="#popa">popA</a>	Pop and AddTo

	<a href="#z">z</a>	Store Zero			<a href="#dsl">dsl</a>	Double Shift Left		<a href="#src">src</a>	Shift Circular Right through Carry
	<a href="#pop">pop</a>	Pop				<a href="#lcal">lcal</a>	Local Call			<a href="#slc">slc</a>	Shift Circular Left through Carry

	<a href="#lr">lr</a>	Load Repeat Count		<a href="#rar">rar</a>	Rotate a Right			<a href="#qs">qs</a>	Quadruple Store
	<a href="#lk">lk</a>	Load Mask Register		<a href="#rbr">rbr</a>	Rotate b Right			<a href="#ql">ql</a>	Quadruple Load

	<a href="#lx">lx</a>	Load Index Pointer x		<a href="#drr">drr</a>	Double Rotate Right		<a href="#fpp">fpp</a>	Floating Pop and Pack
	<a href="#ly">ly</a>	Load Index Pointer y		<a href="#jnc">jnc</a>	Jump No Carry			<a href="#fpx">fpx</a>	Floating Push and Expand

	<a href="#la">la</a>	Load Accumulator a		<a href="#ral">ral</a>	Rotate a Left			<a href="#fa">fa</a>	Floating Add
	<a href="#lb">lb</a>	Load Accumulator b		<a href="#rbl">rbl</a>	Rotate b Left			<a href="#fan">fan</a>	Floating Add Negative

	<a href="#tz">tz</a>	Test Zero			<a href="#drl">drl</a>	Double Rotate Left		<a href="#fm">fm</a>	Floating Multiply
	<a href="#tp">tp</a>	Test Positive			<a href="#jc">jc</a>	Jump on Carry			<a href="#fd">fd</a>	Floating Divide

	<a href="#ax">ax</a>	Add to Index Pointer x		<a href="#saa">saa</a>	Shift a Algebraic		<a href="#qpop">qpop</a>	Quadruple Pop
	<a href="#ay">ay</a>	Add to Index Pointer y		<a href="#sba">sba</a>	Shift b Algebraic		<a href="#qpush">qpush</a>	Quadruple Push

	<a href="#or">or</a>	OR Accumulator a		<a href="#dsa">dsa</a>	Double Shift Algebraic		<a href="#ex">ex</a>	Execute
	<a href="#orb">orB</a>	OR Accumulator b		<a href="#jao">jao</a>	Jump a Odd			<a href="#dpush">dpush</a>	Double Push

	<a href="#and">and</a>	AND Accumulator a		<a href="#jpa">jpa</a>	Jump Positive a			<a href="#lsc">lsc</a>	Load Shift and Count
	<a href="#andb">andB</a>	AND Accumulator b		<a href="#jpb">jpb</a>	Jump Positive b			<a href="#mta">mta</a>	Masked Test a

	<a href="#xor">xor</a>	XOR Accumulator a		<a href="#j">j</a>	Jump				<a href="#sc">sc</a>	Store Carry
	<a href="#xorb">xorB</a>	XOR Accumulator b		<a href="#jpo">jpo</a>	Jump Parity Odd			<a href="#mlb">mlb</a>	Masked Load b

	<a href="#aa">aa</a>	Add To Accumulator a		<a href="#jza">jza</a>	Jump Zero a			<a href="#ds">ds</a>	Double Store
	<a href="#ab">ab</a>	Add To Accumulator b		<a href="#jzb">jzb</a>	Jump Zero b			<a href="#dl">dl</a>	Double Load

	<a href="#ana">ana</a>	Add Negative To Accumulator a	<a href="#jnza">jnza</a>	Jump NonZero a			<a href="#da">da</a>	Double Add
	<a href="#anb">anb</a>	Add Negative To Accumulator b	<a href="#jnzb">jnzb</a>	Jump NonZero b			<a href="#dan">dan</a>	Double Add Negative

	<a href="#m">m</a>	Multiply			<a href="#jna">jna</a>	Jump Negative a			<a href="#dlsc">dlsc</a>	Double Load Shift and Count
	<a href="#mf">mf</a>	Multiply Fractional		<a href="#jnb">jnb</a>	Jump Negative b

	<a href="#d">d</a>	Divide				<a href="#jxge">jxge</a>	Jump x Not Less Than r		<a href="#go">go</a>	Far Bank Jump
	<a href="#push">push</a>	Push				<a href="#jyge">jyge</a>	Jump y Not Less Than r		<a href="#call">call</a>	Far Bank Call




</pre>

<a	name="ifield"/>
<h3>3.4 Instruction Layout, Effective Address Generation and Operand Codes</h3>
<a	name="layout"/>
<h4>3.4.1 Instruction Layout</h4>

<p>
The operand code is marked J and determines the operand type
and which instruction file the instruction F is from

<p>
The instruction stem code is marked F and determines an instruction within the instruction file

<p>
Instructions in File 1 derive a single 24-bit operand from a register, a storage word or byte, the effective address as immediate operand, or a sign-extended-immediate

<p>
Instructions in File 4A take the effective address as immediate operand

<p>
Instructions in File 5A take a sign-extended immediate operand

<p>
Instructions in File 6 take the effective address as immediate operand

<p>
Instructions in File 7 take a one-word two-word or four-word operand in registers or storage

<pre>


                                 23         18   15                            0
                                _________________________________________________
                                |     F    | J  |            address            |       instruction word
                                |__________|____|_______________________________|       ________________



</pre>
<a	name="ea"/>
<h4>3.4.2 Effective Address Generation</h4>
<pre>



			effective address generation
			____________________________


			If the operand code J is other than 5, an effective address is
			generated according to fields I X U of the address as shown here




                                 23         18     14    11                    0
                                _________________________________________________
                                |     F    | J  |I|  X  |           U           |       instruction word
                                |__________|____|_|_____|_______________________|       ________________
						|
						|15




			if I = 0 the effective address is 15 bits X U

			if I = 1

				if X = 0
					the effective address is indirect and found in in the storage word at 0 + U

					if U < 256 the indirect 24-bit address is the value in a register 
					otherwise the 24-bit indirect address is the value in a storage word
					in Bank 0 locations 256..4095


				if X = 1
					the effective address is indirect and found in the storage word at 
					4096 + U which is in Bank 1 (Bank 65 if see$1 is on)





				Base + Displacement Addressing I=1 and X = [2|3|4|5|6|7]
				________________________________________________________


				 23					       0
				_________________________________________________
				|		index value 24 bits		|	index register [x|y|a|b|fp|sp]
				|_______________________________________________|	______________________________
							|			|
							|    + displacement	|
							|    12 bits unsigned	|
				 23         18     14	 11	               0
	  			_________________________________________________
				|     F    | J  |I|  X  |	    U		|	instruction word
				|__________|____|_|_____|_______________________|	________________
						|
						|15			


				if X = 2
					the effective address is the sum of
					index register x plus the 12 unsigned bits U


				if X = 3
					the effective address is the sum of
					index register y plus the 12 unsigned bits U


				if X = 4
					the effective address is the sum of
					arithmetic register a plus the 12 unsigned bits U


				if X = 5
					the effective address is the sum of
					arithmetic register b plus the 12 unsigned bits U


				if X = 6
					the effective address is the sum of
					frame pointer register fp plus the 12 unsigned bits U


				if X = 7
					the effective address is the sum of
					stack pointer register sp plus the 12 unsigned bits U



</pre>
<a	name="ocodes"/>
<h4>3.4.3 Operand Codes and Instruction Files</h4>
<pre>



			The meanings of operand code J
			______________________________


			000	The instruction is in Instruction File 1			mnemonic w0
				and the storage operand is the computer word
				at the effective address I X U					assembler syntax example
												________________________

												la		this_word
												sx		that_word, y, w0
												push		a_word

												ly		*indirectly

												________________________

												operand W0 = word is the default
												the mnemonic W0 need not be typed
												________________________


				 23					       0
				_________________________________________________
				|						|	register
				|_______________________________________________|	________
				|						|

				|						|

				|						|

				|_______________________________________________|
				|		       w0			|	storage
				|_______________________________________________|	_______
				 23					       0




 





			operand codes J 001..011 when PSR Flag half$w = 0
			_________________________________________________

			Partial words are only written and read in system memory

			Bytes are sign extended to a 24-bit word on load, including
			push to the internal stack from a byte of system memory

			Byte writes to storage are from the low-order bits of the
			source register, including byte writes to system memory
			from the register at the internal stack top----------------->		pop[,t1|t2|t3]	target

			Only 24-bit words are read from registers addressed as storage
			Only 24-bit words are written to registers addressed as storage

 


			001	The instruction is in Instruction File 1			mnemonic t1
				and the storage operand is bits 23..16 of
				the word at effective address I X U				assembler syntax example
												________________________

				load and store are to bits 7..0 of the CPU			lb, t1		structure, fp		
				register with sign extension on load				pop		outside,,t1

				bits 15..0 of the memory word are unchanged on store





				 23					       0
				_________________________________________________
				|<------- sign extension on read:		|	register
				|_______________________________________________|	________
								|		|
								|		
				<------------------------------->		|
				|						
										|
				|		<------------------------------->
						|		
				|_______________|_______________________________
				|	t1	|		|		|	storage
				|_______________|_______________|_______________|	_______
				 23	      16










			010	The instruction is in Instruction File 1			mnemonic t2
				and the storage operand is bits 15..8 of
				the word at effective address I X U				assembler syntax example
												________________________

				load and store are to bits 7..0 of the CPU			andB, t2	record, y		
				register with sign extension on load				tp		reaction, fp, t2
												sr, t2		latent_parameter
				bits 23..16, 7..0 of the memory word
				are unchanged on store



 



 


				 23					       0
				_________________________________________________
				|<------- sign extension on read:		|	register
				|_______________________________________________|	________
								|		|
								|		
						<--------------->		|
						|				
										|
						|		<--------------->
								|		
				________________|_______________|_______________
				|		|	t2	|		|	storage
				|_______________|_______________|_______________|	_______
						 15	       8








			011	The instruction is in Instruction File 1			mnemonic t3
				and the storage operand is bits 7..0 of
				the word at effective address I X U				assembler syntax example
												________________________

				load and store are to bits 7..0 of the CPU			d, t3		divisor_array, x
				register with sign extension on load				push		everyone,,t3

				bits 23..8 are unchanged on store

				PARTIAL WORDS MAY ONLY BE READ FROM SYSTEM			xor, t3		keyvalue
				MEMORY AND WRITTEN TO SYSTEM MEMORY

				REGISTERS ARE 24-BIT WORD SCALARS
				OR MULTI-WORD-SCALARS






				 23					       0
				_________________________________________________
				|<------- sign extension on read:		|	register
				|_______________________________________________|	________
								|		|
										
								|		|
										
								|		|
												
				|_______________________________|_______________|
				|		|		|	t3	|	storage
				|_______________|_______________|_______________|	_______
								 7	       0








			operand codes J 010..011 when PSR Flag half$w = 1
			_________________________________________________

                        Partial words are only written and read in system memory

                        Bytes are sign extended to a 24-bit word on load, including
                        push to the internal stack from a byte of system memory

                        Byte writes to storage are from the low-order bits of the
                        source register, including byte writes to system memory
                        from the register at the internal stack top----------------->		pop[,h1|h2]	 target

                        Only 24-bit words are read from registers addressed as storage
                        Only 24-bit words are written to registers addressed as storage




			010	The instruction is in Instruction File 1			mnemonic h1
				and the storage operand is bits 23..12 of
				the word at effective address I X U				assembler syntax example
												________________________

				load and store are to bits 11..0 of the CPU			lb, h1		katakana_table, a
				register with sign extension on load				z		restart_counter,,h1

				bits 11..0 of the memory word are unchanged on store



 


				 23					       0
				_________________________________________________
				|<------- sign extension:			|	register
				|_______________________________________________|	________
							|			|
							|			
				<----------------------->			|
				|						
										|
				|			<----------------------->
							|		
				|_______________________|_______________________
				|	    h1		|			|	storage
				|_______________________|_______________________|	_______
				 23		      12




 







			011	The instruction is in Instruction File 1			mnemonic h2
				and the storage operand is bits 11..0 of
				the word at effective address I X U				assembler syntax example
												________________________

				load and store are to bits 11..0 of the CPU			tz, h2		restart_counter
				register with sign extension on load				pop		along, b, h2

				bits 23..12 of the memory word are unchanged on store





				 23					       0
				_________________________________________________
				|<------- sign extension:			|	register
				|_______________________________________________|	________
							|			|
										
							|			|
										
							|			|		
				________________________|_______________________|
				|			|	   h2		|	storage
				|_______________________|_______________________|	_______
							 11		       0








			Operand Codes J 100..111
			________________________

			100	The instruction is in Instruction File 1			mnemomic i
				and the immediate operand is the effective
				address with or without indirection or indexing			assembler syntax example
												________________________

												lr, i		4, x

												lx, i		frame_size, sp
												aa, i		63



				instructions in Instruction File 4A also have J			sabr		BASE_REGISTER_33
				code 100 and the effective address as operand			inB		PORT_131A






			101	The instruction is in Instruction File 1			mnemonic xi
				and the sign extended immediate operand
				is I X U = bits 15..0 of the instruction word			assembler syntax example
												________________________

												ax, xi		-FRAME_SIZE

												ly, xi		$literal("ISBN %s ":;
															 "Title %s ":;
															 "Author %s\n")

												push, xi	-12500



				 23					       0
			 	_________________________________________________
				|+sign extension+				|	register
				|_______________________________________________|	_______
						|				|
										
						|				|
										
										
						|				|
				________________|_______________________________|
				| ffff f  | 101	|	   immediate		|	instruction
				|_________|_____|_______________________________|	___________
						 15			       0






				instructions in Instruction File 5A also have J			rsr		BYTE_SIZE
				code 101 and the sign extended address fields I X U		on		see$6++see$7
				as operand
												lret		+1



			110	The instruction is in Instruction File 6 and the		assembler syntax example
				operand is the effective address after any			________________________
				indirection or indexing
												drl		BYTE_SIZE
												dsr		15, x
												j		*somewhere
												jc		not_less
												sal		*PAGE_SIZE_LOG
												lcal		0, a



			111	The instruction is in Instruction File 7 and the		assembler syntax example
				operand is one or two or four words at the			________________________
				effective address I X U

												fm	$literals_B3(1.633*-1200009)

												qpush		segment:sequence
												

												dlsc		mantissa
												ds		normalised

												popA		byte_count, x



</pre>

<a	name="isymbol"/>
<h3>3.5 Instruction Field Summary and Programming Symbols</h3>

All instructions at present have one operand field and most may have subfields

<p>
The first subfield is the operand address or value, the second a possible index register, the third an operand type, for example
<pre>

	andB	table, x, h1

</pre>
<p>
The third subfield, operand type [w0 | h1 | h2 | t1 | t2 | t3 | i | xi] is only for the single-integer instructions
in Instruction File 1 and has the default w0. A File 1 instruction may alternatively mark the operand type
on the instruction field
<pre>

	ly, i	buffer+10
	aa,t2	matrix, b

</pre>
<p>
An instruction may have operand indirection marked with unary * but then may not also have indexing
<pre>

	j	*pointer
	lx	*pointer2,,t1

</pre>

<p>
Operand type sign-extended-immediate <b>xi</b> may be designated on File 1 instructions and is automatic on File 5A instructions.
<b>xi</b> operand precludes both indirection and indexing
<pre>

	ax	-12,,xi
	lret	1

</pre>

Designation <b>i</b> immediate is the effective address used as an immediate operand and may have indirection or indexing.
<b>i</b> operand may be designated for a File 1 instruction and is automatic for File 4A (I/O) and File 6 (jump and shift) instructions
<pre>

	ab	1,a,i		. add one more than the value in a to b
	inB	*port_table_pointer
	ral	*page_size_log
	j	along

</pre>
<p>
The large arithmetic instructions in Instruction File 7 have storage operands one, two or four words in size,
and may use indirection or indexing to address them
<pre>

	ql	running_total
	fa	parameter, sp
	
</pre>

<a	name="instru"/>
<h3>3.6 Instructions</h3>

See <a href="#iset">Lookup Panel</a> to find an instruction by name

<pre>

	<a      name="i24s"/>
	<div    style="margin-left:28pt;font-family:times-roman;font-size:12.75pt;color:0000FF">
	<i>3.6.1	Integer Store Instructions</i>
	</div>
	instructions	<a href="#sr">sr</a>	<a href="#sk">sk</a>
			<a href="#sx">sx</a>	<a href="#sy">sy</a>
			<a href="#sa">sa</a>	<a href="#sb">sb</a>
			<a href="#z">z</a>	<a href="#pop">pop</a>


	Integer store instructions write a word, or a third or halfword


	An operand mode J mnemonic may be typed either after the instruction mnemonic
	or after the index position:

                sa, t1          record_control_word, y

	Integer store instructions write thirdwords when PSR Flag <b>half$w</b> = 0
	and halfwords when PSR Flag <b>half$w</b> = 1:

		pop		sense_record,,h2


	See also	<a href="#ds">ds</a>	<a href="#qs">qs</a>	<a href="#qpop">qpop</a>









	<a	name="sr"/>
	Store Repeat Count	sr
	__________________	__

				_________________________________________________________
				|							|
				|	repeat count and limit pointer register r	|
				|	is stored					|
				|_______________________________________________________|
				|	destination is memory/register at EA		|
				|	memory target may be a word, half or thirdword	|
				|_______________________________________________________|



	assembler syntax	sr[, {w0|h1|h2}]		target[, {x|y|a|b|fp|sp}] 	

				sr[, {w0|t1|t2|t3}]		target[, {x|y|a|b|fp|sp}]

				sr[, {w0|h1|h2}]		*ptarget	

				sr[, {w0|t1|t2|t3}]		*ptarget

				sr				target[, {x|y|a|b|fp|sp}][, {w0|h1|h2}] 	

				sr				target[, {x|y|a|b|fp|sp}][, {w0|t1|t2|t3}]

				sr				*ptarget[,, {w0|h1|h2}] 	

				sr				*ptarget[,, {w0|t1|t2|t3}]


	assembler examples	sr		target
				sr, h2		target
				sr		target,b,t1
				sr		*ptarget,,h1

				_________________________________________________________
	Instruction Code 0	| 0 0 0 0 0 | 0 . . | . . . .  . . . . . . . . . . . .  |
				|___________|_______|___________________________________|
				




	<a	name="sk"/>
	Store Mask Register	sk
	___________________	__

				_________________________________________________________
				|							|
				|	mask register k is stored			|
				|_______________________________________________________|
				|	destination is memory/register at EA		|
				|	memory target may be a word, half or thirdword	|
				|_______________________________________________________|



	assembler syntax	sk[, {w0|h1|h2}]		target[, {x|y|a|b|fp|sp}] 	

				sk[, {w0|t1|t2|t3}]		target[, {x|y|a|b|fp|sp}]

				sk[, {w0|h1|h2}]		*ptarget	

				sk[, {w0|t1|t2|t3}]		*ptarget

				sk				target[, {x|y|a|b|fp|sp}][, {w0|h1|h2}] 	

				sk				target[, {x|y|a|b|fp|sp}][, {w0|t1|t2|t3}]

				sk				*ptarget[,, {w0|h1|h2}] 	

				sk				*ptarget[,, {w0|t1|t2|t3}]


	assembler examples	sk		target
				sk, h2		target, x
				sk		target,,t1
				sk		*ptarget,,h1

				_________________________________________________________
	Instruction Code 1	| 0 0 0 0 1 | 0 . . | . . . .  . . . . . . . . . . . .  |
				|___________|_______|___________________________________|
				




	<a	name="sx"/>
	Store Index Register x	sx
	______________________	__


				_________________________________________________________
				|							|
				|	index register x is stored			|
				|_______________________________________________________|
				|	destination is memory/register at EA		|
				|	memory target may be a word, half or thirdword	|
				|_______________________________________________________|


	assembler syntax	sx[, {w0|h1|h2}]		target[, {x|y|a|b|fp|sp}] 	

				sx[, {w0|t1|t2|t3}]		target[, {x|y|a|b|fp|sp}]

				sx[, {w0|h1|h2}]		*ptarget	

				sx[, {w0|t1|t2|t3}]		*ptarget

				sx				target[, {x|y|a|b|fp|sp}][, {w0|h1|h2}] 	

				sx				target[, {x|y|a|b|fp|sp}][, {w0|t1|t2|t3}]

				sx				*ptarget[,, {w0|h1|h2}] 	

				sx				*ptarget[,, {w0|t1|t2|t3}]


	assembler examples	sx		target, a
				sx, h2		target
				sx		target,,t1
				sx		*ptarget,,h1

				_________________________________________________________
	Instruction Code 2	| 0 0 0 1 0 | 0 . . | . . . .  . . . . . . . . . . . .  |
				|___________|_______|___________________________________|
				


	<a	name="sy"/>
	Store Index Register y	sy
	______________________	__

				_________________________________________________________
				|							|
				|	index register y is stored			|
				|_______________________________________________________|
				|	destination is memory/register at EA		|
				|	memory target may be a word, half or thirdword	|
				|_______________________________________________________|


	assembler syntax	sy[, {w0|h1|h2}]		target[, {x|y|a|b|fp|sp}] 	

				sy[, {w0|t1|t2|t3}]		target[, {x|y|a|b|fp|sp}]

				sy[, {w0|h1|h2}]		*ptarget	

				sy[, {w0|t1|t2|t3}]		*ptarget

				sy				target[, {x|y|a|b|fp|sp}][, {w0|h1|h2}] 	

				sy				target[, {x|y|a|b|fp|sp}][, {w0|t1|t2|t3}]

				sy				*ptarget[,, {w0|h1|h2}] 	

				sy				*ptarget[,, {w0|t1|t2|t3}]


	assembler examples	sy		target
				sy, h2		target
				sy		target,b,t1
				sy		*ptarget,,h1

				_________________________________________________________
	Instruction Code 3	| 0 0 0 1 1 | 0 . . | . . . .  . . . . . . . . . . . .  |
				|___________|_______|___________________________________|
				


	<a	name="sa"/>
	Store Arithmetic Register a	sa
	___________________________	__


				_________________________________________________________
				|							|
				|	arithmetic register a is stored			|
				|_______________________________________________________|
				|	destination is memory/register at EA		|
				|	memory target may be a word, half or thirdword	|
				|_______________________________________________________|



	assembler syntax	sa[, {w0|h1|h2}]		target[, {x|y|a|b|fp|sp}] 	

				sa[, {w0|t1|t2|t3}]		target[, {x|y|a|b|fp|sp}]

				sa[, {w0|h1|h2}]		*ptarget	

				sa[, {w0|t1|t2|t3}]		*ptarget

				sa				target[, {x|y|a|b|fp|sp}][, {w0|h1|h2}] 	

				sa				target[, {x|y|a|b|fp|sp}][, {w0|t1|t2|t3}]

				sa				*ptarget[,, {w0|h1|h2}] 	

				sa				*ptarget[,, {w0|t1|t2|t3}]


	assembler examples	sa		target, x
				sa		*(31*/18++OFFSET)
				sa, h2		target
				sa		target,,t1
				sa		*ptarget,,h1

				_________________________________________________________
	Instruction Code 4	| 0 0 1 0 0 | 0 . . | . . . .  . . . . . . . . . . . .  |
				|___________|_______|___________________________________|
				


	<a	name="sb"/>
	Store Arithmetic Register b	sb
	___________________________	__


				_________________________________________________________
				|							|
				|	arithmetic register b is stored			|
				|_______________________________________________________|
				|	destination is memory/register at EA		|
				|	memory target may be a word, half or thirdword	|
				|_______________________________________________________|


	assembler syntax	sb[, {w0|h1|h2}]		target[, {x|y|a|b|fp|sp}] 	

				sb[, {w0|t1|t2|t3}]		target[, {x|y|a|b|fp|sp}]

				sb[, {w0|h1|h2}]		*ptarget	

				sb[, {w0|t1|t2|t3}]		*ptarget

				sb				target[, {x|y|a|b|fp|sp}][, {w0|h1|h2}] 	

				sb				target[, {x|y|a|b|fp|sp}][, {w0|t1|t2|t3}]

				sb				*ptarget[,, {w0|h1|h2}] 	

				sb				*ptarget[,, {w0|t1|t2|t3}]


	assembler examples	sb		target
				sb, h2		target
				sb		target,y,t1
				sb		*ptarget,,h1

				_________________________________________________________
	Instruction Code 5	| 0 0 1 0 1 | 0 . . | . . . .  . . . . . . . . . . . .  |
				|___________|_______|___________________________________|
				



	<a	name="z"/>
	Store Zero		z
	__________		_


				_________________________________________________________
				|							|
				|	value zero is written at the operand address	|
				|_______________________________________________________|
				|	destination is memory/register at EA		|
				|	memory target may be a word, half or thirdword	|
				|_______________________________________________________|


	assembler syntax	z[, {w0|h1|h2}]			target[, {x|y|a|b|fp|sp}] 	

				z[, {w0|t1|t2|t3}]		target[, {x|y|a|b|fp|sp}]

				z[, {w0|h1|h2}]			*ptarget	

				z[, {w0|t1|t2|t3}]		*ptarget

				z				target[, {x|y|a|b|fp|sp}][, {w0|h1|h2}] 	

				z				target[, {x|y|a|b|fp|sp}][, {w0|t1|t2|t3}]

				z				*ptarget[,, {w0|h1|h2}] 	

				z				*ptarget[,, {w0|t1|t2|t3}]


	assembler examples	z		target, fp
				z, h2		target
				z		target,,t1
				z		*ptarget,,h1

				_________________________________________________________
	Instruction Code 6	| 0 0 1 1 0 | 0 . . | . . . .  . . . . . . . . . . . .  |
				|___________|_______|___________________________________|
				



	<a	name="pop"/>
	pop			pop
	___			___

				_________________________________________________________
				|							|
				|	the data word at the internal stack top is 	| 
				|	stored the operand address			|
				|	internal stack pointer sp is incremented	|
				|_______________________________________________________|
                                |       on internal stack overflow / underflow		|
                                |       [sp < 24 | sp > 127] before operation           |
                                |       guard interrupt 95 is raised                    |
				|_______________________________________________________|
				|	destination is memory/register at EA		|
				|	memory target may be a word, half or thirdword	|
				|_______________________________________________________|


	assembler syntax	pop[, {w0|h1|h2}]		target[, {x|y|a|b|fp|sp}] 	

				pop[, {w0|t1|t2|t3}]		target[, {x|y|a|b|fp|sp}]

				pop[, {w0|h1|h2}]		*ptarget

				pop[, {w0|t1|t2|t3}]		*ptarget

				pop				target[, {x|y|a|b|fp|sp}][, {w0|h1|h2}] 	

				pop				target[, {x|y|a|b|fp|sp}][, {w0|t1|t2|t3}]

				pop				*ptarget[,, {w0|h1|h2}] 	

				pop				*ptarget[,, {w0|t1|t2|t3}]


	assembler examples	pop		target
				pop, h2		target
				pop		target,b,t1
				pop		*ptarget,,h1

				_________________________________________________________
	Instruction Code 7	| 0 0 1 1 1 | 0 . . | . . . .  . . . . . . . . . . . .  |
				|___________|_______|___________________________________|
				




        <a      name="i24l"/>
        <div    style="margin-left:28pt;font-family:times-roman;font-size:12.75pt;color:0000FF">
        <i>3.6.2	Integer Load Instructions</i>
        </div>
	instructions	<a href="#lr">lr</a>		<a href="#lk">lk</a>
			<a href="#lx">lx</a>		<a href="#ly">ly</a>
			<a href="#la">la</a>		<a href="#lb">lb</a>
			<a href="#push">push</a>


        Integer load instructions read a one-word operand, a third or halfword,
        the effective address itself as an immediate operand, or a sign-extended immediate operand.


        An operand mode J mnemonic may be typed either after the instruction mnemonic
        or after the index position:

                ly, i           4, b

                lx              4, b, i

                push            -640,,xi

                la, t1          record_control_word, y

        Integer load instructions can read thirdwords when PSR Flag <b>half$w</b> = 0
        and halfwords when PSR Flag <b>half$w</b> = 1:

		lk		masks, y, h1



	See also	<a href="#dl">dl</a>	<a href="#dpush">dpush</a>

			<a href="#ql">ql</a>	<a href="#qpush">qpush</a>






	<a	name="lr"/>
	Load Repeat Count	lr
	_________________	__


				_________________________________________________________
				|							|
				|	repeat count and limit pointer register r 	|
				|	is loaded					|
				|_______________________________________________________|
				|	source is memory/register value at EA		|
				|	or the value EA or a signed immediate		|
				|	memory source may be a word, half or thirdword	|
				|_______________________________________________________|




	assembler syntax	lr[, {w0|h1|h2|i}]		target[, {x|y|a|b|fp|sp}] 	

				lr[, {w0|t1|t2|t3|i}]		target[, {x|y|a|b|fp|sp}]

				lr[, {w0|h1|h2|i}]		*ptarget

				lr[, {w0|t1|t2|t3|i}]		*ptarget

				lr, i				VALUE[, {x|y|a|b|fp|sp}]

				lr, xi				VALUE

				lr				target[, {x|y|a|b|fp|sp}][, {w0|h1|h2|i}] 	

				lr				target[, {x|y|a|b|fp|sp}][, {w0|t1|t2|t3|i}]

				lr				*ptarget[,, {w0|h1|h2|i}] 	

				lr				*ptarget[,, {w0|t1|t2|t3|i}]

				lr				VALUE[, {x|y|a|b|fp|sp}], i

				lr				VALUE,, xi


	assembler examples	lr			target, sp
				lr			(5000000)
				lr, h2			target
				lr			target,,t1
				lr			*ptarget,,h1

				lr, xi			-48000/2
				lr			12, y, i
				lr, i			apointer
				lr, i			*apointer	[ = lr	apointer ]

				_________________________________________________________
	Instruction Code 8	| 0 1 0 0 0 | . . . | . . . .  . . . . . . . . . . . .  |
				|___________|_______|___________________________________|
				





	<a	name="lk"/>
	Load Mask Register	lk
	__________________	__


				_________________________________________________________
				|							|
				|	mask register k is loaded	 		|
				|_______________________________________________________|
				|	operand is memory/register value at EA		|
				|	or the value EA or a signed immediate		|
				|	memory source may be a word, half or thirdword	|
				|_______________________________________________________|




	assembler syntax	lk[, {w0|h1|h2|i}]		mask[, {x|y|a|b|fp|sp}] 	

				lk[, {w0|t1|t2|t3|i}]		mask[, {x|y|a|b|fp|sp}]

				lk[, {w0|h1|h2|i}]		*pmask

				lk[, {w0|t1|t2|t3|i}]		*pmask

				lk, i				MASK[, {x|y|a|b|fp|sp}]

				lk, xi				MASK

				lk				mask[, {x|y|a|b|fp|sp}][, {w0|h1|h2|i}] 	

				lk				mask[, {x|y|a|b|fp|sp}][, {w0|t1|t2|t3|i}]

				lk				*pmask[,, {w0|h1|h2|i}] 	

				lk				*pmask[,, {w0|t1|t2|t3|i}]

				lk				MASK[, {x|y|a|b|fp|sp}], i

				lk				MASK,, xi


	assembler examples	lk			mask
				lk			(0FC0000:s)
				lk, h2			mask, y
				lk			mask,,t1
				lk			*ptarget,,h1

				lk, xi			-48000/2
				lk			12, y, i
				lk, i			apointer
				lk, i			*apointer	[ = lk	apointer ]

				_________________________________________________________
	Instruction Code 9	| 0 1 0 0 1 | . . . | . . . .  . . . . . . . . . . . .  |
				|___________|_______|___________________________________|
				





	<a	name="lx"/>
	Load Index Register x	lx
	_____________________	__


				_________________________________________________________
				|							|
				|	index register x is loaded	 		|
				|_______________________________________________________|
				|	operand is memory/register value at EA		|
				|	or the value EA or a signed immediate		|
				|	memory source may be a word, half or thirdword	|
				|_______________________________________________________|



	assembler syntax	lx[, {w0|h1|h2|i}]		target[, {x|y|a|b|fp|sp}] 	

				lx[, {w0|t1|t2|t3|i}]		target[, {x|y|a|b|fp|sp}]

				lx[, {w0|h1|h2|i}]		*ptarget

				lx[, {w0|t1|t2|t3|i}]		*ptarget

				lx, i				VALUE[, {x|y|a|b|fp|sp}]

				lx, xi				VALUE

				lx				target[, {x|y|a|b|fp|sp}][, {w0|h1|h2|i}] 	

				lx				target[, {x|y|a|b|fp|sp}][, {w0|t1|t2|t3|i}]

				lx				*ptarget[,, {w0|h1|h2|i}] 	

				lx				*ptarget[,, {w0|t1|t2|t3|i}]

				lx				VALUE[, {x|y|a|b|fp|sp}], i

				lx				VALUE,, xi


	assembler examples	lx			target, b
				lx			(47*/18++240:s)
				lx, h2			target
				lx			target,,t1
				lx			*ptarget,,h1

				lx, xi			-48000/2
				lx			12, y, i
				lx, i			apointer
				lx, i			*apointer	[ = lx	apointer ]

				_________________________________________________________
	Instruction Code 10	| 0 1 0 1 0 | . . . | . . . .  . . . . . . . . . . . .  |
				|___________|_______|___________________________________|
				





	<a	name="ly"/>
	Load Index Register y	ly
	_____________________	__


				_________________________________________________________
				|							|
				|	index register y is loaded			|
				|_______________________________________________________|
				|	operand is memory/register value at EA		|
				|	or the value EA or a signed immediate		|
				|	memory source may be a word, half or thirdword	|
				|_______________________________________________________|



	assembler syntax	ly[, {w0|h1|h2|i}]		target[, {x|y|a|b|fp|sp}] 	

				ly[, {w0|t1|t2|t3|i}]		target[, {x|y|a|b|fp|sp}]

				ly[, {w0|h1|h2|i}]		*ptarget

				ly[, {w0|t1|t2|t3|i}]		*ptarget

				ly, i				VALUE[, {x|y|a|b|fp|sp}]

				ly, xi				VALUE

				ly				target[, {x|y|a|b|fp|sp}][, {w0|h1|h2|i}] 	

				ly				target[, {x|y|a|b|fp|sp}][, {w0|t1|t2|t3|i}]

				ly				*ptarget[,, {w0|h1|h2|i}] 	

				ly				*ptarget[,, {w0|t1|t2|t3|i}]

				ly				VALUE[, {x|y|a|b|fp|sp}], i

				ly				VALUE,, xi


	assembler examples	ly			target
				ly			*(HIGH_ORDER_ADDRESS:s)
				ly, h2			target, a
				ly			target,,t1
				ly			*ptarget

				ly, xi			-48000/2
				ly			12, y, i
				ly, i			apointer
				ly, i			*apointer	[ = ly	apointer ]

				_________________________________________________________
	Instruction Code 11	| 0 1 0 1 1 | . . . | . . . .  . . . . . . . . . . . .  |
				|___________|_______|___________________________________|
				





	<a	name="la"/>
	Load Arithmetic Register a	la
	__________________________	___


				_________________________________________________________
				|							|
				|	arithmetic register a is loaded			|
				|_______________________________________________________|
				|	operand is memory/register value at EA		|
				|	or the value EA or a signed immediate		|
				|	memory source may be a word, half or thirdword	|
				|_______________________________________________________|





	assembler syntax	la[, {w0|h1|h2|i}]		target[, {x|y|a|b|fp|sp}] 	

				la[, {w0|t1|t2|t3|i}]		target[, {x|y|a|b|fp|sp}]

				la[, {w0|h1|h2|i}]		*ptarget

				la[, {w0|t1|t2|t3|i}]		*ptarget

				la, i				VALUE[, {x|y|a|b|fp|sp}]

				la, xi				VALUE

				la				target[, {x|y|a|b|fp|sp}][, {w0|h1|h2|i}] 	

				la				target[, {x|y|a|b|fp|sp}][, {w0|t1|t2|t3|i}]

				la				*ptarget[,, {w0|h1|h2|i}] 	

				la				*ptarget[,, {w0|t1|t2|t3|i}]

				la				VALUE[, {x|y|a|b|fp|sp}], i

				la				VALUE,, xi


	assembler examples	la			target, sp
				la, h2			target
				la			target,,t1
				la			*ptarget,,h1

				la, xi			-48000/2
				la			12, y, i
				la, i			apointer
				la, i			*apointer	[ = la	apointer ]

				_________________________________________________________
	Instruction Code 12	| 0 1 1 0 0 | . . . | . . . .  . . . . . . . . . . . .  |
				|___________|_______|___________________________________|
				





	<a	name="lb"/>
	Load Arithmetic Register b	lb
	__________________________	___


				_________________________________________________________
				|							|
				|	arithmetic register b is loaded			|
				|_______________________________________________________|
				|	operand is memory/register value at EA		|
				|	or the value EA or a signed immediate		|
				|	memory source may be a word, half or thirdword	|
				|_______________________________________________________|



	assembler syntax	lb[, {w0|h1|h2|i}]		target[, {x|y|a|b|fp|sp}] 	

				lb[, {w0|t1|t2|t3|i}]		target[, {x|y|a|b|fp|sp}]

				lb[, {w0|h1|h2|i}]		*ptarget

				lb[, {w0|t1|t2|t3|i}]		*ptarget

				lb, i				VALUE[, {x|y|a|b|fp|sp}]

				lb, xi				VALUE

				lb				target[, {x|y|a|b|fp|sp}][, {w0|h1|h2|i}] 	

				lb				target[, {x|y|a|b|fp|sp}][, {w0|t1|t2|t3|i}]

				lb				*ptarget[,, {w0|h1|h2|i}] 	

				lb				*ptarget[,, {w0|t1|t2|t3|i}]

				lb				VALUE[, {x|y|a|b|fp|sp}], i

				lb				VALUE,, xi


	assembler examples	lb			target, a
				lb, h2			target
				lb			target,,t1
				lb			*ptarget,,h1

				lb, xi			-48000/2
				lb			12, y, i
				lb, i			apointer
				lb, i			*apointer	[ = lb	apointer ]

				_________________________________________________________
	Instruction Code 13	| 0 1 1 0 1 | . . . | . . . .  . . . . . . . . . . . .  |
				|___________|_______|___________________________________|
				




	<a	name="push"/>
	push			push
	____			____

				_________________________________________________________
				|							|
				|	internal stack pointer sp is decremented	| 
				|	operand is copied to the new internal stack top	|
				|_______________________________________________________|
                                |       on internal stack overflow / underflow		|
                                |       [sp < 25 | sp > 128] before operation           |
                                |       guard interrupt 95 is raised                    |
				|_______________________________________________________|
				|	operand is memory/register value at EA		|
				|	or the value EA or a signed immediate		|
				|	memory source may be a word, half or thirdword	|
				|_______________________________________________________|


	assembler syntax	push[, {w0|h1|h2|i}]		target[, {x|y|a|b|fp|sp}] 	

				push[, {w0|t1|t2|t3|i}]		target[, {x|y|a|b|fp|sp}]

				push[, {w0|h1|h2|i}]		*ptarget

				push[, {w0|t1|t2|t3|i}]		*ptarget

				push, i				VALUE[, {x|y|a|b|fp|sp}]

				push, xi			VALUE

				push				target[, {x|y|a|b|fp|sp}][, {w0|h1|h2|i}] 	

				push				target[, {x|y|a|b|fp|sp}][, {w0|t1|t2|t3|i}]

				push				*ptarget[,, {w0|h1|h2|i}] 	

				push				*ptarget[,, {w0|t1|t2|t3|i}]

				push				VALUE[, {x|y|a|b|fp|sp}], i

				push				VALUE,, xi


	assembler examples	push			target
				push			(45*262144+OFFSET:s)
				push			(45*/18++OFFSET:s)
				push, h2		target
				push			target,,t1
				push			*ptarget,,h1

				push, xi		-48000/2
				push			12, y, i
				push, i			apointer
				push, i			*apointer	[ = 	push	apointer ]

				_________________________________________________________
	Instruction Code 31	| 1 1 1 1 1 | . . . | . . . .  . . . . . . . . . . . .  |
				|___________|_______|___________________________________|
				





        <a      name="i24t"/>
        <div    style="margin-left:28pt;font-family:times-roman;font-size:12.75pt;color:0000FF">
        <i>3.6.3        Integer Test Instructions</i>
        </div>
	instructions	<a href="#tz">Test Zero</a>		<a href="#tp">Test Positive</a>


        Integer test instructions sample a word, or a third or halfword


        An operand mode J mnemonic may be typed either after the instruction mnemonic
        or after the index position:

                tz, t1		record_control_word, y

        Integer test instructions sample thirdwords when PSR Flag <b>half$w</b> = 0
        and halfwords when PSR Flag <b>half$w</b> = 1:

                tp		sense_record,,h2








	<a	name="tz"/>
	Test Zero		tz
	_________		__


				_________________________________________________________
				|							|
				|	next instruction is skipped if operand is zero 	|
				|_______________________________________________________|
				|	operand is memory/register value at EA		|
				|	memory target may be a word, half or thirdword	|
				|_______________________________________________________|


	assembler syntax	tz[, {w0|h1|h2}]		target[, {x|y|a|b|fp|sp|}] 	

				tz[, {w0|t1|t2|t3}]		target[, {x|y|a|b|fp|sp}]

				tz[, {w0|h1|h2}]		*ptarget	

				tz[, {w0|t1|t2|t3}]		*ptarget

				tz				target[, {x|y|a|b|fp|sp|}][, {w0|h1|h2}] 	

				tz				target[, {x|y|a|b|fp|sp}][, {w0|t1|t2|t3}]

				tz				*ptarget[,, {w0|h1|h2}] 	

				tz				*ptarget[,, {w0|t1|t2|t3}]


	assembler examples	tz		target
				tz, h2		target, fp
				tz		target,,t1
				tz		*ptarget,,h1

				_________________________________________________________
	Instruction Code 14	| 0 1 1 1 0 | 0 . . | . . . .  . . . . . . . . . . . .  |
				|___________|_______|___________________________________|
				



	<a	name="tp"/>
	Test Positive		tp
	_____________		__

				_________________________________________________________
				|							|
				|	next instruction is skipped if operand bit 23	|
				|	is zero						|
				|	half and thirdwords have sign extension		|
				|_______________________________________________________|
				|	operand is memory/register value at EA		|
				|	memory target may be a word, half or thirdword	|
				|_______________________________________________________|



	assembler syntax	tp[, {w0|h1|h2}]		target[, {x|y|a|b|fp|sp|}] 	

				tp[, {w0|t1|t2|t3}]		target[, {x|y|a|b|fp|sp}]

				tp[, {w0|h1|h2}]		*ptarget	

				tp[, {w0|t1|t2|t3}]		*ptarget

				tp				target[, {x|y|a|b|fp|sp|}][, {w0|h1|h2}] 	

				tp				target[, {x|y|a|b|fp|sp}][, {w0|t1|t2|t3}]

				tp				*ptarget[,, {w0|h1|h2}] 	

				tp				*ptarget[,, {w0|t1|t2|t3}]


	assembler examples	tp		target, y
				tp		*(HIGH_ADDRESS:s)
				tp, h2		target
				tp		target,,t1
				tp		*ptarget

				_________________________________________________________
	Instruction Code 15	| 0 1 1 1 1 | 0 . . | . . . .  . . . . . . . . . . . .  |
				|___________|_______|___________________________________|
				




        <a      name="i24x"/>
        <div    style="margin-left:28pt;font-family:times-roman;font-size:12.75pt;color:0000FF">
        <i>3.6.4        Index Register Add Instructions</i>
        </div>
	instructions	<a href="#ax">ax</a>	<a href="#ay">ay</a>


        Index register add instructions read a one-word operand, a third or halfword,
        the effective address itself as an immediate operand, or a sign-extended immediate operand.


        An operand mode J mnemonic may be typed either after the instruction mnemonic
        or after the index position:

                ay, i           4, b

                ax              4, b, i

                ax		-640,,xi

                ay, t1          record_control_word, y

        Index register add instructions can read thirdwords when PSR Flag <b>half$w</b> = 0
        and halfwords when PSR Flag <b>half$w</b> = 1:

                ax              displacements, y, h1










	<a	name="ax"/>
	Add to Index Register x	ax
	_______________________	__


				_________________________________________________________
				|							|
				|	operand is added to index register x		|
				|	carry$ is not affected				|
				|_______________________________________________________|
				|	operand is memory/register value at EA		|
				|	or the value EA or a signed immediate		|
				|	memory source may be a word, half or thirdword	|
				|_______________________________________________________|



	assembler syntax	ax[, {w0|h1|h2|i}]		address_update[, {x|y|a|b|fp|sp}] 	

				ax[, {w0|t1|t2|t3|i}]		address_update[, {x|y|a|b|fp|sp}]

				ax[, {w0|h1|h2|i}]		*paddress_update

				ax[, {w0|t1|t2|t3|i}]		*paddress_update

				ax, i				ADDRESS_UPDATE[, {x|y|a|b|fp|sp}]

				ax, xi				ADDRESS_UPDATE

				ax				address_update[, {x|y|a|b|fp|sp}][, {w0|h1|h2|i}] 	

				ax				address_update[, {x|y|a|b|fp|sp}][, {w0|t1|t2|t3|i}]

				ax				*paddress_update[,, {w0|h1|h2|i}] 	

				ax				*paddress_update[,, {w0|t1|t2|t3|i}]

				ax				ADDRESS_UPDATE[, {x|y|a|b|fp|sp}], i

				ax				ADDRESS_UPDATE,, xi


	assembler examples	ax			address_update
				ax, h2			address_update, b
				ax			address_update,,t1
				ax			*paddress_update,,h1

				ax, xi			-48000/2
				ax			12, y, i
				ax, i			apointer
				ax, i			*apointer	[ =	ax	apointer ]

				_________________________________________________________
	Instruction Code 16	| 1 0 0 0 0 | . . . | . . . .  . . . . . . . . . . . .  |
				|___________|_______|___________________________________|
				








	<a	name="ay"/>
	Add to Index Register y	ay
	______________________	__


				_________________________________________________________
				|							|
				|	operand is added to index register y		|
				|	carry$ is not affected				|
				|_______________________________________________________|
				|	operand is memory/register value at EA		|
				|	or the value EA or a signed immediate		|
				|	memory source may be a word, half or thirdword	|
				|_______________________________________________________|



	assembler syntax	ay[, {w0|h1|h2|i}]		address_update[, {x|y|a|b|fp|sp}] 	

				ay[, {w0|t1|t2|t3|i}]		address_update[, {x|y|a|b|fp|sp}]

				ay[, {w0|h1|h2|i}]		*paddress_update

				ay[, {w0|t1|t2|t3|i}]		*paddress_update

				ay, i				ADDRESS_UPDATE[, {x|y|a|b|fp|sp}]

				ay, xi				ADDRESS_UPDATE

				ay				address_update[, {x|y|a|b|fp|sp}][, {w0|h1|h2|i}] 	

				ay				address_update[, {x|y|a|b|fp|sp}][, {w0|t1|t2|t3|i}]

				ay				*paddress_update[,, {w0|h1|h2|i}] 	

				ay				*paddress_update[,, {w0|t1|t2|t3|i}]

				ay				ADDRESS_UPDATE[, {x|y|a|b|fp|sp}], i

				ay				ADDRESS_UPDATE,, xi


	assembler examples	ay			address_update, x
				ay, h2			address_update
				ay			address_update,,t1
				ay			*paddress_update,,h1

				ay, xi			-48000/2
				ay			12, y, i
				ay, i			apointer
				ay, i			*apointer	[ =	ay	apointer ]

				_________________________________________________________
	Instruction Code 17	| 1 0 0 0 1 | . . . | . . . .  . . . . . . . . . . . .  |
				|___________|_______|___________________________________|
				








        <a      name="i24b"/>
        <div    style="margin-left:28pt;font-family:times-roman;font-size:12.75pt;color:0000FF">
        <i>3.6.5        Boolean Instructions</i>
        </div>
	instructions	<a href="#or">or</a>		<a href="#orb">orB</a>
			<a href="#and">and</a>		<a href="#andb">andB</a>
			<a href="#xor">xor</a>		<a href="#xorb">xorB</a>


        Boolean instructions read a one-word operand, a third or halfword,
        the effective address itself as an immediate operand, or a sign-extended immediate operand.


        An operand mode J mnemonic may be typed either after the instruction mnemonic
        or after the index position:

                orB, i		4, b

                xor		4, b, i

                and		-640,,xi

                xorB, t1	record_control_word, y

        Boolean instructions can read thirdwords when PSR Flag <b>half$w</b> = 0
        and halfwords when PSR Flag <b>half$w</b> = 1:

                andB		masks, y, h1








	<a	name="or"/>
	Or Arithmetic Register a	or
	________________________	__


				_________________________________________________________
				|							|
				|	arithmetic register a OR operand -> a		|
				|_______________________________________________________|
				|	operand is memory/register value at EA		|
				|	or the value EA or a signed immediate		|
				|	memory source may be a word, half or thirdword	|
				|_______________________________________________________|



	assembler syntax	or[, {w0|h1|h2|i}]		mask[, {x|y|a|b|fp|sp}] 	

				or[, {w0|t1|t2|t3|i}]		mask[, {x|y|a|b|fp|sp}]

				or[, {w0|h1|h2|i}]		*pmask

				or[, {w0|t1|t2|t3|i}]		*pmask

				or, i				MASK[, {x|y|a|b|fp|sp}]

				or, xi				MASK

				or				mask[, {x|y|a|b|fp|sp}][, {w0|h1|h2|i}] 	

				or				mask[, {x|y|a|b|fp|sp}][, {w0|t1|t2|t3|i}]

				or				*pmask[,, {w0|h1|h2|i}] 	

				or				*pmask[,, {w0|t1|t2|t3|i}]

				or				MASK[, {x|y|a|b|fp|sp}], i

				or				MASK,, xi


	assembler examples	or			mask
				or, h2			mask, b
				or			mask,,t1
				or			*pmask,,h1

				or, xi			-48000/2
				or			12, y, i
				or, i			apointer
				or, i			*apointer	[ =	or	apointer ]

				_________________________________________________________
	Instruction Code 18	| 1 0 0 1 0 | . . . | . . . .  . . . . . . . . . . . .  |
				|___________|_______|___________________________________|
				








	<a	name="orb"/>
	Or Arithmetic Register b	orB
	________________________	___


				_________________________________________________________
				|							|
				|	arithmetic register b OR operand -> b		|
				|_______________________________________________________|
				|	operand is memory/register value at EA		|
				|	or the value EA or a signed immediate		|
				|	memory source may be a word, half or thirdword	|
				|_______________________________________________________|




	assembler syntax	orB[, {w0|h1|h2|i}]		mask[, {x|y|a|b|fp|sp}] 	

				orB[, {w0|t1|t2|t3|i}]		mask[, {x|y|a|b|fp|sp}]

				orB[, {w0|h1|h2|i}]		*pmask

				orB[, {w0|t1|t2|t3|i}]		*pmask

				orB, i				MASK[, {x|y|a|b|fp|sp}]

				orB, xi				MASK

				orB				mask[, {x|y|a|b|fp|sp}][, {w0|h1|h2|i}] 	

				orB				mask[, {x|y|a|b|fp|sp}][, {w0|t1|t2|t3|i}]

				orB				*pmask[,, {w0|h1|h2|i}] 	

				orB				*pmask[,, {w0|t1|t2|t3|i}]

				orB				MASK[, {x|y|a|b|fp|sp}], i

				orB				MASK,, xi


	assembler examples	orB			mask
				orB, h2			mask
				orB			mask,a,t1
				orB			*pmask,,h1

				orB, xi			-48000/2
				orB			12, y, i
				orB, i			apointer
				orB, i			*apointer	[ =	orB	apointer ]

				_________________________________________________________
	Instruction Code 19	| 1 0 0 1 1 | . . . | . . . .  . . . . . . . . . . . .  |
				|___________|_______|___________________________________|
				








	<a	name="and"/>
	And Arithmetic Register a	and
	_________________________	___


				_________________________________________________________
				|							|
				|	arithmetic register a AND operand -> a		|
				|_______________________________________________________|
				|	operand is memory/register value at EA		|
				|	or the value EA or a signed immediate		|
				|	memory source may be a word, half or thirdword	|
				|_______________________________________________________|




	assembler syntax	and[, {w0|h1|h2|i}]		mask[, {x|y|a|b|fp|sp}] 	

				and[, {w0|t1|t2|t3|i}]		mask[, {x|y|a|b|fp|sp}]

				and[, {w0|h1|h2|i}]		*pmask

				and[, {w0|t1|t2|t3|i}]		*pmask

				and, i				MASK[, {x|y|a|b|fp|sp}]

				and, xi				MASK

				and				mask[, {x|y|a|b|fp|sp}][, {w0|h1|h2|i}] 	

				and				mask[, {x|y|a|b|fp|sp}][, {w0|t1|t2|t3|i}]

				and				*pmask[,, {w0|h1|h2|i}] 	

				and				*pmask[,, {w0|t1|t2|t3|i}]

				and				MASK[, {x|y|a|b|fp|sp}], i

				and				MASK,, xi


	assembler examples	and			mask
				and, h2			mask, x
				and			mask,,t1
				and			*pmask,,h1

				and, xi			-48000/2
				and			12, y, i
				and, i			apointer
				and, i			*apointer	[ =	and	apointer ]

				_________________________________________________________
	Instruction Code 20	| 1 0 1 0 0 | . . . | . . . .  . . . . . . . . . . . .  |
				|___________|_______|___________________________________|
				








	<a	name="andb"/>
	And Arithmetic Register b	andB
	_________________________	___


				_________________________________________________________
				|							|
				|	arithmetic register b AND operand -> b		|
				|_______________________________________________________|
				|	operand is memory/register value at EA		|
				|	or the value EA or a signed immediate		|
				|	memory source may be a word, half or thirdword	|
				|_______________________________________________________|



	assembler syntax	andB[, {w0|h1|h2|i}]		mask[, {x|y|a|b|fp|sp}] 	

				andB[, {w0|t1|t2|t3|i}]		mask[, {x|y|a|b|fp|sp}]

				andB[, {w0|h1|h2|i}]		*pmask

				andB[, {w0|t1|t2|t3|i}]		*pmask

				andB, i				MASK[, {x|y|a|b|fp|sp}]

				andB, xi			MASK

				andB				mask[, {x|y|a|b|fp|sp}][, {w0|h1|h2|i}] 	

				andB				mask[, {x|y|a|b|fp|sp}][, {w0|t1|t2|t3|i}]

				andB				*pmask[,, {w0|h1|h2|i}] 	

				andB				*pmask[,, {w0|t1|t2|t3|i}]

				andB				MASK[, {x|y|a|b|fp|sp}], i

				andB				MASK,, xi


	assembler examples	andB			(MASK_VALUE)
				andB, h2		mask
				andB			mask,,t1
				andB			*pmask,,h1

				andB, xi		-48000/2
				andB			12, y, i
				andB, i			apointer
				andB, i			*apointer	[ =	andB	apointer ]

				_________________________________________________________
	Instruction Code 21	| 1 0 1 0 1 | . . . | . . . .  . . . . . . . . . . . .  |
				|___________|_______|___________________________________|
				








	<a	name="xor"/>
	Exlusive Or Arithmetic Register a	xor
	_________________________________	___


				_________________________________________________________
				|							|
				|	arithmetic register a XOR operand -> a		|
				|_______________________________________________________|
				|	operand is memory/register value at EA		|
				|	or the value EA or a signed immediate		|
				|	memory source may be a word, half or thirdword	|
				|_______________________________________________________|


	assembler syntax	xor[, {w0|h1|h2|i}]		mask[, {x|y|a|b|fp|sp}] 	

				xor[, {w0|t1|t2|t3|i}]		mask[, {x|y|a|b|fp|sp}]

				xor[, {w0|h1|h2|i}]		*pmask

				xor[, {w0|t1|t2|t3|i}]		*pmask

				xor, i				MASK[, {x|y|a|b|fp|sp}]

				xor, xi				MASK

				xor				mask[, {x|y|a|b|fp|sp}][, {w0|h1|h2|i}] 	

				xor				mask[, {x|y|a|b|fp|sp}][, {w0|t1|t2|t3|i}]

				xor				*pmask[,, {w0|h1|h2|i}] 	

				xor				*pmask[,, {w0|t1|t2|t3|i}]

				xor				MASK[, {x|y|a|b|fp|sp}], i

				xor				MASK,, xi


	assembler examples	xor			mask
				xor, h2			mask
				xor			mask,,t1
				xor			*pmask,,h1

				xor, xi			-48000/2
				xor			12, y, i
				xor, i			apointer
				xor, i			*apointer	[ =	xor	apointer ]

				_________________________________________________________
	Instruction Code 22	| 1 0 1 1 0 | . . . | . . . .  . . . . . . . . . . . .  |
				|___________|_______|___________________________________|
				








	<a	name="xorb"/>
	Exlusive Or Arithmetic Register b	xorB
	_________________________________	____


				_________________________________________________________
				|							|
				|	arithmetic register b XOR operand -> b		|
				|_______________________________________________________|
				|	operand is memory/register value at EA		|
				|	or the value EA or a signed immediate		|
				|	memory source may be a word, half or thirdword	|
				|_______________________________________________________|


	assembler syntax	xorB[, {w0|h1|h2|i}]		mask[, {x|y|a|b|fp|sp}] 	

				xorB[, {w0|t1|t2|t3|i}]		mask[, {x|y|a|b|fp|sp}]

				xorB[, {w0|h1|h2|i}]		*pmask

				xorB[, {w0|t1|t2|t3|i}]		*pmask

				xorB, i				MASK[, {x|y|a|b|fp|sp}]

				xorB, xi			MASK

				xorB				mask[, {x|y|a|b|fp|sp}][, {w0|h1|h2|i}] 	

				xorB				mask[, {x|y|a|b|fp|sp}][, {w0|t1|t2|t3|i}]

				xorB				*pmask[,, {w0|h1|h2|i}] 	

				xorB				*pmask[,, {w0|t1|t2|t3|i}]

				xorB				MASK[, {x|y|a|b|fp|sp}], i

				xorB				MASK,, xi


	assembler examples	xorB			mask
				xorB, h2		mask
				xorB			mask,a,t1
				xorB			*pmask,,h1

				xorB, xi		-48000/2
				xorB			12, y, i
				xorB, i			apointer
				xorB, i			*apointer	[ =	xorB	apointer ]

				_________________________________________________________
	Instruction Code 23	| 1 0 1 1 1 | . . . | . . . .  . . . . . . . . . . . .  |
				|___________|_______|___________________________________|
				




        <a      name="i24a"/>
        <div    style="margin-left:28pt;font-family:times-roman;font-size:12.75pt;color:0000FF">
        <i>3.6.6        Integer Arithmetic Instructions</i>
        </div>
	instructions	<a href="#aa">aa</a>		<a href="#ana">ana</a>
			<a href="#ab">ab</a>		<a href="#anb">anb</a>
			<a href="#m">m</a>		<a href="#d">d</a>
			<a href="#mf">mf</a>


        Integer arithmetic instructions read a one-word operand, a third or halfword,
        the effective address itself as an immediate operand, or a sign-extended immediate operand.


        An operand mode J mnemonic may be typed either after the instruction mnemonic
        or after the index position:

                aa, i		4, b

                m		4, b, i

                d		-640,,xi

                mf, t1		record_control_word, y

        Integer arithmetic instructions can read thirdwords when PSR Flag <b>half$w</b> = 0
        and halfwords when PSR Flag <b>half$w</b> = 1:

                anb		masks, y, h1




	See also	<a href="#da">da</a>	<a href="#dan">dan</a>




	<a	name="aa"/>
	Add to Arithmetic Register a	aa
	____________________________	__

				_________________________________________________________
				|							|
				|	arithmetic register a + operand -> a		|
				|	carry$ = the carry from bit 23 of the addition	|
				|_______________________________________________________|
				|	operand is memory/register value at EA		|
				|	or the value EA or a signed immediate		|
				|	memory source may be a word, half or thirdword	|
				|_______________________________________________________|


	assembler syntax	aa[, {w0|h1|h2|i}]		addend[, {x|y|a|b|fp|sp}] 	

				aa[, {w0|t1|t2|t3|i}]		addend[, {x|y|a|b|fp|sp}]

				aa[, {w0|h1|h2|i}]		*paddend

				aa[, {w0|t1|t2|t3|i}]		*paddend

				aa, i				ADDEND[, {x|y|a|b|fp|sp}]

				aa, xi				ADDEND

				aa				addend[, {x|y|a|b|fp|sp}][, {w0|h1|h2|i}] 	

				aa				addend[, {x|y|a|b|fp|sp}][, {w0|t1|t2|t3|i}]

				aa				*paddend[,, {w0|h1|h2|i}] 	

				aa				*paddend[,, {w0|t1|t2|t3|i}]

				aa				ADDEND[, {x|y|a|b|fp|sp}], i

				aa				ADDEND,, xi


	assembler examples	aa			addend
				aa			(2000000)
				aa, h2			addend
				aa			addend,,t1
				aa			*paddend,,h1

				aa, xi			-48000/2
				aa			12, y, i
				aa, i			apointer
				aa, i			*apointer	[ =	aa	apointer ]

				_________________________________________________________
	Instruction Code 24	| 1 1 0 0 0 | . . . | . . . .  . . . . . . . . . . . .  |
				|___________|_______|___________________________________|
				








	<a	name="ab"/>
	Add to Arithmetic Register b	ab
	____________________________	__

				_________________________________________________________
				|							|
				|	arithmetic register b + operand -> b		|
				|	carry$ = the carry from bit 23 of the addition	|
				|_______________________________________________________|
				|	operand is memory/register value at EA		|
				|	or the value EA or a signed immediate		|
				|	memory source may be a word, half or thirdword	|
				|_______________________________________________________|


	assembler syntax	ab[, {w0|h1|h2|i}]		addend[, {x|y|a|b|fp|sp}] 	

				ab[, {w0|t1|t2|t3|i}]		addend[, {x|y|a|b|fp|sp}]

				ab[, {w0|h1|h2|i}]		*paddend

				ab[, {w0|t1|t2|t3|i}]		*paddend

				ab, i				ADDEND[, {x|y|a|b|fp|sp}]

				ab, xi				ADDEND

				ab				addend[, {x|y|a|b|fp|sp}][, {w0|h1|h2|i}] 	

				ab				addend[, {x|y|a|b|fp|sp}][, {w0|t1|t2|t3|i}]

				ab				*paddend[,, {w0|h1|h2|i}] 	

				ab				*paddend[,, {w0|t1|t2|t3|i}]

				ab				ADDEND[, {x|y|a|b|fp|sp}], i

				ab				ADDEND, xi


	assembler examples	ab			addend, x
				ab			(-3000000)
				ab, h2			addend
				ab			addend,,t1
				ab			*paddend,,h1

				ab, xi			-48000/2
				ab			12, y, i
				ab, i			apointer
				ab, i			*apointer	[ =	ab	apointer ]

				_________________________________________________________
	Instruction Code 25	| 1 1 0 0 1 | . . . | . . . .  . . . . . . . . . . . .  |
				|___________|_______|___________________________________|
				








	<a	name="ana"/>
	Add Negative to Arithmetic Register a	ana
	_____________________________________	___

				_________________________________________________________
				|							|
				|	arithmetic register a += 2scomplement(operand)	|
				|	carry$ = the carry from bit 23 of the addition	|
				|_______________________________________________________|
				|	operand is memory/register value at EA		|
				|	or the value EA or a signed immediate		|
				|	memory source may be a word, half or thirdword	|
				|_______________________________________________________|


	assembler syntax	ana[, {w0|h1|h2|i}]		subtrahend[, {x|y|a|b|fp|sp}] 	

				ana[, {w0|t1|t2|t3|i}]		subtrahend[, {x|y|a|b|fp|sp}]

				ana[, {w0|h1|h2|i}]		*psubtrahend

				ana[, {w0|t1|t2|t3|i}]		*psubtrahend

				ana, i				SUBTRAHEND[, {x|y|a|b|fp|sp}]

				ana, xi				SUBTRAHEND

				ana				subtrahend[, {x|y|a|b|fp|sp}][, {w0|h1|h2|i}] 	

				ana				subtrahend[, {x|y|a|b|fp|sp}][, {w0|t1|t2|t3|i}]

				ana				*psubtrahend[,, {w0|h1|h2|i}] 	

				ana				*psubtrahend[,, {w0|t1|t2|t3|i}]

				ana				SUBTRAHEND[, {x|y|a|b|fp|sp}], i

				ana				SUBTRAHEND,, xi


	assembler examples	ana			subtrahend
				ana, h2			subtrahend
				ana			subtrahend,,t1
				ana			*psubtrahend,,h1

				ana, xi			-48000/2
				ana			12, y, i
				ana, i			apointer
				ana, i			*apointer	[ =	ana	apointer ]

				_________________________________________________________
	Instruction Code 26	| 1 1 0 1 0 | . . . | . . . .  . . . . . . . . . . . .  |
				|___________|_______|___________________________________|
				






	<a	name="anb"/>
	Add Negative to Arithmetic Register b	anb
	_____________________________________	___

				_________________________________________________________
				|							|
				|	arithmetic register b += 2scomplement(operand)	|
				|	carry$ = the carry from bit 23 of the addition	|
				|_______________________________________________________|
				|	operand is memory/register value at EA		|
				|	or the value EA or a signed immediate		|
				|	memory source may be a word, half or thirdword	|
				|_______________________________________________________|


	assembler syntax	anb[, {w0|h1|h2|i}]		subtrahend[, {x|y|a|b|fp|sp}] 	

				anb[, {w0|t1|t2|t3|i}]		subtrahend[, {x|y|a|b|fp|sp}]

				anb, {w0|h1|h2|i}]		*psubtrahend

				anb[, {w0|t1|t2|t3|i}]		*psubtrahend

				anb, i				SUBTRAHEND[, {x|y|a|b|fp|sp}]

				anb, xi				SUBTRAHEND

				anb				subtrahend[, {x|y|a|b|fp|sp}][, {w0|h1|h2|i}] 	

				anb				subtrahend[, {x|y|a|b|fp|sp}][, {w0|t1|t2|t3|i}]

				anb				*psubtrahend[,, {w0|h1|h2|i}] 	

				anb				*psubtrahend[,, {w0|t1|t2|t3|i}]

				anb				SUBTRAHEND[, {x|y|a|b|fp|sp}], i

				anb				SUBTRAHEND,, xi


	assembler examples	anb			subtrahend, a
				anb, h2			subtrahend
				anb			subtrahend,,t1
				anb			*psubtrahend,,h1

				anb, xi			-48000/2
				anb			12, y, i
				anb, i			apointer
				anb, i			*apointer	[ =	anb	apointer ]

				_________________________________________________________
	Instruction Code 27	| 1 1 0 1 1 | . . . | . . . .  . . . . . . . . . . . .  |
				|___________|_______|___________________________________|
				








	<a	name="m"/>
	Multiply		m
	________		_


				_________________________________________________________
				|							|
				|	operand and arithmetic register b are		|
				|	multiplied algebraically. The 48-bit product	|					
				|	is stored in arithmetic registers a and b	|
				|_______________________________________________________|
				|	operand is memory/register value at EA		|
				|	or the value EA or a signed immediate		|
				|	memory source may be a word, half or thirdword	|
				|_______________________________________________________|


	assembler syntax	m[, {w0|h1|h2|i}]		multiplier[, {x|y|a|b|fp|sp}] 	

				m[, {w0|t1|t2|t3|i}]		multiplier[, {x|y|a|b|fp|sp}]

				m[, {w0|h1|h2|i}]		*pmultiplier

				m[, {w0|t1|t2|t3|i}]		*pmultiplier

				m, i				MULTIPLIER[, {x|y|a|b|fp|sp}]

				m, xi				MULTIPLIER

				m				multiplier[, {x|y|a|b|fp|sp}][, {w0|h1|h2|i}] 	

				m				multiplier[, {x|y|a|b|fp|sp}][, {w0|t1|t2|t3|i}]

				m				*pmultiplier[,, {w0|h1|h2|i}] 	

				m				*pmultiplier[,, {w0|t1|t2|t3|i}]

				m				MULTIPLIER[, {x|y|a|b|fp|sp}], i

				m				MULTIPLIER,, xi


	assembler examples	m			multiplier
				m			(-1250000)
				m, h2			multiplier
				m			multiplier,,t1
				m			*pmultiplier,,h1

				m, xi			-48000/2
				m			12, y, i
				m, i			apointer
				m, i			*apointer	[ =	m	apointer ]

				_________________________________________________________
	Instruction Code 28	| 1 1 1 0 0 | . . . | . . . .  . . . . . . . . . . . .  |
				|___________|_______|___________________________________|
				








	<a	name="mf"/>
	Multiply Fractional	mf
	___________________	__

				_________________________________________________________
				|							|
				|	unsigned integer in register b is multiplied.	|
				|	multiplier is signed. 48-bit product		|
				|	is stored in arithmetic registers a and b	|
				|							|
				|	multiply fractional is used for			|
				|							|
				|	   display edit of floating fractions		|
				|							|
				|	   integer multiplication with multiplicands of	|
				|	   2 or more words				|
				|_______________________________________________________|
				|	multiplier is memory/register value at EA	|
				|	or the value EA or a signed immediate.		|
				|	memory source may be a word, half or thirdword	|
				|_______________________________________________________|


	assembler syntax	mf[, {w0|h1|h2|i}]		multiplier[, {x|y|a|b|fp|sp}] 	

				mf[, {w0|t1|t2|t3|i}]		multiplier[, {x|y|a|b|fp|sp}]

				mf[, {w0|h1|h2|i}]		*pmultiplier

				mf[, {w0|t1|t2|t3|i}]		*pmultiplier

				mf, i				MULTIPLIER[, {x|y|a|b|fp|sp}]

				mf, xi				MULTIPLIER

				mf				multiplier[, {x|y|a|b|fp|sp}][, {w0|h1|h2|i}] 	

				mf				multiplier[, {x|y|a|b|fp|sp}][, {w0|t1|t2|t3|i}]

				mf				*pmultiplier[,, {w0|h1|h2|i}] 	

				mf				*pmultiplier[,, {w0|t1|t2|t3|i}]

				mf				MULTIPLIER[, {x|y|a|b|fp|sp}], i

				mf				MULTIPLIER,, xi


	assembler examples	mf			multiplier, x
				mf, h2			multiplier
				mf			multiplier,,t1
				mf			*pmultiplier,,h1

				mf, xi			-48000/2
				mf			12, y, i
				mf, i			apointer
				mf, i			*apointer	[ =	mf	apointer ]

				_________________________________________________________
	Instruction Code 29	| 1 1 1 0 1 | . . . | . . . .  . . . . . . . . . . . .  |
				|___________|_______|___________________________________|
				








	<a	name="d"/>
	Divide			d
	______			_

				_________________________________________________________
				|							|
				|	the 48-bit integer in arithmetic registers	|
				|	a and b is divided algebraically by the operand	|
				|	giving a 48-bit integer quotient and 24-bit	|
				|	integer remainder				|
				|							|
				|	quotient low-order 24 bits are in register a	|
				|	and high-order 24-bits in register mantissa2	|
				|							|
				|	remainder is in register b			|
				|							|
				|_______________________________________________________|
				|	operand is memory/register value at EA		|
				|	or the value EA or a signed immediate		|
				|	memory source may be a word, half or thirdword	|
				|_______________________________________________________|


	assembler syntax	d[, {w0|h1|h2|i}]		divisor[, {x|y|a|b|fp|sp}] 	

				d[, {w0|t1|t2|t3|i}]		divisor[, {x|y|a|b|fp|sp}]

				d[, {w0|h1|h2|i}]		*pdivisor

				d[, {w0|t1|t2|t3|i}]		*pdivisor

				d, i				DIVISOR[, {x|y|a|b|fp|sp}]

				d, xi				DIVISOR

				d				divisor[, {x|y|a|b|fp|sp}][, {w0|h1|h2|i}] 	

				d				divisor[, {x|y|a|b|fp|sp}][, {w0|t1|t2|t3|i}]

				d				*pdivisor[,, {w0|h1|h2|i}] 	

				d				*pdivisor[,, {w0|t1|t2|t3|i}]

				d				DIVISOR[, {x|y|a|b|fp|sp}], i

				d				value,, xi


	assembler examples	d			divisor
				d			(1000000)
				d, h2			divisor
				d			divisor,,t1
				d			*pdivisor,,h1

				d, xi			-48000/2
				d			12, y, i
				d, i			apointer
				d, i			*apointer	[ =	d	apointer ]

				_________________________________________________________
	Instruction Code 30	| 1 1 1 1 0 | . . . | . . . .  . . . . . . . . . . . .  |
				|___________|_______|___________________________________|
				










	<a	name="io"/>
	<div    style="margin-left:28pt;font-family:times-roman;font-size:12.75pt;color:0000FF">
	<i>3.6.7	I/O Ports Input and Output Instructions</i>
	</div>
	instructions	<a href="#ina">inA</a>		<a href="#outa">outA</a>
			<a href="#inb">inB</a>		<a href="#outb">outB</a>


	Input and Output Instructions identify the target port by effective address
	with or without indirection or indexing:


		inA		SOURCE_PORT
		outB		*target_port_pointer

		inB		RELATIVE_PORT_NUMBER, a






	<a	name="ina"/>
	I/O In to Arithmetic Register a		inA
	_______________________________		___

				_________________________________________________________
				|							|
				|	I/O port[EA] is read to arithmetic register a	|
				|_______________________________________________________|
				|	source is the I/O port EA			|
				|_______________________________________________________|

	assembler syntax	inA		PORT_NUMBER[, {x|y|a|b|fp|sp}]
				inA		*port_number_variable

				_________________________________________________________
	Instruction Code 0.4	| 0 0 0 0 0 | 1 0 0 | . . . .  . . . . . . . . . . . .	|
				|___________|_______|___________________________________|





	<a	name="inb"/>
	I/O In to Arithmetic Register b		inB
	_______________________________		___

				_________________________________________________________
				|							|
				|	I/O port[EA] is read to arithmetic register b	|
				|_______________________________________________________|
				|	source is the I/O port EA			|
				|_______________________________________________________|


	assembler syntax	inB		PORT_NUMBER[, {x|y|a|b|fp|sp}]
				inB		*port_number_variable

				_________________________________________________________
	Instruction Code 1.4	| 0 0 0 0 1 | 1 0 0 | . . . .  . . . . . . . . . . . .	|
				|___________|_______|___________________________________|





	<a	name="outa"/>
	I/O Out from Arithmetic Register a	outA
	__________________________________	____

				_________________________________________________________
				|							|
				|	value is written from register a to I/O port[EA]|
				|_______________________________________________________|
				|	target is the I/O port EA			|
				|_______________________________________________________|

	assembler syntax	outA		PORT_NUMBER[, {x|y|a|b|fp|sp}]
				outA		*port_number_variable

				_________________________________________________________
	Instruction Code 2.4	| 0 0 0 1 0 | 1 0 0 | . . . .  . . . . . . . . . . . .	|
				|___________|_______|___________________________________|






	<a	name="outb"/>
	I/O Out from Arithmetic Register b	outB
	__________________________________	____

				_________________________________________________________
				|							|
				|	value is written from register b to I/O port[EA]|
				|_______________________________________________________|
				|	target is the I/O port EA			|
				|_______________________________________________________|


	assembler syntax	outB		PORT_NUMBER[, {x|y|a|b|fp|sp}]
				outB		*port_number_variable

				_________________________________________________________
	Instruction Code 3.4	| 0 0 0 1 1 | 1 0 0 | . . . .  . . . . . . . . . . . .	|
				|___________|_______|___________________________________|






        <a      name="relo"/>
        <div    style="margin-left:28pt;font-family:times-roman;font-size:12.75pt;color:0000FF">
        <i>3.6.8        Process and Thread Memory Switch Instructions</i>
        </div>
	Applications issue <a href="#sabr">sabr</a> instruction to select memory blocks B2..B63

	Kernel issues <a href="#reload">reload</a> instruction to switch application memory space

	<a href="#b1">B1</a> is a private stack frame organised with I/O instructions




	<a	name="sabr"/>
	Store Arithmetic Register a to Base Register	sabr
	____________________________________________	____


				_________________________________________________________
				|							|
				|	the absolute pointer part of the storage	|
				|	block identified in register a is written 	|
				|	to relocation register I/O Port[EA]		|
				|							|
				|	the storage block symbolic identifier is copied	|
				|	from register a to memory window 65 (thread
				|	control block) offset 64 + EA			|
				|							|
				|	value of EA may be 2..63			|
				|							|
				|	symbolic identifier and absolute pointer of	|
				|	storage are identical unless the symbolic	|
				|	identifier is a translatable value		|
				|							|
				|	translating storage block identifiers		|
				|	are not currently implemented			|
				|							|
				|	sabr an instruction for application use		|
				|_______________________________________________________|




	assembler syntax	sabr		RELOCATION_REGISTER_ID[, {x|y|a|b|fp|sp}]
				sabr		*base_register_id_variable

				_________________________________________________________
	Instruction Code 6.4	| 0 0 1 1 0 | 1 0 0 | . . . .  . . . . . . . . . . . .	|
				|___________|_______|___________________________________|







	<a	name="reload"/>
	Reload			reload
	______			______

				_________________________________________________________
				|							|
				|	two storage block identifiers are read from	|
				|	memory at the address in Register a		|
				|							|
				|	the two retrieved storage pointers are written	|
				|	to relocation registers				|
				|							|
				|		I/O Port[EA]				|
				|		I/O Port[EA + 1]			|
				|							|
				|	Register a is incremented by 2			|
				|							|
				|	value of EA can be 2..62			|
				|_______________________________________________________|
				|							|
				|	reload instruction is used in the loadup beat	|
				|	of thread/process switch			|
				|							|
				|	it reads the list of identifiers which is stored|
				|	in the thread control block as the application	|
				|	obtains memory					|
				|_______________________________________________________|
				|	source is two storage words at [a]		|
				|	target is memory block pointer ports[EA, EA + 1]|
				|_______________________________________________________|


	assembler syntax	reload			RELOCATION_REGISTER_PAIR[, {x|y|a|b|fp|sp}]
				reload			*base_register_id_variable


	assembler example	la, xi		TCB_BASE_REGISTER_TABLE+B2
			?	$do		USER_BANKS/2,	reload	?*2

				_________________________________________________________
	Instruction Code 4.4	| 0 0 1 0 0 | 1 0 0 | . . . .  . . . . . . . . . . . .	|
				|___________|_______|___________________________________|




	<a	name="b1"/>
	_________________________________________________________________________________________________________________________________
	|						    BANK B1 PRIVATE STORAGE FRAME						|
	|_______________________________________________________________________________________________________________________________|
	|																|
	|			Bank B1 is a window in a private stack. B1 is out side the scope of sabr and reload instructions	|
	|																|
	|			<a href="#sabr">sabr</a> and <a href="#reload">reload</a> instructions concern banks B2..B63							|
	|																|
	|			applications execute sabr instruction to base memory blocks in B2..B63					|
	|			sabr also copies the relocation values through to the TCB						|
	|																|
	|			reload instruction bases some or all of B2..B63 in pairs on the loadup beat of task switch		|
	|																|
	|			Applications manipulate and restore B1 pointer in a different dynamic from B2..63			|
	|																|
	|			Task switch inputs B1 from I/O Port 1 and saves it individually						|
	|			Task switch outputs B1 of the loading task to I/O Port 1 individually					|
	|																|
	|_______________________________________________________________________________________________________________________________|
	|																|
	|																|
	|			A process has at least one B1 frame or B1 bank								|
        |                                                                                                                               |
        |                       a B1 frame contains private data at addresses 4096..8191                                                |
	|																|
	|			a B1 frame is not in the address space of an entity which has a different B1 frame			|
	|																|
	|			divisions of a process may have separate B1 frames							|
	|																|
	|			the owning entity of a B1 frame may be a thread, a service, a function,					|
	|			or a recursive execution of a function									|
	|																|
	|			services base their B1 bank temporarily to use private data on behalf of calling routines		|
	|																|
	|			the private data in B1 may include mechanical information underlying a service and compiler-generated	|
	|			information like database subschemas									|
	|																|
	|																|
	|_______________________________________________________________________________________________________________________________|






        <a      name="onoff"/>
        <div    style="margin-left:28pt;font-family:times-roman;font-size:12.75pt;color:0000FF">
        <i>3.6.9	PSR Flags Update Instructions</i>
        </div>
	<a	name="on"/>
	<a href="#on">On</a> and <a href="#off">Off</a> instructions switch PSR flags according to bits 15..0 of
	the sign-extended immediate operand


	PSR Flags On		on
	____________		__

				_________________________________________________________
				|							|
				|	1 is written to PSR flags designated by 1 in the|
				|	immediate operand. Only Flags 15..0 are affected|
				|_______________________________________________________|
				|	MASK is 16-bit immediate with sign extension	|
				|_______________________________________________________|


	assembler syntax	on	PSR_FLAGS_MASK

	assembler example	on	see$1++see$6++see$7


				_________________________________________________________
	Instruction Code 0.5	| 0 0 0 0 0 | 1 0 1 |		   MASK			|
				|___________|_______|___________________________________|





	<a	name="off"/>
	PSR Flags Off		off
	_____________		___


				_________________________________________________________
				|							|
				|	0 is written to PSR flags designated by 1 in the|
				|	immediate operand. Only Flags 15..0 are affected|
				|_______________________________________________________|
				|	MASK is 16-bit immediate with sign extension	|
				|_______________________________________________________|


	assembler syntax	off	PSR_FLAGS_MASK

	assembler example	off	half$w++carry$

				_________________________________________________________
	Instruction Code 1.5	| 0 0 0 0 1 | 1 0 1 | 		    MASK		|
				|___________|_______|___________________________________|




	<a      name="bstream"/>
	<div    style="margin-left:28pt;font-family:times-roman;font-size:12.75pt;color:0000FF">
	<i>3.6.10	Bit Stream Read and Write Channels</i>
	</div>
	instructions	<a href="#rsr">Read Staging Register</a>	<a href="#wsr">Write Staging Register</a>



        _________________________________________________________________________________________________________________________________
        |                                               The Bit Stream Read Channel                                                     |
        |_______________________________________________________________________________________________________________________________|
        |                                                                                                                               |
	|	The Bit Stream Read Channel allows storage to be read as a stream of bits in fields of any size up to one word		|
	|	Bit fields may be read across word boundaries transparently								|
	|																|
	|	Successive reads may each be a fixed number of bits giving a stream of bytes of arbitrary size up to 24 bits		|
	|	Alternatively successive reads may be an irregular number of bits							|
	|																|
	|	24 bits may be read from each storage word, or 16 bits to accommodate 16-bit input devices				|
	|																|
	|	Read Staging Register instruction drives the Bit Stream Read Channel							|
	|_______________________________________________________________________________________________________________________________|
<a	style="color:0000FF">
	_________________________________________________________________________________________________________________________________
	|							Multiplexing								|
	|_______________________________________________________________________________________________________________________________|
	|																|
	|	The Bit Stream Read Channel is within application context, so every thread has one					|
	|																|
	|	Many applications only scan one read stream, stdin									|
	|																|
	|	The prototype kernel smaragd7 has a system call for switching stream states						|
	|	so that an application may scan many ANSI filestreams and other arrays in overlapped time				|
	|_______________________________________________________________________________________________________________________________|
</a>



	<a	name="rsr"/>
	Read Staging Register	rsr
	_____________________	___

	rsr instruction shifts BITS bits from storage stream *q to arithmetic register a
	controlled by counter register RDATAC and buffered in data register RDATA

	BITS is the sign extended immediate operand

				_________________________________________________________
				|							|
				|	shift BITS bits left from Staging Register	|
				|	RDATA to Arithmetic Register a			|
				|							|
				|	reload RDATA from storage on empty		|
				|							|
				|_______________________________________________________|
				|							|
				|	if RDATAC < BITS				|
				|							|
				|		subtract RDATAC	from BITS		|
				|							|
				|		shift RDATAC bits to Register a		|
				|							|
				|		read memory/register to RDATA with	|
				|		Pointer Register *q			|
				|							|
				|		increment Pointer Register q		|
				|							|
				|		restart RDATAC = RSTREAM_WORD		|
				|							|
				|	shift BITS bits from RDATA to Register a	|
				|							|
				|	subtract BITS from RDATAC			|
				|_______________________________________________________|
				|							|
				|	if PSR Flag b$streamZR = 0 displace the prior	|
				|	value in Register a leftwards			|
				|							|
				|	if PSR Flag b$streamZR = 1 clear Register a	|
				|	before shifting from RDATA			|
				|							|
				|	if PSR Flag b$stream16r = 0 RSTREAM_WORD = 24	|
				|							|
				|	if PSR Flag b$stream16r = 1 RSTREAM_WORD = 16	|
				|	and RDATA is shifted left 8 bits on memory read	|
				|							|
				|_______________________________________________________|
				|							|
				|	RDATAC RDATA and q are registers		|
				|							|
				|	RSTREAM_WORD is a term not a register		|
				|_______________________________________________________|
				|	BITS is 16-bit immediate with sign extension  	|
				|_______________________________________________________|
				|							|
				|	RDATAC and RDATA are application registers	|
				|	not replicated as interrupt registers		|
				|							|
				|	if ISRs program bit read streams they use	|
				|	application registers RDATAC and RDATA and	|
				|	must first save them				|
				|							|
				|	storage read pointer q is replicated in		|
				|	application and interrupt register sets		|
				|							|
				|	rsr instruction in interrupt mode uses q_x	|
				|_______________________________________________________|

	assembler syntax	rsr	BITS_TO_READ

	assembler example	rsr	BYTE_SIZE

				_________________________________________________________
	Instruction Code 2.5	| 0 0 0 1 0 | 1 0 1 | 		    BITS		|
				|___________|_______|___________________________________|






        _________________________________________________________________________________________________________________________________
        |                                               The Bit Stream Write Channel                                                    |
        |_______________________________________________________________________________________________________________________________|
        |                                                                                                                               |
        |       The Bit Stream Write Channel allows storage to be written as a stream of bits in fields of any size up to one word	|
        |       Bit fields may be written across word boundaries transparently                                                          |
        |                                                                                                                               |
        |       Successive writes may each be a fixed number of bits giving a stream of bytes of arbitrary size up to 24 bits		|
	|       Alternatively successive writes may be an irregular number of bits                                                      |
        |                                                                                                                               |
        |       24 bits may be written to each storage word, or 16 bits to accommodate 16-bit output devices                            |
        |                                                                                                                               |
        |       Write Staging Register instruction drives the Bit Stream Write Channel                                                  |
        |_______________________________________________________________________________________________________________________________|
<a      style="color:0000FF">
        _________________________________________________________________________________________________________________________________
        |                                                       Multiplexing                                                            |
        |_______________________________________________________________________________________________________________________________|
        |                                                                                                                               |
        |       The Bit Stream Write Channel is within application context, so every thread has one					|
        |                                                                                                                               |
        |       Many applications only format one write stream, stdout									|
        |                                                                                                                               |
        |       The prototype kernel smaragd7 has a system call for switching stream states                                             |
        |       so that an application may format many ANSI filestreams and other arrays in overlapped time				|
	|_______________________________________________________________________________________________________________________________|
</a>




	<a	name="wsr"/>
	Write Staging Register	wsr
	______________________	___


	wsr instruction shifts BITS bits from arithmetic register a to storage stream *p
	controlled by counter register WDATAC and buffered in data register WDATA

	BITS is the sign extended immediate operand 


				_________________________________________________________
				|							|
				|	shift BITS bits left from Register a		|
				|	to Staging Register WDATA			|
				|							|
				|	write WDATA to storage on full			|
				|							|
				|_______________________________________________________|
				|							|
				|	WSPACE = WSTREAM_WORD - WDATAC			|
				|							|
				|	if BITS >= WSPACE				|
				|							|
				|		subtract WSPACE from BITS		|
				|							|
				|		shift WSPACE bits to WDATA		|
				|							|
				|		write WDATA to memory/register with	|
				|		Pointer Register *p			|
				|							|
				|		increment Pointer Register p		|
				|							|
				|		restart WDATAC = 0			|
				|							|
				|		restart WDATA = 0			|
				|							|
				|	shift BITS bits from Register a to WDATA	|
				|							|
				|	add BITS to WDATAC				|
				|_______________________________________________________|
				|							|
				|	if PSR Flag b$stream16w = 0 WSTREAM_WORD = 24	|
				|							|
				|	if PSR Flag b$stream16r = 1 WSTREAM_WORD = 16	|
				|							|
				|_______________________________________________________|
				|							|
				|	WDATAC WDATA and p are registers		|
				|							|
				|	WSPACE and WSTREAM_WORD are terms not registers	|
				|_______________________________________________________|
				|	BITS is 16-bit immediate with sign extension	|
				|_______________________________________________________|
				|							|
				|	WDATAC and WDATA are application registers	|
				|	not replicated as interrupt registers		|
				|							|
				|	if ISRs program bit write streams they use	|
				|	application registers WDATAC and WDATA and	|
				|	must first save them				|
				|							|
				|	storage write pointer p is replicated in	|
				|	application and interrupt register sets		|
				|							|
				|	wsr instruction in interrupt mode uses p_x	|
				|_______________________________________________________|


	assembler syntax	wsr		BITS_TO_WRITE

	assembler example	sal		24-BYTE_SIZE
				wsr		BYTE_SIZE


				_________________________________________________________
	Instruction Code 3.5	| 0 0 0 1 1 | 1 0 1 | 		    BITS		|
				|___________|_______|___________________________________|


				_________________________________________________________
				|	at the end of a stream of wsr writes software	|
				|	intervention may be needed to write outstanding	|
				|	bits of an incomplete data word			|
				|_______________________________________________________|
				|	if zero-padding is required, an unconditional	|
				|	write instruction drives a conditional write	|
				|_______________________________________________________|


				wsr		$word-$byte


				_________________________________________________________
				|	if the unwritten values in the last written word|
				|	must be unchanged, conditional masking is needed|
				|_______________________________________________________| 


										write_last_bits	lb	*p	
												la	WDATA
				tz		WDATAC						sbl	*WDATAC
				lcal		write_last_bits					dsr	*WDATAC
												sb	*p
												lret	0




	<a      name="lfiret"/>
	<div    style="margin-left:28pt;font-family:times-roman;font-size:12.75pt;color:0000FF">
	<i>3.6.11	Return Instructions and Internal Interrupt</i>
	</div>
	instructions	<a href="#lret">Local Return</a>		<a href="#ii">Internal Interrupt</a>
			<a href="#fret">Far Return</a>		<a href="#ir">Interrrupt return</a>

	Return instructions increment the stacked return address with the sign extended immediate operand
 



	<a	name="lret"/>
	Local Return		lret
	____________		____

				_________________________________________________________
				|							|
				|	return address relative to current instruction	|
				|	window B0 is popped from the internal stack	|
				|							|
				|	sign extended immediate operand of the return	|
				|	instruction is added to the relative address	|
				|							|
				|	B0 * 4096 is added to the relative address	|
				|							|
				|	the resulting absolute address is transferred	|
				|	to the program counter				|
				|							|
				|	if sp = 128 before lret				|
				|	task exit interrupt 70 is raised		|
				|							|
				|	on internal stack overflow / underflow		|
				|	[sp < 24 | sp > 128] before operation		|
				|	guard interrupt 95 is raised			|
				|							|
				|_______________________________________________________|
				|	DISPLACEMENT is 16-bit sign extended immediate	|
				|_______________________________________________________|


	assembler syntax	lret		SKIP_STEPS

	assembler examples	lret		0
				lret		1
				lret		-1
				lret		2

				_________________________________________________________
	Instruction Code 6.5	| 0 0 1 1 0 | 1 0 1 | 		  DISPLACEMENT		|
				|___________|_______|___________________________________|






	<a	name="fret"/>
	Far Return		fret
	__________		___

				_________________________________________________________
				|							|
				|	identifier of return target instruction window 	|
				|	is popped from the internal stack to B0		|
				|							|
				|	return address relative to retrieved instruction|
				|	window is popped from Internal Stack		|
				|							|
				|	sign extended immediate operand of the return	|
				|	instruction is added to the relative address	|
				|							|
				|	B0 * 4096 is added to the relative address	|
				|							|
				|	the resulting absolute address is transferred	|
				|	to the program counter				|
				|							|
                                |       if sp = 128 before fret                         |
                                |       task exit interrupt 70 is raised                |
                                |                                                       |
                                |       on internal stack overflow / underflow		|
                                |       [sp < 24 | sp > 126 ^ 128] before operation	|
				|	guard interrupt 95 is raised			|
                                |                                                       |
				|_______________________________________________________|
				|	DISPLACEMENT is 16-bit sign extended immediate	|
				|_______________________________________________________|



	assembler syntax	fret		SKIP_STEPS

	assembler examples	fret		0
				fret		-1
				fret		1
				fret		2

				_________________________________________________________
	Instruction Code 7.5	| 0 0 1 1 1 | 1 0 1 | 		DISPLACEMENT		|
				|___________|_______|___________________________________|






	_________________________________________________________________________________________________________________________________
	|							   INTERRUPTS								|
	|_______________________________________________________________________________________________________________________________|
	|																|
	|			on external or internal interrupt									|
	|			_________________________________									|
	|																|
	|			absolute Program Counter minus B0 * 4096 is pushed onto the Interrupt Internal Stack			|
	|																|
	|			B0 is pushed onto the Interrupt Internal Stack								|
	|																|
	|			PSR is pushed onto the Interrupt Internal Stack								|
	|																|
	|			a latent parameter word is pushed onto the Interrupt Internal Stack					|
	|			when instruction ii raises the interrupt, the latent parameter word = 0					|
	|																|
	|			if PSR Flag 23 = 0 then Interrupt Stack Pointer sp_x is copied to Interrupt Frame Pointer fp_x		|
	|			this marks which Interrupt Stack Frame is the interrupted application					|
	|			the absolute address of the application Interrupt Stack Frame should always be 252			|
	|																|
	|			1 is written to PSR Flag 23										|
	|																|
	|_______________________________________________________________________________________________________________________________|
	|																|
	|			The Interrupt Stack Frame at Interrupt Stack Pointer sp_x is						|
	|			____________________________________________________________						|
	|																|
	|																|
	|			 95			 71			 47			 23		       0	|
	|			_________________________________________________________________________________________________	|
	|			|    latent parameter	|	saved PSR	|	saved B0	|   saved relative PC	|	|
	|			|_______________________|_______________________|_______________________|_______________________|	|
	|																|
	|_______________________________________________________________________________________________________________________________|




	<a	name="ii"/>
	Internal Interrupt	ii
	__________________	__

				_________________________________________________________
				|							|
				|	B0 * 4096 is subtracted from the value of	|
				|	the absolute program counter			|
				|							|
				|	the resulting instruction-window relative value	|
				|	is pushed on the interrupt internal stack	|
				|							|
				|	B0 is pushed on the interrupt internal stack	|
				|							|
				|	PSR is pushed on the interrupt internal stack	|
				|							|
				|	latent parameter value 0 is pushed on the	|
				|	interrupt internal stack			|
				|							|
				|	PSR Flag 23 = 1					|
				|							|
				|	the high-order 18 bits of the immediate operand	|
				|	designate a VECTOR_BANK				|
				|							|
				|	the low-order 6 bits if the immediate operand	|
				|	designate a VECTOR_OFFSET			|
				|							|
				|	B0 = VECTOR_BANK				|
				|							|
				|	program counter = VECTOR_BANK*4096+VECTOR_OFFSET|
				|_______________________________________________________|
				|	VECTOR_BANK			  |VECTOR_OFFSET|
				|23______________________________________6|5___________0|
				|	VECTOR is 16-bit sign extended immediate	|
				|_______________________________________________________|


	assembler syntax	ii	INTERRUPT_VECTOR

	assembler examples	ii	BANK_1*/6++2
				ii	BANK_1*/6++11

				_________________________________________________________
	Instruction Code 14.5	| 0 1 1 1 0 | 1 0 1 |		  VECTOR		|
				|___________|_______|___________________________________|






	<a	name="ir"/>
	Interrupt Return	ir
	________________	__

				_________________________________________________________
				|							|
				|							|
				|	interrupted PSR is retrieved from		|
				|	[interrupt internal stack pointer + 1]		|
				|							|
				|	interrupted instruction window identity is	|
				|	retrieved to B0 from				|
				|	[interrupt internal stack pointer + 2]		|
				|							|
				|	interrupted address relative to instruction	|
				|	window is retrieved from			|
				|	[interrupt internal stack pointer + 3]		|
				|							|
				|	the sign extended immediate operand of the ir	|
				|	instruction is added to the relative address	|
				|							|
				|	B0 * 4096 is added to the relative address	|
				|							|
				|	the resulting absolute address is transferred	|
				|	to the program counter				|
				|							|
				|	interrupt internal stack pointer		|
				|	is incremented by 4				|
				|_______________________________________________________|
				|	DISPLACEMENT is 16-bit sign extended immediate	|
				|_______________________________________________________|


	assembler syntax	ir	SKIP_STEPS

	assembler examples	ir	0
				ir	-1
				ir	2

				_________________________________________________________
	Instruction Code 15.5	| 0 1 1 1 1 | 1 0 1 | 		DISPLACEMENT		|
				|___________|_______|___________________________________|







	<a      name="shijo"/>
	<div    style="margin-left:28pt;font-family:times-roman;font-size:12.75pt;color:0000FF">
	<i>3.6.12      Shift and Jump Instructions</i>
	</div>
	Shift instructions and jump instructions use the effective address
	with or without indirection or indexing as an immediate operand

	instructions	<a href="#sar">Shift a Right</a>			<a href="#j">Jump</a>
			<a href="#sbr">Shift b Right</a>			<a href="#lcal">Local Call</a>
			<a href="#dsr">Double Shift Right</a>		<a href="#jc">Jump Carry</a>
			<a href="#sal">Shift a Left</a>			<a href="#jnc">Jump No Carry</a>
			<a href="#sbl">Shift b Left</a>			<a href="#jza">Jump Zero a</a>
			<a href="#dsl">Double Shift Left</a>		<a href="#jzb">Jump Zero b</a>
			<a href="#rar">Rotate a Right</a>			<a href="#jnza">Jump NonZero a</a>
			<a href="#rbr">Rotate b Right</a>			<a href="#jnzb">Jump NonZero b</a>
			<a href="#drr">Double Rotate Right</a>		<a href="#jpa">Jump Positive a</a>
			<a href="#ral">Rotate a Left</a>			<a href="#jpb">Jump Positive b</a>
			<a href="#rbl">Rotate b Left</a>			<a href="#jna">Jump Negative a</a>
			<a href="#drl">Double Rotate Left</a>		<a href="#jnb">Jump Negative b</a>
			<a href="#saa">Shift a Algebraic</a>		<a href="#jao">Jump a Odd</a>
			<a href="#sba">Shift b Algebraic</a>		<a href="#jpo">Jump Parity k**a Odd</a>
			<a href="#dsa">Double Shift Algebraic</a>		<a href="#jdr">Jump Decrement Counter Register</a>
							<a href="#jxge">Jump x NOT < r</a>
							<a href="#jyge">Jump y NOT < r</a>
							<a href="#jdz">Jump Double Zero</a>


			see also	target modify instructions	<a href="#src">src</a> and <a href="#slc">slc</a>
					scale instructions		<a href="#lsc">lsc</a> and <a href="#dlsc">dlsc</a>
					far jump instructions		<a href="#go">go</a>  and <a href="#call">call</a>		


	<a	name="sar"/>
	Shift Arithmetic Register a Right	sar
	_________________________________	___

				_________________________________________________________
				|							|
				|	the value in arithmetic register a is shifted	|
				|	rightward for EA bit positions			|
				|	0 is written to vacated high-order bit positions|
				|_______________________________________________________|


	assembler syntax	sar	BIT_POSITIONS[, {x|y|a|b|fp|sp}]
				sar	*shift_distance_variable

				_________________________________________________________
	Instruction Code 0.6	| 0 0 0 0 0 | 1 1 0 | . . . .  . . . . . . . . . . . .	|
				|___________|_______|___________________________________|






	<a	name="sbr"/>
	Shift Arithmetic Register b Right	sbr
	_________________________________	___

				_________________________________________________________
				|							|
				|	the value in arithmetic register b is shifted 	|
				|	rightward for EA bit positions			|
				|	0 is written to vacated high-order bit positions|
				|_______________________________________________________|


	assembler syntax	sbr	BIT_POSITIONS[, {x|y|a|b|fp|sp}]
				sbr	*shift_distance_variable

				_________________________________________________________
	Instruction Code 1.6	| 0 0 0 0 1 | 1 1 0 | . . . .  . . . . . . . . . . . .  |
				|___________|_______|___________________________________|






	<a	name="dsr"/>
	Double Shift Right	dsr
	__________________	___

				_________________________________________________________
				|							|
				|	the 48-bit value in arithmetic registers a and b|
				|	is shifted rightward for EA bit positions	|
				|	0 is written to vacated high-order bit positions|
				|_______________________________________________________|


	assembler syntax	dsr	BIT_POSITIONS[, {x|y|a|b|fp|sp}]
				dsr	*shift_distance_variable

				_________________________________________________________
	Instruction Code 2.6	| 0 0 0 1 0 | 1 1 0 | . . . .  . . . . . . . . . . . .  |
				|___________|_______|___________________________________|





	<a	name="jdr"/>
	Jump Decrement Repeat Count	jdr
	___________________________	___


				_________________________________________________________
				|							|
				|	repeat count register r	is decremented.		|
				|	instruction path jumps to EA			|
				|	unless r changes from 0 to -1			|
				|_______________________________________________________|


	assembler syntax	jdr	jump_address[, {x|y|a|b|fp|sp}]
				jdr	*jump_pointer

				_________________________________________________________
	Instruction Code 3.6	| 0 0 0 1 1 | 1 1 0 | . . . .  . . . . . . . . . . . .  |
				|___________|_______|___________________________________|





	<a	name="sal"/>
	Shift Arithmetic Register a Left	sal
	________________________________	___

				_________________________________________________________
				|							|
				|	the value in arithmetic register a is shifted	|
				|	leftward for EA bit positions			|
				|	0 is written to vacated low-order bit positions |
				|_______________________________________________________|


	assembler syntax	sal	BIT_POSITIONS[, {x|y|a|b|fp|sp}]
				sal	*shift_distance_variable

				_________________________________________________________
	Instruction Code 4.6	| 0 0 1 0 0 | 1 1 0 | . . . .  . . . . . . . . . . . .  |
				|___________|_______|___________________________________|






	<a	name="sbl"/>
	Shift Arithmetic Register b Left	sbl
	________________________________	___

				_________________________________________________________
				|							|
				|	the value in arithmetic register b is shifted	|
				|	leftward for EA bit positions			|
				|	0 is written to vacated low-order bit positions	|
				|_______________________________________________________|


	assembler syntax	sbl	BIT_POSITIONS[, {x|y|a|b|fp|sp}]
				sbl	*shift_distance_variable

				_________________________________________________________
	Instruction Code 5.6	| 0 0 1 0 1 | 1 1 0 | . . . .  . . . . . . . . . . . .  |
				|___________|_______|___________________________________|






	<a	name="dsl"/>
	Double Shift Left	dsl
	_________________	___

				_________________________________________________________
				|							|
				|	the 48-bit value in arithmetic registers a and b|
				|	is shifted leftward for EA bit positions	|
				|	0 is written to vacated low-order bit positions	|
				|_______________________________________________________|


	assembler syntax	dsl	BIT_POSITIONS[, {x|y|a|b|fp|sp}]
				dsl	*shift_distance_variable

				_________________________________________________________
	Instruction Code 6.6	| 0 0 1 1 0 | 1 1 0 | . . . .  . . . . . . . . . . . .  |
				|___________|_______|___________________________________|






	<a	name="lcal"/>
	Local Call		lcal
	__________		____


				_________________________________________________________
				|							|
				|	absolute program counter minus B0 * 4096	|	
				|	is pushed onto the internal stack		|
				|							|
				|	new program counter = B0 * 4096 + EA:		|
				|	instruction path jumps to EA			|
				|							|
                                |       on internal stack overflow / underflow		|
                                |       [sp < 25 | sp > 128] before operation           |
                                |       guard interrupt 95 is raised			|
				|_______________________________________________________|



	assembler syntax	lcal	jump_address[, {x|y|a|b|fp|sp}]
				lcal	*jump_pointer

				_________________________________________________________
	Instruction Code 7.6	| 0 0 1 1 1 | 1 1 0 | . . . .  . . . . . . . . . . . .  |
				|___________|_______|___________________________________|





	<a	name="rar"/>
	Rotate Arithmetic Register a Right	rar
	__________________________________	___

				_________________________________________________________
				|							|
				|	the value in arithmetic register a is rotated 	|
				|	rightward for EA bit positions			|
				|	values shifted out of the register are		|
				|	transferred to high-order bit positions 	|
				|_______________________________________________________|

	assembler syntax	rar	BIT_POSITIONS[, {x|y|a|b|fp|sp}]
				rar	*shift_distance_variable

				_________________________________________________________
	Instruction Code 8.6	| 0 1 0 0 0 | 1 1 0 | . . . .  . . . . . . . . . . . .  |
				|___________|_______|___________________________________|





	<a	name="rbr"/>
	Rotate Arithmetic Register b Right	rbr
	__________________________________	___

				_________________________________________________________
				|							|
				|	the value in arithmetic begister b is rotated 	|
				|	rightward for EA bit positions			|
				|	values shifted out of the register are		|
				|	transferred to high-order bit positions		|
				|_______________________________________________________|


	assembler syntax	rbr	BIT_POSITIONS[, {x|y|a|b|fp|sp}]
				rbr	*shift_distance_variable

				_________________________________________________________
	Instruction Code 9.6	| 0 1 0 0 1 | 1 1 0 | . . . .  . . . . . . . . . . . .  |
				|___________|_______|___________________________________|





	<a	name="drr"/>
	Double Rotate Right	drr
	___________________	___

				_________________________________________________________
				|							|
				|	the 48-bit value in arithmetic registers a and b|
				|	is rotated rightward for EA bit positions	|
				|	values shifted out of the register pair are	|
				|	transferred to high-order bit positions		|
				|_______________________________________________________|


	assembler syntax	drr	BIT_POSITIONS[, {x|y|a|b|fp|sp}]
				drr	*shift_distance_variable

				_________________________________________________________
	Instruction Code 10.6	| 0 1 0 1 0 | 1 1 0 | . . . .  . . . . . . . . . . . .  |
				|___________|_______|___________________________________|





	<a	name="jnc"/>
	Jump No Carry		jnc
	_____________		___

				_________________________________________________________
				|							|
				|	instruction path jumps to EA if carry$ flag is 0|
				|_______________________________________________________|


	assembler syntax	jnc	jump_address[, {x|y|a|b|fp|sp}]
				jnc	*jump_pointer

				_________________________________________________________
	Instruction Code 11.6	| 0 1 0 1 1 | 1 1 0 | . . . .  . . . . . . . . . . . .  |
				|___________|_______|___________________________________|






	<a	name="ral"/>
	Rotate Arithmetic Register a Left	ral
	_________________________________	___

				_________________________________________________________
				|							|
				|	the value in arithmetic register a is rotated 	|
				|	leftward for EA bit positions			|
				|	values shifted out of the register are		|
				|	transferred to low-order bit positions		|
				|_______________________________________________________|


	assembler syntax	ral	BIT_POSITIONS[, {x|y|a|b|fp|sp}]
				ral	*shift_distance_variable

				_________________________________________________________
	Instruction Code 12.6	| 0 1 1 0 0 | 1 1 0 | . . . .  . . . . . . . . . . . .  |
				|___________|_______|___________________________________|






	<a	name="rbl"/>
	Rotate Arithmetic Register b Left	rbl
	_________________________________	___

				_________________________________________________________
				|							|
				|	the value in arithmetic register b is rotated 	|
				|	leftward for EA bit positions			|
				|	values shifted out of the register are		|
				|	transferred to low-order bit positions		|
				|_______________________________________________________|


	assembler syntax	rbl	BIT_POSITIONS[, {x|y|a|b|fp|sp}]
				rbl	*shift_distance_variable

				_________________________________________________________
	Instruction Code 13.6	| 0 1 1 0 1 | 1 1 0 | . . . .  . . . . . . . . . . . .  |
				|___________|_______|___________________________________|






	<a	name="drl"/>
	Double Rotate Left	drl
	__________________	___

				_________________________________________________________
				|							|
				|	the 48-bit value in arithmetic registers a and b|
				|	is rotated leftward for EA bit positions	|
				|	values shifted out of the register pair are	|
				|	transferred to low-order bit positions		|
				|_______________________________________________________|


	assembler syntax	drl	BIT_POSITIONS[, {x|y|a|b|fp|sp}]
				drl	*shift_distance_variable

				_________________________________________________________
	Instruction Code 14.6	| 0 1 1 1 0 | 1 1 0 | . . . .  . . . . . . . . . . . .  |
				|___________|_______|___________________________________|






	<a	name="jc"/>
	Jump on Carry		jc
	_____________		__

				_________________________________________________________
				|							|
				|	instruction path jumps to EA if carry$ flag is 1|
				|_______________________________________________________|



	assembler syntax	jc	jump_address[, {x|y|a|b|fp|sp}]
				jc	*jump_pointer

				_________________________________________________________
	Instruction Code 15.6	| 0 1 1 1 1 | 1 1 0 | . . . .  . . . . . . . . . . . .  |
				|___________|_______|___________________________________|






	<a	name="saa"/>
	Shift Arithmetic Register a Algebraic	saa
	_____________________________________	___

				_________________________________________________________
				|							|
				|	the value in arithmetic Register a is shifted	|
				|	algebraically rightwards for EA bit positions	|
				|	the initial value of bit 23 is repeated in	|
				|	each vacated high order bit position		|
				|_______________________________________________________|

	assembler syntax	saa	BIT_POSITIONS[, {x|y|a|b|fp|sp}]
				saa	*shift_distance_variable

				_________________________________________________________
	Instruction Code 16.6	| 1 0 0 0 0 | 1 1 0 | . . . .  . . . . . . . . . . . .  |
				|___________|_______|___________________________________|






	<a	name="sba"/>
	Shift Arithmetic Register b Algebraic	sba
	_____________________________________	___

				_________________________________________________________
				|							|
				|	the value in arithmetic Register b is shifted	|
				|	algebraically rightwards for EA bit positions	|
				|	the initial value of bit 23 is repeated in	|
				|	each vacated high order bit position		|
				|_______________________________________________________|


	assembler syntax	sba	BIT_POSITIONS[, {x|y|a|b|fp|sp}]
				sba	*shift_distance_variable

				_________________________________________________________
	Instruction Code 17.6	| 1 0 0 0 1 | 1 1 0 | . . . .  . . . . . . . . . . . .  |
				|___________|_______|___________________________________|





	<a	name="dsa"/>
	Double Shift Algebraic	dsa
	______________________	___
				_________________________________________________________
				|							|
				|	the 48-bit value in arithmetic registers a and b|
				|	is shifted algebraically rightwards for EA bit	|
				|	positions. The value of bit 47 is repeated in	|
				|	each vacated high order bit position		|
				|_______________________________________________________|

	assembler syntax	dsa	BIT_POSITIONS[, {x|y|a|b|fp|sp}]
				dsa	*shift_distance_variable

				_________________________________________________________
	Instruction Code 18.6	| 1 0 0 1 0 | 1 1 0 | . . . .  . . . . . . . . . . . .  |
				|___________|_______|___________________________________|





	<a	name="jao"/>
	Jump a Odd		jao
	__________		___
	
				_________________________________________________________
				|							|
				|	instruction path jumps to EA 			|
				|	if bit 0 of Arithmetic Register a = 1		|
				|_______________________________________________________|


	assembler syntax	jao	jump_address[, {x|y|a|b|fp|sp}]
				jao	*jump_pointer

				_________________________________________________________
	Instruction Code 19.6	| 1 0 0 1 1 | 1 1 0 | . . . .  . . . . . . . . . . . .  |
				|___________|_______|___________________________________|






	<a	name="jpa"/>
	Jump Positive a		jpa
	_______________		___

				_________________________________________________________
				|							|
				|	instruction path jumps to EA			|
				|	if bit 23 of Arithmetic Register a = 0		|
				|_______________________________________________________|


	assembler syntax	jpa	jump_address[, {x|y|a|b|fp|sp}]
				jpa	*jump_pointer

				_________________________________________________________
	Instruction Code 20.6	| 1 0 1 0 0 | 1 1 0 | . . . .  . . . . . . . . . . . .  |
				|___________|_______|___________________________________|





	<a	name="jpb"/>
	Jump Positive b		jpb
	_______________		___

				_________________________________________________________
				|							|
				|	instruction path jumps to EA			|
				|	if bit 23 of Arithmetic Register b = 0		|
				|_______________________________________________________|


	assembler syntax	jpb	jump_address[, {x|y|a|b|fp|sp}]
				jpb	*jump_pointer

				_________________________________________________________
	Instruction Code 21.6	| 1 0 1 0 1 | 1 1 0 | . . . .  . . . . . . . . . . . .  |
				|___________|_______|___________________________________|




	<a	name="j"/>
	Jump			j
	____			_

				_________________________________________________________
				|							|
				|	instruction path jumps to EA			|
				|_______________________________________________________|


	assembler syntax	j	jump_address[, {x|y|a|b|fp|sp}]
				j	*jump_pointer

				_________________________________________________________
	Instruction Code 22.6	| 1 0 1 1 0 | 1 1 0 | . . . .  . . . . . . . . . . . .  |
				|___________|_______|___________________________________|






	<a	name="jpo"/>
	Jump Parity Odd		jpo
	_______________		___

				_________________________________________________________
				|							|
				|	instruction path jumps to EA			|
				|	if register a AND mask register k has odd parity|
				|_______________________________________________________|



	assembler syntax	jpo	jump_address[, {x|y|a|b|fp|sp}]
				jpo	*jump_pointer


				_________________________________________________________
	Instruction Code 23.6	| 1 0 1 1 1 | 1 1 0 | . . . .  . . . . . . . . . . . .  |
				|___________|_______|___________________________________|





	<a	name="jza"/>
	Jump Zero a		jza
	___________		___
	
				_________________________________________________________
				|							|
				|	instruction path jumps EA			|
				|	if all bits of Arithmetic register a are 0	|
				|_______________________________________________________|


	assembler syntax	jza	jump_address[, {x|y|a|b|fp|sp}]
				jza	*jump_pointer

				_________________________________________________________
	Instruction Code 24.6	| 1 1 0 0 0 | 1 1 0 | . . . .  . . . . . . . . . . . .  |
				|___________|_______|___________________________________|






	<a	name="jzb"/>
	Jump Zero b		jzb
	___________		___

				_________________________________________________________
				|							|
				|	instruction path jumps to EA			|
				|	if all bits of arithmetic register b are 0	|
				|_______________________________________________________|


	assembler syntax	jzb	jump_address[, {x|y|a|b|fp|sp}]
				jzb	*jump_pointer

				_________________________________________________________
	Instruction Code 25.6	| 1 1 0 0 1 | 1 1 0 | . . . .  . . . . . . . . . . . .  |
				|___________|_______|___________________________________|






	<a	name="jnza"/>
	Jump NonZero a		jnza
	______________		____
	
				_________________________________________________________
				|							|
				|	instruction path jumps to EA			|
				|	if any bits of arithmetic register a are 1	|
				|_______________________________________________________|

	assembler syntax	jnza	jump_address[, {x|y|a|b|fp|sp}]
				jnza	*jump_pointer

				_________________________________________________________
	Instruction Code 26.6	| 1 1 0 1 0 | 1 1 0 | . . . .  . . . . . . . . . . . .  |
				|___________|_______|___________________________________|






	<a	name="jnzb"/>
	Jump NonZero b		jnzb
	______________		____

				_________________________________________________________
				|							|
				|	instruction path jumps to EA			|
				|	if any bits of arithmetic register b are 1	|
				|_______________________________________________________|

	assembler syntax	jnzb	jump_address[, {x|y|a|b|fp|sp}]
				jnzb	*jump_pointer

				_________________________________________________________
	Instruction Code 27.6	| 1 1 0 1 1 | 1 1 0 | . . . .  . . . . . . . . . . . .  |
				|___________|_______|___________________________________|





	<a	name="jna"/>
	Jump Negative a		jna
	_______________		___
	
				_________________________________________________________
				|							|
				|	instruction path jumps to EA			|
				|	if bit 23 of arithmetic register a = 1		|
				|_______________________________________________________|

	assembler syntax	jna	jump_address[, {x|y|a|b|fp|sp}]
				jna	*jump_pointer

				_________________________________________________________
	Instruction Code 28.6	| 1 1 1 0 0 | 1 1 0 | . . . .  . . . . . . . . . . . .  |
				|___________|_______|___________________________________|





	<a	name="jnb"/>
	Jump Negative b		jnb
	_______________		___

				_________________________________________________________
				|							|
				|	instruction path jumps to EA			|
				|	if bit 23 of arithmetic register b = 1		|
				|_______________________________________________________|

	assembler syntax	jnb	jump_address[, {x|y|a|b|fp|sp}]
				jnb	*jump_pointer

				_________________________________________________________
	Instruction Code 29.6	| 1 1 1 0 1 | 1 1 0 | . . . .  . . . . . . . . . . . .  |
				|___________|_______|___________________________________|





	<a	name="jxge"/>
	Jump x Greater or Equal	jxge
	_______________________	___

				_________________________________________________________
				|							|
				|	instruction path jumps to EA unless		|
				|	index register x < limit pointer register r	|
				|_______________________________________________________|

	assembler syntax	jxge	jump_address[, {x|y|a|b|fp|sp}]
				jxge	*jump_pointer




				_________________________________________________________
	Instruction Code 30.6	| 1 1 1 1 0 | 1 1 0 | . . . .  . . . . . . . . . . . .  |
				|___________|_______|___________________________________|





	<a	name="jyge"/>
	Jump y Greater or Equal	jyge
	_______________________	____

				_________________________________________________________
				|							|
				|	instruction path jumps to EA unless		|
				|	index register y < limit pointer register r	|
				|_______________________________________________________|

	assembler syntax	jyge	jump_address[, {x|y|a|b|fp|sp}]
				jyge	*jump_pointer


				_________________________________________________________
	Instruction Code 31.6	| 1 1 1 1 1 | 1 1 0 | . . . .  . . . . . . . . . . . .  |
				|___________|_______|___________________________________|






	<a	name="jdz"/>
	Jump Double Zero	jdz
	________________	___

				_________________________________________________________
				|							|
				|	instruction path jumps to EA if all 48 bits 	|
				|	of arithmetic registers a and b are 0		|
				|_______________________________________________________|


	assembler syntax	jdz	jump_address[, {x|y|a|b|fp|sp}]
				jdz	*jump_pointer

				_________________________________________________________
	Instruction Code 15.4	| 0 1 1 1 1 | 1 0 0 | . . . .  . . . . . . . . . . . .  |
				|___________|_______|___________________________________|








	<a      name="modify"/>
	<div    style="margin-left:28pt;font-family:times-roman;font-size:12.75pt;color:0000FF">
	<i>3.6.13	Target Modify Instructions</i>
	</div>
	Eight instructions modify a single-word target operand

	The first modify instruction <a href="#ts">ts</a> operates on a storage operand not a register,
	and must execute atomically with storage lock

	The other seven modify instructions <a href="#n">n</a> <a href="#inc">inc</a> <a href="#dec">dec</a> <a href="#src">src</a> <a href="#slc">slc</a> <a href="#sim">sim</a> <a href="#popa">popA</a>
	can be usefully executed on registers or storage.
	Registers have no storage lock and are not shared between threads.
	It is not intended that <b>n inc dec src slc sim popA</b> instructions
	necessarily lock storage target operands or are used in arbitration



	<a	name="ts"/>
	Test and Set		ts
	____________		__

				_________________________________________________________
				|							|
				|	value at EA is atomically read and rewritten	|
				|	with value 1 in bit 23				|
				|							|
				|	the next instruction is skipped if bit 23 was 0 |
				|	before the operation				|
				|_______________________________________________________|
				|	target operand is the storage word at EA	|
				|	and not a register				|
				|	EA < 256 resolves to a location in memory B0	|
				|_______________________________________________________|



	assembler		ts	lock_cell[, {x|y|a|b|fp|sp}]
	syntax/example		j	$-1

				ts	*pointer_to_lock_cell
				lcal	wait_and_try_again


				_________________________________________________________
	Instruction Code 0.7	| 0 0 0 0 0 | 1 1 1 | . . . .  . . . . . . . . . . . .  |
				|___________|_______|___________________________________|







	<a	name="n"/>
	Negate			n
	______			_

				_________________________________________________________
				|							|
				|	the value at EA is rewritten in ones complement	|
				|_______________________________________________________|
				|	target is the register or storage word at EA	|
				|_______________________________________________________|	



	assembler syntax	n	mantissa[, {x|y|a|b|fp|sp}]

				n	*pointer_to_switch



				_________________________________________________________
	Instruction Code 1.7	| 0 0 0 0 1 | 1 1 1 | . . . .  . . . . . . . . . . . .  |
				|___________|_______|___________________________________|







	<a	name="inc"/>
	Increment		inc
	_________		___

				_________________________________________________________
				|							|
				|	+1 is added to the 24-bit value at EA		|
				|	 carry$ is not affected				|
				|_______________________________________________________|
				|	target is the register or storage word at EA	|
				|_______________________________________________________|	



	assembler syntax	inc	tally[, {x|y|a|b|fp|sp}]

				inc	*pointer2uptozerocounter



				_________________________________________________________
	Instruction Code 2.7	| 0 0 0 1 0 | 1 1 1 | . . . .  . . . . . . . . . . . .  |
				|___________|_______|___________________________________|






	<a	name="dec"/>
	Decrement		dec
	_________		___

				_________________________________________________________
				|							|
				|	-1 is added to the 24-bit value at EA		|
				|	carry$ is not affected				|
				|_______________________________________________________|
				|	target is the register or storage word at EA	|
				|_______________________________________________________|	



	assembler syntax	dec	counter[, {x|y|a|b|fp|sp}]

				dec	*pointer_to_counter



				_________________________________________________________
	Instruction Code 3.7	| 0 0 0 1 1 | 1 1 1 | . . . .  . . . . . . . . . . . .  |
				|___________|_______|___________________________________|






	<a	name="sim"/>
	Switch Interrupt Mask	sim
	_____________________	___

				_________________________________________________________
				|							|
				|	interrupt mask from PSR bits 18..16 is switched	|
				|	with the word at EA. Bits 23..3 of the storage	|
				|	word are dropped on read and zero on write	|
				|_______________________________________________________|
				|	PSR		I000 0iii 0xxx xxxx Hyyy 000C	|
				|_______________________________________________________|
				|	storage		0000 0000 0000 0000 0000 0iii	|
				|_______________________________________________________|
				|	target is the register or storage word at EA	|
				|_______________________________________________________|	




	assembler syntax	sim	aside_location[, {x|y|a|b|fp|sp}]

				sim	*pointer_to_imask_save


	assembler example	push	MAXIMUM_IMASK,,xi
				sim	0, sp
				.
				.
				sim	0, sp
				inc	sp


				_________________________________________________________
	Instruction Code 4.7	| 0 0 1 0 0 | 1 1 1 | . . . .  . . . . . . . . . . . .  |
				|___________|_______|___________________________________|





	<a	name="popa"/>
	Pop and AddTo		popA
	_____________		____

				_________________________________________________________
				|							|
				|	the value at the internal stack top is added to |
				|	the word at EA. carry$ = the carry out of bit 23|
				|	of the addition. sp is incremented		|
				|							|
                                |       on internal stack overflow / underflow		|
                                |       [sp < 24 | sp > 127] before operation           |
                                |       guard interrupt 95 is raised                    |
                                |                                                       |
				|_______________________________________________________|
				|	target is the register or storage word at EA	|
				|_______________________________________________________|	



	assembler syntax	popA	storage_total[, {x|y|a|b|fp|sp}]

				popA	*pointer_to_storage_total



				_________________________________________________________
	Instruction Code 5.7	| 0 0 1 0 1 | 1 1 1 | . . . .  . . . . . . . . . . . .  |
				|___________|_______|___________________________________|






	<a	name="src"/>
	Shift Right through Carry	src
	_________________________	___

				_________________________________________________________
				|							|
				|	the word at EA and carry$ are rotated in	|
				|	a 25-bit ring rightwards one bit position	|
				|_______________________________________________________|
				|	target is the register or storage word at EA	|
				|_______________________________________________________|	



	assembler syntax	src	rounding_overflow[, {x|y|a|b|fp|sp}]

				src	*bit_race_indirectly



				_________________________________________________________
	Instruction Code 6.7	| 0 0 1 1 0 | 1 1 1 | . . . .  . . . . . . . . . . . .  |
				|___________|_______|___________________________________|





	<a	name="slc"/>
	Shift Left through Carry	slc
	________________________	___

				_________________________________________________________
				|							|
				|	the word at EA and carry$ are rotated in 	|
				|	a 25-bit ring leftwards one bit position	|
				|_______________________________________________________|
				|	target is the register or storage word at EA	|
				|_______________________________________________________|	



	assembler syntax	slc	attention_flags[, {x|y|a|b|fp|sp}]

				slc	*pointer_to_ring



				_________________________________________________________
	Instruction Code 7.7	| 0 0 1 1 1 | 1 1 1 | . . . .  . . . . . . . . . . . .  |
				|___________|_______|___________________________________|



	<a      name="scala"/>
	<div    style="margin-left:28pt;font-family:times-roman;font-size:12.75pt;color:0000FF">
	<i>3.6.14	Double and Quadword Load and Store, Masked, Execute and Scale Operations, Large Integer Arithmetic</i>
	</div>
	Large integer operations have a source or target operand of one, two or four registers or storage words


	instructions		<a href="#ds">Double Store</a>			<a href="#dl">Double Load</a>
								<a href="#dpush">Double Push</a>
				<a href="#da">Double Add</a>			<a href="#dan">Double Add Negative</a>
				<a href="#lsc">Load Shift and Count</a>		<a href="#dlsc">Double Load Shift and Count</a>
				<a href="#mta">Masked Test A</a>			<a href="#mlb">Masked Load B</a>
				<a href="#sc">Store Carry</a>			<a href="#ex">Execute</a>
				<a href="#qs">Quadruple Store</a>			<a href="#ql">Quadruple Load</a>
				<a href="#qpop">Quadruple Pop</a>			<a href="#qpush">Quadruple Push</a>	


	<a	name="qs"/>
	Quadruple Store		qs
	_______________		__

				_________________________________________________________
				|							|
				|	four arithmetic registers			|
				|	a b mantissa2 mantissa3	are stored to EA			|
				|							|
				|	Register a is stored at register / storage EA	|
				|	Register b is stored at register / storage EA+1	|
				|	mantissa2  is stored at register / storage EA+2	|
				|	mantissa3  is stored at register / storage EA+3	|
				|_______________________________________________________|
				|	target is four registers or storage words at EA	|
				|	EA is any word address				|
				|_______________________________________________________|



	assembler syntax	qs	sum[, {x|y|a|b|fp|sp}]

				qs	*pointer_to_sum



				_________________________________________________________
	Instruction Code 8.7	| 0 1 0 0 0 | 1 1 1 | . . . .  . . . . . . . . . . . .  |
				|___________|_______|___________________________________|







	<a	name="ql"/>
	Quadruple Load		ql
	______________		__

				_________________________________________________________
				|							|
				|	a 96-bit value at EA is loaded to four		|
				|	arithmetic registers a b mantissa2 mantissa3	|
				|							|
				|	register / storage at EA   loads to Register a	|
				|	register / storage at EA+1 loads to Register b	|
				|	register / storage at EA+2 loads to mantissa2	|
				|	register / storage at EA+3 loads to mantissa3	|
				|_______________________________________________________|
				|	source is four registers or storage words at EA	|
				|	EA is any word address				|
				|_______________________________________________________|



	assembler syntax	ql	sum[, {x|y|a|b|fp|sp}]

				ql	*pointer_to_sum

				ql	(250600004700003450.630*+1262001)


				_________________________________________________________
	Instruction Code 9.7	| 0 1 0 0 1 | 1 1 1 | . . . .  . . . . . . . . . . . .  |
				|___________|_______|___________________________________|




	<a	name="qpop"/>
	Quadruple Pop		qpop
	_____________		____

				_________________________________________________________
				|							|
				|	four words are storedfrom the internal stack top|
				|							|
				|	store order is as stack order 	0, sp -> EA	|
				|					1, sp -> EA+1	|
				|					2, sp -> EA+2	|
				|					3, sp -> EA+3	|
				|							|
				|	internal stack pointer sp is incremented by 4	|
				|							|
                                |       on internal stack overflow / underflow		|
                                |       [sp < 24 | sp > 124] before operation           |
                                |       guard interrupt 95 is raised                    |
				|							|
				|_______________________________________________________|
				|	target is four registers or storage words at EA	|
				|	EA is any word address				|
				|_______________________________________________________|



	assembler syntax	qpop	buffer[, {x|y|a|b|fp|sp}]

				qpop	*pointer_to_buffer



				_________________________________________________________
	Instruction Code 16.7	| 1 0 0 0 0 | 1 1 1 | . . . .  . . . . . . . . . . . .  |
				|___________|_______|___________________________________|








	<a	name="qpush"/>
	Quadruple Push		qpush
	______________		_____

				_________________________________________________________
				|							|
				|	internal stack pointer sp is decremented by 4	|
				|							|
				|	a 96-bit value at EA is read to the internal	|
				|	stack top at [sp]				|
				|							|
				|	the word read from EA is at the stack top  0,sp	|
				|	the word read from EA+1 is at stack top+1  1,sp	|
				|	the word read from EA+2 is at stack top+2  2,sp	|
				|	the word read from EA+3 is at stack top+3  3,sp	|
				|							|
                                |       on internal stack overflow / underflow		|
                                |       [sp < 28 | sp > 128] before operation           |
                                |       guard interrupt 95 is raised                    |
                                |                                                       |
				|_______________________________________________________|
				|	source is four registers or storage words at EA	|
				|	EA is any word address				|
				|_______________________________________________________|




	assembler syntax	qpush	buffer[, {x|y|a|b|fp|sp}]

				qpush	*pointer_to_buffer

				qpush	(623600004700003450.630*+1262001)


				_________________________________________________________
	Instruction Code 17.7	| 1 0 0 0 1 | 1 1 1 | . . . .  . . . . . . . . . . . .  |
				|___________|_______|___________________________________|








	<a	name="ex"/>
	Execute			ex
	_______			__

				_________________________________________________________
				|							|
				|	a data word is read from memory, decoded	|
				|	and execute as an instruction			|
				|							|
				|	if the target instruction is not a jump, call,  |
				|	skip or	interrupt, execution continues at the	|
				|	instruction after the execute instruction	|
				|							|
				|	if the target instruction decides to jump, call,|
				|	skip or interrupt, execution continues at the	|
				|	jump target. If the target instruction is a call|
				|	or interrupt, return is to the instruction	|
				|	after the execute instruction			|
				|_______________________________________________________|
				|	execute target is the storage word at EA	|
				|	and not a register				|
				|	operand address < 256 resolves to a location in	|
				|	current B0 memory block				|
				|_______________________________________________________|



	assembler syntax	ex	instruction[, {x|y|a|b|fp|sp}]

				ex	*instruction_indirectly


	assembler example


		next_column	jxge		frame_scanned
				ex		key_difference, x
				ax, xi		1
				and, xi		4095
				aa		crc12_table_pointer
				la		0, a
				j		next_column


		key_difference
		column		$do		ARRAY_LIMIT,    ;
				xor		frame+(column-1)/2, b, h1+(column-1)///2

		........................................................................

				lx		bytes
				lb, xi		0
				on		b$streamZR

		next_digit	rsr		BYTE
				ax, xi		-1
				ex		raise,x 
				tz		x
				j		next_digit

				

		raise		ab		units-'0', a
				ab		tens-'0', a
				ab		hundreds-'0', a
				ab		thousands-'0', a
				ab		ten_thousands-'0', a
				ab		hundred_thousands-'0', a



					


				_________________________________________________________
	Instruction Code 18.7	| 1 0 0 1 0 | 1 1 1 | . . . .  . . . . . . . . . . . .  |
				|___________|_______|___________________________________|







	<a	name="dpush"/>
	Double Push		dpush
	___________		_____

				_________________________________________________________
				|							|
				|	internal stack pointer sp is decremented by 2	|
				|	a 48-bit value at EA is loaed to the		|
				|	internal stack top at [sp]			|
				|							|
				|	the word read from EA is at the stack top  0,sp	|
				|	the word read from EA+1 is at stack top+1  1,sp	|
				|							|
                                |       on internal stack overflow / underflow		|
                                |       [sp < 26 | sp > 128] before operation           |
                                |       guard interrupt 95 is raised                    |
                                |                                                       |
				|_______________________________________________________|
				|	source is two registers or storage words at EA 	|
				|	EA is any word address				|
				|_______________________________________________________|



	assembler syntax	dpush	preload48[, {x|y|a|b|fp|sp}]

				dpush	*preload48_indirectly

				dpush	(258000000000000:d)



				_________________________________________________________
	Instruction Code 19.7	| 1 0 0 1 1 | 1 1 1 | . . . .  . . . . . . . . . . . .  |
				|___________|_______|___________________________________|








	<a	name="lsc"/>
	Load Shift and Count	lsc
	____________________	___

				_________________________________________________________
				|							|
				|	a value at EA is retrieved, rotated to scale	|
				|	and stored in arithmetic register a		|
				|							|
				|	the value is rotated left counting		|
				|	until bit 23 changes or the count reaches 24	|
				|							|
				|	the shift count is stored in register b		|
				|							|
				|_______________________________________________________|
				|	source is the register or storage word at EA	|
				|_______________________________________________________|




	assembler syntax	lsc	short_mantissa[, {x|y|a|b|fp|sp}]

				lsc	*short_mantissa_indirectly



				_________________________________________________________
	Instruction Code 20.7	| 1 0 1 0 0 | 1 1 1 | . . . .  . . . . . . . . . . . .  |
				|___________|_______|___________________________________|







	<a	name="mta"/>
	Masked Test Equal a	mta
	___________________	___

				_________________________________________________________
				|							|
				|	the next instruction is skipped  if		|
				|	(Register a AND Mask Register k) equals		|
				|	(register / storage at EA) AND Mask Register k 	|
				|_______________________________________________________|
				|	comparand is register or storage word at EA	|
				|_______________________________________________________|



	assembler syntax	mta	comparand[, {x|y|a|b|fp|sp}]

				mta	*comparand_indirectly


	assembler_example	lk	(0FFFF00:s)
				mta	(00D0A00:s)
				j	not_cr_lf



				_________________________________________________________
	Instruction Code 21.7	| 1 0 1 0 1 | 1 1 1 | . . . .  . . . . . . . . . . . .  |
				|___________|_______|___________________________________|







	<a	name="sc"/>
	Store Carry		sc
	___________		__

				_________________________________________________________
				|							|
				|	Processor State Register AND 1 is stored	|
				|	at the target register / storage word		|
				|_______________________________________________________|
				|	target is the register or storage word at EA	|
				|_______________________________________________________|



	assembler syntax	sc	next_add_word[, {x|y|a|b|fp|sp}]

				sc	*pointer_to_next_add_word



				_________________________________________________________
	Instruction Code 22.7	| 1 0 1 1 0 | 1 1 1 | . . . .  . . . . . . . . . . . .  |
				|___________|_______|___________________________________|








	<a	name="mlb"/>
	Masked Load b		mlb
	_____________		___

				_________________________________________________________
				|							|
				|	arithmetic register b is loaded with 		|
				|	   (register / storage AND Mask Register k)	|
				|	OR (Register b AND (NOT Mask Register k))	|
				|_______________________________________________________|
				|	source is the register or storage word at EA	|
				|_______________________________________________________|



	assembler syntax	mlb	word2merge[, {x|y|a|b|fp|sp}]

				mlb	*pointer_to_word2merge



				_________________________________________________________
	Instruction Code 23.7	| 1 0 1 1 1 | 1 1 1 | . . . .  . . . . . . . . . . . .  |
				|___________|_______|___________________________________|







	<a	name="ds"/>
	Double Store		ds
	____________		__

				_________________________________________________________
				|							|
				|	the 48-bit value in arithmetic registers a and b|
				|	is stored at EA					|
				|							|
				|	Register a is stored at EA			|
				|	Register b is stored at EA+1			|
				|_______________________________________________________|
				|	target is two registers or storage words at EA	|
				|	EA is any word address				|
				|_______________________________________________________|




	assembler syntax	ds	destination48[, {x|y|a|b|fp|sp}]

				ds	*pointer_to_destination48



				_________________________________________________________
	Instruction Code 24.7	| 1 1 0 0 0 | 1 1 1 | . . . .  . . . . . . . . . . . .  |
				|___________|_______|___________________________________|







	<a	name="dl"/>
	Double Load		dl
	___________		__

				_________________________________________________________
				|							|
				|	a 48-bit value is loaded from EA		|
				|	to arithmetic registers a and b			|
				|							|
				|	the word at EA is loaded to Register a		|
				|	the word at EA+1 is loaded to Register b	|
				|_______________________________________________________|
				|	source is two registers or storage words at EA	|
				|	EA is any word address				|
				|_______________________________________________________|




	assembler syntax	dl	from48[, {x|y|a|b|fp|sp}]

				dl	*pointer_to_from48

				dl	(258000000000000:d)


				_________________________________________________________
	Instruction Code 25.7	| 1 1 0 0 1 | 1 1 1 | . . . .  . . . . . . . . . . . .  |
				|___________|_______|___________________________________|







	<a	name="da"/>
	Double Add		da
	__________		__

				_________________________________________________________
				|							|
				|	a 48-bit integer at EA is added to		|
				|	arithmetic registers a and b			|
				|							|
				|	the word at EA contains high-order bits 47..24	|
				| 	of the addend					|
				|							|
				|	the word at EA+1 contains low-order bits 23..0	|
				|	of the addend					|
				|							|
				|	carry$ = the carry from bit 47 of the addition	|
				|_______________________________________________________|
				|	2nd addend is 2 registers or storage words at EA|
				|	EA is any word address				|
				|_______________________________________________________|



	assembler syntax	da	addend48[, {x|y|a|b|fp|sp}]

				da	*addend48_indirectly

				da	(-120000000000000)

				_________________________________________________________
	Instruction Code 26.7	| 1 1 0 1 0 | 1 1 1 | . . . .  . . . . . . . . . . . .  |
				|___________|_______|___________________________________|







	<a	name="dan"/>
	Double Add Negative	dan
	__________________	___

				_________________________________________________________
				|							|
				|	the 2s complement of a 48-bit integer at EA 	|
				|	is added to arithmetic registers a and b	|
				|							|
				|	the word at EA contains high-order bits 47..24	|
				| 	of the subtrahend				|
				|							|
				|	the word at EA+1 contains low-order bits 23..0	|
				|	of the subtrahend				|
				|							|
				|	carry$ = the carry from bit 47 of the addition	|
				|_______________________________________________________|
				|	subtrahend is 2 registers or storage words at EA|
				|	EA is any word address				|
				|_______________________________________________________|



	assembler syntax	dan	subtrahend48[, {x|y|a|b|fp|sp}]

				dan	*subtrahend48_indirectly

				dan	(120000000000000)


				_________________________________________________________
	Instruction Code 27.7	| 1 1 0 1 1 | 1 1 1 | . . . .  . . . . . . . . . . . .  |
				|___________|_______|___________________________________|







	<a	name="dlsc"/>
	Double Load Shift and Count	dlsc
	___________________________	____

				_________________________________________________________
				|							|
				|	a 48-bit value is loaded from two words at EA	|
				|	and rotated to scale then stored in arithmetic 	|
				|	registers a and b				|
				|							|
				|	the value is rotated left counting		|
				|	until bit 47 changes or the count reaches 48	|
				|							|
				|	the shift count is stored in register mantissa2	|
				|							|
				|_______________________________________________________|
				|	source is two registers or storage words at EA	|
				|	EA is any word address				|
				|_______________________________________________________|



	assembler syntax	dlsc	mantissa[, {x|y|a|b|fp|sp}]

				dlsc	*mantissa_indirectly


				_________________________________________________________
	Instruction Code 28.7	| 1 1 1 0 0 | 1 1 1 | . . . .  . . . . . . . . . . . .  |
				|___________|_______|___________________________________|











        <a      name="fp"/>
        <div    style="margin-left:28pt;font-family:times-roman;font-size:12.75pt;color:0000FF">
        <i>3.6.15       96-bit and 192-bit Floating Point, Floating 48-Bit Compression</i>
        </div>
	instructions	<a href="#fa">Floating Add</a>			<a href="#fpp">Floating Pop and Pack</a>
			<a href="#fan">Floating Add Negative</a>		<a href="#fpx">Floating Push and Expand</a>
			<a href="#fm">Floating Multiply</a>
			<a href="#fd">Floating Divide</a>


	_________________________________________________________________________________________________________________________________
	|						The 96-bit Floating Architecture						|
	|_______________________________________________________________________________________________________________________________|
	|																|
	|																|
	|			RTA1 has four floating operation instructions and two instructions for					|
	|			storage compression and expansion of floating numbers							|
	|																|
	|			Four consecutive computer words form a 96-bit floating number						|
	|																|
	|			the 72-bit mantissa is a simple fraction in bits 71..0							|
	|																|
	|			The mantissa has no integer part either represented or unrepresented					|
	|																|
	|			The binary point is between the normalising bit 71 and the characteristic field in bits 94..72 		|
	|																|
	|			An integer value is obtained by hauling the mantissa upwards through the binary point by the number	|
	|			of shift positions with which the characteristic exceeds the midpoint value of 400000 hexadecimal	|
	|																|
	|			The midpointed 23-bit characteristic covers the range of decimal exponents -1262611 to +1262611		|
	|																|
	|			A characteristic of zero expresses the lowest possible exponent						|
	|																|
	|			A characteristic at midpoint 400000 expresses the zero exponent. The normalised number is >= 0.5 and < 1|
	|																|
	|			A maximum characteristic 7FFFFF expresses the highest possible exponent					|
	|																|
	|			Bit 95 = 1 indicates the the number is a ones complement negative number				|
	|																|
	|			Bit 95 is not a sign bit in the sense of indicating negative polarity over a following positive		|
	|			magnitude. It is an indication that all the bits of the positive magnitude are flipped to make		|
	|			a negative number											|
	|																|
	|			Internally addition and subtraction require no conditional inversions					|
	|			Subtraction is the addition of a ones complement							|
	|																|
	|			A number is normalised if bit 71 is different from sign bit 95						|
	|																|
	|			All unnormalised numbers have the algebraic value of zero						|
	|																|
	|			Rounding is determined by the pattern of high-order bits in register <b>fp$guard</b> at address 147		|
	|			(hex 93). <b>fp$guard</b> can only be written by interrupt code. Prototype kernel smaragd7 assigns a	 	|
	|			default value C00000 hex to <b>fp$guard</b> for every thread. <b>fp$guard</b> value is part of thread			|
	|			context and each thread may change its value with the system call					|
	|																|
	|					la	(<i>NEW_PATTERN</i>)									|
	|					ii	FP_GUARD$									|
	|																|
	|			This system call returns the rounding pattern from before in application register a			|
	|																|
	|																|
	|																|
	|																|
	|																|
	|			The format of an RTA1 floating number									|
	|			_____________________________________									|
	|																|
	|			95  94			 71								       0	|
	|			_________________________________________________________________________________________________	|
	|			|s|    characteristic	|				mantissa				|	|
	|			|_|_____________________|_______________________________________________________________________|	|
	|																|
	|																|
	|																|
	|_______________________________________________________________________________________________________________________________|
	|																|
	|																|
	|																|
	|			192-bit floating values											|
	|			_______________________											|
	|																|
	|																|
	|			PSR Flag <b>fp$r</b> signals floating instructions to store a minor result in registers 8..11			|
	|			giving this overall format in the eight registers a:b:mantissa2:mantissa3::8:9:10:11			|
	|																|
	|																|
	|			95 94			 71								       0	|
	|			_________________________________________________________________________________________________	|
	|	major result	|s|	characteristic	|				mantissa				|	|
	|			|_|_____________________|_______________________________________________________________________|	|
	|	minor result	|s|	characteristic	|				mantissa				|	|
	|			|_|_____________________|_______________________________________________________________________|	|
	|																|
	|																|
	|			The minor characteristic (exponent) is the major characteristic minus 72				|
	|			minus the normalising count of the minor mantissa							|
	|																|
	|			If the minor mantissa cannot be normalised because it is either positive zero or negative zero then 	|
	|			the minor result characteristic is all signs and the algebraic value of the minor result is zero	|
	|																|
	|			The minor mantissa is used in further operations to determine the low-order part 			|
	|			of 192-bit floating values										|
	|																|
	|			If a minor result is stored in registers 8..11 in compliance with <b>fp$r</b> then rounding per		|
	|			guard pattern register <b>fp$guard</b> takes place on the minor result and not the major result		|
	|																|
	|_______________________________________________________________________________________________________________________________|
	|																|
	|																|
	|																|
	|			Detecting and Correcting Exponent Underflow and Overflow						|
	|			________________________________________________________						|
	|																|
	|																|
	|			Floating point operations cannot store a true result if the exponent borrows or carries			|
	|			from its 23-bit field. These conditions are called exponent underflow and exponent overflow		|
	|																|
	|			Exponent underflow and exponent overflow are detected in RTA1 floating instruction architecture.	|
	|			Interrupt FP_XPO$ is raised										|
	|																|
	|			ISR FP_XPO$ in prototype kernel smaragd7 marks the event in the thread control block			|
	|																|
	|			The application may issue system call internal interrupt FP_XPO$FLAG at any time after			|
	|			exponent underflow/overflow may have been raised. FP_XPO$FLAG ISR					|
	|																|
	|				returns indicating exponent overflow/underflow has or has not been raised			|
	|																|
	|				resets the assertion which remains reset until exponent overflow/underflow is next raised	|
	|																|
	|			The reasons for accumulating underflow/overflow event for later examination are				|
	|																|
	|				RTA1 23-bit floating exponent field is so large that exponent overflow/underflow should		|
	|				never happen as an expected result of an application operation					|
	|																|
	|				Applications need no exponent field larger than 23 bits, but an oversight or			|
	|				misunderstanding in machine programming could cause exponent underflow or overflow		|
	|																|
	|				Realtime routines should not need to check continually for exponent overflow errors		|
	|				since, especially, many calculations are multiple operations in subroutines and libraries	|
	|																|
	|				If routines process values within the range							|
	|																|
	|					&plusmn;9.999999999999999999999e+1262610							|
	|																|
	|					&plusmn;9.999999999999999999999e-1262611							|
	|																|
	|				or in 192-bit floating algebra, the range							|
	|																|
	|					&plusmn;9.999999999999999999999999999999999999999999e+1262610					|
	|																|
	|					&plusmn;9.999999999999999999999999999999999999999999e-1262566					|
	|																|
	|				then exponent underflow/overflow is not raised.							|
	|																|
	|				Possible diminishing exponent "only" reaches -1262566 in 192-bit floating algebra		|
	|				because 192-bit values are maintained in two 96-bit numbers each with an exponent		|
	|																|
	|			Applications may check that no underflow/overflow has happened with call FP_XPO$FLAG			|
	|			If exponent underflow/overflow has been raised, the affected instruction may be pinpointed by		|
	|			repositioning the call to FP_XPO$FLAG. Call sequence is							|
	|																|
	|				ii	FP_XPO$FLAG										|
	|				j	<i>react</i>		. return + 0: underflow/overflow raised since last ii FP_XPO$FLAG	|
	|				.			. return + 1: exponent underflow/overflow has not been raised		|
	|																|
	|			The default behaviour of ISR FP_XPO$ which executes when exponent underflow/overflow occurs		|
	|			is to change the value in destination registers to -0.0 represented as all binary 1s. This		|
	|			may indicate exponent underflow/overflow, although -0.0 can also be a legitimate instruction result	|
	|																|
	|			FP_XPO$FLAG indication remains available although instructions subsequent to the operation		|
	|			may overwrite any indication in target application registers						|
	|																|
	|			If any one instruction in a sequence or routine has raised exponent underflow or overflow		|
	|			then the results of the instruction sequence are unusable						|
	|																|
	|			FP_XPO$FLAG return + 0 is a reliable indication that floating exponent underflow/overflow happened	|
	|			during execution of instructions leading up to the FP_XPO$FLAG enquiry					|
	|																|
	|			FP_XPO$FLAG return + 1 is equally a reliable indication that floating exponent underflow/overflow	|
	|			did not happen since the last FP_XPO$FLAG enquiry							|
	|																|
	|_______________________________________________________________________________________________________________________________|	
	


	<a	name="fpp"/>
	Floating Pop and Pack	fpp
	_____________________	___


				_________________________________________________________
				|							|
				|	the 96-bit floating point value at the		|
				|	internal stack top is compressed and stored	|
				|	as two words in registers or storage at EA	|
				|							|
				|	the high-order exponent bit and the		|
				|	10 low-order exponent bits are stored		|
				|							|
				|	the 36 high-order fraction bits are stored	|
				|							|
				|	no rounding takes place				|
				|							|
				|	internal stack pointer sp is incremented by 4	|
				|							|
				|_______________________________________________________|
				|	target is two registers or storage words at EA	|
				|	EA is any word address				|
				|_______________________________________________________|








                                 95                              71                           48
                                _________________________________________________________________
        4-word source from	| SXxx xxxx xxxx xxXX XXXX XXXX | MMMM MMMM MMMM MMMM MMMM MMMM |
        internal stack top      |_______________________________|_______________________________|
				| MMMM MMMM MMMM mmmm mmmm mmmm | mmmm mmmm mmmm mmmm mmmm mmmm |
				|_______________________________|_______________________________|
        			 47			         23     		       0


				
				compression to 48 bits retains	exponent bits 94,81..72
								fraction bits 71..36


                                _________________________________________________________________
        2-word stored		| SXXX XXXX XXXX MMMM MMMM MMMM | MMMM MMMM MMMM MMMM MMMM MMMM |
        pop target		|_______________________________|_______________________________|
 				 47				 23			      0


				midpoint exponent  XXX XXXX XXXX is stored in ranges 000..3FF:400..7FF
				equivalent to decimal scales -308..+308

				these example values are in 48-bit compressed format and range


				00:000000 3FF800000000         0.25d
				00:000002 C007FFFFFFFF        -0.25d
				00:000004 400800000000         0.5d
				00:000006 BFF7FFFFFFFF        -0.5d
				00:000000 7FFFFFFFFFFF         8.98846567418078014812d*+307
				00:000002 800000000000        -8.98846567418078014812d*+307
				00:000004 000FFFFFFFFF         5.56268464618705574232d*-309
				00:000006 FFF000000000        -5.56268464618705574232d*-309




	assembler syntax	fpp	floating_packed_storage[, {x|y|a|b|fp|sp}]

				fpp	*pointer_to_store



				_________________________________________________________
	Instruction Code 10.7	| 0 1 0 1 0 | 1 1 1 | . . . .  . . . . . . . . . . . .  |
				|___________|_______|___________________________________|









	<a	name="fpx"/>
	Floating Push and Expand	fpx
	________________________	___


				_________________________________________________________
				|							|
				|	the internal stack pointer sp is		|
				|	decremented by 4				|
				|							|
				|	the 48-bit compressed floating number at EA	|
				|	is expanded to 96 bits and placed at the	|
				|	internal stack top				|
				|							|
				|	the high-order bit of the restored exponent	|
				|	is followed by 12 bits of reverse polarity	|
				|	then the 10 remaining exponent bits		|
				|							|
				|	the 12 inserted bits are therefore signs if	|
				|	the exponent is midpoint or higher otherwise	|
				|	reverse signs					|
				|							|
				|	36 sign bits are added to the mantissa		|
				|							|
				|_______________________________________________________|
				|	source is two registers or storage words at EA	|
				|	EA is any word address				|
				|_______________________________________________________|




				________________________________________________________________
        2-word push source	| SXXX XXXX XXXX MMMM MMMM MMMM | MMMM MMMM MMMM MMMM MMMM MMMM |
				|_______________________________|_______________________________|
				 47                                                            0



				11 available exponent values are written to exponent positions 94,81:72
				the polar reverse of bit 94 is written to exponent positions 93..82

				the 23 bit exponent is restored in ranges 3FFC00..3FFFFF:400000..4003FF
				equivalent to decimal scales -308..+308

				36 available fraction values are written to fraction positions 71..36
				signs are written to fraction positions 35..0



				 95				 71			      48
				_________________________________________________________________
	4-word result on	| SXxx xxxx xxxx xxXX XXXX XXXX	| MMMM MMMM MMMM MMMM MMMM MMMM	| 
	internal stack top	|_______________________________|_______________________________|
				| MMMM MMMM MMMM SSSS SSSS SSSS | SSSS SSSS SSSS SSSS SSSS SSSS |
				|_______________________________|_______________________________|
				 47				 23			       0
				

				these example values are in the range which may be compressed and subsequently
				expanded without loss


				00:000000 3FFFFF800000000000000000	 0.25
				00:000004 C000007FFFFFFFFFFFFFFFFF	-0.25
				00:000008 400000800000000000000000	 0.5
				00:00000C BFFFFF7FFFFFFFFFFFFFFFFF	-0.5
				00:000010 4003FFFFFFFFFFF000000000	 8.98846567418078014812*+307
				00:000014 BFFC00000000000FFFFFFFFF	-8.98846567418078014812*+307
				00:000018 3FFC00FFFFFFFFF000000008	 5.56268464618705574232*-309
				00:00001C C003FF000000000FFFFFFFF7	-5.56268464618705574232*-309





	assembler syntax	fpx	floating_packed_storage[, {x|y|a|b|fp|sp}]

				fpx	*pointer_to_floating_packed

				fpx	(4.4510310377d*+300)


				_________________________________________________________
	Instruction Code 11.7	| 0 1 0 1 1 | 1 1 1 | . . . .  . . . . . . . . . . . .  |
				|___________|_______|___________________________________|







	<a	name="fa"/>
	Floating Add		fa
	_____________		__

				_________________________________________________________
				|							|
				|	the four-word floating-point number at EA	|
				|	is added to the four-word floating-point number	|
				|	in arithmetic registers a b mantissa2 mantissa3	|
				|							|
				|	Register a contains sign and characteristic bits|
				|	95..72 of one addend and of the sum		|
				|							|
				|	Registers b mantissa2 mantissa3 contain	the	|	
				|	mantissa of one addend and of the sum with	|
				|	highest order bits in Register b and lowest	|
				|	order bits in Register mantissa3		|
				|							|
				|	the word at EA contains sign and characteristic	|
				|	bits of the other addend. The highest order	|
				|	mantissa bits are at EA+1, bits 47..24 at EA+2	|
				|	and the lowest order mantissa bits are at EA+3	|
				|							|
				|_______________________________________________________|
				|	2nd addend is 4 registers or storage words at EA|
				|	EA is any word address				|
				|_______________________________________________________|



	assembler syntax	fa	addend[, {x|y|a|b|fp|sp}]

				fa	*pointer_to_addend

				fa	(2.50600004700003450630*+1262600)


				_________________________________________________________
	Instruction Code 12.7	| 0 1 1 0 0 | 1 1 1 | . . . .  . . . . . . . . . . . .  |
				|___________|_______|___________________________________|



	operation sequence	ql	first_addend
	192-bit values		on	fp$r
				fa	second_addend
				qs	sum
				off	fp$r
				ql	first_addend+4
				fa	$residue
				fa	second_addend+4
				  on	fp$r		. force super-normalisation
				  fa	sum		. between major and minor numbers
				  off	fp$r
				  qs	sum
				  ql	$residue	. especially if this sequence is iterative
				qs	sum+4





	<a	name="fan"/>
	Floating Add Negative		fan
	_____________________		___

				_________________________________________________________
				|							|
				|	the 1s complement of the four-word		|
				|	floating-point number at EA is added to		|
				|	the four-word floating-point number		|
				|	in arithmetic registers a b mantissa2 mantissa3	|
				|							|
				|	Register a contains sign and characteristic bits|
				|	95..72 of the minuend and of the difference	|
				|							|
				|	Registers b mantissa2 mantissa3 contain the	|	
				|	mantissa of the minuend and of the difference	|
				|	with highest order bits in Register b and	|
				|	lowest order bits in Register mantissa3		|
				|							|
				|	the word at EA contains sign and characteristic	|
				|	bits of the subtrahend. The highest order	|
				|	mantissa bits are at EA+1, bits 47..24 at EA+2	|
				|	ans the lowest order mantissa bits are at EA+3	|
				|							|
				|_______________________________________________________|
				|	subtrahend is 4 registers or storage words at EA|
				|	EA is any word address				|
				|_______________________________________________________|




	assembler syntax	fan	subtrahend[, {x|y|a|b|fp|sp}]

				fan	*subtrahend_indirectly

				fan	(457600004700003450.630*+1262001)


				_________________________________________________________
	Instruction Code 13.7	| 0 1 1 0 1 | 1 1 1 | . . . .  . . . . . . . . . . . .  |
				|___________|_______|___________________________________|



	operation sequence	ql	minuend
	192-bit values		on	fp$r
				fan	subtrahend
				qs	difference
				off	fp$r
				ql	minuend+4
				fan	subtrahend+4
				fa	$residue
				  on	fp$r		. force super-normalisation
				  fa	difference	. between major and minor numbers
				  off	fp$r
				  qs	difference
				  ql	$residue	. especially if this sequence is iterative
				qs	difference+4
				






	<a	name="fm"/>
	Floating Multiply	fm
	_________________	__

				_________________________________________________________
				|							|
				|	the four-word floating-point number		|
				|	in arithmetic registers a b mantissa2 mantissa3	|
				|	is multiplied by				|
				|	the four-word floating-point number at EA	|
				|							|
				|	Register a contains sign and characteristic bits|
				|	95..72 of the multiplicand and of the product	|
				|							|
				|	Registers b mantissa2 mantissa3 contain the	|	
				|	mantissa of the multiplicand and of the product	|
				|	with highest order bits in Register b and	|
				|	lowest oder bits in mantissa3			|
				|							|
				|	the word at EA contains sign and characteristic	|
				|	bits of the multiplier. The highest order	|
				|	mantissa bits are at EA+1, bits 47..24 at EA+2	|
				|	ans the lowest order mantissa bits are at EA+3	|
				|							|
				|_______________________________________________________|
				|	multiplier is 4 registers or storage words at EA|
				|	EA is any word address				|
				|_______________________________________________________|



	assembler syntax	fm	multiplier[, {x|y|a|b|fp|sp}]

				fm	*multiplier_indirectly

				fm	(250600004700003450.630*-1262001)


				_________________________________________________________
	Instruction Code 14.7	| 0 1 1 1 0 | 1 1 1 | . . . .  . . . . . . . . . . . .  |
				|___________|_______|___________________________________|


	operation sequence	ql	multiplicand
	192-bit values		on	fp$r
				fm	multiplier
				off	fp$r
				qs	product
				ql	multiplicand+4
				fm	multiplier
				fa	$residue
				  on	fp$r		. force super-normalisation
				  fa	product		. between major and minor numbers
				  off	fp$r
				  qs	product
				  ql	$residue	. especially if this sequence is iterative
				qs	product+4

				If the multiplier is represented in more than 96 bits, then the
				192-bit multiplicand is also multiplied by the minor multiplier
				and the two long products summed. Minor result <b>$residue</b> is
				needed during both multiplication sequences and during the final
				long addition






	<a	name="fd"/>
	Floating Divide		fd
	_______________		__

				_________________________________________________________
				|							|
				|	the four-word floating-point number 		|
				|	in arithmetic registers a b mantissa2 mantissa3	|
				|	is divided by					|
				|	the four-word floating-point number at EA 	|
				|							|
				|	Register a contains sign and characteristic bits|
				|	95..72 of the dividend and of the quotient	|
				|							|
				|	Registers b mantissa2 mantissa3 contain the	|	
				|	mantissa of the dividend and of the quotient	|
				|	with highest order bits in Register b and	|
				|	lowest oder bits in mantissa3			|
				|							|
				|	the word at EA contains sign and characteristic	|
				|	bits of the divisor. The highest order		|
				|	mantissa bits are at EA+1, bits 47..24 at EA+2	|
				|	ans the lowest order mantissa bits are at EA+3	|
				|							|
				|_______________________________________________________|
				|	divisor is four registers or storage words at EA|
				|	EA is any word address				|
				|_______________________________________________________|



	assembler syntax	fd	divisor[, {x|y|a|b|fp|sp}]

				fd	*divisor_indirectly

				fd	(458.600004700003450630*+1262001)


				_________________________________________________________
	Instruction Code 15.7	| 0 1 1 1 1 | 1 1 1 | . . . .  . . . . . . . . . . . .  |
				|___________|_______|___________________________________|


	operation sequence	ql	dividend
	192-bit values		on	fp$r
				fd	divisor
				off	fp$r
				qs	quotient
				ql	dividend+4
				fd	divisor
				fa	$residue
				  on	fp$r		. force super-normalisation
				  fa	quotient	. between major and minor numbers
				  off	fp$r
				  qs	quotient
				  ql	$residue	. especially if this sequence is iterative
				qs	quotient+4


				If the divisor value is represented in more than 96 bits,
				a quotient precise to 192 bits is obtained by multiplying
				by the reciprocal of the divisor

				Divisor values with an equivalent decimal exponent less than zero
				or greater than 31 are represented in more than 96 bits
 







	<a	name="gocall"/>
	<div	style="margin-left:28pt;font-family:times-roman;font-size:12.75pt;color:0000FF">	
	<i>3.6.16	Far Go and Call</i>
	</div>
	_________________________________________________________________________________________
	|				go and call Between Banks				|
	|_______________________________________________________________________________________|
	|											|
	|	Inter-bank jumps <b>go</b> and <b>call</b> read a single word storage operand			|
	|	of format									|
	|											|
	|											|
	|											|
	|											|
        |        		    21                6       0					|
	|	                ________________________________				|
        |       		|00|bbbb bbbb bbbb bbbb| vector|				|
	|	                |__|___________________|_______|				|
        |       		    16-bit pointer       6-bit					|
	|	                    to 4K bank edge      vector					|
	|											|
	|											|
        |       		OR								|
	|											|
	|											|
        |       		    21                    3   0					|
	|	                ________________________________				|
        |       		|01|bbbb bbbb bbbb bbbb bbb|vvv|				|
	|	                |__|_______________________|___|				|
        |       		    19-bit pointer          3-bit				|
	|	                    to 32K bank edge        vector				|
	|											|
	|											|
	|											|
	|	<b>call</b> instruction pushes the program-counter minus B0 * 4096 on the		|
	|	internal stack then pushes B0							|
	|											|
	|	<b>go</b> and <b>call</b> update the program counter						|
	|											|
	|											|
	|       B0 = (operand bit 22) ? operand[21..3] * 8 : operand[21..6] / 64		|
        |	PC = B0 * 4096 ++ (operand bit 22) ? operand[2..0] : operand[5..0]		|
	|											|
	|											|
	|											|
	|	                        _____________________					|
        |		                go / call destination					|
        |       		        _____________________					|
        |               		        |						|
	|                       	        |						|
	|       	        operand b22 = 0 | operand b22 = 1				|
        |	        	________________|________________				|
	|       	        |                               |				|
	|       	________|________               ________|________			|
	|	        | B0 =          |               | B0 = operand  |			|
        |		| operand /* 6  |               | AND 03FFFF8   |			|
	|	        |_______________|               |_______________|			|
        |		        |                               |				|
	| 		________|________               ________|________			|
	|	        | offset =      |               | offset =      |			|
        |		| operand AND 63|               | operand AND 7 |			|
	|       	|_______________|               |_______________|			|
	|       	        |                               |				|
        |	        	|_______________________________|				|
        |       	        	        |						|
        |               	        	|						|
	|	                        ________|________					|
        |		                | PC = B0 */ 12 |					|
        |       		        | OR offset     |					|
        |               		|_______________|					|
	|											|
	|											|
	|											|
	|											|
	|$ masmx ibj -ln									|
	|MASMX 7r3										|
	|3/ibj.msm										|
	|freeware/RTA1/rta/fs/fs.txo:$(0) 477 words decimal from hexadecimal 000000 to 0001DD	|
	|*EOF*											|
	|  :                            1							|
	|  :                            2:       $include        freeware/RTA1/rta/def/rta.def	|
	|  :                            3        $include,$void freeware/RTA1/rta/fs/fs.txo $(0)|
	|  :                            4 $(0:64)						|
	|00:000040 FF0100              +5        call            (seg$load)			|
	|  :                            6							|
	|  :                            7							|
	|  :                            8        $do             $<256,$(0:256)			|
	|  :                            9							|
	|*EOF*											|
	|00:000100+000187									|
	|:$(00):000040:000101									|
	|											|
	|_______________________________________________________________________________________|






	<a	name="go"/>
	Go			go
	__			__

				_________________________________________________________
				|							|
				|	Far Bank Jump					|
				|							|
				|							|
				|	target vector value is read from		|
				|	storage word or register at EA			|
				|							|
				|	depending bit 22 the storage operand contains	|
				|							|
				|		a 16-bit pointer to a bank at a 4Kword	|
				|		boundary and a 6-bit vector offset:	|
				|							|
				|		target bank starts at a 4Kword block in |
				|		first 256 Megawords of executable space	|
				|		and has 64 entry points			|
				|							|
				|	or	a 19-bit pointer to a bank at a 32Kword	|
				|		boundary and a 3-bit vector offset:	|
				|							|
				|		target bank starts at any 32Kword	|
				|		boundary in 16 Gigawords of executable	|
				|		space and has 8 entry points		|
				|							|
				|							|
				|	operand bit 22 = 0:				|
				|							|
				|		B0 = operand bits 21..6			|
				|		PC = B0 * 4096 + operand 5..0		|
				|							|
				|	operand bit 22 = 1:				|
				|							|
				|		B0 = operand word bits 21..3 * 8	|
				|		PC = B0 * 4096 + operand 2..0		|
				|							|
				|	operand bit 23 = 1:				|
				|							|
				|		translating target bank identifier	|
				|		not implemented				|
				|							|
				|_______________________________________________________|
				| 00 |       pointer to 4K-aligned bank   |       vector|
				|____|21__________________________________|5___________0|
				| 01 |       pointer to 32K-aligned bank         |vector|
				|____|21________________________________________ |2____0|
				|	     vector is in register / storage word at EA	|
				|_______________________________________________________|



	assembler syntax	go	target_identifier[, {x|y|a|b|fp|sp}]

				go	*target_identifier_indirectly

				go	(MEMORY/4096*64++VECTOR_0_63)

				go	(0400000++HIGH_MEMORY_ADDRESS/32768*8++VECTOR_0_7)



				_________________________________________________________
	Instruction Code 30.7	| 1 1 1 1 0 | 1 1 1 | . . . .  . . . . . . . . . . . .  |
				|___________|_______|___________________________________|







	<a	name="call"/>
	Call			call
	____			____

				_________________________________________________________
				|							|
				|	Far Bank Call					|
				|							|
				|	Program Counter minus B0 * 4096			|
				|	is pushed to internal stack			|
				|							|
				|	B0 is pushed to Internal Stack			|
				|							|
				|	target vector value is read from		|
				|	storage word or register at EA			|
				|							|
				|	depending bit 22 the storage operand contains	|
				|							|
				|		a 16-bit pointer to a bank at a 4Kword	|
				|		boundary and a 6-bit vector offset:	|
				|							|
				|		target bank starts at a 4Kword block in |
				|		first 256 Megawords of executable space	|
				|		and has 64 entry points			|
				|							|
				|	or	a 19-bit pointer to a bank at a 32Kword	|
				|		boundary and a 3-bit vector offset:	|
				|							|
				|		target bank starts at any 32Kword	|
				|		boundary in 16 Gigawords of executable	|
				|		space and has 8 entry points		|
				|							|
				|							|
				|	operand bit 22 = 0:				|
				|							|
				|		B0 = operand bits 21..6			|
				|		PC = B0 * 4096 + operand 5..0		|
				|							|
				|	operand bit 22 = 1:				|
				|							|
				|		B0 = operand word bits 21..3 * 8	|
				|		PC = B0 * 4096 + operand 2..0		|
				|							|
				|	operand bit 23 = 1:				|
				|							|
				|		translating target bank identifier	|
				|		not implemented				|
                                |                                                       |
                                |       on internal stack overflow / underflow		|
                                |       [sp < 26 | sp > 128] before operation           |
                                |       guard interrupt 95 is raised                    |
				|							|
				|_______________________________________________________|
				| 00 |       pointer to 4K-aligned bank   |       vector|
				|____|21__________________________________|5___________0|
				| 01 |       pointer to 32K-aligned bank         |vector|
				|____|21________________________________________ |2____0|
				|	     vector is in register/storage word at EA	|
				|_______________________________________________________|



	assembler syntax	call		target_identifier[, {x|y|a|b|fp|sp}]

				call		*target_identifier_indirectly

				call		(LOCATION/4096*64++VECTOR_0_63)

				call		(0400000++HIGH_MEMORY/32768*8++VECTOR_0_7)



				_________________________________________________________
	Instruction Code 31.7	| 1 1 1 1 1 | 1 1 1 | . . . .  . . . . . . . . . . . .  |
				|___________|_______|___________________________________|







<i>

    _____________________________________________________________________________________



    LICENCE NOTICE



    Copyright Tim Cox, 2012
    TimMilesCox@gmx.ch

    This processor programmable architecture specification
    is the principal and central work delivered here.

    It is the specification of the freeware processor architecture

                RTA1

    RTA1 is a free processor architecture specification. It is licensed
    under the GNU General Public Licence Version 3

    The executable emulation of RTA1 is free software.

    Instruction code for the target RTA1 architecture is free software
    if it is delivered with this software

    Software programs delivered with this software to connect the
    emulated RTA1 with real network interfaces in the emulator host
    are free software

    Scripts and programs delivered with this software for running
    on other computers and interacting with the RTA1 are free software

    Scripts and utility programs for constructing RTA1 target
    executable software are free software

    You can redistribute it and/or modify RTA1
    under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    RTA1 is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with RTA1.  If not, see &lt;http://www.gnu.org/licenses/&gt;.

</i>
</pre>
</div>
</html>
