<html>
<div>
<center>
<h1>
	The RTA1 Processor Architecture
</h1>
<i>
Copyright Tim Cox, 2012<br>
RTA1 Architecture is freeware licensed with the GNU General Public Licence Version 3<br>
This processor programmable architecture specification is the principal and central subject of the licence<br>
The same licence encompasses all accompanying software and documentation <br>
The full licence text is included with these materials<br>
See also the licensing notice at the foot of this document
</i>
<h2>
	Programmable Architecture Specification
</h2>
</center>
<h2>1. Overview and Address Spaces</h2>

<div	style="margin-left:60pt">
<i>
<p>
RTA1 is a computer processor architecture which has run in emulation on a Unix host computer since January 2012
<p>
Scalability is claimed for the RTA1 architecture. It can run simple dedicated microcontroller applications in a few dozen words of
storage, and it can run as a major system maintaining some millions of TCP connections simultaneously

<p>
RTA1 is designed for symmetric multiprocessing, an important plane of scalability

<p>
RTA specification has I/O space as well as memory space, making a further plane of scalability

<p>
Excellent code density is claimed for RTA1. The emulated prototype runs IP, UDP and TCP
in 3250 instructions which each take one storage location. Another 4000 instructions run Telnet,
MIB-II and snmp v1, a simple HTTP server, and an online floating point server program

<p>
IP in the emulated prototype is interfaced to real networks. RTA1 Telnet, SNMP, HTTP and ICMP interact
with other computers

<p>
The floating-point server application runs over UDP for interaction with RTA1 96-bit floating architecture
</i>
</div>

<h3>1.1 Overview</h3>
<p>
RTA1 is a 24-bit word-addressing architecture with 24- 48- and 96-bit arithmetic

<p>
The addressable storage location is the 24-bit computer word. Instructions are one computer word in size 

<h3>1.2	Executable Space and Array Space</h3>

<p>
The limit of executable space (or system memory) is 16 gigawords.

<p>
Additional arrays up to one teraword total which are not part of executable space
may be added.
RTA1 documentation calls these additional arrays devices, and they may each contain
up to 16 gigawords of 8- 16- or 24-bit memory. The devices may include among others
video RAMs, dual-ported 16-bit network buffers, memory-addressable 24-bit filestores,
and removable 8-bit memory sticks

<p>
System memory or executable space is Device 0, and there may be 63 more devices

<p>
There are arrays outside executable space because the relocation register format
can organise one space of 16 gigawords in banks of 4K Words. 4K organisation is
needed for executable space

<p>
Another 63 * 16-gigaword spaces can be organised in banks of 256K words

<p>
Relocation registers are one word in size to minimise cycles at context switch
and to make relocation values the width of I/O ports. Each relocation register
is implemented in one I/O port
<pre>


					executable space 16 gigawords
					_____________________________

			_________________________________________________
			|  22 page select bits	        | 12 offset bits|
			|_______________________________|_______________|
			|  16 bank select bits	|         18 offset bits|
			|_______________________|_______________________|


					array space 1 teraword
					______________________

		_________________________________________________________
		|device|   16 bank select bits  |         18 offset bits|
		|______|________________________|_______________________|








					relocation value, 4K bank (page)
					________________________________

				_________________________________________
				|00|		22 bank select bits	|
				|__|____________________________________|



					relocation value, 256K bank
					________________________________

				________________________________________
 				|01|	16 bank select bits	|device|
				|__|____________________________|______|


</pre>
Bit 22 of the relocation pointer is "big" or "big bank".
Device 0 is system memory, so system memory is placed the address space
in ranges of 4096-word blocks or in ranges of 262144-word blocks.

<p>
Device arrays can be placed in the address space in ranges of 262144-word blocks

<p>
There is an outline for increasing the executable space to 256 terawords.
Most applications do not need that, and the emulated prototype does not include it
<pre>

	_________________________________________________________________________________
	|										|
	|			ADDRESS SPACE AND EXECUTABLE SPACE			|
	|_______________________________________________________________________________|
	|										|
        |                                                                               |
	|	These definitions are offered for address space and executable space	|
	|										|
	|										|
	|	Address space is the space which the effective address can reach	|
	|       i.e. the space which code can see at one moment             		|
	|										|
	|	Different memory can be in the address space at different times		|
	|										|
	|	So long as it's the sort of memory that can be used for both code	|
	|	and data, that's executable space					|
	|										|
	|	In the RTA1 case that's the maximum 16 Gigawords of Device 0		|
	|	which is 1024 times the address space					|
	|										|
	|	RTA1 needs program memory to be						|
	|										|
	|		relocation-register-selectable in 4K-word banks			|
	|		and in 256K-word banks						|
	|										|
	|		24-bit-word writable / readable					|
	|										|
	|			optimally readable in bursts of 1 / 2 / 4 / 8 words	|
	|			at any 24-bit word address				|
	|										|
	|			optimally writable in bursts of 1 / 2 / 4 words		|
	|			at any 24-bit word address				|
	|										|
	|		able to do atomic read-modify-write on a single word		|
	|		at least when in SMP configuration				|
	|										|
	|										|
	|	Arrays outside executable space cannot be based at 4K-word granularity	|
	|	and need not necessarily read-rewrite atomically			|
	|										|
	|_______________________________________________________________________________|


</pre>
<h3>1.3 Address Space</h3>

<p>
RTA1 has a 16 megaword address space for instructions and operands. The address space
has many simultaneous fixed and moving windows on the 16 gigaword executable space
and the teraword array space


<h3>1.4 Operand Address Space</h3>
<p>
Operand address space starts with the 256 registers

<p>
Above address 256, operand address space is 16 megawords in 64 windows

<p>
Up to effective address 262144, address bits 17..12 select window 0..63
<pre>

					__________________________________
					| 0000 0000 0000 0000 | register |
					|_____________________|__________|

					__________________________________
					|000 000| window| 12 offset bits |
					|_______|_______|________________|
					| window|         18 offset bits |
					|_______|________________________|


</pre>
<p>
From effective address 262144, address bits 23..18 select window 1..63.

They are the same windows wider open

<p>
The 6-bit window index corresponds to a relocation pointer in I/O ports 0..63
(or to certain switchable alternatives in I/O ports 65..71)

<h3>1.5 Instruction Address Space</h3>

<p>
instructions are read in window B0. Window B0 is the physical bank at
the 4K-word bank-edge pointed by relocation register B0 in I/O Port 0

<p>
B0 is switchable between different physical instruction banks

<p>
Instructions are read from the leading edge of window B0 and not from
registers or any different address window

<p>
Window B0 is any size in 4K-granularity. The 48-bit program counter is absolute
and B0 base value is used to make jump addresses absolute and to make saved
addresses program-relative

<p>
Words 256..4095 of window B0 are in the operand address space as well as the
instruction window


<h3>1.6 The Internal Stack</h3>
<p>
RTA1 is intended to work very fast without having operand cache. The large array of
scratch registers is organised in an internal stack.

<p>
In the absence of operand cache, SMP configurations do not need cache coherency electronics

<p>
Software avoids double updates by recognising the scope of test-and-set locks

<p>
The internal stack has a logic footprint infinitessimally smaller than any level-one cache, 
but can produce a very large performance advantage

<p>
The part of the register stack available to an application is 128 words, and the part
of it organised in an internal stack is 104 words. The working of the internal stack is
somewhat inverse to an external stack.

<p>
Pushes and pops generate an operand effective address like all other instructions.

A push is a load into CPU registers in RTA1, and a pop is a store
<pre>


				A push is a load to the CPU in RTA1
				___________________________________


							_________________________________________
	________________________________		|					|
	|		|		|		|					|
	|		|		|		|					|
	|	CPU	|	scalar	|		|	total operand space
	|		|    registers	|		|	registers + storage
	|		|		|		|
	|		|_______________|		|
	|		|	sp--	|		|
	|		|_______________|		|
	|				|		|
	|				|		|
	|				|		|
	|	________________________|				_________________
	|new stack top	|	+	|<------<--------<--------<-----|     data	|
	|		|_______________|				|_______________|
	|		|		|		|
	|		|   internal	|		|
	|		|      stack	|






				A pop is a store from the CPU in RTA1
				_____________________________________


							_________________________________________
	________________________________		|					|
	|		|		|		|					|
	|		|		|		|					|
	|	CPU	|	scalar	|		|	total operand space
	|		|    registers	|		|	registers + storage
	|		|		|		|
	|		|_______________|		|
	|		|	sp++	|		|
	|		|_______________|		|
	|				|		|
	|				|		|
	|				|		|
	|		_ _ _ _ _ _ _ _ |				_________________
	|				|------>------>-------->------->|     data	|
	|	________|_______________|				|_______________|
	|new stack top	|		|		|
	|		|   internal	|		|
	|		|      stack	|




</pre>



<h3>1.7 Address Space Summary and Diagram</h3>

<pre>

	Summary of Instruction and Operand Address Spaces
	_________________________________________________


	Instructions are only obtained from window B0
	and B0 switches between instruction banks

	Operands may be obtained from the registers,
	from part of the actual instruction bank in window B0,
	from the 63 actual application data banks,
	from the seven alternative data banks used by the kernel

	An application may have gigawords of storage
	in blocks from 4096 words to 16 gigawords in size

	Up to 63 blocks of 4096 words or 262144 words
	are at any time visible in 63 address windows

	Relocation Registers 1..63 are I/O ports 1..63

	Applications can change which storage banks
	are based in their 63 data address windows

	The tasks's current data spaces do not need to
	be saved at context switch. They are already
	mirrored in the Thread Control Block





	instruction address	|  operand address space
	space			|
	________________________|________________________				
	|0			|0			|
	|			|	registers	|
	|			|255____________________|				TCB and six kernel banks can be
	|			 256			|				switched into address windows 1..7
	|						| 
	|	  Bank 0				|				their relocation base registers are
	|						|				I/O Ports 65..71
	|			 4095___________________|________________________
	|			|4096			|4096 alternative	|	TCB B65 holds an automatic copy of
	|			|			|			|	current relocation registers B2..B63
	|			|	Bank 1		|       Bank 65		|	B65 is visible instead of B1
	|			|			|	TCB		|	if PSR Flag see$1 = 1
	|			|8191___________________|_______________________|
	|			|8192			|8192 alternative	|	kernel banks 66..71 are populated
	|			|			|			|	to the extent of kernel requirement
	|			|	Bank 2		|	Bank 66		|	with either large or small banks
	|			|	Vector List	|	Kernel Vectors	|
	|			|12287__________________|_______________________|	kernel banks are visible instead
	|			|12288 or 786432	|12K / 768K alternative	|	of application data banks B2..B7
	|			|			|			|	as PSR Flags see$2..see$7 = 1
	|			|	Bank 3		|	Bank 67
	|			|			|
	|			|16383_or_1048575_______|_______________________
	|			|16384 or 1048576	|16K / 1024K alternative|
	|			|			|			|
	|			|	Bank 4		|	Bank 68
	|			|			|
	|			|_______________________|_______________________
	|			|20K or 1280K		|20K / 1280K alternative|
	|			|			|			|
	|			|	Bank 5		|	Bank 69
	|			|			|
	|			|_______________________|_______________________
	|			|24K or 1536K		|24K / 1536K alternative|
	|			|			|			|
	|			|	Bank 6		|	Bank 70		|
	|			|			|			|
	|			|_______________________|_______________________|
	|			|28K or 1792K		|28K / 1792K alternative|
	|			|			|			|
	|			|	Bank 7		|	Bank 71		|
	|			|			|			|
	|			|_______________________|_______________________|
	|			|32K or 2048K		|
	|			|			|
	|			|	Bank 8		|
	|			|			|
	|			|_______________________|
	|			|36K or 2304K		|
	|			|			|
	|			|	Bank 9		|
	|			|			|
	|			|_______________________|
	|			|40K or 2560K		|
	|			|			|
	|			|	Bank 10		|
	|			|			|
	|			|_______________________|
	|			|44K or 2816K		|
	|			|			|



				|			|
				|			|
				|_______________________|
				|248K or 15872K		|
				|			|
				|	Bank 62		|
				|			|
				|_______________________|
				|252K or 16128K		|
				|			|
				|	Bank 63		|
				|			|
				|262143_or_16777215_____|





	Addressing Arrays
	_________________

	Arrays less than the address space in size can be adressed all at once
	in one or more address windows

				_________________________
				|			|
		WINDOW n	|	.---------------|-------.
				|_______|_______________|	|
				|	|		|	|
		WINDOW n + 1	|	|		|	|
				|_______|_______________|	|<-----	array addressed
				|	|		|	|	in a range of
		WINDOW n + 2	|	|		|	|	address windows
				|_______|_______________|	|
				|	|		|	|
		WINDOW n + x	|	.---------------|-------.
				|_______________________|





	An array is one linear storage block of any size up to 16 gigawords. The prototype
	RTOS smaragd7 responds to memory requests with a single pointer

	When an array is many times the address space in size, address windows
	are used as cursors in the array

	If structures in the array straddle banks, the cursor should be two or more
	adjacent physical banks based in adjacent windows

	This allows the physical address of two or four word operands to be generated
	only once and data read or written in a single burst if memory supports that


	For example

			dl		array_offset
			dsl		6		. separate the bank-id from
							. the word offset

			orB, xi		WINDOW		. tag the word offset
			rbr		6		. with an address window


		.	____________________________
		.	|WINDOW|    word offset    |	<- effective adress
		.	|______|___________________|	   start of structure
		.					   in register b


			sal		6		. position the big-bank index
			aa		array_start_bank. add to array start for bank-id

			sabr		WINDOW		. base the bank where the structure
							. starts in the address window

			la, i		64, a		. identify the next big-bank id
			sabr		WINDOW+1	. base that in the adjacent 
							. address window

							. register b is now a pointer to a
							. guaranteed 262145 words from the
							. leading edge of the structure

							. this array is any size up to
							. 16 gigawords

	
</pre>


<h3>1.8 Device Array Protection</h3>

<p>
Banks in devices outside system memory can only be based by interrupt code. This is to prevent
accidental damage to anything like a static RAM file system. An inadvertant attempt to base
a device from an application raises the guard interrupt


<h3>1.9 Thread Switch and Address Space</h3>

Task current relocation pointers are not saved on task switch because they are
already mirrored in the TCB

<p>
Typically &frac34; of relocation registers are part of task context, OS depending

<p>
47 relocation registers are reloaded in 25 instructions


<p>
<h3>1.10 I/O Ports other than Relocation Registers</h3>

<p>
The emulated machine detects from Port 124 <b>ram$threshold</b> on system start how large its ROM is,
whether the ROM contains a system or just a boot page, and where RAM starts.

<p>
In the emulated machine, the boot ROM size is exactly the containing number of 4096-word blocks
where the emulator has loaded a complete system ROM image. RAM starts at the next page after that.

<p>
The emulated machine goes on to detect the size of system memory from Port 128 <b>device$flags</b>.
Devices like network interfaces and local file systems are detected by reading I/O ports 129 onwards.
These values are primed by the emulator to help the emulated machine to run.
Hardware implementations must wire the real memory and device information to I/O Ports 124, 128+ upwards



<h2>2. Registers and Instruction Set</h2>

<h3>2.1 Non-Addressable Registers</h3>

<p>
Two registers are not addressable. The program counter which contains an absolute address 48 bits in size, and the Processor State Register, which contains settings and the carry bit

<p>
The program counter is never stored as its absolute 48-bit value. Its value relative to the start of Bank 0
is saved on interrupts and calls. On interrupts and far (inter-bank) calls Bank 0 identity is also saved

<p>
The Processor State Register is saved on interrupts

<p>
The layout of the Processor State Register is
<pre>
		23             18   16     14           8   7   6   5   4           0
		_______________________________________________________________________
		| I | 0 0 0 0 | i i i | 0 | see$          | H | R | R | W | 0 0 0 | C |
		|   |         |       |   | 1 2 3 4 5 6 7 |   | Z |16 |16 |       |   |
		|___|_________|_______|___|_______________|___|___|___|___|_______|___|

</pre>
The PSR flags shown as 0 are not currently used
<p>
PSR flags 15..0 are directly application programmable with instructions <b>on</b> and <b>off</b>

<p>
Flag 23 <b>I</b> is on during an interrupt. CPU-side registers, that is those which receive computation results
or are stack pointers, index registers, the target of load instructions or the source of store instructions, automatic
counter or mask register, are in interrupt mode in the range 128..255. The application registers are 0..127

<p>
Registers addressed as storage operands are absolute locations in a 256-word array
regardless of ISR / application mode. However applications cannot write the interrupt registers

<p>
Flags 18..16 <b>iii</b> are the interrupt mask. Both applications and ISRs can swap and restore the
interrupt mask with the <b>Switch Interrupt Mask</b> instruction <b>sim</b>

<p>
Flags 14..8 <b>see$1..see$7</b> individually make the TCB and kernel banks visible in address windows 1..7,
instead of application data banks B1..B7

<p>
Flag 7 <b>half$w</b> concerns instructions which can take a byte operand as an alternative to a word operand.
RTA1 is not a byte addressing machine, and any byte other than a 24-bit byte is a field of a storage location.

The 32 instructions in Instruction File 1 may take a storage word or part of a storage word as operand.
These bytes are either halfwords (12 bits) with sign extension on read
<pre>

		 23			 11		       0
		_________________________________________________
		|	    h1		|	  h2		|
		|_______________________|_______________________|

</pre>
<p>
or else they are thirdwords (8 bits) with sign extension on read
<pre>

		 23		 15		 7	       0
		_________________________________________________
		|	t1	|	t2	|	t3	|
		|_______________|_______________|_______________|

</pre>		
<p>

But it is very undesirable that the File 1 Instructions should all have five different encodings
for accessing bytes. There are three byte-select encodings available in those instructions,
and flag <b>half$w</b> = 1 = halfword access, otherwise the application may access thirdwords

<p>
Flags 6 5 and 4 adjust the <b>Bit Stream Read Channel</b> and <b>Bit Stream Write Channel</b>

<p>
Flag 6 <b>b$streamZR</b> affects the operation of the <b>Read Staging Register</b> instruction <b>rsr</b>,
which makes a stream of bits or bytes serially available to the arithmetic registers

<p>
<b>b$streamZR</b> states that bits from the staging register <b>RDATA</b> shall be shifted into a cleared arithmetic register,
saving an extra instruction to mask the desired field. Otherwise the previous arithmetic register contents are shifted towards
the high order bit positions as new bits are transferred from <b>RDATA</b>

<p>
Flag 5 <b>b$stream16r</b> also affects the operation of <b>Read Staging Register</b>.
Only 16 bits are delivered from each input data word if <b>b$stream16r</b> = 1.
The high-order bits 23..16 are discarded when <b>b$stream16r</b> = 1.
This allows efficient handling with network data and with 16-bit peripherals.
If <b>b$stream16r</b> = 0 successive <b>rsr</b> instructions deliver all the 24 bits read from storage.

<p>
Flag 4 <b>b$stream16w</b> affects the operation of <b>Write Staging Register</b> instruction <b>wsr</b>
which writes a stream of bits or bytes from the arithmetic registers. Bits shifted into Staging Register
<b>WDATA</b> are stored at 16 bits per data word when <b>b$stream16w</b> = 1.
This allows efficient handling with network data and with 16-bit peripherals.
If <b>b$stream16w</b> = 0 successive <b>wsr</b> instructions compose 24 bits for each storage write.

<p>
Flag 0 <b>carry$</b> is set or cleared by this subset of the fixed point instructions
<ul>

	<li><b>aa</b>	Add to Register <b>a</b></li>
	<li><b>ab</b>	Add to Register <b>b</b></li>
	<li><b>ana</b>	Add Negative to Register <b>a</b></li>
	<li><b>anb</b>	Add Negative to Register <b>b</b></li>
	<li><b>da</b>	Double Length Add to <b>a:b</b></li>
	<li><b>dan</b>	Double Length Add Negative to <b>a:b</b></li>
	<li><b>src</b>	circular Shift Right through Carry</li>
	<li><b>slc</b>	circular Shift Left through Carry</li>
	<li><b>popA</b>	Pop and AddTo</li>

</ul>

<p>
The instructions which add the twos complement of the operand, <b>ana</b> <b>anb</b> <b>dan</b>,
have the same result in <b>carry$</b> as positive adds which have that twos complement as input operand.
Carry is set if addition at the register high order bit position carries, in all these instructions

<p>
There are no PSR condition bits other than <b>carry$</b>. All other conditions are available in the register
containing the instruction result. Many different results can be examined long after they are generated


<p>
The conditional jump instructions which examine carry or a register or storage word are
<ul>
	<li><b>jc</b>	Jump Carry</li>
	<li><b>jnc</b>	Jump No Carry</li>
	<li><b>jza</b>	Jump Zero <b>a</b></li>
	<li><b>jzb</b>	Jump Zero <b>b</b></li>
        <li><b>jnza</b> Jump NonZero <b>a</b></li>
        <li><b>jnzb</b> Jump NonZero <b>b</b></li>
	<li><b>jpa</b>	Jump Positive <b>a</b></li>
	<li><b>jpb</b>	Jump Positive <b>b</b></li>
	<li><b>jna</b>	Jump Negative <b>a</b></li>
	<li><b>jnb</b>	Jump Negative <b>b</b></li>
	<li><b>jpo</b>	Jump Parity Odd <b>a**k</b></li>
	<li><b>jao</b>	Jump <b>a</b> Odd</li>
	<li><b>jdz</b>	Jump Double Zero <b>a:b</b></li>
	<li><b>mta</b>	Masked Test <b>a</b> skip equal</li>
	<li><b>tz</b>	Test Zero location skip</li>
	<li><b>tp</b>	Test Positive location skip</li>
	<li><b>ts</b>	Test and Set location skip</li>
	<li><b>jxge</b> Jump <b>x</b> not less than <b>r</b></li>
	<li><b>jyge</b> Jump <b>y</b> not less than <b>r</b></li>
	<li><b>jdr</b>	Jump Decrement Repeat Register</li>
</ul>
<h3>2.2 Addressable Application and Interrupt Registers</h3>

<p>
RTA1 registers occur twice. The application has 128 registers and interrupts have 128 registers

<p>
All 256 registers are in the operand address space as one linear array

<p>
Some registers are implictly addressed as the register operand of an instruction.
These register-side operands are compartmented by application / interrupt context

<p>
The interrupt register set is a replica of the application register set, and has the same arithmetic registers,
index registers and special-purpose registers, with some minor differences

<p>
Having one set of interrupt registers does not mean that interrupts are not nested.
It means that certain much-used ISRs which are never nested in execution have a set of registers which can be used without saving.
Other ISRs wich may run nested must save registers before they change them.
Interrupts also have an internal stack made from 104 of their 128 registers.

<p>
An important category of interrupts which are never nested is application-callable kernel routines
which are implemented as internal interrupts. These have a set of registers for immediate free use,
and they only need to touch the application registers in order to read parameters and write results

<p>
It is advisable to implement a kernel routine as an internal interrupt instead of a call if the routine
temporarily manipulates the address space via the PSR flags. On return from interrupt the the saved PSR
is reloaded and all flags are restored


<pre>



		Layout of the Register Stack
		____________________________

		Notes
		_____

		Only registers 0..127 switch with the task

		The internal stack addressed with sp is only large enough for scalars and pointers
		Frame Pointer register fp is intended to be an external stack pointer for structures and arrays

		The application internal stack pointer is guarded from overflow (decrement
		below 24) and underflow (increment above 128). At sp = 128 the internal
		stack is completely empty. At sp = 24 the internal stack is completely full
		Stack range violation raises the guard interrupt at vector 1:31

		DAYCLOCK$U:DAYCLOCK$ are a feature not of RTA1 architecture but of the
		smaragd7 kernel developed to run the emulated prototype.

		The 48-bit millisecond counter is intended to be incremented by a timer
		interrupt sprung for example from a nanosecond decrementer providing
		additionally much finer-granule timer services. The emulated
		machine retrieves time periodically from the emulator host instead

		DAYCLOCK$U:DAYCLOCK$ are maintained in two scratch registers of the
		interrupt stack. All tasks can read them atomically as a pair with
		48-bit-operand instructions

		PRIORITY$ is a feature not of RTA1 architecture, but of the smaragd7 kernel
		developed to run the emulated prototype. It is a copy of the running task's
		priority stored here for quick retrieval at task switch

		REALTIME$_CLOCK is a decrementing timer count which switches the running
		task on expiry. If the initial REALTIME$_CLOCK value assigned to the task
		is zero, neither decrement nor switch interrupt takes place




			The Application Registers						  The Interrupt Registers
			_________________________						  _______________________


		 23			       0					 23			       0
		_________________________________					_________________________________
	0	|		r		|	repeat counter	 	128	|		r_x		|
		|_______________________________|					|_______________________________|
	1	|		k		|	mask register		129	|		k_x		|
		|_______________________________|					|_______________________________|
	2	|		x		|	index register		130	|		x_x		|
		|_______________________________|					|_______________________________|
	3	|		y		|	index register		131	|		y_x		|
		|_______________________________|					|_______________________________|
	4	|		a		|  arithmetic + index register	132	|		a_x		|
		|_______________________________|					|_______________________________|
	5	|		b		|  arithmetic + index register	133	|		b_x		|
		|_______________________________|					|_______________________________|
	6	|	mantissa2		|	arithmetic register	134	|	mantissa2_x		|
		|_______________________________|					|_______________________________|
	7	|	mantissa3		|	arithmetic register	135	|	mantissa3_x		|
		|_______________________________|					|_______________________________|
	8	|		aA		|	arithmetic register	136	|		aA_x		|
		|_______________________________|					|_______________________________|
	9	|		bA		|	arithmetic register	137	|		bA_x		|
		|_______________________________|					|_______________________________|
	10	|	mantissa2A		|	arithmetic register	138	|	mantissa2A_x		|
		|_______________________________|					|_______________________________|
	11	|	mantissa3A		|	arithmetic register	139	|	mantissa3A_x		|
		|_______________________________|					|_______________________________|
	12	|	    	 p		|	bitstream pointer write	140	|		p_x		|
		|_______________________________|					|_______________________________|
	13	|	   	 q		|	bitstream pointer read	141	|		q_x		|
		|_______________________________|					|_______________________________|
	14	|	  	 fp		|	index register		142	|		fp_x		|
		|_______________________________|					|_______________________________|
	15	|	  	 sp		|	index register		143	|		sp_x		|
		|_______________________________|					|_______________________________|
	16	|				|	scratch			144	|	REALTIME$_CLOCK		|
		|_______________________________|					|_______________________________|
	17	|				|	scratch			145	|	PRIORITY$		|
		|_______________________________|					|_______________________________|
	18	|				|	scratch			146	|	DAYCLOCK$U		|
		|_______________________________|					|_______________________________|
	19	|				|	scratch			147	|	DAYCLOCK$		|
		|_______________________________|					|_______________________________|
	20	|	   RDATAC		|	bitstream counter read	148	|	X_RDATAC		|
		|_______________________________|					|_______________________________|
	21	|	    RDATA		|	bitstream data read	149	|	 X_RDATA		|
		|_______________________________|					|_______________________________|
	22	|	   WDATAC		|	bitstream counter write	150	|	X_WDATAC		|
		|_______________________________|					|_______________________________|
	23	|	    WDATA		|	bitstream data write	151	|	 X_WDATA		|
		|_______________________________|					|_______________________________|
	24	| maximum internal stack top	|				152	|				|
		|_______________________________|					|_______________________________|
	25	|				|				153	|				|
		|_______________________________|					|_______________________________|
	26	|				|				154	|				|
		|_______________________________|					|_______________________________|
	27	|				|				155	|				|
		|_______________________________|					|_______________________________|
	28	|				|				156	|				|
		|_______________________________|					|_______________________________|
	29	|				|				157	|				|








	118									246
		|_______________________________|					|_______________________________|
	119	|				|				247	|				|
		|_______________________________|					|_______________________________|
	120	|				|				248	|				|
		|_______________________________|					|_______________________________|
	121	|				|				249	|				|
		|_______________________________|					|_______________________________|
	122	|				|				250	|				|
		|_______________________________|					|_______________________________|
	123	|				|				251	|				|
		|_______________________________|					|_______________________________|
	124	|				|				252	|				|
		|_______________________________|					|_______________________________|
	125	|				|				253	|				|
		|_______________________________|					|_______________________________|
	126	|				|				254	|				|
		|_______________________________|					|_______________________________|
	127	|				|	first pushed word	255	|				|
		|_______________________________|					|_______________________________|



</pre>


<h3>2.3 Instruction Set Summary</h3>


<p>
RTA1 instructions are grouped in 5 columns called instruction files.
The five instruction files map to eight operand characteristics.

<p>
Instruction File 1 spans six of the eight operand types. Instruction File 1 is integer operations with single word operand.
The 24-bit operand may be read from a word, a half or third word, or an immediate value

<p>
Instruction Files 4A and 5A are a small number of special instructions which only need an effective address immediate or a sign-extended immediate.

<p>
Instruction File 6 contains shifts and jumps which use the effective address as an immediate operand.

<p>
Instruction File 7 contains arithmetic instructions which have an operand of one, two or four words

<pre>

	RTA1 Instructions at a Glance
	_____________________________


	Instruction File 1				Instruction File 4A				Instruction File 5A
	__________________				___________________				___________________


	sr	Store Repeat Counter			inA	In Port to A				on	PSR Flags On
	sk	Store Mask Register			inB	In Port to B				off	PSR Flags Off

	sx	Store Index x				outA	Out A to Port				rsr	Read Staging Register
	sy	Store Index y				outB	Out B to Port				wsr	Write Staging Register

	sa	Store Arithmetic Register a		reload
	sb	Store Arithmetic Register b		emulator_cool

	z	Store Zero				sabr	Store a to Base Register		lret	local return
	pop												fret	far return

	lr	Load Repeat Counter
	lk	Load Mask Register

	lx	Load Index x
	ly	Load Index y

	la	Load Arithmetic Register a
	lb	Load Arithmetic Register b

	tz	Test Zero										ii	Internal Interrupt
	tp	Test Positive				jdz	Jump Double Zero			ir	Interrupt Return

	ax	Add to Index x
	ay	Add to Index y

	or	or a
	orB	or b

	and	and a
	andB	and b

	xor	Exclusive Or Arithmetic Register a
	xorB	Exclusive Or Arithmetic Register b

	aa	Add to a
	ab	Add to b

	ana	Add Negative to A
	anb	Add Negative to B

	m	Multiply
	mf	Multiply Fractional

	d	Divide
	push	




	Instruction File 6				Instruction File 7
	__________________				__________________

	sar	Shift a Right				ts	Test and Set
	sbr	Shift b Right				n	Negate

	dsr	Double Shift Right			inc	Increment
	jdr	Jump Decrement Repeat Counter		dec	Decrement

	sal	Shift a Left				sim	Switch Interrupt Mask
	sbl	Shift b Left				popA	Pop and AddTo

	dsl	Double Shift Left			src	Shift Circular Right through Carry
	lcal	Local Call				slc	Shift Circular Left through Carry

	rar	Rotate a Right				qs	Quadruple Store
	rbr	Rotate b Right				ql	Quadruple Load

	drr	Double Rotate Right			fpp	Floating Pop and Pack
	jnc	Jump No Carry				fpx	Floating Push and Expand

	ral	Rotate a Left				fa	Floating Add
	rbl	Rotate b Left				fan	Floating Add Negative

	drl	Double Rotate Left			fm	Floating Multiply
	jc	Jump on Carry				fd	Floating Divide

	saa	Shift a Algebraic			qpop	Quadruple Pop
	sba	Shift b Algebraic			qpush	Quadruple Push

	dsa	Double Shift Algebraic			ex	Execute
	jao	Jump a Odd				dpush	Double Push

	jpa	Jump Positive a				lsc	Load Shift and Count
	jpb	Jump Positive b				mta	Masked Test a

	j	Jump					sc	Store Carry
	jpo	Jump Parity Odd				mlb	Masked Load b

	jza	Jump Zero a				ds	Double Store
	jzb	Jump Zero b				dl	Double Load

	jnza	Jump NonZero a				da	Double Add
	jnzb	Jump NonZero b				dan	Double Add Negative

	jna	Jump Negative a				dlsc	Double Load Shift and Count
	jnb	Jump Negative b

	jxge	Jump x Not Less Than r			go	Far Bank Jump
	jyge	Jump y Not Less Than r			call	Far Bank Call


</pre>

<h3>2.4 Instruction Layout and Effective Address Generation</h3>

<p>
The operand code is marked J and determines the operand type
and which instruction file the instruction F is from

<p>
The instruction stem code is marked F and determines an instruction within the instruction file

<p>
Instructions in File 1 take an operand from types word / byte / immediate / sign-extended-immediate

<p>
Instructions in File 4A take an immediate operand, which is the effective address

<p>
Instructions in File 5A take a sign-extended immediate operand

<p>
Instructions in File 6 take the effective address as operand

<p>
Instructions in File 7 take a one-word two-word or four-word operand according to which instruction

<pre>


                                 23         18   15                            0
                                _________________________________________________
                                |     F    | J  |            address            |       instruction word
                                |__________|____|_______________________________|       ________________






			effective address generation
			____________________________


			If the operand code J is other than 5, an effective address is
			generated according to fields I X U of the address as shown here




                                 23         18     14    11                    0
                                _________________________________________________
                                |     F    | J  |I|  X  |           U           |       instruction word
                                |__________|____|_|_____|_______________________|       ________________
						|
						|15




			if I = 0 the effective address is 15 bits X U

			if I = 1

				if X = 0
					the effective address is indirect and found in in the storage word at 0 + U

					if U < 256 the indirect 24-bit address is the value in a register 
					otherwise the 24-bit indirect address is the value in a storage word
					in Bank 0 locations 256..4095


				if X = 1
					the effective address is indirect and found in the storage word at 
					4096 + U which is in Bank 1 (Bank 65 if see$1 is on)





				Base + Displacement Addressing I=1 and X = [2|3|4|5|6|7]
				________________________________________________________


				 23					       0
				_________________________________________________
				|		index value 24 bits		|	index register [x|y|a|b|fp|sp]
				|_______________________________________________|	______________________________
							|			|
							|    + displacement	|
							|    12 bits unsigned	|
				 23         18     14	 11	               0
	  			_________________________________________________
				|     F    | J  |I|  X  |	    U		|	instruction word
				|__________|____|_|_____|_______________________|	________________
						|
						|15			


				if X = 2
					the effective address is the sum of
					index register x plus the 12 unsigned bits U


				if X = 3
					the effective address is the sum of
					index register y plus the 12 unsigned bits U


				if X = 4
					the effective address is the sum of
					arithmetic register a plus the 12 unsigned bits U


				if X = 5
					the effective address is the sum of
					arithmetic register b plus the 12 unsigned bits U


				if X = 6
					the effective address is the sum of
					frame pointer register fp plus the 12 unsigned bits U


				if X = 7
					the effective address is the sum of
					stack pointer register sp plus the 12 unsigned bits U




			The meanings of operand code J
			______________________________


			000	The instruction is in Instruction File 1			mnemonic w0
				and the storage operand is the computer word
				at the effective address I X U					assembler syntax example
												________________________

												la		this_word
												sx		that_word, y, w0
												push		a_word

												ly		*indirectly

												________________________

												operand W0 = word is the default
												the mnemonic W0 need not be typed
												________________________


				 23					       0
				_________________________________________________
				|						|	register
				|_______________________________________________|	________
				|						|

				|						|

				|						|

				|_______________________________________________|
				|		       w0			|	storage
				|_______________________________________________|	_______
				 23					       0




 





			operand codes J 001..011 when PSR Flag half$w = 0
			_________________________________________________

			Partial words are only written and read in system memory

			Bytes are sign extended to a 24-bit word on load, including
			push to the internal stack from a byte of system memory

			Byte writes to storage are from the low-order bits of the
			source register, including byte writes to system memory
			from the register at the internal stack top----------------->		pop[,t1|t2|t3]	target

			Only 24-bit words are read from registers addressed as storage
			Only 24-bit words are written to registers addressed as storage

 


			001	The instruction is in Instruction File 1			mnemonic t1
				and the storage operand is bits 23..16 of
				the word at effective address I X U				assembler syntax example
												________________________

				load and store are to bits 7..0 of the CPU			lb, t1		structure, fp		
				register with sign extension on load				pop		outside,,t1

				bits 15..0 of the memory word are unchanged on store





				 23					       0
				_________________________________________________
				|<------- sign extension on read:		|	register
				|_______________________________________________|	________
								|		|
								|		
				<------------------------------->		|
				|						
										|
				|		<------------------------------->
						|		
				|_______________|_______________________________
				|	t1	|		|		|	storage
				|_______________|_______________|_______________|	_______
				 23	      16










			010	The instruction is in Instruction File 1			mnemonic t2
				and the storage operand is bits 15..8 of
				the word at effective address I X U				assembler syntax example
												________________________

				load and store are to bits 7..0 of the CPU			andB, t2	record, y		
				register with sign extension on load				tp		reaction, fp, t2
												sr, t2		latent_parameter
				bits 23..16, 7..0 of the memory word
				are unchanged on store



 



 


				 23					       0
				_________________________________________________
				|<------- sign extension on read:		|	register
				|_______________________________________________|	________
								|		|
								|		
						<--------------->		|
						|				
										|
						|		<--------------->
								|		
				________________|_______________|_______________
				|		|	t2	|		|	storage
				|_______________|_______________|_______________|	_______
						 15	       8








			011	The instruction is in Instruction File 1			mnemonic t3
				and the storage operand is bits 7..0 of
				the word at effective address I X U				assembler syntax example
												________________________

				load and store are to bits 7..0 of the CPU			d, t3		divisor_array, x
				register with sign extension on load				push		everyone,,t3

				bits 23..8 are unchanged on store

				PARTIAL WORDS MAY ONLY BE READ FROM SYSTEM			xor, t3		keyvalue
				MEMORY AND WRITTEN TO SYSTEM MEMORY

				REGISTERS ARE 24-BIT WORD SCALARS
				OR MULTI-WORD-SCALARS






				 23					       0
				_________________________________________________
				|<------- sign extension on read:		|	register
				|_______________________________________________|	________
								|		|
										
								|		|
										
								|		|
												
				|_______________________________|_______________|
				|		|		|	t3	|	storage
				|_______________|_______________|_______________|	_______
								 7	       0








			operand codes J 010..011 when PSR Flag half$w = 1
			_________________________________________________

                        Partial words are only written and read in system memory

                        Bytes are sign extended to a 24-bit word on load, including
                        push to the internal stack from a byte of system memory

                        Byte writes to storage are from the low-order bits of the
                        source register, including byte writes to system memory
                        from the register at the internal stack top----------------->		pop[,h1|h2]	 target

                        Only 24-bit words are read from registers addressed as storage
                        Only 24-bit words are written to registers addressed as storage




			010	The instruction is in Instruction File 1			mnemonic h1
				and the storage operand is bits 23..12 of
				the word at effective address I X U				assembler syntax example
												________________________

				load and store are to bits 11..0 of the CPU			lb, h1		katakana_table, a
				register with sign extension on load				z		restart_counter,,h1

				bits 11..0 of the memory word are unchanged on store



 


				 23					       0
				_________________________________________________
				|<------- sign extension:			|	register
				|_______________________________________________|	________
							|			|
							|			
				<----------------------->			|
				|						
										|
				|			<----------------------->
							|		
				|_______________________|_______________________
				|	    h1		|			|	storage
				|_______________________|_______________________|	_______
				 23		      12




 







			011	The instruction is in Instruction File 1			mnemonic h2
				and the storage operand is bits 11..0 of
				the word at effective address I X U				assembler syntax example
												________________________

				load and store are to bits 11..0 of the CPU			tz, h2		restart_counter
				register with sign extension on load				pop		along, b, h2

				bits 23..12 of the memory word are unchanged on store





				 23					       0
				_________________________________________________
				|<------- sign extension:			|	register
				|_______________________________________________|	________
							|			|
										
							|			|
										
							|			|		
				________________________|_______________________|
				|			|	   h2		|	storage
				|_______________________|_______________________|	_______
							 11		       0








			Operand Codes J 100..111
			________________________

			100	The instruction is in Instruction File 1			mnemomic i
				and the immediate operand is the effective
				address with or without indirection or indexing			assembler syntax example
												________________________

												lr, i		4, x

												lx, i		frame_size, sp
												aa, i		63



				instructions in Instruction File 4A also have J			sabr		BASE_REGISTER_33
				code 100 and the effective address as operand			inB		PORT_131A






			101	The instruction is in Instruction File 1			mnemonic xi
				and the sign extended immediate operand
				is I X U = bits 15..0 of the instruction word			assembler syntax example
												________________________

												ax, xi		-FRAME_SIZE

												ly, xi		$literal("ISBN %s ":;
															 "Title %s ":;
															 "Author %s\n")

												push, xi	-12500



				 23					       0
			 	_________________________________________________
				|+sign extension+				|	register
				|_______________________________________________|	_______
						|				|
										
						|				|
										
										
						|				|
				________________|_______________________________|
				| ffff f  | 101	|	   immediate		|	instruction
				|_________|_____|_______________________________|	___________
						 15			       0






				instructions in Instruction File 5A also have J			rsr		BYTE_SIZE
				code 101 and the sign extended address fields I X U		on		see$6++see$7
				as operand
												lret		+1



			110	The instruction is in Instruction File 6 and the		assembler syntax example
				operand is the effective address after any			________________________
				indirection or indexing
												drl		BYTE_SIZE
												dsr		15, x
												j		*somewhere
												jc		not_less
												sal		*PAGE_SIZE_LOG
												lcal		0, a



			111	The instruction is in Instruction File 7 and the		assembler syntax example
				operand is one or two or four words at the			________________________
				effective address I X U

												fm	$literals_B3(1.633*-1200009)

												qpush		segment:sequence
												

												dlsc		mantissa
												ds		normalised

												popA		byte_count, x



</pre>

<h3>2.5 Instructions</h3>

<h5>Note on Instruction Layout vs Assembly Language Syntax</h5>

<p>
No instruction has both *indirection and indexing
<p>
File 1 and File 5A instructions, J=5, with sign extended immediate operand,,xi can have neither *indirection nor indexing


<h5>Instruction File 1</h5>
<p>
22 File 1 instructions read a one-word operand, a third or halfword, the effective address itself as an immediate operand, or a sign-extended immediate operand.

<p>
10 File 1 instructions write or test a word, or a third or halfword, but not an immediate operand.

<p>
An operand mode J mnemonic may be typed either after the instruction mnemonic or the after the index position in the assembly language syntax of File 1 instructions
<pre>


		ay, i		4, b

		ay		4, b, i

		push		-640,,xi

		la, t1		record_control_word, y


</pre>
<p>
File 1 instructions can read or write thirdwords when PSR Flag <b>half$w</b> = 0 and halfwords when PSR Flag <b>half$w</b> = 1
<pre>


	Store Repeat Counter	sr
	____________________	__

				_________________________________________________________
				|							|
				|	store Repeat Counter Register r		 	|
				|_______________________________________________________|
				|	destination is memory/register at EA		|
				|	memory target may be a word, half or thirdword	|
				|_______________________________________________________|



	assembler syntax	sr[, {w0|h1|h2}]		target[, {x|y|a|b|fp|sp}] 	

				sr[, {w0|t1|t2|t3}]		target[, {x|y|a|b|fp|sp}]

				sr[, {w0|h1|h2}]		*ptarget	

				sr[, {w0|t1|t2|t3}]		*ptarget

				sr				target[, {x|y|a|b|fp|sp}][, {w0|h1|h2}] 	

				sr				target[, {x|y|a|b|fp|sp}][, {w0|t1|t2|t3}]

				sr				*ptarget[,, {w0|h1|h2}] 	

				sr				*ptarget[,, {w0|t1|t2|t3}]


	assembler examples	sr		target
				sr, h2		target
				sr		target,b,t1
				sr		*ptarget,,h1

				_________________________________________________________
	Instruction Code 0	| 0 0 0 0 0 | 0 . . | . . . .  . . . . . . . . . . . .  |
				|___________|_______|___________________________________|
				





	Store Mask Register	sk
	___________________	__

				_________________________________________________________
				|							|
				|	store Mask Register k				|
				|_______________________________________________________|
				|	destination is memory/register at EA		|
				|	memory target may be a word, half or thirdword	|
				|_______________________________________________________|



	assembler syntax	sk[, {w0|h1|h2}]		target[, {x|y|a|b|fp|sp}] 	

				sk[, {w0|t1|t2|t3}]		target[, {x|y|a|b|fp|sp}]

				sk[, {w0|h1|h2}]		*ptarget	

				sk[, {w0|t1|t2|t3}]		*ptarget

				sk				target[, {x|y|a|b|fp|sp}][, {w0|h1|h2}] 	

				sk				target[, {x|y|a|b|fp|sp}][, {w0|t1|t2|t3}]

				sk				*ptarget[,, {w0|h1|h2}] 	

				sk				*ptarget[,, {w0|t1|t2|t3}]


	assembler examples	sk		target
				sk, h2		target, x
				sk		target,,t1
				sk		*ptarget,,h1

				_________________________________________________________
	Instruction Code 1	| 0 0 0 0 1 | 0 . . | . . . .  . . . . . . . . . . . .  |
				|___________|_______|___________________________________|
				





	Store Index Register x	sx
	______________________	__


				_________________________________________________________
				|							|
				|	store Index Register x				|
				|_______________________________________________________|
				|	destination is memory/register at EA		|
				|	memory target may be a word, half or thirdword	|
				|_______________________________________________________|


	assembler syntax	sx[, {w0|h1|h2}]		target[, {x|y|a|b|fp|sp}] 	

				sx[, {w0|t1|t2|t3}]		target[, {x|y|a|b|fp|sp}]

				sx[, {w0|h1|h2}]		*ptarget	

				sx[, {w0|t1|t2|t3}]		*ptarget

				sx				target[, {x|y|a|b|fp|sp}][, {w0|h1|h2}] 	

				sx				target[, {x|y|a|b|fp|sp}][, {w0|t1|t2|t3}]

				sx				*ptarget[,, {w0|h1|h2}] 	

				sx				*ptarget[,, {w0|t1|t2|t3}]


	assembler examples	sx		target, a
				sx, h2		target
				sx		target,,t1
				sx		*ptarget,,h1

				_________________________________________________________
	Instruction Code 2	| 0 0 0 1 0 | 0 . . | . . . .  . . . . . . . . . . . .  |
				|___________|_______|___________________________________|
				



	Store Index Register y	sy
	______________________	__

				_________________________________________________________
				|							|
				|	store Index Register y				|
				|_______________________________________________________|
				|	destination is memory/register at EA		|
				|	memory target may be a word, half or thirdword	|
				|_______________________________________________________|


	assembler syntax	sy[, {w0|h1|h2}]		target[, {x|y|a|b|fp|sp}] 	

				sy[, {w0|t1|t2|t3}]		target[, {x|y|a|b|fp|sp}]

				sy[, {w0|h1|h2}]		*ptarget	

				sy[, {w0|t1|t2|t3}]		*ptarget

				sy				target[, {x|y|a|b|fp|sp}][, {w0|h1|h2}] 	

				sy				target[, {x|y|a|b|fp|sp}][, {w0|t1|t2|t3}]

				sy				*ptarget[,, {w0|h1|h2}] 	

				sy				*ptarget[,, {w0|t1|t2|t3}]


	assembler examples	sy		target
				sy, h2		target
				sy		target,b,t1
				sy		*ptarget,,h1

				_________________________________________________________
	Instruction Code 3	| 0 0 0 1 1 | 0 . . | . . . .  . . . . . . . . . . . .  |
				|___________|_______|___________________________________|
				



	Store Arithmetic Register a	sa
	___________________________	__


				_________________________________________________________
				|							|
				|	store Arithmetic Register a			|
				|_______________________________________________________|
				|	destination is memory/register at EA		|
				|	memory target may be a word, half or thirdword	|
				|_______________________________________________________|



	assembler syntax	sa[, {w0|h1|h2}]		target[, {x|y|a|b|fp|sp}] 	

				sa[, {w0|t1|t2|t3}]		target[, {x|y|a|b|fp|sp}]

				sa[, {w0|h1|h2}]		*ptarget	

				sa[, {w0|t1|t2|t3}]		*ptarget

				sa				target[, {x|y|a|b|fp|sp}][, {w0|h1|h2}] 	

				sa				target[, {x|y|a|b|fp|sp}][, {w0|t1|t2|t3}]

				sa				*ptarget[,, {w0|h1|h2}] 	

				sa				*ptarget[,, {w0|t1|t2|t3}]


	assembler examples	sa		target, x
				sa		*(31*/18++OFFSET)
				sa, h2		target
				sa		target,,t1
				sa		*ptarget,,h1

				_________________________________________________________
	Instruction Code 4	| 0 0 1 0 0 | 0 . . | . . . .  . . . . . . . . . . . .  |
				|___________|_______|___________________________________|
				



	Store Arithmetic Register b	sb
	___________________________	__


				_________________________________________________________
				|							|
				|	store Arithmetic Register B			|
				|_______________________________________________________|
				|	destination is memory/registe at EA		|
				|	memory target may be a word, half or thirdword	|
				|_______________________________________________________|


	assembler syntax	sb[, {w0|h1|h2}]		target[, {x|y|a|b|fp|sp}] 	

				sb[, {w0|t1|t2|t3}]		target[, {x|y|a|b|fp|sp}]

				sb[, {w0|h1|h2}]		*ptarget	

				sb[, {w0|t1|t2|t3}]		*ptarget

				sb				target[, {x|y|a|b|fp|sp}][, {w0|h1|h2}] 	

				sb				target[, {x|y|a|b|fp|sp}][, {w0|t1|t2|t3}]

				sb				*ptarget[,, {w0|h1|h2}] 	

				sb				*ptarget[,, {w0|t1|t2|t3}]


	assembler examples	sb		target
				sb, h2		target
				sb		target,y,t1
				sb		*ptarget,,h1

				_________________________________________________________
	Instruction Code 5	| 0 0 1 0 1 | 0 . . | . . . .  . . . . . . . . . . . .  |
				|___________|_______|___________________________________|
				




	Store Zero		z
	__________		_


				_________________________________________________________
				|							|
				|	write zero to the operand			|
				|_______________________________________________________|
				|	destination is memory/register at EA		|
				|	memory target may be a word, half or thirdword	|
				|_______________________________________________________|


	assembler syntax	z[, {w0|h1|h2}]			target[, {x|y|a|b|fp|sp}] 	

				z[, {w0|t1|t2|t3}]		target[, {x|y|a|b|fp|sp}]

				z[, {w0|h1|h2}]			*ptarget	

				z[, {w0|t1|t2|t3}]		*ptarget

				z				target[, {x|y|a|b|fp|sp}][, {w0|h1|h2}] 	

				z				target[, {x|y|a|b|fp|sp}][, {w0|t1|t2|t3}]

				z				*ptarget[,, {w0|h1|h2}] 	

				z				*ptarget[,, {w0|t1|t2|t3}]


	assembler examples	z		target, fp
				z, h2		target
				z		target,,t1
				z		*ptarget,,h1

				_________________________________________________________
	Instruction Code 6	| 0 0 1 1 0 | 0 . . | . . . .  . . . . . . . . . . . .  |
				|___________|_______|___________________________________|
				



	pop			pop
	___			___

				_________________________________________________________
				|							|
				|	store the word on the internal stack top	| 
				|	at the operand address. sp is incremented	|
				|_______________________________________________________|
                                |       on internal stack overflow / underflow		|
                                |       [sp < 24 | sp > 127] before operation           |
                                |       guard interrupt 95 is raised                    |
				|_______________________________________________________|
				|	destination is memory/register at EA		|
				|	memory target may be a word, half or thirdword	|
				|_______________________________________________________|


	assembler syntax	pop[, {w0|h1|h2}]		target[, {x|y|a|b|fp|sp}] 	

				pop[, {w0|t1|t2|t3}]		target[, {x|y|a|b|fp|sp}]

				pop[, {w0|h1|h2}]		*ptarget

				pop[, {w0|t1|t2|t3}]		*ptarget

				pop				target[, {x|y|a|b|fp|sp}][, {w0|h1|h2}] 	

				pop				target[, {x|y|a|b|fp|sp}][, {w0|t1|t2|t3}]

				pop				*ptarget[,, {w0|h1|h2}] 	

				pop				*ptarget[,, {w0|t1|t2|t3}]


	assembler examples	pop		target
				pop, h2		target
				pop		target,b,t1
				pop		*ptarget,,h1

				_________________________________________________________
	Instruction Code 7	| 0 0 1 1 1 | 0 . . | . . . .  . . . . . . . . . . . .  |
				|___________|_______|___________________________________|
				



	Load Repeat Counter	lr
	__________________	__


				_________________________________________________________
				|							|
				|	load operand to Repeat Counter Register r 	|
				|_______________________________________________________|
				|	operand is memory/register value at EA		|
				|	or the value EA or a signed immediate		|
				|	memory source may be a word, half or thirdword	|
				|_______________________________________________________|




	assembler syntax	lr[, {w0|h1|h2|i}]		target[, {x|y|a|b|fp|sp}] 	

				lr[, {w0|t1|t2|t3|i}]		target[, {x|y|a|b|fp|sp}]

				lr[, {w0|h1|h2|i}]		*ptarget

				lr[, {w0|t1|t2|t3|i}]		*ptarget

				lr, i				VALUE[, {x|y|a|b|fp|sp}]

				lr, xi				VALUE

				lr				target[, {x|y|a|b|fp|sp}][, {w0|h1|h2|i}] 	

				lr				target[, {x|y|a|b|fp|sp}][, {w0|t1|t2|t3|i}]

				lr				*ptarget[,, {w0|h1|h2|i}] 	

				lr				*ptarget[,, {w0|t1|t2|t3|i}]

				lr				VALUE[, {x|y|a|b|fp|sp}], i

				lr				VALUE,, xi


	assembler examples	lr			target, sp
				lr			(5000000)
				lr, h2			target
				lr			target,,t1
				lr			*ptarget,,h1

				lr, xi			-48000/2
				lr			12, y, i
				lr, i			apointer
				lr, i			*apointer	[ = lr	apointer ]

				_________________________________________________________
	Instruction Code 8	| 0 1 0 0 0 | . . . | . . . .  . . . . . . . . . . . .  |
				|___________|_______|___________________________________|
				






	Load Mask Register	lk
	__________________	__


				_________________________________________________________
				|							|
				|	load operand to Mask Register k 		|
				|_______________________________________________________|
				|	operand is memory/register value at EA		|
				|	or the value EA or a signed immediate		|
				|	memory source may be a word, half or thirdword	|
				|_______________________________________________________|




	assembler syntax	lk[, {w0|h1|h2|i}]		mask[, {x|y|a|b|fp|sp}] 	

				lk[, {w0|t1|t2|t3|i}]		mask[, {x|y|a|b|fp|sp}]

				lk[, {w0|h1|h2|i}]		*pmask

				lk[, {w0|t1|t2|t3|i}]		*pmask

				lk, i				MASK[, {x|y|a|b|fp|sp}]

				lk, xi				MASK

				lk				mask[, {x|y|a|b|fp|sp}][, {w0|h1|h2|i}] 	

				lk				mask[, {x|y|a|b|fp|sp}][, {w0|t1|t2|t3|i}]

				lk				*pmask[,, {w0|h1|h2|i}] 	

				lk				*pmask[,, {w0|t1|t2|t3|i}]

				lk				MASK[, {x|y|a|b|fp|sp}], i

				lk				MASK,, xi


	assembler examples	lk			mask
				lk			(0FC0000:s)
				lk, h2			mask, y
				lk			mask,,t1
				lk			*ptarget,,h1

				lk, xi			-48000/2
				lk			12, y, i
				lk, i			apointer
				lk, i			*apointer	[ = lk	apointer ]

				_________________________________________________________
	Instruction Code 9	| 0 1 0 0 1 | . . . | . . . .  . . . . . . . . . . . .  |
				|___________|_______|___________________________________|
				






	Load Index Register x	lx
	_____________________	__


				_________________________________________________________
				|							|
				|	load operand to Index Register x 		|
				|_______________________________________________________|
				|	operand is memory/register value at EA		|
				|	or the value EA or a signed immediate		|
				|	memory source may be a word, half or thirdword	|
				|_______________________________________________________|



	assembler syntax	lx[, {w0|h1|h2|i}]		target[, {x|y|a|b|fp|sp}] 	

				lx[, {w0|t1|t2|t3|i}]		target[, {x|y|a|b|fp|sp}]

				lx[, {w0|h1|h2|i}]		*ptarget

				lx[, {w0|t1|t2|t3|i}]		*ptarget

				lx, i				VALUE[, {x|y|a|b|fp|sp}]

				lx, xi				VALUE

				lx				target[, {x|y|a|b|fp|sp}][, {w0|h1|h2|i}] 	

				lx				target[, {x|y|a|b|fp|sp}][, {w0|t1|t2|t3|i}]

				lx				*ptarget[,, {w0|h1|h2|i}] 	

				lx				*ptarget[,, {w0|t1|t2|t3|i}]

				lx				VALUE[, {x|y|a|b|fp|sp}], i

				lx				VALUE,, xi


	assembler examples	lx			target, b
				lx			(47*/18++240:s)
				lx, h2			target
				lx			target,,t1
				lx			*ptarget,,h1

				lx, xi			-48000/2
				lx			12, y, i
				lx, i			apointer
				lx, i			*apointer	[ = lx	apointer ]

				_________________________________________________________
	Instruction Code 10	| 0 1 0 1 0 | . . . | . . . .  . . . . . . . . . . . .  |
				|___________|_______|___________________________________|
				






	Load Index Register y	ly
	_____________________	__


				_________________________________________________________
				|							|
				|	load operand to Index Register y		|
				|_______________________________________________________|
				|	operand is memory/register value at EA		|
				|	or the value EA or a signed immediate		|
				|	memory source may be a word, half or thirdword	|
				|_______________________________________________________|



	assembler syntax	ly[, {w0|h1|h2|i}]		target[, {x|y|a|b|fp|sp}] 	

				ly[, {w0|t1|t2|t3|i}]		target[, {x|y|a|b|fp|sp}]

				ly[, {w0|h1|h2|i}]		*ptarget

				ly[, {w0|t1|t2|t3|i}]		*ptarget

				ly, i				VALUE[, {x|y|a|b|fp|sp}]

				ly, xi				VALUE

				ly				target[, {x|y|a|b|fp|sp}][, {w0|h1|h2|i}] 	

				ly				target[, {x|y|a|b|fp|sp}][, {w0|t1|t2|t3|i}]

				ly				*ptarget[,, {w0|h1|h2|i}] 	

				ly				*ptarget[,, {w0|t1|t2|t3|i}]

				ly				VALUE[, {x|y|a|b|fp|sp}], i

				ly				VALUE,, xi


	assembler examples	ly			target
				ly			*(HIGH_ORDER_ADDRESS:s)
				ly, h2			target, a
				ly			target,,t1
				ly			*ptarget

				ly, xi			-48000/2
				ly			12, y, i
				ly, i			apointer
				ly, i			*apointer	[ = ly	apointer ]

				_________________________________________________________
	Instruction Code 11	| 0 1 0 1 1 | . . . | . . . .  . . . . . . . . . . . .  |
				|___________|_______|___________________________________|
				






	Load Arithmetic Register a	la
	__________________________	___


				_________________________________________________________
				|							|
				|	load operand to Arithmetic Register a		|
				|_______________________________________________________|
				|	operand is memory/register value at EA		|
				|	or the value EA or a signed immediate		|
				|	memory source may be a word, half or thirdword	|
				|_______________________________________________________|





	assembler syntax	la[, {w0|h1|h2|i}]		target[, {x|y|a|b|fp|sp}] 	

				la[, {w0|t1|t2|t3|i}]		target[, {x|y|a|b|fp|sp}]

				la[, {w0|h1|h2|i}]		*ptarget

				la[, {w0|t1|t2|t3|i}]		*ptarget

				la, i				VALUE[, {x|y|a|b|fp|sp}]

				la, xi				VALUE

				la				target[, {x|y|a|b|fp|sp}][, {w0|h1|h2|i}] 	

				la				target[, {x|y|a|b|fp|sp}][, {w0|t1|t2|t3|i}]

				la				*ptarget[,, {w0|h1|h2|i}] 	

				la				*ptarget[,, {w0|t1|t2|t3|i}]

				la				VALUE[, {x|y|a|b|fp|sp}], i

				la				VALUE,, xi


	assembler examples	la			target, sp
				la, h2			target
				la			target,,t1
				la			*ptarget,,h1

				la, xi			-48000/2
				la			12, y, i
				la, i			apointer
				la, i			*apointer	[ = la	apointer ]

				_________________________________________________________
	Instruction Code 12	| 0 1 0 0 0 | . . . | . . . .  . . . . . . . . . . . .  |
				|___________|_______|___________________________________|
				






	Load Arithmetic Register b	lb
	__________________________	___


				_________________________________________________________
				|							|
				|	load operand to Arithmetic Register b		|
				|_______________________________________________________|
				|	operand is memory/register value at EA		|
				|	or the value EA or a signed immediate		|
				|	memory source may be a word, half or thirdword	|
				|_______________________________________________________|



	assembler syntax	lb[, {w0|h1|h2|i}]		target[, {x|y|a|b|fp|sp}] 	

				lb[, {w0|t1|t2|t3|i}]		target[, {x|y|a|b|fp|sp}]

				lb[, {w0|h1|h2|i}]		*ptarget

				lb[, {w0|t1|t2|t3|i}]		*ptarget

				lb, i				VALUE[, {x|y|a|b|fp|sp}]

				lb, xi				VALUE

				lb				target[, {x|y|a|b|fp|sp}][, {w0|h1|h2|i}] 	

				lb				target[, {x|y|a|b|fp|sp}][, {w0|t1|t2|t3|i}]

				lb				*ptarget[,, {w0|h1|h2|i}] 	

				lb				*ptarget[,, {w0|t1|t2|t3|i}]

				lb				VALUE[, {x|y|a|b|fp|sp}], i

				lb				VALUE,, xi


	assembler examples	lb			target, a
				lb, h2			target
				lb			target,,t1
				lb			*ptarget,,h1

				lb, xi			-48000/2
				lb			12, y, i
				lb, i			apointer
				lb, i			*apointer	[ = lb	apointer ]

				_________________________________________________________
	Instruction Code 13	| 0 1 1 0 1 | . . . | . . . .  . . . . . . . . . . . .  |
				|___________|_______|___________________________________|
				



	Test Zero		tz
	_________		__


				_________________________________________________________
				|							|
				|	skip the next instruction if operand is zero 	|
				|_______________________________________________________|
				|	operand is memory/register value at EA		|
				|	memory target may be a word, half or thirdword	|
				|_______________________________________________________|


	assembler syntax	tz[, {w0|h1|h2}]		target[, {x|y|a|b|fp|sp|}] 	

				tz[, {w0|t1|t2|t3}]		target[, {x|y|a|b|fp|sp}]

				tz[, {w0|h1|h2}]		*ptarget	

				tz[, {w0|t1|t2|t3}]		*ptarget

				tz				target[, {x|y|a|b|fp|sp|}][, {w0|h1|h2}] 	

				tz				target[, {x|y|a|b|fp|sp}][, {w0|t1|t2|t3}]

				tz				*ptarget[,, {w0|h1|h2}] 	

				tz				*ptarget[,, {w0|t1|t2|t3}]


	assembler examples	tz		target
				tz, h2		target, fp
				tz		target,,t1
				tz		*ptarget,,h1

				_________________________________________________________
	Instruction Code 14	| 0 1 1 1 0 | 0 . . | . . . .  . . . . . . . . . . . .  |
				|___________|_______|___________________________________|
				



	Test Positive		tp
	_____________		__

				_________________________________________________________
				|							|
				|	skip the next instruction if operand bit 23 is	|
				|	zero. half and thirdwords have sign extension	|
				|_______________________________________________________|
				|	operand is memory/register value at EA		|
				|	memory target may be a word, half or thirdword	|
				|_______________________________________________________|



	assembler syntax	tp[, {w0|h1|h2}]		target[, {x|y|a|b|fp|sp|}] 	

				tp[, {w0|t1|t2|t3}]		target[, {x|y|a|b|fp|sp}]

				tp[, {w0|h1|h2}]		*ptarget	

				tp[, {w0|t1|t2|t3}]		*ptarget

				tp				target[, {x|y|a|b|fp|sp|}][, {w0|h1|h2}] 	

				tp				target[, {x|y|a|b|fp|sp}][, {w0|t1|t2|t3}]

				tp				*ptarget[,, {w0|h1|h2}] 	

				tp				*ptarget[,, {w0|t1|t2|t3}]


	assembler examples	tp		target, y
				tp		*(HIGH_ADDRESS:s)
				tp, h2		target
				tp		target,,t1
				tp		*ptarget

				_________________________________________________________
	Instruction Code 15	| 0 1 1 1 1 | 0 . . | . . . .  . . . . . . . . . . . .  |
				|___________|_______|___________________________________|
				






	Add to Index Register x	ax
	_______________________	__


				_________________________________________________________
				|							|
				|	add the operand to Index Register x		|
				|	carry$ is not affected				|
				|_______________________________________________________|
				|	operand is memory/register value at EA		|
				|	or the value EA or a signed immediate		|
				|	memory source may be a word, half or thirdword	|
				|_______________________________________________________|



	assembler syntax	ax[, {w0|h1|h2|i}]		address_update[, {x|y|a|b|fp|sp}] 	

				ax[, {w0|t1|t2|t3|i}]		address_update[, {x|y|a|b|fp|sp}]

				ax[, {w0|h1|h2|i}]		*paddress_update

				ax[, {w0|t1|t2|t3|i}]		*paddress_update

				ax, i				ADDRESS_UPDATE[, {x|y|a|b|fp|sp}]

				ax, xi				ADDRESS_UPDATE

				ax				address_update[, {x|y|a|b|fp|sp}][, {w0|h1|h2|i}] 	

				ax				address_update[, {x|y|a|b|fp|sp}][, {w0|t1|t2|t3|i}]

				ax				*paddress_update[,, {w0|h1|h2|i}] 	

				ax				*paddress_update[,, {w0|t1|t2|t3|i}]

				ax				ADDRESS_UPDATE[, {x|y|a|b|fp|sp}], i

				ax				ADDRESS_UPDATE,, xi


	assembler examples	ax			address_update
				ax, h2			address_update, b
				ax			address_update,,t1
				ax			*paddress_update,,h1

				ax, xi			-48000/2
				ax			12, y, i
				ax, i			apointer
				ax, i			*apointer	[ =	ax	apointer ]

				_________________________________________________________
	Instruction Code 16	| 1 0 0 0 0 | . . . | . . . .  . . . . . . . . . . . .  |
				|___________|_______|___________________________________|
				









	Add to Index Register y	ay
	______________________	__


				_________________________________________________________
				|							|
				|	add the operand to Index Register y		|
				|	carry$ is not affected				|
				|_______________________________________________________|
				|	operand is memory/register value at EA		|
				|	or the value EA or a signed immediate		|
				|	memory source may be a word, half or thirdword	|
				|_______________________________________________________|



	assembler syntax	ay[, {w0|h1|h2|i}]		address_update[, {x|y|a|b|fp|sp}] 	

				ay[, {w0|t1|t2|t3|i}]		address_update[, {x|y|a|b|fp|sp}]

				ay[, {w0|h1|h2|i}]		*paddress_update

				ay[, {w0|t1|t2|t3|i}]		*paddress_update

				ay, i				ADDRESS_UPDATE[, {x|y|a|b|fp|sp}]

				ay, xi				ADDRESS_UPDATE

				ay				address_update[, {x|y|a|b|fp|sp}][, {w0|h1|h2|i}] 	

				ay				address_update[, {x|y|a|b|fp|sp}][, {w0|t1|t2|t3|i}]

				ay				*paddress_update[,, {w0|h1|h2|i}] 	

				ay				*paddress_update[,, {w0|t1|t2|t3|i}]

				ay				ADDRESS_UPDATE[, {x|y|a|b|fp|sp}], i

				ay				ADDRESS_UPDATE,, xi


	assembler examples	ay			address_update, x
				ay, h2			address_update
				ay			address_update,,t1
				ay			*paddress_update,,h1

				ay, xi			-48000/2
				ay			12, y, i
				ay, i			apointer
				ay, i			*apointer	[ =	ay	apointer ]

				_________________________________________________________
	Instruction Code 17	| 1 0 0 0 1 | . . . | . . . .  . . . . . . . . . . . .  |
				|___________|_______|___________________________________|
				









	Or Arithmetic Register a	or
	________________________	__


				_________________________________________________________
				|							|
				|	OR Arithmetic Register a with the operand	|
				|	result in a					|
				|_______________________________________________________|
				|	operand is memory/register value at EA		|
				|	or the value EA or a signed immediate		|
				|	memory source may be a word, half or thirdword	|
				|_______________________________________________________|



	assembler syntax	or[, {w0|h1|h2|i}]		mask[, {x|y|a|b|fp|sp}] 	

				or[, {w0|t1|t2|t3|i}]		mask[, {x|y|a|b|fp|sp}]

				or[, {w0|h1|h2|i}]		*pmask

				or[, {w0|t1|t2|t3|i}]		*pmask

				or, i				MASK[, {x|y|a|b|fp|sp}]

				or, xi				MASK

				or				mask[, {x|y|a|b|fp|sp}][, {w0|h1|h2|i}] 	

				or				mask[, {x|y|a|b|fp|sp}][, {w0|t1|t2|t3|i}]

				or				*pmask[,, {w0|h1|h2|i}] 	

				or				*pmask[,, {w0|t1|t2|t3|i}]

				or				MASK[, {x|y|a|b|fp|sp}], i

				or				MASK,, xi


	assembler examples	or			mask
				or, h2			mask, b
				or			mask,,t1
				or			*pmask,,h1

				or, xi			-48000/2
				or			12, y, i
				or, i			apointer
				or, i			*apointer	[ =	or	apointer ]

				_________________________________________________________
	Instruction Code 18	| 1 0 0 1 0 | . . . | . . . .  . . . . . . . . . . . .  |
				|___________|_______|___________________________________|
				









	Or Arithmetic Register b	orB
	________________________	___


				_________________________________________________________
				|							|
				|	OR Arithmetic Register b with the operand	|
				|	result in b					|
				|_______________________________________________________|
				|	operand is memory/register value at EA		|
				|	or the value EA or a signed immediate		|
				|	memory source may be a word, half or thirdword	|
				|_______________________________________________________|




	assembler syntax	orB[, {w0|h1|h2|i}]		mask[, {x|y|a|b|fp|sp}] 	

				orB[, {w0|t1|t2|t3|i}]		mask[, {x|y|a|b|fp|sp}]

				orB[, {w0|h1|h2|i}]		*pmask

				orB[, {w0|t1|t2|t3|i}]		*pmask

				orB, i				MASK[, {x|y|a|b|fp|sp}]

				orB, xi				MASK

				orB				mask[, {x|y|a|b|fp|sp}][, {w0|h1|h2|i}] 	

				orB				mask[, {x|y|a|b|fp|sp}][, {w0|t1|t2|t3|i}]

				orB				*pmask[,, {w0|h1|h2|i}] 	

				orB				*pmask[,, {w0|t1|t2|t3|i}]

				orB				MASK[, {x|y|a|b|fp|sp}], i

				orB				MASK,, xi


	assembler examples	orB			mask
				orB, h2			mask
				orB			mask,a,t1
				orB			*pmask,,h1

				orB, xi			-48000/2
				orB			12, y, i
				orB, i			apointer
				orB, i			*apointer	[ =	orB	apointer ]

				_________________________________________________________
	Instruction Code 19	| 1 0 0 1 1 | . . . | . . . .  . . . . . . . . . . . .  |
				|___________|_______|___________________________________|
				









	And Arithmetic Register a	and
	_________________________	___


				_________________________________________________________
				|							|
				|	AND Arithmetic Register a with the operand	|
				|	result in a					|
				|_______________________________________________________|
				|	operand is memory/register value at EA		|
				|	or the value EA or a signed immediate		|
				|	memory source may be a word, half or thirdword	|
				|_______________________________________________________|




	assembler syntax	and[, {w0|h1|h2|i}]		mask[, {x|y|a|b|fp|sp}] 	

				and[, {w0|t1|t2|t3|i}]		mask[, {x|y|a|b|fp|sp}]

				and[, {w0|h1|h2|i}]		*pmask

				and[, {w0|t1|t2|t3|i}]		*pmask

				and, i				MASK[, {x|y|a|b|fp|sp}]

				and, xi				MASK

				and				mask[, {x|y|a|b|fp|sp}][, {w0|h1|h2|i}] 	

				and				mask[, {x|y|a|b|fp|sp}][, {w0|t1|t2|t3|i}]

				and				*pmask[,, {w0|h1|h2|i}] 	

				and				*pmask[,, {w0|t1|t2|t3|i}]

				and				MASK[, {x|y|a|b|fp|sp}], i

				and				MASK,, xi


	assembler examples	and			mask
				and, h2			mask, x
				and			mask,,t1
				and			*pmask,,h1

				and, xi			-48000/2
				and			12, y, i
				and, i			apointer
				and, i			*apointer	[ =	and	apointer ]

				_________________________________________________________
	Instruction Code 20	| 1 0 1 0 0 | . . . | . . . .  . . . . . . . . . . . .  |
				|___________|_______|___________________________________|
				









	And Arithmetic Register b	andB
	_________________________	___


				_________________________________________________________
				|							|
				|	AND Arithmetic Register b with the operand	|
				|	result in b					|
				|_______________________________________________________|
				|	operand is memory/register value at EA		|
				|	or the value EA or a signed immediate		|
				|	memory source may be a word, half or thirdword	|
				|_______________________________________________________|



	assembler syntax	andB[, {w0|h1|h2|i}]		mask[, {x|y|a|b|fp|sp}] 	

				andB[, {w0|t1|t2|t3|i}]		mask[, {x|y|a|b|fp|sp}]

				andB[, {w0|h1|h2|i}]		*pmask

				andB[, {w0|t1|t2|t3|i}]		*pmask

				andB, i				MASK[, {x|y|a|b|fp|sp}]

				andB, xi			MASK

				andB				mask[, {x|y|a|b|fp|sp}][, {w0|h1|h2|i}] 	

				andB				mask[, {x|y|a|b|fp|sp}][, {w0|t1|t2|t3|i}]

				andB				*pmask[,, {w0|h1|h2|i}] 	

				andB				*pmask[,, {w0|t1|t2|t3|i}]

				andB				MASK[, {x|y|a|b|fp|sp}], i

				andB				MASK,, xi


	assembler examples	andB			(MASK_VALUE)
				andB, h2		mask
				andB			mask,,t1
				andB			*pmask,,h1

				andB, xi		-48000/2
				andB			12, y, i
				andB, i			apointer
				andB, i			*apointer	[ =	andB	apointer ]

				_________________________________________________________
	Instruction Code 21	| 1 0 1 0 1 | . . . | . . . .  . . . . . . . . . . . .  |
				|___________|_______|___________________________________|
				









	Exlusive Or Arithmetic Register a	xor
	_________________________________	___


				_________________________________________________________
				|							|
				|	XOR Arithmetic Register a with the operand	|
				|	result in a					|
				|_______________________________________________________|
				|	operand is memory/register value at EA		|
				|	or the value EA or a signed immediate		|
				|	memory source may be a word, half or thirdword	|
				|_______________________________________________________|


	assembler syntax	xor[, {w0|h1|h2|i}]		mask[, {x|y|a|b|fp|sp}] 	

				xor[, {w0|t1|t2|t3|i}]		mask[, {x|y|a|b|fp|sp}]

				xor[, {w0|h1|h2|i}]		*pmask

				xor[, {w0|t1|t2|t3|i}]		*pmask

				xor, i				MASK[, {x|y|a|b|fp|sp}]

				xor, xi				MASK

				xor				mask[, {x|y|a|b|fp|sp}][, {w0|h1|h2|i}] 	

				xor				mask[, {x|y|a|b|fp|sp}][, {w0|t1|t2|t3|i}]

				xor				*pmask[,, {w0|h1|h2|i}] 	

				xor				*pmask[,, {w0|t1|t2|t3|i}]

				xor				MASK[, {x|y|a|b|fp|sp}], i

				xor				MASK,, xi


	assembler examples	xor			mask
				xor, h2			mask
				xor			mask,,t1
				xor			*pmask,,h1

				xor, xi			-48000/2
				xor			12, y, i
				xor, i			apointer
				xor, i			*apointer	[ =	xor	apointer ]

				_________________________________________________________
	Instruction Code 22	| 1 0 1 1 0 | . . . | . . . .  . . . . . . . . . . . .  |
				|___________|_______|___________________________________|
				









	Exlusive Or Arithmetic Register b	xorB
	_________________________________	____


				_________________________________________________________
				|							|
				|	XOR Arithmetic Register b with the operand	|
				|	result in b					|
				|_______________________________________________________|
				|	operand is memory/register value at EA		|
				|	or the value EA or a signed immediate		|
				|	memory source may be a word, half or thirdword	|
				|_______________________________________________________|


	assembler syntax	xorB[, {w0|h1|h2|i}]		mask[, {x|y|a|b|fp|sp}] 	

				xorB[, {w0|t1|t2|t3|i}]		mask[, {x|y|a|b|fp|sp}]

				xorB[, {w0|h1|h2|i}]		*pmask

				xorB[, {w0|t1|t2|t3|i}]		*pmask

				xorB, i				MASK[, {x|y|a|b|fp|sp}]

				xorB, xi			MASK

				xorB				mask[, {x|y|a|b|fp|sp}][, {w0|h1|h2|i}] 	

				xorB				mask[, {x|y|a|b|fp|sp}][, {w0|t1|t2|t3|i}]

				xorB				*pmask[,, {w0|h1|h2|i}] 	

				xorB				*pmask[,, {w0|t1|t2|t3|i}]

				xorB				MASK[, {x|y|a|b|fp|sp}], i

				xorB				MASK,, xi


	assembler examples	xorB			mask
				xorB, h2		mask
				xorB			mask,a,t1
				xorB			*pmask,,h1

				xorB, xi		-48000/2
				xorB			12, y, i
				xorB, i			apointer
				xorB, i			*apointer	[ =	xorB	apointer ]

				_________________________________________________________
	Instruction Code 23	| 1 0 1 1 1 | . . . | . . . .  . . . . . . . . . . . .  |
				|___________|_______|___________________________________|
				









	Add to Arithmetic Register a	aa
	____________________________	__

				_________________________________________________________
				|							|
				|	add the operand to Register a			|
				|	carry$ = the carry from bit 23 of the addition	|
				|_______________________________________________________|
				|	operand is memory/register value at EA		|
				|	or the value EA or a signed immediate		|
				|	memory source may be a word, half or thirdword	|
				|_______________________________________________________|


	assembler syntax	aa[, {w0|h1|h2|i}]		addend[, {x|y|a|b|fp|sp}] 	

				aa[, {w0|t1|t2|t3|i}]		addend[, {x|y|a|b|fp|sp}]

				aa[, {w0|h1|h2|i}]		*paddend

				aa[, {w0|t1|t2|t3|i}]		*paddend

				aa, i				ADDEND[, {x|y|a|b|fp|sp}]

				aa, xi				ADDEND

				aa				addend[, {x|y|a|b|fp|sp}][, {w0|h1|h2|i}] 	

				aa				addend[, {x|y|a|b|fp|sp}][, {w0|t1|t2|t3|i}]

				aa				*paddend[,, {w0|h1|h2|i}] 	

				aa				*paddend[,, {w0|t1|t2|t3|i}]

				aa				ADDEND[, {x|y|a|b|fp|sp}], i

				aa				ADDEND,, xi


	assembler examples	aa			addend
				aa			(2000000)
				aa, h2			addend
				aa			addend,,t1
				aa			*paddend,,h1

				aa, xi			-48000/2
				aa			12, y, i
				aa, i			apointer
				aa, i			*apointer	[ =	aa	apointer ]

				_________________________________________________________
	Instruction Code 24	| 1 1 0 0 0 | . . . | . . . .  . . . . . . . . . . . .  |
				|___________|_______|___________________________________|
				









	Add to Arithmetic Register b	ab
	____________________________	__

				_________________________________________________________
				|							|
				|	add the operand to Register b			|
				|	carry$ = the carry from bit 23 of the addition	|
				|_______________________________________________________|
				|	operand is memory/register value at EA		|
				|	or the value EA or a signed immediate		|
				|	memory source may be a word, half or thirdword	|
				|_______________________________________________________|


	assembler syntax	ab[, {w0|h1|h2|i}]		addend[, {x|y|a|b|fp|sp}] 	

				ab[, {w0|t1|t2|t3|i}]		addend[, {x|y|a|b|fp|sp}]

				ab[, {w0|h1|h2|i}]		*paddend

				ab[, {w0|t1|t2|t3|i}]		*paddend

				ab, i				ADDEND[, {x|y|a|b|fp|sp}]

				ab, xi				ADDEND

				ab				addend[, {x|y|a|b|fp|sp}][, {w0|h1|h2|i}] 	

				ab				addend[, {x|y|a|b|fp|sp}][, {w0|t1|t2|t3|i}]

				ab				*paddend[,, {w0|h1|h2|i}] 	

				ab				*paddend[,, {w0|t1|t2|t3|i}]

				ab				ADDEND[, {x|y|a|b|fp|sp}], i

				ab				ADDEND, xi


	assembler examples	ab			addend, x
				ab			(-3000000)
				ab, h2			addend
				ab			addend,,t1
				ab			*paddend,,h1

				ab, xi			-48000/2
				ab			12, y, i
				ab, i			apointer
				ab, i			*apointer	[ =	ab	apointer ]

				_________________________________________________________
	Instruction Code 25	| 1 1 0 0 1 | . . . | . . . .  . . . . . . . . . . . .  |
				|___________|_______|___________________________________|
				









	Add Negative to Arithmetic Register a	ana
	_____________________________________	___

				_________________________________________________________
				|							|
				|	add the 2s complement of the operand to		|
				|	Register a					|
				|	carry$ = the carry from bit 23 of the addition	|
				|_______________________________________________________|
				|	operand is memory/register value at EA		|
				|	or the value EA or a signed immediate		|
				|	memory source may be a word, half or thirdword	|
				|_______________________________________________________|


	assembler syntax	ana[, {w0|h1|h2|i}]		subtrahend[, {x|y|a|b|fp|sp}] 	

				ana[, {w0|t1|t2|t3|i}]		subtrahend[, {x|y|a|b|fp|sp}]

				ana[, {w0|h1|h2|i}]		*psubtrahend

				ana[, {w0|t1|t2|t3|i}]		*psubtrahend

				ana, i				SUBTRAHEND[, {x|y|a|b|fp|sp}]

				ana, xi				SUBTRAHEND

				ana				subtrahend[, {x|y|a|b|fp|sp}][, {w0|h1|h2|i}] 	

				ana				subtrahend[, {x|y|a|b|fp|sp}][, {w0|t1|t2|t3|i}]

				ana				*psubtrahend[,, {w0|h1|h2|i}] 	

				ana				*psubtrahend[,, {w0|t1|t2|t3|i}]

				ana				SUBTRAHEND[, {x|y|a|b|fp|sp}], i

				ana				SUBTRAHEND,, xi


	assembler examples	ana			subtrahend
				ana, h2			subtrahend
				ana			subtrahend,,t1
				ana			*psubtrahend,,h1

				ana, xi			-48000/2
				ana			12, y, i
				ana, i			apointer
				ana, i			*apointer	[ =	ana	apointer ]

				_________________________________________________________
	Instruction Code 26	| 1 1 0 1 0 | . . . | . . . .  . . . . . . . . . . . .  |
				|___________|_______|___________________________________|
				







	Add Negative to Arithmetic Register b	anb
	_____________________________________	___

				_________________________________________________________
				|							|
				|	add the 2s complement of the operand to		|
				|	Register b					|
				|	carry$ = the carry from bit 23 of the addition	|
				|_______________________________________________________|
				|	operand is memory/register value at EA		|
				|	or the value EA or a signed immediate		|
				|	memory source may be a word, half or thirdword	|
				|_______________________________________________________|


	assembler syntax	anb[, {w0|h1|h2|i}]		subtrahend[, {x|y|a|b|fp|sp}] 	

				anb[, {w0|t1|t2|t3|i}]		subtrahend[, {x|y|a|b|fp|sp}]

				anb, {w0|h1|h2|i}]		*psubtrahend

				anb[, {w0|t1|t2|t3|i}]		*psubtrahend

				anb, i				SUBTRAHEND[, {x|y|a|b|fp|sp}]

				anb, xi				SUBTRAHEND

				anb				subtrahend[, {x|y|a|b|fp|sp}][, {w0|h1|h2|i}] 	

				anb				subtrahend[, {x|y|a|b|fp|sp}][, {w0|t1|t2|t3|i}]

				anb				*psubtrahend[,, {w0|h1|h2|i}] 	

				anb				*psubtrahend[,, {w0|t1|t2|t3|i}]

				anb				SUBTRAHEND[, {x|y|a|b|fp|sp}], i

				anb				SUBTRAHEND,, xi


	assembler examples	anb			subtrahend, a
				anb, h2			subtrahend
				anb			subtrahend,,t1
				anb			*psubtrahend,,h1

				anb, xi			-48000/2
				anb			12, y, i
				anb, i			apointer
				anb, i			*apointer	[ =	anb	apointer ]

				_________________________________________________________
	Instruction Code 27	| 1 1 0 1 1 | . . . | . . . .  . . . . . . . . . . . .  |
				|___________|_______|___________________________________|
				









	Multiply		m
	________		_


				_________________________________________________________
				|							|
				|	algebraically multiply Register b by the operand|
				|	giving a 48-bit product in Registers a and b	|
				|_______________________________________________________|
				|	operand is memory/register value at EA		|
				|	or the value EA or a signed immediate		|
				|	memory source may be a word, half or thirdword	|
				|_______________________________________________________|


	assembler syntax	m[, {w0|h1|h2|i}]		multiplier[, {x|y|a|b|fp|sp}] 	

				m[, {w0|t1|t2|t3|i}]		multiplier[, {x|y|a|b|fp|sp}]

				m[, {w0|h1|h2|i}]		*pmultiplier

				m[, {w0|t1|t2|t3|i}]		*pmultiplier

				m, i				MULTIPLIER[, {x|y|a|b|fp|sp}]

				m, xi				MULTIPLIER

				m				multiplier[, {x|y|a|b|fp|sp}][, {w0|h1|h2|i}] 	

				m				multiplier[, {x|y|a|b|fp|sp}][, {w0|t1|t2|t3|i}]

				m				*pmultiplier[,, {w0|h1|h2|i}] 	

				m				*pmultiplier[,, {w0|t1|t2|t3|i}]

				m				MULTIPLIER[, {x|y|a|b|fp|sp}], i

				m				MULTIPLIER,, xi


	assembler examples	m			multiplier
				m			(-1250000)
				m, h2			multiplier
				m			multiplier,,t1
				m			*pmultiplier,,h1

				m, xi			-48000/2
				m			12, y, i
				m, i			apointer
				m, i			*apointer	[ =	m	apointer ]

				_________________________________________________________
	Instruction Code 28	| 1 1 1 0 0 | . . . | . . . .  . . . . . . . . . . . .  |
				|___________|_______|___________________________________|
				









	Multiply Fractional	mf
	___________________	__

				_________________________________________________________
				|							|
				|	multiply unsigned Register b by signed operand	|
				|	giving a 48-bit product in Registers a and b	|
				|							|
				|	enables floating fractions to be interpreted	|
				|	enables long integers to be multiplied		|
				|_______________________________________________________|
				|	operand is memory/register value at EA		|
				|	or the value EA or a signed immediate		|
				|	memory source may be a word, half or thirdword	|
				|_______________________________________________________|


	assembler syntax	mf[, {w0|h1|h2|i}]		multiplier[, {x|y|a|b|fp|sp}] 	

				mf[, {w0|t1|t2|t3|i}]		multiplier[, {x|y|a|b|fp|sp}]

				mf[, {w0|h1|h2|i}]		*pmultiplier

				mf[, {w0|t1|t2|t3|i}]		*pmultiplier

				mf, i				MULTIPLIER[, {x|y|a|b|fp|sp}]

				mf, xi				MULTIPLIER

				mf				multiplier[, {x|y|a|b|fp|sp}][, {w0|h1|h2|i}] 	

				mf				multiplier[, {x|y|a|b|fp|sp}][, {w0|t1|t2|t3|i}]

				mf				*pmultiplier[,, {w0|h1|h2|i}] 	

				mf				*pmultiplier[,, {w0|t1|t2|t3|i}]

				mf				MULTIPLIER[, {x|y|a|b|fp|sp}], i

				mf				MULTIPLIER,, xi


	assembler examples	mf			multiplier, x
				mf, h2			multiplier
				mf			multiplier,,t1
				mf			*pmultiplier,,h1

				mf, xi			-48000/2
				mf			12, y, i
				mf, i			apointer
				mf, i			*apointer	[ =	mf	apointer ]

				_________________________________________________________
	Instruction Code 29	| 1 1 1 0 1 | . . . | . . . .  . . . . . . . . . . . .  |
				|___________|_______|___________________________________|
				









	Divide			d
	______			_

				_________________________________________________________
				|							|
				|	algebraically divide the 48-bit integer in	|
				|	Registers a and b by the operand giving a	|
				|	48-bit quotient	in Registers a and mantissa2	|
				|	and a 24-bit remainder in Register b		|
				|							|
				|	the high-order 24 bits of the 48-bit integer	|
				|	quotient are in	Register mantissa2		|
				|							|
				|_______________________________________________________|
				|	operand is memory/register value at EA		|
				|	or the value EA or a signed immediate		|
				|	memory source may be a word, half or thirdword	|
				|_______________________________________________________|


	assembler syntax	d[, {w0|h1|h2|i}]		divisor[, {x|y|a|b|fp|sp}] 	

				d[, {w0|t1|t2|t3|i}]		divisor[, {x|y|a|b|fp|sp}]

				d[, {w0|h1|h2|i}]		*pdivisor

				d[, {w0|t1|t2|t3|i}]		*pdivisor

				d, i				DIVISOR[, {x|y|a|b|fp|sp}]

				d, xi				DIVISOR

				d				divisor[, {x|y|a|b|fp|sp}][, {w0|h1|h2|i}] 	

				d				divisor[, {x|y|a|b|fp|sp}][, {w0|t1|t2|t3|i}]

				d				*pdivisor[,, {w0|h1|h2|i}] 	

				d				*pdivisor[,, {w0|t1|t2|t3|i}]

				d				DIVISOR[, {x|y|a|b|fp|sp}], i

				d				value,, xi


	assembler examples	d			divisor
				d			(1000000)
				d, h2			divisor
				d			divisor,,t1
				d			*pdivisor,,h1

				d, xi			-48000/2
				d			12, y, i
				d, i			apointer
				d, i			*apointer	[ =	d	apointer ]

				_________________________________________________________
	Instruction Code 30	| 1 1 1 1 0 | . . . | . . . .  . . . . . . . . . . . .  |
				|___________|_______|___________________________________|
				









	push			push
	____			____

				_________________________________________________________
				|							|
				|	decrement the Internal Stack Pointer sp and	|
				|	load the operand to the new internal stack top	|
				|_______________________________________________________|
                                |       on internal stack overflow / underflow		|
                                |       [sp < 25 | sp > 128] before operation           |
                                |       guard interrupt 95 is raised                    |
				|_______________________________________________________|
				|	operand is memory/register value at EA		|
				|	or the value EA or a signed immediate		|
				|	memory source may be a word, half or thirdword	|
				|_______________________________________________________|


	assembler syntax	push[, {w0|h1|h2|i}]		target[, {x|y|a|b|fp|sp}] 	

				push[, {w0|t1|t2|t3|i}]		target[, {x|y|a|b|fp|sp}]

				push[, {w0|h1|h2|i}]		*ptarget

				push[, {w0|t1|t2|t3|i}]		*ptarget

				push, i				VALUE[, {x|y|a|b|fp|sp}]

				push, xi			VALUE

				push				target[, {x|y|a|b|fp|sp}][, {w0|h1|h2|i}] 	

				push				target[, {x|y|a|b|fp|sp}][, {w0|t1|t2|t3|i}]

				push				*ptarget[,, {w0|h1|h2|i}] 	

				push				*ptarget[,, {w0|t1|t2|t3|i}]

				push				VALUE[, {x|y|a|b|fp|sp}], i

				push				VALUE,, xi


	assembler examples	push			target
				push			(45*262144+OFFSET:s)
				push			(45*/18++OFFSET:s)
				push, h2		target
				push			target,,t1
				push			*ptarget,,h1

				push, xi		-48000/2
				push			12, y, i
				push, i			apointer
				push, i			*apointer	[ = 	push	apointer ]

				_________________________________________________________
	Instruction Code 31	| 1 1 1 1 1 | . . . | . . . .  . . . . . . . . . . . .  |
				|___________|_______|___________________________________|
				






</pre>


<h5>Instruction File 4A</h5>
<p>
The eight instructions in Instruction File 4A use the effective address with or without indirection or indexing as an
immediate operand
<pre>


	I/O In to Arithmetic Register a		inA
	_______________________________		___

				_________________________________________________________
				|							|
				|	read the I/O port EA to Register a		|
				|_______________________________________________________|
				|	operand is the I/O port EA			|
				|_______________________________________________________|

	assembler syntax	inA		PORT_NUMBER[, {x|y|a|b|fp|sp}]
				inA		*port_number_variable

				_________________________________________________________
	Instruction Code 0.4	| 0 0 0 0 0 | 1 0 0 | . . . .  . . . . . . . . . . . .	|
				|___________|_______|___________________________________|





	I/O In to Arithmetic Register b		inB
	_______________________________		___

				_________________________________________________________
				|							|
				|	read the I/O port EA to Register b		|
				|_______________________________________________________|
				|	operand is the I/O port EA			|
				|_______________________________________________________|


	assembler syntax	inB		PORT_NUMBER[, {x|y|a|b|fp|sp}]
				inB		*port_number_variable

				_________________________________________________________
	Instruction Code 1.4	| 0 0 0 0 1 | 1 0 0 | . . . .  . . . . . . . . . . . .	|
				|___________|_______|___________________________________|





	I/O Out from Arithmetic Register a	outA
	__________________________________	____

				_________________________________________________________
				|							|
				|	write Register a to the I/O port EA		|
				|_______________________________________________________|
				|	operand is the I/O port EA			|
				|_______________________________________________________|

	assembler syntax	outA		PORT_NUMBER[, {x|y|a|b|fp|sp}]
				outA		*port_number_variable

				_________________________________________________________
	Instruction Code 2.4	| 0 0 0 1 0 | 1 0 0 | . . . .  . . . . . . . . . . . .	|
				|___________|_______|___________________________________|





	I/O Out from Arithmetic Register b	outB
	__________________________________	____

				_________________________________________________________
				|							|
				|	write Register b to the I/O port EA		|
				|_______________________________________________________|
				|	operand is the I/O port EA			|
				|_______________________________________________________|


	assembler syntax	outB		PORT_NUMBER[, {x|y|a|b|fp|sp}]
				outB		*port_number_variable

				_________________________________________________________
	Instruction Code 3.4	| 0 0 0 1 1 | 1 0 0 | . . . .  . . . . . . . . . . . .	|
				|___________|_______|___________________________________|





	Reload			reload
	______			______

				_________________________________________________________
				|							|
				|	read two bank base identifiers from		|
				|	the address in Register a			|
				|							|
				|	write two relocation base registers EA, EA + 1	|
				|							|
				|	Register a is incremented by 2			|
				|							|
				|	value of EA can be 2..62			|
				|_______________________________________________________|
				|	operand is relocation base registers  EA, EA + 1|
				|_______________________________________________________|


	assembler syntax	reload			RELOCATION_REGISTER_PAIR[, {x|y|a|b|fp|sp}]
				reload			*base_register_id_variable

	assembler example	la, xi		BASE_REGISTER_SAVEAREA
				reload		2
				reload		4

	assembler example	la, xi		TCB_BASE_REGISTER_TABLE
			?	$do		USER_BANKS/2,	reload	?*2

				_________________________________________________________
	Instruction Code 4.4	| 0 0 1 0 0 | 1 0 0 | . . . .  . . . . . . . . . . . .	|
				|___________|_______|___________________________________|





	Emulator Cool		emulator_cool
	_____________		_____________


				_________________________________________________________
				|							|
				|	usleep the emulation for EA microseconds	|
				|							|
				|	silicon implementations may have a heat / power	|
				|	save instruction here				|			
				|_______________________________________________________|
				|	operand is EA					|
				|_______________________________________________________|


	assembler syntax	emulator_cool		MICROSECONDS[, {x|y|a|b|fp|sp}]
				emulator_cool		*microseconds_variable

				_________________________________________________________
	Instruction Code 5.4	| 0 0 1 0 1 | 1 0 0 | . . . .  . . . . . . . . . . . .	|
				|___________|_______|___________________________________|


	_________________________________________________________________________________________________________________________________
	|						    BANK B1 PRIVATE STORAGE FRAME						|
	|_______________________________________________________________________________________________________________________________|
	|																|
	|			Bank B1 is a window in a private stack									|
	|																|
	|			sabre and reload instructions concern banks B2..B63							|
	|																|
	|			applications execute sabr instruction to base memory blocks in B2..B63					|
	|			sabr also copies the relocation values through to the TCB						|
	|																|
	|			reload instruction bases some or all of B2..B63 in pairs on the loadup beat of task switch		|
	|																|
	|			Applications manipulate and restore B1 pointer in a different dynamic from B2..63			|
	|																|
	|			Task switch inputs B1 from I/O Port 1 and saves it individually						|
	|			Task switch outputs B1 of the loading task to I/O Port 1 individually					|
	|																|
	|_______________________________________________________________________________________________________________________________|
	|																|
	|																|
	|			A process has at least one B1 frame or B1 bank								|
        |                                                                                                                               |
        |                       a B1 frame contains private data at addresses 4096..8191                                                |       
	|																|
	|			a B1 frame is not in the address space of an entity which has a different B1 frame			|
	|																|
	|			divisions of a process may have separate B1 frames							|
	|																|
	|			the owning entity of a B1 frame can be a thread, a service or a function				|
	|																|
	|			recursive executions of a routine may stack B1 frames recursively					|
	|																|
	|			services base their B1 bank temporarily to use private data on behalf of calling routines		|
	|																|
	|			the private data in B1 may include mechanical information underlying a service and compiler-generated	|
	|			information like database subschemas									|
	|																|
	|																|
	|_______________________________________________________________________________________________________________________________|



	Store Arithmetic Register a to Base Register	sabr
	____________________________________________	____


				_________________________________________________________
				|							|
				|	store the absolute part of the base identifier	|
				|	in Register a to the relocation register	|
				|	implemented in I/O port EA			|
				|							|
				|	store the symbolic part of the base identifier	|
				|	in Register a to Bank 65 offset 64 + EA		|
				|							|
				|	value of EA may be 2..63			|
				|							|
				|	symbolic and absolute parts of the base		|
				|	identifier are identical unless the identifier	|
				|	is in the range of translating bank identifiers	|
				|							|
				|	translating identifiers have bit 23 = 1 and are	|
				|	not implemented in the emulation		|
				|							|
				|	this is an instruction for application use	|
				|_______________________________________________________|
				|	operand is EA					|
				|_______________________________________________________|



	assembler syntax	sabr		RELOCATION_REGISTER_ID[, {x|y|a|b|fp|sp}]
				sabr		*base_register_id_variable

				_________________________________________________________
	Instruction Code 6.4	| 0 0 1 1 0 | 1 0 0 | . . . .  . . . . . . . . . . . .	|
				|___________|_______|___________________________________|





	Jump Double Zero	jdz
	________________	___

				_________________________________________________________
				|							|
				|	jump to EA if the 48 bits of			|
				|	Arithmetic Registers a and b are all 0		|
				|_______________________________________________________|


	assembler syntax	jdz	jump_address[, {x|y|a|b|fp|sp}]
				jdz	*jump_pointer

				_________________________________________________________
	Instruction Code 15.4	| 0 1 1 1 1 | 1 0 0 | . . . .  . . . . . . . . . . . .  |
				|___________|_______|___________________________________|










</pre>
<h5>Instruction File 5A</h5>
<p>
The eight instructions in Instruction File 5A have a sign extended immediate operand
<pre>



	PSR Flags On		on
	____________		__

				_________________________________________________________
				|							|
				|	write 1 to the PSR flags in the operand MASK	|
				|	only Flags 15..0 are affected			|
				|_______________________________________________________|
				|	MASK is 16-bit immediate with sign extension	|
				|_______________________________________________________|


	assembler syntax	on	PSR_FLAGS_MASK

	assembler example	on	see$1++see$6++see$7


				_________________________________________________________
	Instruction Code 0.5	| 0 0 0 0 0 | 1 0 1 |		   MASK			|
				|___________|_______|___________________________________|






	PSR Flags Off		off
	_____________		___


				_________________________________________________________
				|							|
				|	write 0 to the PSR flags which are 1 in the	|
				|	operand MASK. only Flags 15..0 are affected	|
				|_______________________________________________________|
				|	MASK is 16-bit immediate with sign extension	|
				|_______________________________________________________|


	assembler syntax	off	PSR_FLAGS_MASK

	assembler example	off	half$w++carry$

				_________________________________________________________
	Instruction Code 1.5	| 0 0 0 0 1 | 1 0 1 | 		    MASK		|
				|___________|_______|___________________________________|




        _________________________________________________________________________________________________________________________________
        |                                               The Bit Stream Read Channel                                                     |
        |_______________________________________________________________________________________________________________________________|
        |                                                                                                                               |
	|	The Bit Stream Read Channel allows storage to be read as a stream of bits in fields of any size up to one word		|
	|	Bit fields may be read across word boundaries transparently								|
	|																|
	|	Successive reads may each be a fixed number of bits giving a stream of bytes of arbitrary size up to 24 bits		|
	|	Alternatively successive reads may be an irregular number of bits							|
	|																|
	|	24 bits may be read from each storage word, or 16 bits to accommodate 16-bit input devices				|
	|																|
	|	Read Staging Register instruction drives the Bit Stream Read Channel							|
	|_______________________________________________________________________________________________________________________________|



	Read Staging Register	rsr
	_____________________	___

				_________________________________________________________
				|							|
				|	shift BITS bits left from Staging Register	|
				|	RDATA to Arithmetic Register a			|
				|							|
				|	reload RDATA from storage on empty		|
				|							|
				|_______________________________________________________|
				|							|
				|	if RDATAC < BITS				|
				|							|
				|		subtract RDATAC	from BITS		|
				|							|
				|		shift RDATAC bits to Register a		|
				|							|
				|		read memory/register to RDATA with	|
				|		Pointer Register *q			|
				|							|
				|		increment Pointer Register q		|
				|							|
				|		restart RDATAC = RSTREAM_WORD		|
				|							|
				|	shift BITS bits from RDATA to Register a	|
				|							|
				|	subtract BITS from RDATAC			|
				|_______________________________________________________|
				|							|
				|	if PSR Flag b$streamZR = 0 displace the prior	|
				|	value in Register a leftwards			|
				|							|
				|	if PSR Flag b$streamZR = 1 clear Register a	|
				|	before shifting from RDATA			|
				|							|
				|	if PSR Flag b$stream16r = 0 RSTREAM_WORD = 24	|
				|							|
				|	if PSR Flag b$stream16r = 1 RSTREAM_WORD = 16	|
				|	and RDATA is shifted left 8 bits on memory read	|
				|							|
				|_______________________________________________________|
				|							|
				|	RDATAC RDATA and q are registers		|
				|							|
				|	RSTREAM_WORD is a term not a register		|
				|_______________________________________________________|
				|	BITS is 16-bit immediate with sign extension	|
				|_______________________________________________________|

	assembler syntax	rsr	BITS_TO_READ

	assembler example	rsr	BYTE_SIZE

				_________________________________________________________
	Instruction Code 2.5	| 0 0 0 1 0 | 1 0 1 | 		    BITS		|
				|___________|_______|___________________________________|






        _________________________________________________________________________________________________________________________________
        |                                               The Bit Stream Write Channel                                                    |
        |_______________________________________________________________________________________________________________________________|
        |                                                                                                                               |
        |       The Bit Stream Write Channel allows storage to be written as a stream of bits in fields of any size up to one word	|
        |       Bit fields may be written across word boundaries transparently                                                          |
        |                                                                                                                               |
        |       Successive writes may each be a fixed number of bits giving a stream of bytes of arbitrary size up to 24 bits		|
	|       Alternatively successive writes may be an irregular number of bits                                                      |
        |                                                                                                                               |
        |       24 bits may be written to each storage word, or 16 bits to accommodate 16-bit output devices                            |
        |                                                                                                                               |
        |       Write Staging Register instruction drives the Bit Stream Write Channel                                                  |
        |_______________________________________________________________________________________________________________________________|



	Write Staging Register	wsr
	______________________	___


				_________________________________________________________
				|							|
				|	shift BITS bits left from Register a		|
				|	to Staging Register WDATA			|
				|							|
				|	write WDATA to storage on full			|
				|							|
				|_______________________________________________________|
				|							|
				|	WSPACE = WSTREAM_WORD - WDATAC			|
				|							|
				|	if BITS >= WSPACE				|
				|							|
				|		subtract WSPACE from BITS		|
				|							|
				|		shift WSPACE bits to WDATA		|
				|							|
				|		write WDATA to memory/register with	|
				|		Pointer Register *p			|
				|							|
				|		increment Pointer Register p		|
				|							|
				|		restart WDATAC = 0			|
				|							|
				|		restart WDATA = 0			|
				|							|
				|	shift BITS bits from Register a to WDATA	|
				|							|
				|	add BITS to WDATAC				|
				|_______________________________________________________|
				|							|
				|	if PSR Flag b$stream16w = 0 WSTREAM_WORD = 24	|
				|							|
				|	if PSR Flag b$stream16r = 1 WSTREAM_WORD = 16	|
				|							|
				|_______________________________________________________|
				|							|
				|	WDATAC WDATA and p are registers		|
				|							|
				|	WSPACE and WSTREAM_WORD are terms not registers	|
				|_______________________________________________________|
				|	BITS is 16-bit immediate with sign extension	|
				|_______________________________________________________|


	assembler syntax	wsr		BITS_TO_WRITE

	assembler example	sal		24-BYTE_SIZE
				wsr		BYTE_SIZE


				_________________________________________________________
	Instruction Code 3.5	| 0 0 0 1 1 | 1 0 1 | 		    BITS		|
				|___________|_______|___________________________________|


				_________________________________________________________
				|	at the end of a stream of wsr writes software	|
				|	intervention may be needed to write outstanding	|
				|	bits of an incomplete data word			|
				|_______________________________________________________|


				wsr		BITS				write_last_bits	lb	*p	
				wsr		BITS						la	WDATA
				tz		WDATAC						sbl	*WDATAC
				lcal		write_last_bits					dsr	*WDATAC
												sb	*p
												lret	0



	Local Return		lret
	____________		____

				_________________________________________________________
				|							|
				|	pop relative return address from Internal Stack	|
				|							|
				|	add signed DISPLACEMENT to the popped		|
				|	relative address				|
				|							|
				|	add B0 to the resulting relative address	|
				|							|
				|	transfer the resulting absolute address to the	|
				|	program counter					|
				|							|
				|	if sp = 128 before lret				|
				|	task exit interrupt 70 is raised		|
				|							|
				|	on internal stack overflow / underflow		|
				|	[sp < 24 | sp > 128] before operation		|
				|	guard interrupt 95 is raised			|
				|							|
				|_______________________________________________________|
				|	DISPLACEMENT is 16-bit sign extended immediate	|
				|_______________________________________________________|


	assembler syntax	lret		SKIP_STEPS

	assembler examples	lret		0
				lret		1
				lret		-1
				lret		2

				_________________________________________________________
	Instruction Code 6.5	| 0 0 1 1 0 | 1 0 1 | 		  DISPLACEMENT		|
				|___________|_______|___________________________________|






	Far Return		fret
	__________		___

				_________________________________________________________
				|							|
				|	pop B0 from the Internal Stack			|
				|							|
				|	pop relative return address from Internal Stack	|
				|							|
				|	add signed DISPLACEMENT to the popped		|
				|	relative address				|
				|							|
				|	add B0 to the resulting relative address	|
				|							|
				|	transfer the resulting absolute address to the	|
				|	program counter					|
				|							|
                                |       if sp = 128 before fret                         |
                                |       task exit interrupt 70 is raised                |
                                |                                                       |
                                |       on internal stack overflow / underflow		|
                                |       [sp < 24 | sp > 126 ^ 128] before operation	|
				|	guard interrupt 95 is raised			|
                                |                                                       |
				|_______________________________________________________|
				|	DISPLACEMENT is 16-bit sign extended immediate	|
				|_______________________________________________________|



	assembler syntax	fret		SKIP_STEPS

	assembler examples	fret		0
				fret		-1
				fret		1
				fret		2

				_________________________________________________________
	Instruction Code 7.5	| 0 0 1 1 1 | 1 0 1 | 		DISPLACEMENT		|
				|___________|_______|___________________________________|






	Internal Interrupt	ii
	__________________	__

				_________________________________________________________
				|							|
				|	subtract B0 from the absolute program counter	|
				|							|
				|	push the resulting relative program counter	|
				|	onto the Interrupt Internal Stack		|
				|							|
				|	push B0	onto the Interrupt Internal Stack	|
				|							|
				|	push the PSR onto the Interrupt Internal Stack	|
				|							|
				|	push one word value 0 onto the Interrupt	|
				|	Internal Stack					|
				|							|
				|	PSR Flag 23 = 1					|
				|							|
				|	B0 = VECTOR_BANK				|
				|							|
				|	Program Counter = VECTOR_BANK*4096+VECTOR_OFFSET|
				|_______________________________________________________|
				|	VECTOR_BANK			  |VECTOR_OFFSET|
				|23______________________________________6|5___________0|
				|	VECTOR is 16-bit sign extended immediate	|
				|_______________________________________________________|


	assembler syntax	ii	INTERRUPT_VECTOR

	assembler examples	ii	BANK_1*/6++2
				ii	BANK_1*/6++11

				_________________________________________________________
	Instruction Code 14.5	| 0 1 1 1 0 | 1 0 1 |		  VECTOR		|
				|___________|_______|___________________________________|



	_________________________________________________________________________________________________________________________________
	|							   INTERRUPTS								|
	|_______________________________________________________________________________________________________________________________|
	|																|
	|			on external or internal interrupt									|
	|			_________________________________									|
	|																|
	|			Program Counter minus B0 is pushed onto the Interrupt Internal Stack					|
	|																|
	|			B0 is pushed onto the Interrupt Internal Stack								|
	|																|
	|			PSR is pushed onto the Interrupt Internal Stack								|
	|																|
	|			a latent parameter word is pushed onto the Interrupt Internal Stack					|
	|			when instruction ii raises the interrupt, the latent parameter word = 0					|
	|																|
	|			if PSR Flag 23 = 0 then Interrupt Stack Pointer sp_x is copied to Interrupt Frame Pointer fp_x		|
	|			this marks which Interrupt Stack Frame is the interrupted application					|
	|			the absolute address of the application Interrupt Stack Frame should always be 252			|
	|																|
	|			1 is written to PSR Flag 23										|
	|																|
	|_______________________________________________________________________________________________________________________________|
	|																|
	|			The Interrupt Stack Frame at Interrupt Stack Pointer sp_x is						|
	|			____________________________________________________________						|
	|																|
	|																|
	|			 95			 71			 47			 23		       0	|
	|			_________________________________________________________________________________________________	|
	|			|    latent parameter	|	saved PSR	|	saved B0	|   saved relative PC	|	|
	|			|_______________________|_______________________|_______________________|_______________________|	|
	|																|
	|_______________________________________________________________________________________________________________________________|



	Interrupt Return	ir
	________________	__

				_________________________________________________________
				|							|
				|	increment Interrupt Internal Stack Pointer sp_x	|
				|							|
				|	pop PSR from the Interrupt Internal Stack	|
				|							|
				|	pop B0 from the Internal Stack			|
				|							|
				|	pop relative return address from Internal Stack	|
				|							|
				|	add signed DISPLACEMENT to the popped		|
				|	relative address				|
				|							|
				|	add B0 to the resulting relative address	|
				|							|
				|	transfer the resulting absolute address to the	|
				|	program counter					|
				|_______________________________________________________|
				|	DISPLACEMENT is 16-bit sign extended immediate	|
				|_______________________________________________________|


	assembler syntax	ir	SKIP_STEPS

	assembler examples	ir	0
				ir	-1
				ir	2

				_________________________________________________________
	Instruction Code 15.5	| 0 1 1 1 1 | 1 0 1 | 		DISPLACEMENT		|
				|___________|_______|___________________________________|






</pre>

<h5>Instruction File 6</h5>

<p>
The 32 instructions in Instruction File 6 use the effective address with or without indirection or indexing as an
immediate operand
<pre>


	Shift Arithmetic Register a Right	sar
	_________________________________	___

				_________________________________________________________
				|							|
				|	shift the integer in Arithmetic Register a	|
				|	rightward for EA bit positions			|
				|	replace the values in the vacated high-order	|
				|	bit positions with 0				|
				|_______________________________________________________|


	assembler syntax	sar	BIT_POSITIONS[, {x|y|a|b|fp|sp}]
				sar	*shift_distance_variable

				_________________________________________________________
	Instruction Code 0.6	| 0 0 0 0 0 | 1 1 0 | . . . .  . . . . . . . . . . . .	|
				|___________|_______|___________________________________|






	Shift Arithmetic Register b Right	sbr
	_________________________________	___

				_________________________________________________________
				|							|
				|	shift the integer in Arithmetic Register b 	|
				|	rightward for EA bit positions			|
				|	replace the values in the vacated high-order	|
				|	bit positions with 0				|
				|_______________________________________________________|


	assembler syntax	sbr	BIT_POSITIONS[, {x|y|a|b|fp|sp}]
				sbr	*shift_distance_variable

				_________________________________________________________
	Instruction Code 1.6	| 0 0 0 0 1 | 1 1 0 | . . . .  . . . . . . . . . . . .  |
				|___________|_______|___________________________________|






	Double Shift Right	dsr
	__________________	___

				_________________________________________________________
				|							|
				|	shift the 48-bit integer in Arithmetic Registers|
				|	a and b rightward for EA bit positions		|
				|	replace the values in the vacated high-order	|
				|	bit positions with 0				|
				|_______________________________________________________|


	assembler syntax	dsr	BIT_POSITIONS[, {x|y|a|b|fp|sp}]
				dsr	*shift_distance_variable

				_________________________________________________________
	Instruction Code 2.6	| 0 0 0 1 0 | 1 1 0 | . . . .  . . . . . . . . . . . .  |
				|___________|_______|___________________________________|




	Jump Decrement Repeat Counter	jdr
	_____________________________	___


				_________________________________________________________
				|							|
				|	decrement Repeat Counter Register r		|
				|	jump to EA unless r has changed from 0 to -1	|
				|_______________________________________________________|


	assembler syntax	jdr	jump_address[, {x|y|a|b|fp|sp}]
				jdr	*jump_pointer

				_________________________________________________________
	Instruction Code 3.6	| 0 0 0 1 1 | 1 1 0 | . . . .  . . . . . . . . . . . .  |
				|___________|_______|___________________________________|




	Shift Arithmetic Register a Left	sal
	________________________________	___

				_________________________________________________________
				|							|
				|	shift the integer in Arithmetic Register a 	|
				|	leftward for EA bit positions			|
				|	replace the values in the vacated low-order	|
				|	bit positions with 0				|
				|_______________________________________________________|


	assembler syntax	sal	BIT_POSITIONS[, {x|y|a|b|fp|sp}]
				sal	*shift_distance_variable

				_________________________________________________________
	Instruction Code 4.6	| 0 0 1 0 0 | 1 1 0 | . . . .  . . . . . . . . . . . .  |
				|___________|_______|___________________________________|




	Shift Arithmetic Register b Left	sbl
	________________________________	___

				_________________________________________________________
				|							|
				|	shift the integer in Arithmetic Register b 	|
				|	leftward for EA bit positions			|
				|	replace the values in the vacated low-order	|
				|	bit positions with 0				|
				|_______________________________________________________|


	assembler syntax	sbl	BIT_POSITIONS[, {x|y|a|b|fp|sp}]
				sbl	*shift_distance_variable

				_________________________________________________________
	Instruction Code 5.6	| 0 0 1 0 1 | 1 1 0 | . . . .  . . . . . . . . . . . .  |
				|___________|_______|___________________________________|





	Double Shift Left	dsl
	_________________	___

				_________________________________________________________
				|							|
				|	shift the 48-bit integer in Arithmetic Registers|
				|	a and b leftward for EA bit positions		|
				|	replace the values in the vacated low-order	|
				|	bit positions with 0				|
				|_______________________________________________________|


	assembler syntax	dsl	BIT_POSITIONS[, {x|y|a|b|fp|sp}]
				dsl	*shift_distance_variable

				_________________________________________________________
	Instruction Code 6.6	| 0 0 1 1 0 | 1 1 0 | . . . .  . . . . . . . . . . . .  |
				|___________|_______|___________________________________|





	Local Call		lcal
	__________		____


				_________________________________________________________
				|							|
				|	push program counter minus B0 base address	|	
				|	onto the internal stack. Jump to EA		|
				|							|
                                |       on internal stack overflow / underflow		|
                                |       [sp < 25 | sp > 128] before operation           |
                                |       guard interrupt 95 is raised			|
				|_______________________________________________________|



	assembler syntax	lcal	jump_address[, {x|y|a|b|fp|sp}]
				lcal	*jump_pointer

				_________________________________________________________
	Instruction Code 7.6	| 0 0 1 1 1 | 1 1 0 | . . . .  . . . . . . . . . . . .  |
				|___________|_______|___________________________________|




	Rotate Arithmetic Register a Right	rar
	__________________________________	___

				_________________________________________________________
				|							|
				|	rotate the integer in Arithmetic Register a 	|
				|	rightward for EA bit positions			|
				|	replace the values in the vacated high-order bit|
				|	positions with the values shifted out of bit 0	|
				|_______________________________________________________|

	assembler syntax	rar	BIT_POSITIONS[, {x|y|a|b|fp|sp}]
				rar	*shift_distance_variable

				_________________________________________________________
	Instruction Code 8.6	| 0 1 0 0 0 | 1 1 0 | . . . .  . . . . . . . . . . . .  |
				|___________|_______|___________________________________|




	Rotate Arithmetic Register b Right	rbr
	__________________________________	___

				_________________________________________________________
				|							|
				|	rotate the integer in Arithmetic Register b 	|
				|	rightward for EA bit positions			|
				|	replace the values in the vacated high-order bit|
				|	positions with the values shifted out of bit 0	|
				|_______________________________________________________|


	assembler syntax	rbr	BIT_POSITIONS[, {x|y|a|b|fp|sp}]
				rbr	*shift_distance_variable

				_________________________________________________________
	Instruction Code 9.6	| 0 1 0 0 1 | 1 1 0 | . . . .  . . . . . . . . . . . .  |
				|___________|_______|___________________________________|




	Double Rotate Right	drr
	___________________	___

				_________________________________________________________
				|							|
				|	rotate the 48-bit integer in Arithmetic 	|
				|	Registers a and b rightward for EA bit positions|
				|	replace the values in the vacated high-order bit|
				|	positions with the values shifted out of bit 0	|
				|_______________________________________________________|


	assembler syntax	drr	BIT_POSITIONS[, {x|y|a|b|fp|sp}]
				drr	*shift_distance_variable

				_________________________________________________________
	Instruction Code 10.6	| 0 1 0 1 0 | 1 1 0 | . . . .  . . . . . . . . . . . .  |
				|___________|_______|___________________________________|




	Jump No Carry		jnc
	_____________		___

				_________________________________________________________
				|							|
				|	jump to EA if PSR Flag 0 carry$ is 0		|
				|_______________________________________________________|


	assembler syntax	jnc	jump_address[, {x|y|a|b|fp|sp}]
				jnc	*jump_pointer

				_________________________________________________________
	Instruction Code 11.6	| 0 1 0 1 1 | 1 1 0 | . . . .  . . . . . . . . . . . .  |
				|___________|_______|___________________________________|




	Rotate Arithmetic Register a Left	ral
	_________________________________	___

				_________________________________________________________
				|							|
				|	rotate the integer in Arithmetic Register a 	|
				|	leftward for EA bit positions			|
				|	replace the values in the vacated low-order bit	|
				|	positions with the values shifted out of bit 23	|
				|_______________________________________________________|


	assembler syntax	ral	BIT_POSITIONS[, {x|y|a|b|fp|sp}]
				ral	*shift_distance_variable

				_________________________________________________________
	Instruction Code 12.6	| 0 1 1 0 0 | 1 1 0 | . . . .  . . . . . . . . . . . .  |
				|___________|_______|___________________________________|




	Rotate Arithmetic Register b Left	rbl
	_________________________________	___

				_________________________________________________________
				|							|
				|	rotate the integer in Arithmetic Register b 	|
				|	leftward for EA bit positions			|
				|	replace the values in the vacated low-order bit	|
				|	positions with the values shifted out of bit 23	|
				|_______________________________________________________|


	assembler syntax	rbl	BIT_POSITIONS[, {x|y|a|b|fp|sp}]
				rbl	*shift_distance_variable

				_________________________________________________________
	Instruction Code 13.6	| 0 1 1 0 1 | 1 1 0 | . . . .  . . . . . . . . . . . .  |
				|___________|_______|___________________________________|




	Double Rotate Left	drl
	__________________	___

				_________________________________________________________
				|							|
				|	rotate the 48-bit integer in Arithmetic		|
				|	Registers a and b leftward for EA bit positions	|
				|	replace the values in the vacated low-order bit	|
				|	positions with the values shifted out of bit 47	|
				|_______________________________________________________|


	assembler syntax	drl	BIT_POSITIONS[, {x|y|a|b|fp|sp}]
				drl	*shift_distance_variable

				_________________________________________________________
	Instruction Code 14.6	| 0 1 1 1 0 | 1 1 0 | . . . .  . . . . . . . . . . . .  |
				|___________|_______|___________________________________|




	Jump on Carry		jc
	_____________		__

				_________________________________________________________
				|							|
				|	jump to EA if PSR Flag 0 carry$ is 1		|
				|_______________________________________________________|



	assembler syntax	jc	jump_address[, {x|y|a|b|fp|sp}]
				jc	*jump_pointer

				_________________________________________________________
	Instruction Code 15.6	| 0 1 1 1 1 | 1 1 0 | . . . .  . . . . . . . . . . . .  |
				|___________|_______|___________________________________|




	Shift Arithmetic Register a Algebraic	saa
	_____________________________________	___

				_________________________________________________________
				|							|
				|	shift the integer in Arithmetic Register a	|
				|	algebraically rightwards for EA bit positions	|
				|	write the original value of bit 23 to the	|
				|	vacated high order bit positions		|
				|_______________________________________________________|

	assembler syntax	saa	BIT_POSITIONS[, {x|y|a|b|fp|sp}]
				saa	*shift_distance_variable

				_________________________________________________________
	Instruction Code 16.6	| 1 0 0 0 0 | 1 1 0 | . . . .  . . . . . . . . . . . .  |
				|___________|_______|___________________________________|




	Shift Arithmetic Register b Algebraic	sba
	_____________________________________	___

				_________________________________________________________
				|							|
				|	shift the integer in Arithmetic Register b	|
				|	algebraically rightwards for EA bit positions	|
				|	write the original value of bit 23 to the	|
				|	vacated high order bit positions		|
				|_______________________________________________________|


	assembler syntax	sba	BIT_POSITIONS[, {x|y|a|b|fp|sp}]
				sba	*shift_distance_variable

				_________________________________________________________
	Instruction Code 17.6	| 1 0 0 0 1 | 1 1 0 | . . . .  . . . . . . . . . . . .  |
				|___________|_______|___________________________________|




	Double Shift Algebraic	dsa
	______________________	___
				_________________________________________________________
				|							|
				|	shift the 48-bit integer in Arithmetic Registers|
				|	a and b algebraically rightwards for EA bit	|
				|	positions. write the original value of bit 47	|
				|	to the vacated high order bit positions		|
				|_______________________________________________________|

	assembler syntax	dsa	BIT_POSITIONS[, {x|y|a|b|fp|sp}]
				dsa	*shift_distance_variable

				_________________________________________________________
	Instruction Code 18.6	| 1 0 0 1 0 | 1 1 0 | . . . .  . . . . . . . . . . . .  |
				|___________|_______|___________________________________|



	Jump a Odd		jao
	__________		___
	
				_________________________________________________________
				|							|
				|	jump to EA if bit 0 of Arithmetic Register a = 1|
				|_______________________________________________________|


	assembler syntax	jao	jump_address[, {x|y|a|b|fp|sp}]
				jao	*jump_pointer

				_________________________________________________________
	Instruction Code 19.6	| 1 0 0 1 1 | 1 1 0 | . . . .  . . . . . . . . . . . .  |
				|___________|_______|___________________________________|




	Jump Positive a		jpa
	_______________		___

				_________________________________________________________
				|							|
				|	jump to EA					|
				|	if bit 23 of Arithmetic Register a is 0		|
				|_______________________________________________________|


	assembler syntax	jpa	jump_address[, {x|y|a|b|fp|sp}]
				jpa	*jump_pointer

				_________________________________________________________
	Instruction Code 20.6	| 1 0 1 0 0 | 1 1 0 | . . . .  . . . . . . . . . . . .  |
				|___________|_______|___________________________________|




	Jump Positive b		jpb
	_______________		___

				_________________________________________________________
				|							|
				|	jump to EA					|
				|	if bit 23 of Arithmetic Register b is 0		|
				|_______________________________________________________|


	assembler syntax	jpb	jump_address[, {x|y|a|b|fp|sp}]
				jpb	*jump_pointer

				_________________________________________________________
	Instruction Code 21.6	| 1 0 1 0 1 | 1 1 0 | . . . .  . . . . . . . . . . . .  |
				|___________|_______|___________________________________|



	Jump			j
	____			_

				_________________________________________________________
				|							|
				|	jump to EA					|
				|_______________________________________________________|


	assembler syntax	j	jump_address[, {x|y|a|b|fp|sp}]
				j	*jump_pointer

				_________________________________________________________
	Instruction Code 22.6	| 1 0 1 1 0 | 1 1 0 | . . . .  . . . . . . . . . . . .  |
				|___________|_______|___________________________________|






	Jump Parity Odd		jpo
	_______________		___

				_________________________________________________________
				|							|
				|	jump to EA if the AND sum of Arithmetic		|
				|	Register a and Mask Register k has odd parity	|
				|_______________________________________________________|



	assembler syntax	jpo	jump_address[, {x|y|a|b|fp|sp}]
				jpo	*jump_pointer


				_________________________________________________________
	Instruction Code 23.6	| 1 0 1 1 1 | 1 1 0 | . . . .  . . . . . . . . . . . .  |
				|___________|_______|___________________________________|





	Jump Zero a		jza
	___________		___
	
				_________________________________________________________
				|							|
				|	jump to EA					|
				|	if all bits of Arithmetic Register a are 0	|
				|_______________________________________________________|


	assembler syntax	jza	jump_address[, {x|y|a|b|fp|sp}]
				jza	*jump_pointer

				_________________________________________________________
	Instruction Code 24.6	| 1 1 0 0 0 | 1 1 0 | . . . .  . . . . . . . . . . . .  |
				|___________|_______|___________________________________|





	Jump Zero b		jzb
	___________		___

				_________________________________________________________
				|							|
				|	jump to EA					|
				|	if all bits of Arithmetic Register b are 0	|
				|_______________________________________________________|


	assembler syntax	jzb	jump_address[, {x|y|a|b|fp|sp}]
				jzb	*jump_pointer

				_________________________________________________________
	Instruction Code 25.6	| 1 1 0 0 1 | 1 1 0 | . . . .  . . . . . . . . . . . .  |
				|___________|_______|___________________________________|





	Jump NonZero a		jnza
	______________		____
	
				_________________________________________________________
				|							|
				|	jump to EA					|
				|	if any bits of Arithmetic Register a are 1	|
				|_______________________________________________________|

	assembler syntax	jnza	jump_address[, {x|y|a|b|fp|sp}]
				jnza	*jump_pointer

				_________________________________________________________
	Instruction Code 26.6	| 1 1 0 1 0 | 1 1 0 | . . . .  . . . . . . . . . . . .  |
				|___________|_______|___________________________________|





	Jump NonZero b		jnzb
	______________		____

				_________________________________________________________
				|							|
				|	jump to EA					|
				|	if any bits of Arithmetic Register b are 1	|
				|_______________________________________________________|

	assembler syntax	jnzb	jump_address[, {x|y|a|b|fp|sp}]
				jnzb	*jump_pointer

				_________________________________________________________
	Instruction Code 27.6	| 1 1 0 1 1 | 1 1 0 | . . . .  . . . . . . . . . . . .  |
				|___________|_______|___________________________________|





	Jump Negative a		jna
	_______________		___
	
				_________________________________________________________
				|							|
				|	jump to EA					|
				|	if bit 23 of Arithmetic Register a = 1		|
				|_______________________________________________________|

	assembler syntax	jna	jump_address[, {x|y|a|b|fp|sp}]
				jna	*jump_pointer

				_________________________________________________________
	Instruction Code 28.6	| 1 1 1 0 0 | 1 1 0 | . . . .  . . . . . . . . . . . .  |
				|___________|_______|___________________________________|





	Jump Negative b		jnb
	_______________		___

				_________________________________________________________
				|							|
				|	jump to EA					|
				|	if bit 23 of Arithmetic Register b = 1		|
				|_______________________________________________________|

	assembler syntax	jnb	jump_address[, {x|y|a|b|fp|sp}]
				jnb	*jump_pointer

				_________________________________________________________
	Instruction Code 29.6	| 1 1 1 0 1 | 1 1 0 | . . . .  . . . . . . . . . . . .  |
				|___________|_______|___________________________________|





	Jump x Greater or Equal	jxge
	_______________________	___

				_________________________________________________________
				|							|
				|	jump to EA unless Index Register x is less than	|
				|	Repeat Counter r				|
				|_______________________________________________________|

	assembler syntax	jxge	jump_address[, {x|y|a|b|fp|sp}]
				jxge	*jump_pointer




				_________________________________________________________
	Instruction Code 30.6	| 1 1 1 1 0 | 1 1 0 | . . . .  . . . . . . . . . . . .  |
				|___________|_______|___________________________________|




	Jump y Greater or Equal	jyge
	_______________________	____

				_________________________________________________________
				|							|
				|	jump to EA unless Index Register y is less than	|
				|	Repeat Counter r				|
				|_______________________________________________________|

	assembler syntax	jyge	jump_address[, {x|y|a|b|fp|sp}]
				jyge	*jump_pointer


				_________________________________________________________
	Instruction Code 31.6	| 1 1 1 1 1 | 1 1 0 | . . . .  . . . . . . . . . . . .  |
				|___________|_______|___________________________________|



</pre>
<h5>Instruction File 7</h5>

<p>
The 31 instructions in Instruction File 7 have an operand of one, two or four words

<p>The first eight of these instructions <b>ts n inc dec src slc sim popA</b> must execute atomically with storage
lock if the operand is in storage. <b>ts</b> achieves nothing if the operand is a register instead of storage, because
its function is to co-ordinate with other CPUs via a storage word. <b>n inc dec src slc sim popA</b> can be very
usefully executed on registers or storage. Registers have no storage lock and <b>n inc dec src slc sim popA</b>
operate without lock in the register stack and with lock in storage.
<pre>



	Test and Set		ts
	____________		__

				_________________________________________________________
				|							|
				|	atomically					|
				|	read storage location and rewrite 1 to bit 23	|
				|							|
				|	skip the next instruction if bit 23 was 0 before|
				|_______________________________________________________|



	assembler		ts	lock_cell[, {x|y|a|b|fp|sp}]
	syntax/example		j	$-1

				ts	*pointer_to_lock_cell
				lcal	wait_and_try_again


				_________________________________________________________
	Instruction Code 0.7	| 0 0 0 0 0 | 1 1 1 | . . . .  . . . . . . . . . . . .  |
				|___________|_______|___________________________________|







	Negate			n
	______			_

				_________________________________________________________
				|							|
				|	rewrite the word at EA in its ones complement	|
				|_______________________________________________________|



	assembler syntax	n	mantissa[, {x|y|a|b|fp|sp}]

				n	*pointer_to_switch



				_________________________________________________________
	Instruction Code 1.7	| 0 0 0 0 1 | 1 1 1 | . . . .  . . . . . . . . . . . .  |
				|___________|_______|___________________________________|





	Increment		inc
	_________		___

				_________________________________________________________
				|							|
				|	add 1 to the word at EA. carry$ is not affected	|
				|_______________________________________________________|



	assembler syntax	inc	tally[, {x|y|a|b|fp|sp}]

				inc	*pointer2uptozerocounter



				_________________________________________________________
	Instruction Code 2.7	| 0 0 0 1 0 | 1 1 1 | . . . .  . . . . . . . . . . . .  |
				|___________|_______|___________________________________|




	Decrement		dec
	_________		___

				_________________________________________________________
				|							|
				|	add -1 to the word at EA. carry$ is not affected|
				|_______________________________________________________|



	assembler syntax	dec	counter[, {x|y|a|b|fp|sp}]

				dec	*pointer_to_counter



				_________________________________________________________
	Instruction Code 3.7	| 0 0 0 1 1 | 1 1 1 | . . . .  . . . . . . . . . . . .  |
				|___________|_______|___________________________________|




	Switch Interrupt Mask	sim
	_____________________	___

				_________________________________________________________
				|							|
				|	exchange PSR bits 18..16 interrupt mask		|
				|	with the word at EA. Bits 23..3 of the storage	|
				|	word are dropped on read and zero on write	|
				|_______________________________________________________|
				|	PSR		I000 0iii 0xxx xxxx Hyyy 000C	|
				|_______________________________________________________|
				|	storage		0000 0000 0000 0000 0000 0iii	|
				|_______________________________________________________|



	assembler syntax	sim	aside_location[, {x|y|a|b|fp|sp}]

				sim	*pointer_to_imask_save


	assembler example	push	MAXIMUM_IMASK,,xi
				sim	0, sp
				.
				.
				sim	0, sp
				inc	sp


				_________________________________________________________
	Instruction Code 4.7	| 0 0 1 0 0 | 1 1 1 | . . . .  . . . . . . . . . . . .  |
				|___________|_______|___________________________________|




	Pop and AddTo		popA
	_____________		____

				_________________________________________________________
				|							|
				|	add the word at SP on the internal stack to the	|
				|	word at EA. carry$ = the carry out of bit 23	|
				|	of the addition. sp is incremented		|
				|							|
                                |       on internal stack overflow / underflow		|
                                |       [sp < 24 | sp > 127] before operation           |
                                |       guard interrupt 95 is raised                    |
                                |                                                       |
				|_______________________________________________________|



	assembler syntax	popA	storage_total[, {x|y|a|b|fp|sp}]

				popA	*pointer_to_storage_total



				_________________________________________________________
	Instruction Code 5.7	| 0 0 1 0 1 | 1 1 1 | . . . .  . . . . . . . . . . . .  |
				|___________|_______|___________________________________|




	Shift Right through Carry	src
	_________________________	___

				_________________________________________________________
				|							|
				|	rotate the word at EA and carry$ in a 25-bit	|
				|	ring rightwards	one bit position		|
				|_______________________________________________________|



	assembler syntax	src	rounding_overflow[, {x|y|a|b|fp|sp}]

				src	*bit_race_indirectly



				_________________________________________________________
	Instruction Code 6.7	| 0 0 1 1 0 | 1 1 1 | . . . .  . . . . . . . . . . . .  |
				|___________|_______|___________________________________|




	Shift Left through Carry	slc
	________________________	___

				_________________________________________________________
				|							|
				|	rotate the word at EA and carry$ in a 25-bit	|
				|	ring leftwards one bit position			|
				|_______________________________________________________|



	assembler syntax	slc	attention_flags[, {x|y|a|b|fp|sp}]

				slc	*pointer_to_ring



				_________________________________________________________
	Instruction Code 7.7	| 0 0 1 1 1 | 1 1 1 | . . . .  . . . . . . . . . . . .  |
				|___________|_______|___________________________________|






	Quadruple Store		qs
	_______________		__

				_________________________________________________________
				|							|
				|	store four Arithmetic Registers			|
				|	a b mantissa2 mantissa3				|
				|							|
				|	Register a is stored at register / storage EA	|
				|	Register b is stored at register / storage EA+1	|
				|	mantissa2  is stored at register / storage EA+2	|
				|	mantissa3  is stored at register / storage EA+3	|
				|_______________________________________________________|
				|	store address EA is any word address		|
				|_______________________________________________________|



	assembler syntax	qs	sum[, {x|y|a|b|fp|sp}]

				qs	*pointer_to_sum



				_________________________________________________________
	Instruction Code 8.7	| 0 1 0 0 0 | 1 1 1 | . . . .  . . . . . . . . . . . .  |
				|___________|_______|___________________________________|







	Quadruple Load		ql
	______________		__

				_________________________________________________________
				|							|
				|	load four Arithmetic Registers			|
				|	a b mantissa2 mantissa3				|
				|							|
				|	register / storage at EA   loads to Register a	|
				|	register / storage at EA+1 loads to Register b	|
				|	register / storage at EA+2 loads to mantissa2	|
				|	register / storage at EA+3 loads to mantissa3	|
				|_______________________________________________________|
				|	load address EA is any word address		|
				|_______________________________________________________|



	assembler syntax	ql	sum[, {x|y|a|b|fp|sp}]

				ql	*pointer_to_sum

				ql	(250600004700003450.630*+1262001)


				_________________________________________________________
	Instruction Code 9.7	| 0 1 0 0 1 | 1 1 1 | . . . .  . . . . . . . . . . . .  |
				|___________|_______|___________________________________|



	_________________________________________________________________________________________________________________________________
	|						The 96-bit Floating Architecture						|
	|_______________________________________________________________________________________________________________________________|
	|																|
	|																|
	|			RTA1 has four floating operation instructions and two instructions for					|
	|			storage compression and expansion of floating numbers							|
	|																|
	|			Four consecutive computer words form a 96-bit floating number						|
	|																|
	|			the 72-bit mantissa is a simple fraction in bits 71..0							|
	|																|
	|			The mantissa has no integer part either represented or unrepresented					|
	|																|
	|			The binary point is between the normalising bit 71 and the characteristic field in bits 94..72 		|
	|																|
	|			An integer value is obtained by hauling the mantissa upwards through the binary point			|
	|			for the shift distance by which the characteristic exceeds the midpoint value of 400000 hexadecimal	|
	|																|
	|			The midpointed 23-bit characteristic covers the range of decimal exponents -1262611 to +1262611		|
	|																|
	|			A characteristic of zero expresses the lowest possible exponent						|
	|																|
	|			A characteristic at midpoint 400000 expresses the zero exponent. The normalised number is >= 0.5 and < 1|
	|																|
	|			A maximum characteristic 7FFFFF expresses the highest possible exponent					|
	|																|
	|			Bit 95 = 1 indicates the the number is a ones complement negative number				|
	|																|
	|			Bit 95 is not a sign bit in the sense of indicating negative polarity over a following positive		|
	|			magnitude. It is an indication that all the bits of the positive magnitude are flipped to make		|
	|			a negative number											|
	|																|
	|			Internally addition and subtraction require no conditional inversions					|
	|			Subtraction is the addition of a ones complement							|
	|																|
	|			A number is normalised if bit 71 is different from sign bit 95						|
	|																|
	|			All unnormalised numbers have the algebraic value of zero						|
	|																|
	|																|
	|																|
	|																|
	|																|
	|			The format of an RTA1 floating number									|
	|			_____________________________________									|
	|																|
	|			95  94			 71								       0	|
	|			_________________________________________________________________________________________________	|
	|			|s|    characteristic	|				mantissa				|	|
	|			|_|_____________________|_______________________________________________________________________|	|
	|																|
	|																|
	|_______________________________________________________________________________________________________________________________|




	Floating Pop and Pack	fpp
	_____________________	___


				_________________________________________________________
				|							|
				|	compress the 96-bit floating number at the	|
				|	Internal Stack Top and store it as two words to	|
				|	register / storage at EA			|
				|							|
				|	bits 21..10 of the characteristic are discarded	|
				|	retaining the midpoint bit of the characteristic|
				|	and its 10 low-order bits			|
				|							|
				|	bits 35..0 of the mantissa are discarded. fpp	|
				|	is strictly a logical movement of bit values	|
				|	and no rounding takes place			|
				|							|
				|	a number should only be packed to store if the	|
				|	48-bit format can represent it			|
				|							|
				|	high-order bits 47..24 of the compressed number	|						
				|	are stored at EA				|
				|							|
				|	low-order bits 23..0 of the compressed number	|
				|	are stored at EA+1				|
				|							|
				|	increment the Internal Stack Pointer sp by 4	|
				|							|
				|_______________________________________________________|
				|	store address EA is any word address		|
				|_______________________________________________________|




	<div	style="font-size:8pt">

                                 95                                                                                                                           0
                                _________________________________________________________________________________________________________________________________
        4-word source from	| sxyy yyyy yyyy yyxx xxxx xxxx | mmmm mmmm mmmm mmmm mmmm mmmm | mmmm mmmm mmmm nnnn nnnn nnnn | nnnn nnnn nnnn nnnn nnnn nnnn |
        internal stack top      |_______________________________|_______________________________|_______________________________|_______________________________|
        __________________     


        discarded bits              yy yyyy yyyy yy								 nnnn nnnn nnnn   nnnn nnnn nnnn nnnn nnnn nnnn
        ______________              _______________                                                              ______________________________________________
                                    exponent bits 21..10							 mantissa bits 35..0



                                _________________________________________________________________
        2-word stored		| sxxx xxxx xxxx mmmm mmmm mmmm | mmmm mmmm mmmm mmmm mmmm mmmm |
        pop target		|_______________________________|_______________________________|
        _____________		 47							      0

	</div>








	assembler syntax	fpp	floating_packed_storage[, {x|y|a|b|fp|sp}]

				fpp	*pointer_to_store



				_________________________________________________________
	Instruction Code 10.7	| 0 1 0 1 0 | 1 1 1 | . . . .  . . . . . . . . . . . .  |
				|___________|_______|___________________________________|







	Floating Push and Expand	fpx
	________________________	___


				_________________________________________________________
				|							|
				|	decrement the Internal Stack Pointer sp by 4	|
				|							|
				|	load the 48-bit compressed floating number from	|
				|	registers / storage at EA			|
				|							|
				|	place it on the Internal Stack Top in 96-bit	|
				|	computing format				|
				|							|
				|	12 sign bits are added between bits 10 and 9 of |
				|	the compressed characteristic or 12 reverse	|
				|	signs if the characteristic is below midpoint	|	
				|	and the number is nonzero and normalised	|
				|							|
				|	36 sign bits are added to the mantissa		|
				|							|
				|_______________________________________________________|
				|	load address EA is any word address		|
				|_______________________________________________________|



	<div    style="font-size:8pt">

				 95															      0
				_________________________________________________________________________________________________________________________________
	4-word result on	| sxff ffff ffff ffxx xxxx xxxx	| mmmm mmmm mmmm mmmm mmmm mmmm	| mmmm mmmm mmmm ssss ssss ssss	| ssss ssss ssss ssss ssss ssss	|
	internal stack top	|_______________________________|_______________________________|_______________________________|_______________________________|
	__________________	
				

	inserted bits		    ff ffff ffff ff								 ssss ssss ssss	  ssss ssss ssss ssss ssss ssss
	_____________		    _______________	    							 ______________________________________________
    				    12 * sign ^ midpoint ^ 1 							 36 * sign



				_________________________________________________________________
	2-word loaded		| sxxx xxxx xxxx mmmm mmmm mmmm | mmmm mmmm mmmm mmmm mmmm mmmm	| 
	push source		|_______________________________|_______________________________|
	____________		 47							      0


	</div>



	assembler syntax	fpx	floating_packed_storage[, {x|y|a|b|fp|sp}]

				fpx	*pointer_to_floating_packed

				fpx	(4.4510310377d*+300)


				_________________________________________________________
	Instruction Code 11.7	| 0 1 0 1 1 | 1 1 1 | . . . .  . . . . . . . . . . . .  |
				|___________|_______|___________________________________|







	Floating Add		fa
	_____________		__

				_________________________________________________________
				|							|
				|	add the four-word floating-point number		|
				|	in registers / storage at EA			|
				|	to the four-word floating-point number		|
				|	in Arithmetic Registers a b mantissa2 mantissa3	|
				|							|
				|	Register a contains sign and characteristic bits|
				|	95..72 of one addend and of the sum		|
				|							|
				|	Registers b mantissa2 mantissa3 contain	the	|	
				|	mantissa of one addend and of the sum with	|
				|	highest order bits in Register b and lowest	|
				|	order bits in Register mantissa3		|
				|							|
				|	the word at EA contains sign and characteristic	|
				|	bits of the other addend. The highest order	|
				|	mantissa bits are at EA+1, bits 47..24 at EA+2	|
				|	and the lowest order mantissa bits are at EA+3	|
				|							|
				|_______________________________________________________|
				|	addend address EA is any word address		|
				|_______________________________________________________|



	assembler syntax	fa	addend[, {x|y|a|b|fp|sp}]

				fa	*pointer_to_addend

				fa	(2.50600004700003450630*+1262600)


				_________________________________________________________
	Instruction Code 12.7	| 0 1 1 0 0 | 1 1 1 | . . . .  . . . . . . . . . . . .  |
				|___________|_______|___________________________________|







	Floating Add Negative		fan
	_____________________		__

				_________________________________________________________
				|							|
				|	add the ones complement of the four-word	|
				|	floating-point number in registers / storage	|
				|	at EA to the four-word floating-point number	|
				|	in Arithmetic Registers a b mantissa2 mantissa3	|
				|							|
				|	Register a contains sign and characteristic bits|
				|	95..72 of the minuend and of the difference	|
				|							|
				|	Registers b mantissa2 mantissa3 contain the	|	
				|	mantissa of the minuend and of the difference	|
				|	with highest order bits in Register b and	|
				|	lowest order bits in Register mantissa3		|
				|							|
				|	the word at EA contains sign and characteristic	|
				|	bits of the subtrahend. The highest order	|
				|	mantissa bits are at EA+1, bits 47..24 at EA+2	|
				|	ans the lowest order mantissa bits are at EA+3	|
				|							|
				|_______________________________________________________|
				|	subtrahend address EA is any word address	|
				|_______________________________________________________|




	assembler syntax	fan	subtrahend[, {x|y|a|b|fp|sp}]

				fan	*subtrahend_indirectly

				fan	(457600004700003450.630*+1262001)


				_________________________________________________________
	Instruction Code 13.7	| 0 1 1 0 1 | 1 1 1 | . . . .  . . . . . . . . . . . .  |
				|___________|_______|___________________________________|







	Floating Multiply	fm
	_________________	__

				_________________________________________________________
				|							|
				|	multiply the four-word floating-point number	|
				|	in Arithmetic Registers a b mantissa2 mantissa3	|
				|	by the four-word floating-point number in	|
				|	registers / storage at EA			|
				|							|
				|	Register a contains sign and characteristic bits|
				|	95..72 of the multiplicand and of the product	|
				|							|
				|	Registers b mantissa2 mantissa3 contain the	|	
				|	mantissa of the multiplicand and of the product	|
				|	with highest order bits in Register b and	|
				|	lowest oder bits in mantissa3			|
				|							|
				|	the word at EA contains sign and characteristic	|
				|	bits of the multiplier. The highest order	|
				|	mantissa bits are at EA+1, bits 47..24 at EA+2	|
				|	ans the lowest order mantissa bits are at EA+3	|
				|							|
				|_______________________________________________________|
				|	multiplier address EA is any word address	|
				|_______________________________________________________|



	assembler syntax	fm	multiplier[, {x|y|a|b|fp|sp}]

				fm	*multiplier_indirectly

				fm	(250600004700003450.630*-1262001)


				_________________________________________________________
	Instruction Code 14.7	| 0 1 1 1 0 | 1 1 1 | . . . .  . . . . . . . . . . . .  |
				|___________|_______|___________________________________|







	Floating Divide		fd
	_______________		__

				_________________________________________________________
				|							|
				|	divide the four-word floating-point number	|
				|	in Arithmetic Registers a b mantissa2 mantissa3	|
				|	by the four-word floating-point number in	|
				|	registers / storage at EA			|
				|							|
				|	Register a contains sign and characteristic bits|
				|	95..72 of the dividend and of the quotient	|
				|							|
				|	Registers b mantissa2 mantissa3 contain the	|	
				|	mantissa of the dividend and of the quotient	|
				|	with highest order bits in Register b and	|
				|	lowest oder bits in mantissa3			|
				|							|
				|	the word at EA contains sign and characteristic	|
				|	bits of the divisor. The highest order		|
				|	mantissa bits are at EA+1, bits 47..24 at EA+2	|
				|	ans the lowest order mantissa bits are at EA+3	|
				|							|
				|_______________________________________________________|
				|	divisor address EA is any word address		|
				|_______________________________________________________|



	assembler syntax	fd	divisor[, {x|y|a|b|fp|sp}]

				fd	*divisor_indirectly

				fd	(458.600004700003450630*+1262001)


				_________________________________________________________
	Instruction Code 15.7	| 0 1 1 1 1 | 1 1 1 | . . . .  . . . . . . . . . . . .  |
				|___________|_______|___________________________________|







	Quadruple Pop		qpop
	_____________		____

				_________________________________________________________
				|							|
				|	store four words from the Internal Stack Top	|
				|							|
				|	store order is as stack order 	0, sp -> EA	|
				|					1, sp -> EA+1	|
				|					2, sp -> EA+2	|
				|					3, sp -> EA+3	|
				|							|
				|	increment the Internal Stack Pointer sp by 4	|
				|							|
                                |       on internal stack overflow / underflow		|
                                |       [sp < 24 | sp > 124] before operation           |
                                |       guard interrupt 95 is raised                    |
				|							|
				|_______________________________________________________|
				|	store address EA is any word address		|
				|_______________________________________________________|



	assembler syntax	qpop	buffer[, {x|y|a|b|fp|sp}]

				qpop	*pointer_to_buffer



				_________________________________________________________
	Instruction Code 16.7	| 1 0 0 0 0 | 1 1 1 | . . . .  . . . . . . . . . . . .  |
				|___________|_______|___________________________________|







	Quadruple Push		qpush
	______________		_____

				_________________________________________________________
				|							|
				|	decrement Internal Stack Pointer sp by 4	|
				|							|
				|	load four registers / storage words from	|
				|	address EA to the Internal Stack at sp		|
				|							|
				|	the word read from EA is at the stack top  0,sp	|
				|	the word read from EA+1 is at stack top+1  1,sp	|
				|	the word read from EA+2 is at stack top+2  2,sp	|
				|	the word read from EA+3 is at stack top+3  3,sp	|
				|							|
                                |       on internal stack overflow / underflow		|
                                |       [sp < 28 | sp > 128] before operation           |
                                |       guard interrupt 95 is raised                    |
                                |                                                       |
				|_______________________________________________________|
				|	operand is two words at EA = any location	|
				|_______________________________________________________|




	assembler syntax	qpush	buffer[, {x|y|a|b|fp|sp}]

				qpush	*pointer_to_buffer

				qpush	(623600004700003450.630*+1262001)


				_________________________________________________________
	Instruction Code 17.7	| 1 0 0 0 1 | 1 1 1 | . . . .  . . . . . . . . . . . .  |
				|___________|_______|___________________________________|







	Execute			ex
	_______			__

				_________________________________________________________
				|							|
				|	read a data word from the operand address space	|
				|	decode and execute it as an instruction		|
				|							|
				|	if the target instruction is not a jump, call,  |
				|	skip or	interrupt, execution continues at the	|
				|	instruction after the execute instruction	|
				|							|
				|	if the target instruction decides to jump, call,|
				|	skip or interrupt, execution continues at the	|
				|	jump target. If the target instruction is a call|
				|	or interrupt, return is to the instruction	|
				|	after the execute instruction			|
				|_______________________________________________________|
				|	operand is the word at EA			|
				|_______________________________________________________|



	assembler syntax	ex	instruction[, {x|y|a|b|fp|sp}]

				ex	*instruction_indirectly


	assembler example


		next_column	jxge		frame_scanned
				ex		key_difference, x
				ax, xi		1
				and, xi		4095
				aa		crc12_table_pointer
				la		0, a
				j		next_column


		key_difference
		column		$do		ARRAY_LIMIT,    ;
				xor		frame+(column-1)/2, b, h1+(column-1)///2

		........................................................................

				lx		bytes
				lb, xi		0
				on		b$streamZR

		next_digit	rsr		BYTE
				ax, xi		-1
				ex		raise,x 
				tz		x
				j		next_digit

				

		raise		ab		units-'0', a
				ab		tens-'0', a
				ab		hundreds-'0', a
				ab		thousands-'0', a
				ab		ten_thousands-'0', a
				ab		hundred_thousands-'0', a



					


				_________________________________________________________
	Instruction Code 18.7	| 1 0 0 1 0 | 1 1 1 | . . . .  . . . . . . . . . . . .  |
				|___________|_______|___________________________________|







	Double Push		dpush
	___________		_____

				_________________________________________________________
				|							|
				|	decrement Internal Stack Pointer sp by 2	|
				|	load two registers / storage words from		|
				|	address EA to the Internal Stack at sp		|
				|							|
				|	the word read from EA is at the stack top  0,sp	|
				|	the word read from EA+1 is at stack top+1  1,sp	|
				|							|
                                |       on internal stack overflow / underflow		|
                                |       [sp < 26 | sp > 128] before operation           |
                                |       guard interrupt 95 is raised                    |
                                |                                                       |
				|_______________________________________________________|
				|	operand is two words at EA = any location	|
				|_______________________________________________________|



	assembler syntax	dpush	preload48[, {x|y|a|b|fp|sp}]

				dpush	*preload48_indirectly

				dpush	(258000000000000:d)



				_________________________________________________________
	Instruction Code 19.7	| 1 0 0 1 1 | 1 1 1 | . . . .  . . . . . . . . . . . .  |
				|___________|_______|___________________________________|







	Load Shift and Count	lsc
	____________________	lsc

				_________________________________________________________
				|							|
				|	load the register / storage word at EA		|
				|	to Arithmetic Register a			|
				|							|
				|	rotate left counting until bit 23 changes	|
				|							|
				|	stop at 24 if all bits are the same		|
				|							|
				|	store the shift count in Arithmetic Register b	|
				|							|
				|_______________________________________________________|
				|	operand is the word at EA			|
				|_______________________________________________________|




	assembler syntax	lsc	short_mantissa[, {x|y|a|b|fp|sp}]

				lsc	*short_mantissa_indirectly



				_________________________________________________________
	Instruction Code 20.7	| 1 0 1 0 0 | 1 1 1 | . . . .  . . . . . . . . . . . .  |
				|___________|_______|___________________________________|







	Masked Test Equal a	mta
	___________________	___

				_________________________________________________________
				|							|
				|	skip the next instruction if			|
				|	(Register a AND Mask Register k) equals		|
				|	(register / storage at EA) AND Mask Register k 	|
				|_______________________________________________________|
				|	comparand is storage word at EA			|
				|_______________________________________________________|



	assembler syntax	mta	comparand[, {x|y|a|b|fp|sp}]

				mta	*comparand_indirectly


	assembler_example	lk	(0FFFF00:s)
				mta	(00D0A00:s)
				j	not_cr_lf



				_________________________________________________________
	Instruction Code 21.7	| 1 0 1 0 1 | 1 1 1 | . . . .  . . . . . . . . . . . .  |
				|___________|_______|___________________________________|







	Store Carry		sc
	___________		__

				_________________________________________________________
				|							|
				|	store Processor State Register AND 1		|
				|	at the target register / storage word		|
				|_______________________________________________________|
				|	store address EA is any word address		|
				|_______________________________________________________|



	assembler syntax	sc	next_add_word[, {x|y|a|b|fp|sp}]

				sc	*pointer_to_next_add_word



				_________________________________________________________
	Instruction Code 22.7	| 1 0 1 1 0 | 1 1 1 | . . . .  . . . . . . . . . . . .  |
				|___________|_______|___________________________________|







	Masked Load b		mlb
	_____________		___

				_________________________________________________________
				|							|
				|	load Arithmetic Register b with 		|
				|	   (register / storage AND Mask Register k)	|
					OR (Register b AND (NOT Mask Register k))	|
				|_______________________________________________________|
				|	operand is the storage word at EA		|
				|_______________________________________________________|



	assembler syntax	mlb	word2merge[, {x|y|a|b|fp|sp}]

				mlb	*pointer_to_word2merge



				_________________________________________________________
	Instruction Code 23.7	| 1 0 1 1 1 | 1 1 1 | . . . .  . . . . . . . . . . . .  |
				|___________|_______|___________________________________|







	Double Store		ds
	____________		__

				_________________________________________________________
				|							|
				|	store Arithmetic Registers a and b		|
				|	to two registers / storage words at EA		|
				|							|
				|	Register a is stored at EA			|
				|	Register b is stored at EA+1			|
				|_______________________________________________________|
				|	storage address EA = any word address		|
				|_______________________________________________________|




	assembler syntax	ds	destination48[, {x|y|a|b|fp|sp}]

				ds	*pointer_to_destination48



				_________________________________________________________
	Instruction Code 24.7	| 1 1 0 0 0 | 1 1 1 | . . . .  . . . . . . . . . . . .  |
				|___________|_______|___________________________________|







	Double Load		dl
	___________		__

				_________________________________________________________
				|							|
				|	load two registers / storage words at EA	|
				|	to Arithmetic Registers a and b			|
				|							|
				|	the word at EA is loaded to Register a		|
				|	the word at EA+1 is loaded to Register b	|
				|_______________________________________________________|
				|	operand is two words at EA = any location	|
				|_______________________________________________________|




	assembler syntax	dl	from48[, {x|y|a|b|fp|sp}]

				dl	*pointer_to_from48

				dl	(258000000000000:d)


				_________________________________________________________
	Instruction Code 25.7	| 1 1 0 0 1 | 1 1 1 | . . . .  . . . . . . . . . . . .  |
				|___________|_______|___________________________________|







	Double Add		da
	__________		__

				_________________________________________________________
				|							|
				|	add the 48-bit integer in			|
				|	the two registers / storage words at EA		|
				|	to Arithmetic Registers a and b			|
				|							|
				|	the word at EA forms high-order bits 47..24	|
				| 	of the addend					|
				|							|
				|	the word at EA+1 forms low-order bits 23..0	|
				|	of the addend					|
				|							|
				|	carry$ = the carry from bit 47 of the addition	|
				|_______________________________________________________|
				|	operand is two words at EA = any location	|
				|_______________________________________________________|



	assembler syntax	da	addend48[, {x|y|a|b|fp|sp}]

				da	*addend48_indirectly

				da	(-120000000000000)

				_________________________________________________________
	Instruction Code 26.7	| 1 1 0 1 0 | 1 1 1 | . . . .  . . . . . . . . . . . .  |
				|___________|_______|___________________________________|







	Double Add Negative	dan
	__________________	___

				_________________________________________________________
				|							|
				|	add the 2s complement of the 48-bit integer in	|
				|	the two registers / storage words at EA		|
				|	to Arithmetic Registers a and b			|
				|							|
				|	the word at EA forms high-order bits 47..24	|
				| 	of the subtrahend				|
				|							|
				|	the word at EA+1 forms low-order bits 23..0	|
				|	of the subtrahend				|
				|							|
				|	carry$ = the carry from bit 47 of the addition	|
				|_______________________________________________________|
				|	operand is two words at EA = any location	|
				|_______________________________________________________|



	assembler syntax	dan	subtrahend48[, {x|y|a|b|fp|sp}]

				dan	*subtrahend48_indirectly

				dan	(120000000000000)


				_________________________________________________________
	Instruction Code 27.7	| 1 1 0 1 1 | 1 1 1 | . . . .  . . . . . . . . . . . .  |
				|___________|_______|___________________________________|







	Double Load Shift and Count	dlsc
	___________________________	____

				_________________________________________________________
				|							|
				|	load the two registers / storage words at EA	|
				|	to Arithmetic Registers a and b			|
				|							|
				|	the word from EA is placed in Register a	|
				|	the word form EA+1 is placed in Register b	|
				|							|
				|	rotate left counting until bit 47 changes	|
				|							|
				|	stop at 48 if all bits are the same		|
				|							|
				|	store the shift count in Register mantissa2	|
				|							|
				|_______________________________________________________|
				|	operand is two words at EA = any location	|
				|_______________________________________________________|



	assembler syntax	dlsc	mantissa[, {x|y|a|b|fp|sp}]

				dlsc	*mantissa_indirectly



				_________________________________________________________
	Instruction Code 28.7	| 1 1 1 0 0 | 1 1 1 | . . . .  . . . . . . . . . . . .  |
				|___________|_______|___________________________________|







	Go			go
	__			__

				_________________________________________________________
				|							|
				|	Far Bank Jump					|
				|							|
				|							|
				|	read storage word / register at EA		|
				|							|
				|							|
				|	depending bit 22 the storage operand contains	|
				|							|
				|		a 16-bit pointer to a bank at a 4Kword	|
				|		boundary and a 6-bit vector offset:	|
				|							|
				|		target bank starts at a 4Kword block in |
				|		first 256 Megawords of executable space	|
				|		and has 64 entry points			|
				|							|
				|	or	a 19-bit pointer to a bank at a 32Kword	|
				|		boundary and a 3-bit vector offset:	|
				|							|
				|		target bank starts at any 32Kword	|
				|		boundary in 16 Gigawords of executable	|
				|		space and has 8 entry points		|
				|							|
				|							|
				|	operand bit 22 = 0:				|
				|							|
				|		B0 = operand bits 21..6			|
				|		PC = B0 * 4096 + operand 5..0		|
				|							|
				|	operand bit 22 = 1:				|
				|							|
				|		B0 = operand word bits 21..3 * 8	|
				|		PC = B0 * 4096 + operand 2..0		|
				|							|
				|	operand bit 23 = 1:				|
				|							|
				|		translating target bank identifier	|
				|		not implemented				|
				|							|
				|_______________________________________________________|
				| 00 |       pointer to 4K-aligned bank   |       vector|
				|____|21__________________________________|5___________0|
				| 01 |       pointer to 32K-aligned bank         |vector|
				|____|21________________________________________ |2____0|
				|	     operand is the storage word at EA		|
				|_______________________________________________________|



	assembler syntax	go	target_identifier[, {x|y|a|b|fp|sp}]

				go	*target_identifier_indirectly

				go	(BANK_ADDRESS/4096*/6++3)

				go	(HIGH_MEMORY_ADDRESS/32768*/3++AVECTOR)



				_________________________________________________________
	Instruction Code 30.7	| 1 1 1 1 0 | 1 1 1 | . . . .  . . . . . . . . . . . .  |
				|___________|_______|___________________________________|







	Call			call
	____			____

				_________________________________________________________
				|							|
				|	Far Bank Call					|
				|							|
				|	push Program Counter minus B0 to Internal Stack	|
				|							|
				|	push B0	to Internal Stack			|
				|							|
				|	read storage word / register at EA		|
				|							|
				|							|
				|	depending bit 22 the storage operand contains	|
				|							|
				|		a 16-bit pointer to a bank at a 4Kword	|
				|		boundary and a 6-bit vector offset:	|
				|							|
				|		target bank starts at a 4Kword block in |
				|		first 256 Megawords of executable space	|
				|		and has 64 entry points			|
				|							|
				|	or	a 19-bit pointer to a bank at a 32Kword	|
				|		boundary and a 3-bit vector offset:	|
				|							|
				|		target bank starts at any 32Kword	|
				|		boundary in 16 Gigawords of executable	|
				|		space and has 8 entry points		|
				|							|
				|							|
				|	operand bit 22 = 0:				|
				|							|
				|		B0 = operand bits 21..6			|
				|		PC = B0 * 4096 + operand 5..0		|
				|							|
				|	operand bit 22 = 1:				|
				|							|
				|		B0 = operand word bits 21..3 * 8	|
				|		PC = B0 * 4096 + operand 2..0		|
				|							|
				|	operand bit 23 = 1:				|
				|							|
				|		translating target bank identifier	|
				|		not implemented				|
                                |                                                       |
                                |       on internal stack overflow / underflow		|
                                |       [sp < 26 | sp > 128] before operation           |
                                |       guard interrupt 95 is raised                    |
				|							|
				|_______________________________________________________|
				| 00 |       pointer to 4K-aligned bank   |       vector|
				|____|21__________________________________|5___________0|
				| 01 |       pointer to 32K-aligned bank         |vector|
				|____|21________________________________________ |2____0|
				|	     operand is the storage word at EA		|
				|_______________________________________________________|



	assembler syntax	call		target_identifier[, {x|y|a|b|fp|sp}]

				call		*target_identifier_indirectly

				call		(PAGE_INDEX*/6++VECTOR_OFFSET)

				call		(HIGH_MEMORY_32KBLOCK*/3++ROUTINE_VECTOR)



				_________________________________________________________
	Instruction Code 31.7	| 1 1 1 1 1 | 1 1 1 | . . . .  . . . . . . . . . . . .  |
				|___________|_______|___________________________________|







<i>

    _____________________________________________________________________________________



    LICENCE NOTICE



    Copyright Tim Cox, 2012
    TimMilesCox@gmx.ch

    This processor programmable architecture specification
    is the principal and central work delivered here.

    It is the specification of the freeware processor architecture

                RTA1

    RTA1 is a free processor architecture specification. It is licensed
    under the GNU General Public Licence Version 3

    The executable emulation of RTA1 is free software.

    Instruction code for the target RTA1 architecture is free software
    if it is delivered with this software

    Software programs delivered with this software to connect the
    emulated RTA1 with real network interfaces in the emulator host
    are free software

    Scripts and programs delivered with this software for running
    on other computers and interacting with the RTA1 are free software

    The masmx target-independent meta-asembler delivered here
    is free software whether it is used for constructing RTA1 code
    or any other code. masmx is a separate free program by the
    same author and included with this software to save searching for it

    Scripts and utility programs for constructing RTA1 target
    executable software are free software

    You can redistribute it and/or modify RTA1
    under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    RTA1 is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with RTA1.  If not, see &lt;http://www.gnu.org/licenses/&gt;.

</i>
</pre>
</div>
</html>
