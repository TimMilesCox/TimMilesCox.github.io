<html>
<div	style="font-size:15pt">

<h1>RTA1: The Author's Footnote and Contact</h1>


<p>
RTA1 architecture specification exists because I want to work with it. Nearly all
the ideas used in RTA1 existed before. A machine architecture is largely a matter
of understanding existing ideas properly and combining them well. If you see something
in RTA1 which looks new to you, it probably exists in something else which you
haven't seen

<p>
The aims behind RTA1 are simplicity and high code density,
and high performance without sophisticated add-ons

<p>
An immense range of  scalability is targeted

<p>
RTA1 can be positioned as a large or a tiny architecture. In the smallest
implementations some features need not be used

<p>
RTA1 is a compact 24-bit architecture. It can sail through the applications
which currently overheat 64-bit cores

<p>
RTA1 is equally an agile architecture for tiny applications running
a few dozen instructions of code, and can be used where 8-bit microcontrollers
are used

<p>
RTA1 architecture and the smaragd7 kernel are for single or multiprocessing

<p>
RTA1 SMP scalability has a  vast lateral dimension, without expensive electronic
co-ordination. The internal stack minimises storage reads and writes without
any operand cache

<p>
I believe the aims of simplicity and high code-density are achieved,
because I have implemented most of the IP stack (IP / UDP / TCP) in
about 3000 instructions. It is possibly my good fortune that compilers
don't yet exist for this machine, just a very versatile assembler

<p>
Every RTA1 instruction has the same layout and
occupies one storage location, the 24-bit word

<p>
Some developers will think it should have more accumulators, but I
have not encountered any shortage of accumulators writing the kernel

<p>
I have an outline for using some hundreds of registers as floating-point
accumulators, but it isn't in the emulator because I didn't need it.
It's possible that some applications could benefit from that feature

<p>
The 96-bit floating point demo-program is working fine without the
extra feature. It's doing bigger sums than PCs can do

<p>
RTA1 achieves higher code density and efficiency with arithmetic instructions
than load/store triadic architectures can achieve. See the sample assembly
in the accompanying Q & A document

<p>
A few storage-modify instructions make any register and every storage word
in the machine into a simple accumulator

<p>
The only condition bit in RTA1 is carry. Instructions testing other conditions
examine registers or storage. It is not necessary to generate flags for each possible
condition of every computed result

<p>
For people for whom a proper processor is one with 32 all-purpose registers,
I would say the following. Help yourself, there are plenty of those about
But they lack a certain agility

<p>
None of them seems to have two-register shifts or two-register arithmetic,
although these ideas have been used effectively for many decades. Those are the
features that make an architecture agile, much more than a lot of accumulators
or very long accumulators

<p>
The tiny RTA1 has 96-bit arithmetic and a comprehensive set of one- and
two-register shifts

<p>
Conventional load-store architectures need systematic register-saving however many
registers they have, because a compiler doesn't know which registers are free until
it has saved them

<p>
Many Compilers for 32-register load-store machines use about three registers to
load parameters or dynamic variables, and then save them on an external stack as
soon as they have loaded them

<p>
The magnificent SPARC-9 architecture has a better technique. So does the simple RTA1

<p>
In structured programming on the RTA1, parameters and dynamic variables are in
a register array, the internal stack. These variables are <i>all</i> registers,
and they don't need saving on the stack, because they're there already.
Please see the accompanying document,
<b>Towards Compiler Languages for RTA1 Architecture</b>

<p>
A small set of RTA1 registers is volatile, that is, intended and expected
to be used without saving

<p>
Naturally you cannot place structures or arrays in the internal stack,
only scalars and pointers. A program with deeply recursive functions would
also force you to store all dynamic variables in the external stack. But
recursive techniques are not for realtime processing; they are for
applications which take as long as they take. The purpose of RTA1 is
realtime

<p>
I hope you enjoy working with the RTA1 architecture

<p>
Tim Cox, Bern, 3 December 2012

<p>
+41 78 629 86 11

<p>
TimMilesCox@gmx.ch

</div>
</html>

