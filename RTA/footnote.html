<html>
<div	style="font-size:15pt">

<h1>RTA1: The Author's Footnote and Contact</h1>


<p>
RTA1 architecture specification exists because I want to work with it. Nearly all
the ideas used in RTA1 existed before. I have worked at developing existing ideas
as simply as possible, and combined as few of them as I could. If you see something
in RTA1 which looks new to you, it probably exists in something else which you
haven't seen

<p>
The aims behind RTA1 are simplicity and high code density,
and high performance without sophisticated add-ons

<p>
An immense range of  scalability is targeted

<p>
RTA1 can be positioned as a large or a tiny architecture. In the smallest
implementations some features need not be used

<p>
RTA1 is a compact 24-bit architecture. It can sail through the applications
which currently overheat 64-bit cores

<p>
RTA1 is equally an agile architecture for tiny applications running
a few dozen instructions of code, and can be used where 8-bit microcontrollers
are used

<p>
RTA1 architecture and the smaragd7 kernel are for single or multiprocessing

<p>
RTA1 SMP scalability has a  vast lateral dimension, without expensive electronic
co-ordination. The internal stack minimises storage reads and writes without
any operand cache

<p>
I believe the aims of simplicity and high code-density are achieved,
because I have implemented most of the IP stack (IP / UDP / TCP) in
about 3000 instructions. It may be my good fortune that compilers
don't yet exist for this machine, just a very versatile assembler

<p>
RTA1 Code is dense. Few instructions are needed in program steps,
although RTA1 instruction set is rigorously simple

<p>
Some developers will think it should have more accumulators, but I
have not encountered any shortage of accumulators writing the kernel

<p>
I have an outline for using some hundreds of registers as floating-point
accumulators, but it isn't in the emulator because I didn't need it.
I think expanded features need to be market led according to real needs,
and vital statistics like numbers of registers are not real needs

<p>
The 96-bit floating point demo-program is working fine on the basic
architecture specification. It's doing bigger sums than PCs can do

<p>
RTA1 achieves higher code density and efficiency with arithmetic instructions
than load/store triadic architectures can achieve. See the sample assembly
in the accompanying Q & A document

<p>
A few storage-modify instructions make any register and every storage word
in the machine into a simple accumulator

<p>
The only condition bit in RTA1 is carry. Instructions testing other conditions
examine registers or storage. It is not necessary to generate flags for each possible
condition of every computed result

<p>
For people for whom a proper processor is one with 32 all-purpose registers,
I would say the following. Help yourself, there are plenty of those about
But they lack a certain agility

<p>
None of them seems to have two-register shifts or two-register arithmetic,
although these ideas have been used effectively for many decades. Those are the
features that make an architecture agile, much more than a lot of accumulators
or very long accumulators

<p>
The tiny RTA1 has 96-bit arithmetic and a comprehensive set of one- and
two-register shifts

<p>
Compilers seem to make very confined use of 32-register load-store architectures.
Few of the registers are used. The external stack gets written all the time

<p>
The magnificent SPARC-9 is a better architectural frame, which
is more surmountable for compiler writers. So is the simple RTA1

<p>
In structured programming on RTA1, parameters and dynamic variables are in
a register array, the internal stack. These variables are <i>all</i> registers,
and they don't need saving on the stack, because they're there already.
Please see the accompanying document,
<b>Towards Compiler Languages for RTA1 Architecture</b>

<p>
Naturally you cannot place structures or arrays in the internal stack,
only scalars and pointers. Programs with deeply recursive functions need
to store even dynamic scalars in the external stack

<p>
Macro language achieves zero internal stack demand where necessary
with very few extra instructions -the trade-off is operand memory cycles

<p>
Recursive programming is not for realtime, but for applications which take as
long as they take.

<p>
The purpose of RTA1 is realtime, with operands closely grouped in the internal
stack -an array of registers- all the way through each program step

<p>
I hope you enjoy working with the RTA1 architecture

<p>
Tim Cox, Bern, 3 December 2012

<p>
+41 78 629 86 11

<p>
TimMilesCox@gmx.ch

</div>
</html>

