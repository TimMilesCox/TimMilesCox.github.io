<html>
<div	style="font-size:15pt">

<h1>RTA1: The Author's Footnote and Contact</h1>


<p>
RTA1 architecture specification exists because I want to work with it

<p>
Most ideas used in RTA1 existed before and a few I have turned around in a new way

<p>
A byword especially of embedded industry is code density. RTA1 certainly has that,
but that only means how closely instruction code can pack into memory

<p>
My real target is economy in the number of instructions executed to do work

<p>
This is sometimes called efficiency. RTA1 has that like no other architecture.

<p>
RTA1 Code is dense and more importantly economical or efficient

<p>
RTA1 instruction set is rigorously simple. RTA1 nevertheless executes
fewer instructions than other machines to complete program steps.

<p>
RTA1 is aimed at low-power efficiency and high performance without sophisticated add-ons

<p>
RTA1 can be configured very compact and run its deeply-embedded network applications
in less memory than a DOS PC of the early 1980s, but can scale to maintain 5 million TCP connections

<p>
RTA1 architecture and the smaragd7 kernel are for single or multiprocessing

<p>
RTA1 SMP does not need level 1-cache or coherency electronics

<p>
The internal stack minimises storage reads and writes. Software arbitrates using Test and Set

<p>
I have implemented most of the IP stack (IP / UDP / TCP) in about 3750 instructions

<p>
96-bit floating point benchmarks are doing bigger sums than PCs can do

<p>
192-bit floating benchmarks are doing bigger sums again. The servers are reached over
UDP. There are no complex extensions to instruction architecture. 192-bit
arithmetic is a minor modification to 96-bit arithmetic, with different scan
and format libraries

<p>
RTA1 solves floating arithmetic problems with higher code density and efficiency
than load/store triadic architectures can achieve

<p>
The only condition bit in RTA1 is carry. Instructions testing other conditions
examine registers or storage. It is not necessary to generate flags for each possible
condition of every computed result

<p>
For people for whom a proper processor is one with 32 all-purpose registers,
I would say the following. Help yourself, there are plenty of those about.
But their instruction paths show they are not quite agile

<p>
None of them seems to have two-register shifts or two-register arithmetic,
although these ideas have been used effectively for many decades.

<p>
Those features shorten instruction paths

<p>
The tiny RTA1 has 96-bit arithmetic (192-bit if needed) and a comprehensive set of one- and
two-register shifts

<p>
In structured programming on RTA1, parameters and dynamic variables are in
an array of scratch registers, the internal stack.

<p>
These variables are <i>all</i> registers, and they don't need saving
on the stack, because that's where they are already.

<p>
Naturally you cannot place structures or arrays in the internal stack,
only scalars and pointers. Programs with deeply recursive functions need
to store even dynamic scalars in the external stack

<p>
Macro language can select zero internal stack demand for individual functions.
The trade-off is operand memory cycles plus a very few extra instructions

<p>
Recursive programming is not for realtime, but for applications which take as
long as they take.

<p>
The purpose of RTA1 is realtime, with operands closely grouped in an array
of registers, the internal stack, all the way through each program step.
This has been achieved with the whole of the kernel and IP stack

<p>
I hope you enjoy working with the RTA1 architecture

<p>
Tim Cox, Bern, 5 April 2021

<p>
+41 76 383 33 49

<p>
TimMilesCox@gmx.ch

</div>
</html>

