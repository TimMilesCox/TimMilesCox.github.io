<html>
<div	style="font-size:15pt">

<h1>RTA1: The Author's Footnote and Contact</h1>


<p>
RTA1 architecture specification exists because I want to work with it. Nearly all
the ideas used in RTA1 existed before. I have worked at developing existing ideas
as simply as possible, and combined as few of them as I could. If you see something
in RTA1 which looks new to you, it probably exists in something else which you
haven't seen

<p>
RTA1 is a new and agile combination of architectural ideas

<p>
A byword especially of embedded industry is code density. RTA1 certainly has that,
but that only means how many instructions you can squash into memory. My real target
is economy in the number of instructions executed to do work. This is sometimes called
efficiency. RTA1 has that like no other architecture.

<p>
RTA1 Code is dense and more importantly economical or efficient. Although RTA1
instruction set is rigorously simple, compared with other architectures RTA1
needs execute drastically fewer instructions to complete program steps.

<p>
Beyond simplicity and high code density, the aims in RTA1 are efficiency
and high performance without sophisticated add-ons

<p>
An immense range of  scalability is targeted

<p>
RTA1 can be positioned as a large or a tiny architecture. In the smallest
implementations some features need not be used

<p>
RTA1 is a compact 24-bit architecture. It can maintain 5 million TCP connections

<p>
RTA1 is equally an agile architecture for tiny applications running
a few dozen instructions of code, and can be used where 8-bit microcontrollers
are used

<p>
RTA1 architecture and the smaragd7 kernel are for single or multiprocessing

<p>
RTA1 SMP is a vast lateral dimension of scalability with no expensive electronic
co-ordination. There is no operand cache. The internal stack minimises storage
reads and writes

<p>
I believe the aims of simplicity and high code-density are achieved,
because I have implemented most of the IP stack (IP / UDP / TCP) in
about 3750 instructions. It may be my good fortune that compilers
don't yet exist for this machine, just a very versatile assembler

<p>
Some developers will think it should have more accumulators, but I
have not encountered any shortage of accumulators writing the kernel

<p>
I have an outline for using some hundreds of registers as floating-point
accumulators, but it isn't in the emulator because I didn't need it.
I think expanded features need to be market-led according to real needs,
and vital statistics like numbers of registers are not real needs

<p>
The 96-bit floating point demo-program is working fine on the basic
architecture specification. It's doing bigger sums than PCs can do

<p>
192-bit floating arithmetic is now onstream as well. The servers are reached over
UDP. There are no complex extensions to instruction architecture. 192-bit
arithmetic is a minor modification to 96-bit arithmetic, with different scan
and format libraries

<p>
RTA1 achieves higher code density and efficiency with arithmetic instructions
than load/store triadic architectures can achieve. See the sample assembly
in the accompanying Q & A document

<p>
A few storage-modify instructions make any register and every storage word
in the machine into a simple accumulator

<p>
The only condition bit in RTA1 is carry. Instructions testing other conditions
examine registers or storage. It is not necessary to generate flags for each possible
condition of every computed result

<p>
For people for whom a proper processor is one with 32 all-purpose registers,
I would say the following. Help yourself, there are plenty of those about.
But they lack a certain agility

<p>
None of them seems to have two-register shifts or two-register arithmetic,
although these ideas have been used effectively for many decades.

<p>
Those particular features shorten instruction paths and add far more to
performance than many accumulators or long accumulators

<p>
The tiny RTA1 has 96-bit arithmetic and a comprehensive set of one- and
two-register shifts

<p>
Compilers seem to make very confined use of 32-register load-store architectures.
Few of the registers are used. The external stack gets written all the time

<p>
The 32 registers of the conventional load-store architecture are strictly
scalars. They can't be viewed as a list or table. A lot of performance and
flexibility gets strangled like that

<p>
The magnificent SPARC-9 is a better architectural frame and is more aligned
with compiler language ideas. So is the simple RTA1

<p>
In structured programming on RTA1, parameters and dynamic variables are in
an array of scratch registers, the internal stack.

<p>
These variables are <i>all</i> registers, and they don't need saving
on the stack, because they're there already.
Please see the accompanying document,
<b>Towards Compiler Languages for RTA1 Architecture</b>

<p>
Naturally you cannot place structures or arrays in the internal stack,
only scalars and pointers. Programs with deeply recursive functions need
to store even dynamic scalars in the external stack

<p>
Macro language can select zero internal stack demand for individual functions.
The trade-off is operand memory cycles plus a very few extra instructions

<p>
Recursive programming is not for realtime, but for applications which take as
long as they take.

<p>
The purpose of RTA1 is realtime, with operands closely grouped in an array
of registers, the internal stack, all the way through each program step.
This has been achieved with the whole of the kernel and IP stack

<p>
I hope you enjoy working with the RTA1 architecture

<p>
Tim Cox, Bern, 3 December 2012

<p>
+41 76 383 33 49

<p>
TimMilesCox@gmx.ch

</div>
</html>

