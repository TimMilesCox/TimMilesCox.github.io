<div	style="font-size:14pt">
<center>

<h1>RTA1 Kernel and API</h1>

<i>
Copyright Tim Cox, 2012<br>
This document is part of the RTA1 Processor Programmable Architecture Specification<br>
The RTA1 Architecture is freeware licensed with the GNU General Public Licence Version 3<br>
The same licence encompasses all accompanying software and documentation <br>
The full licence text is included with these materials<br>
See also the licensing notice at the foot of this document
</i>

</center>


<div	style="font-size:12pt">
<ol>
<li><a href="#preamble">Kernel and API</a></li>
	<ol>
	<li><a href="#posix_api">POSIX API and Lower Level Interface</a></li>
	<li><a href="#ii_call">Call Interface and Internal Interrupt Interface</a></li>
	</ol>
<li><a href="#api">API</a></li>
	<ol>
	<li><dl><a	href="#ii">Internal Interrupt System Calls</a></li>
		<dd><a	href="#spawn_ii">SPAWN$</a></dd>
		<dd><a	href="#thread_ii">THREAD$</a></dd>
		<dd><a	href="#tag_ii">TAG$</a></dd>
		<dd><a	href="#bank_ii">BANK$</a></dd>
		<dd><a	href="#array_ii">ARRAY$</a></dd>
		<dd><a	href="#bfree_ii">BANK$FREE</a></dd>
                <dd><a  href="#fpguard_ii">FP_GUARD$</a></dd>
                <dd><a  href="#evw_ii">EVENT_WAIT$ </a></dd>
		<dd><a	href="#xpof_ii">FP_XPO$FLAG</a></dd>
		<dd><a	href="#yield_ii">YIELD$</a></dd>
		<dd><a	href="#twait_ii">TWAIT$</a></dd>
		<dd><a	href="#exit_ii">EXIT$</a></dd>
	</dl><br>
	<li><a	href="#handles"/>Handles</a></li>
	<li><dl><a	href="#so_calls">Network Call Interface</a></li>
	<dt><a href="#net_posix">Calls by Socket Handle</a></dt>
		<dd><a href="#__socket">__socket</a></dd>
	        <dd><a href="#bind">bind</a></dd>
		<dd><a href="#connect">connect</a></dd>
        	<dd><a href="#recv">recv</a></dd>
	        <dd><a href="#send">send</a></dd>
                <dd><a href="#tcp_listen">tcp_listen</a></dd>
                <dd><a href="#tcp_accept">tcp_accept</a></dd>
                <dd><a href="#socket_close">close</a></dd>
	</dl>
	<li><dl><a	href="#fs_calls">File Systems Call Interface</a></li>
		<dt><a href="#fs_posix">Calls by File Handle</a></dt>
			<dd><a href="#open">open</a></dd>
			<dd><a href="#read">read</a></dd>
			<dd><a href="#write">write</a></dd>
			<dd><a href="#seek">seek</a></dd>
			<dd><a href="#fsync">fsync</a></dd>
			<dd><a href="#close">close</a></dd>
		<br>
		<dt><a href="#process">Reentrant Shared Code Applications</a></dt>
		<br>
		<dt><a href="#fs_loadgo">Process Load Calls</a></dt>
			<dd><a href="#seg$load">seg$load</a></dd>
			<dd><a href="#recursive$seg$load">recursive$seg$load</a></dd>
			<dd><a href="#array$seg$load">array$seg$load</a></dd>
			<dd><a href="#iframe_load">iframe_load</a></dd>
			<dd><a href="#qstart">qstart</a></dd>
		<br>
		<dt><a href="#fs_stream">File Stream Calls</a></dt>
			<dd><a href="#fstream">Mapping Streams to Files</a></dd>
			<dd><a href="#format">Scan and Format Control Strings</a>
			<dd><a href="#sscanf">sscanf</a>		macro -->	__sscanf</dd>
			<dd><a href="#sprintf">sprintf</a>		macro -->	__sprintf</dd>
			<dd><a href="#fscanf">scanf/fscanf</a>		macro -->	__fscanf</dd>
			<dd><a href="#fprintf">printf/fprintf</a>	macro -->	__printf fprintf</dd>
			<dd><a href="#fgets">fgets</a>			macro -->	read</dd>
			<dd><a href="#fflush">fflush</a>		macro -->	fsync</dd>
	</dl>
	</ol>
	<br>
<li><a href="#auto">Automatic Events</a></li>
	<ol>
	<li><dl><a	href="#ii_contingency">Contingency Interrupts</a></li>
                <dd><a  href="#xpo_ii">FP_XPO$</a>      79      .       bank 1  vector  15      . exponent overflow | underflow</dd>
		<dd><a	href="#guard_ii">GUARD$</a>	95	.	bank 1	vector	31</dd>
	</dl>
	<li><a	href="#timeslice">TimeSlice</a>
	</ol>
	<br>
<li><a	href="#library">Embedded Library</li>
	<ol>
	<li><dl><a href="#arith_lib">Large Arithmetic Library</a></li>
		<dt><a href="#fp192_lib">192-Bit Floating Library</a></dt>
		<dd><a href="#fp192_add">fp192_add</a></dd>
		<dd><a href="#fp192_add_negative">fp192_add_negative</a></dd>
		<dd><a href="#fp192_multiply">fp192_multiply</a></dd>
		<dd><a href="#fp192_mfa">fp192_mfa</a></dd>
		<dd><a href="#fp192_divide">fp192_divide</a></dd>
		<dd><a href="#fp192_load">fp192_load</a></dd>
		<dd><a href="#fp192_load_negative">fp192_load_negative</a></dd>
		<dd><a href="#reciprocal192">reciprocal192</a></dd>
		<dt><a href="#i72_lib">72-Bit Integer Macro Library</a></dt>
	</dl>
	<li><dl><a href="#app_lib">192-Bit Floating Application Library</a></li>
		<dd><a  href="#square192">square192</a></dd>
		<dd><a	href="#root192">square_root192</a></dd>
		<dd><a  href="#cube192">cube192</a></dd>
		<dd><a  href="#cube_root192">cube_root192</a></dd>

		<dd><a  href="#integer192">integer192</a></dd>
		<dd><a  href="#fraction192">fraction192</a></dd>

		<dd><a  href="#sine192">sine192</a></dd>
		<dd><a  href="#cosine192">cosine192</a></dd>
		<dd><a  href="#tangent192">tangent192</a></dd>
		<dd><a  href="#cotangent192">cotangent192</a></dd>
	</dl>
	</ol>
</dl>
</ol>

<div    style="background-color:E0E0E0">

<dl><a href="#tcp_steps">Appendix A: Low-Level TCP Interface</li>
</dl>
<dl><a href="#udp_steps">Appendix B: Low-Level UDP Interface</li>
</dl>
<dl><a href="#ii_steps">Appendix C: Kernel Service Building Block Internal Interrupts</li>
</dl>
</div>
</div>

<a	name="preamble"/>
<h2>1. Kernel and API</h2>

<a	name="posix_api"/>
<h3>1.1 POSIX API and Low Level Interface</h3>

<p>

RTA1 kernel has services with a POSIX-like API based on handles

<p>
The kernel is nevertheless ultra-thin layer with the objective of extreme efficiency, and contains nothing approaching the complexity of a Unix operating system 

<p>
Kernel services are also callable at a lower layer than handle-based POSIX functions. This shortens instruction paths and allows single threads to serve millions of users and network connections at once. This would not be possible within a handle-based API


<a      name="ii_call"/>

<h3>1.2 Kernel Call Interface and Internal Interrupt Interface</h3>

Most kernel routines have a call interface and their
arguments are on the internal stack

<p>
Some system calls are internal interrupts. They are called with
the <a href="rta.html#ii">ii</a> internal interrupt instruction

<p>
Functional wrappers may be placed around internal interrupt system calls
for a single and simple C-Language interface

<p>
Macro language supports a <a href="language.html">structured calling sequences</a> for a call-based API

<p>
Arguments for internal interrupts are typically in the application
accumulator registers

<pre	style="font-size:12pt">

        la      <i>argument</i>
        ii      <i>isr_vector</i>


</pre>

<p>
An interrupt vector is a value with a 16-bit page pointer and a 6-bit offset<br>
The sign extended immediate operand of ii instruction only has 10 page bits

<pre	style="font-size:12pt">

        [ii opcode] pp pppp pppp offset

</pre>

The instruction code <a href="rta.html#ii">ii</a> is 750000 hex and the vector name THREAD$ is 000047 hex = Page Index 1 offset 7

<pre	style="font-size:12pt">

        <b>
        00:00004C 750047              +50       ii              THREAD$
        </b>

</pre>

<p>
The operand of the far call instruction <b>call</b>
is a variable or a constant containing the vector value
of the target routine, or an indirect pointer to a <a href="rta.html#gate">gate<a>

<p>
The instruction code <a href="rta.html#call">call</a> is FF0000 hex and the literal at 00:000e74 is vector name __socket at Page Index 2 offset 1


<pre	style="font-size:12pt">

        <b>
        00:000047 FF0E74              +122      call    (__socket)


        00:000e74+000081
        </b>

</pre>

<p>
A far call routine executes in application mode and reads parameters
from the internal stack. It returns by executing a far return instruction <a href="rta.html#fret">fret</a>

<p>
ISRs are in 4096-word page at absolute address 4096, i.e. the second page of storage at Page Index 1.

<p>
Instruction frames can be any size in adjacent pages of 4096 words

<a	name="api"/>
<h2>2: API</h2>

<a	name="ii"/>
<h3>2.1: Internal Interrupt System Calls</h3>
<pre	style="font-size:12pt">

	<a	name="spawn_ii"/>
	SPAWN$		66	= Page Index 1	offset 2

				process launch
		                has 4 parameters in application registers a b mantissa2 mantissa3

				<a	style="color:#0000FF">
				ql	(<i>iframe:offset, PRIORITY, DATA_SIZE, -B1_PRIVATE_DATA_FRAMES</i>:q)
				ii	SPAWN$
				</a>

				<a style="color:#0000FF"><i>PRIORITY</i></a> is 0..7
				Highest priority 0 is not timesliced. Lowest priority 7 has the least timeslice
				All threads ready to execute get some time

				<a style="color:#0000FF"><i>DATA_SIZE</i></a> is words of application data including an external stack
				which contains file open descriptors, fprintf format buffer and
				and any large dynamic data not in the internal stack

				<a style="color:#0000FF"><i>-B1_PRIVATE_DATA_FRAMES</i></a> is a negative number expressing how many 4096-word
				private data frames the application requires. If no negative number is present
				in the 4th parameter field the application has one B1 frame. Applications do
				not share access to this space with any called or calling routines


	<a	name="thread_ii"/>
	THREAD$		71	= Page Index 1  offset 7

		                start a new thread of the current process

                		has 4 parameters in application registers a b mantissa2 mantissa3

				<a      style="color:#0000FF">
				ql	(<i>offset, PRIORITY, LATENT_PARAMETER, INITIAL_FP</i>:q)
				ii	THREAD$
				</a>

				<a style="color:#0000FF"><i>offset</i></a> is in the current Instruction Frame

				<a style="color:#0000FF"><i>PRIORITY</i></a> is 0..7
				Highest priority 0 is not timesliced. Lowest priority 7 has the least timeslice
				All threads ready to execute get some time

				<a style="color:#0000FF"><i>LATENT_PARAMETER</i></a> is an integer or pointer delivered in register a at thread start

				<a style="color:#0000FF"><i>INITIAL_FP</i></a> is an external stack root delivered if required in register fp


	<a	name="tag_ii"/>
	TAG$		73	= Page Index 1  offset 9

				name a thread

				<a      style="color:#0000FF">
				dl	({0 | <i>TARGET_TCB</i>}, <i>POINTER_TO_NAMESTRING</i>:d)
				ii	TAG$
				</a>

				application register a -> target Thread Control Block, zero = calling thread
				application register b -> name string, low order octet final word = zero


	<a	name="bank_ii"/>
	BANK$		67	= Page Index 1  offset 3


				<a      style="color:#0000FF">
				la	{ (<i>STORAGE_WORDS_REQUIRED</i>) | <i>STORAGE_WORDS_REQUIRED</i>,,xi }
				ii	BANK$
				</a>

                		storage acquire
		                words requested in application register a
                		start page index returned in a / zero if no grant
		                descriptor is linked to thread memory estate

	<a	name="array_ii"/>
	ARRAY$		68	= Page Index 1  offset 4

				<a      style="color:#0000FF">
				la	(<i>STORAGE_PAGES_REQUIRED</i>)
				ii	ARRAY$
				</a>

                		very large storage acquire
		                4096-word blocks requested in application register a
                		start page index returned in a / zero if no grant
		                descriptor is linked to thread memory estate

	<a	name="bfree_ii"/>
	BANK$FREE	69	= Page Index 1  offset 5

				<a      style="color:#0000FF">
				la	<i>START_PAGE_INDEX</i>
				ii	BANK$FREE
				</a>

                		storage relinquish
                		start page index in application register a
		                descriptor is unlinked from thread memory estate

	<a	name="fpguard_ii"/>
	FP_GUARD$	94	= Page Index 1  offset 30

				<a      style="color:#0000FF">
				la	(<i>ROUNDING_PATTERN</i>)
				ii	FP_GUARD$
				</a>

				set floating point rounding guard pattern in interrupt register 147
				to the value in application register a
				returns old value in application register a

	<a	name="evw_ii"/>
	EVENT_WAIT$	92	= Page Index 1  offset 28
				<a      style="color:#0000FF">
				la	(<i>EVENT_SELECTORS</i>)
				ii	EVENT_WAIT$
				</a>

				wait for the event flagged in application register a

	<a	name="xpof_ii"/>
	FP_XPO$FLAG	78	= Page Index 1  offset 14

				<a	style="color:#0000FF">
				ii	FP_XPO$FLAG
				lcal	<i>react_to_outflow</i>
				j	<i>result_valid</i>
				</a>

				retrieve + clear exponent overflow flag
				interrogate OR-sum of exponent underflow / overflow events in this thread
				reset the sum
				return skips one instruction if the the sum is not set at interrupt start

	<a	name="yield_ii"/>
	YIELD$		65	= Page Index 1  offset 1

				<a	style="color:#0000FF">
				ii	YIELD$
				</a>

				thread switch	on preemptive event
                		                or event wait
                                		or voluntarily

	<a	name="twait_ii"/>
	TWAIT$		91	= Page Index 1	offset 27


				<a	style="color:#0000FF">
				dl	(<i>MILLISECONDS</i>:d)
				ii	TWAIT$
				</a>


                		thread switch and wait millisecond count in
                		application registers a:b

	<a	name="exit_ii"/>
	EXIT$		70	= Page Index 1	offset 6

				<a	style="color:#0000FF">
				ii	EXIT$
				</a>

         			end thread
	 			end initial thread ends all other threads of process

				instructions fret and lret also raise interrupt EXIT$ if internal stack pointer sp = 128

</pre>

<a	name="handles"/>
<h3>2.2: Handles</h3>
<pre	style="font-size:12pt">

	Socket and file handles share a number space

	Handles [ 0 1 2 ] are the automatic files stdin stdout stderr

	Handles are modeled in the process vector list, an information table which an application reads but does not write

	The process vector list is common to all threads in a process

	Handles are common to all threads in a process

</pre>

<a	name="so_calls"/>
<h3>2.3: Network Call Interface</h3>

<pre	style="font-size:12pt">


<a	name="net_posix"/>
	<a	style="font-family:optima;font-size:16pt;color:#0000FF">Calls by Socket Handle</a>

	<a	name="__socket"/>
	<a	style="font-family:optima;font-size:16pt;color:#0000FF">__socket</a>

	get a socket

        	la	{ (IPPROTO_TCP*/16) | (IPPROTO_UDP*/16) }	. according to protocol
        	call    (__socket)

        result in application register a
        +integer = socket ID
        -1      = handle not available
        -2      = protocol not supported



	<a	name="bind"/>
	<a	style="font-family:optima;font-size:16pt;color:#0000FF">_bind</a>

        bind a handle to a port and optionally to a network address

        	dl	{ ($net_socket 10.0.0.63:PORT) | dsr      48 }	. bind a port or wild-card
									. network address optional
	        ds      6
        	la      socket_handle
	        [lb, xi 0]
        	call    (bind)</b>


        result in application register a
        0       = good
        -2      = handle is not TCP or UDP
        -3      = port number specified and not free
        -4      = no resource to model the socket


	<a	name="connect"/>
	<a	style="font-family:optima;font-size:16pt;color:#0000FF">_connect</a>

        	c	(connect)	socket_handle                           ;
					($net_socket 10.0.0.65:REMOTE_PORT),,long

        <a      style="font-family:optima;font-size:16pt">connect UDP socket</a>

        connect() in UDP associates the local
        socket with a remote socket, but causes no
        external protocol activity. UDP socket connect
        therefore returns immediately


        <a      style="font-family:optima;font-size:16pt;color:#0000FF">connect TCP socket</a>

        connect() in TCP changes the socket to a
        connection handle and negotiates that connection
        with the remote socket over TCP and IP protocols

        The handle may already be bound to a port
        and optionally to a local network address

        Otherwise connect() binds the socket to an available
        unique local port, and to the default network address
        of the outgoing interface

        A small number of application protocols have a
        well-known and constant client port number

        Some port numbers therefore support being bound to
        multiple sockets for outgoing connect. The sockets
        may be of one process or many

        However an outgoing connection with all addresses and
        ports identical to an existing connection is declined
        internally, so that the remote host does not reset
        the existing connection

        The kernel call

                c       (share_port)    {IPPROTO_TCP,,xi|IPPROTO_UDP,,xi}               ;
                                        {PORT_NUMBER,,xi|port_number_variable}

        allows multiple sockets to bind to the local port number

        The individual socket moves from the port to
        the connection on connect() and is lost on close()

        To use that local port for another connect() a new
        socket must first be bound to it

        TCP connect() is a blocking call

        NON_BLOCKING call tcp_start_connection() in the
        low-level interface starts the negotiation of
        a remote connection for asynchronous completion

        The sequence for outgoing connections is, starting with
        the optional separate bind() step

                                 _______________
                                (    bind()     )
                                 ---------------
                                        |
                        any port        |   specific port
                        ________________|________________
                        |                               |
                ________|________                       |
                | TCP names port|                       |
                |_______________|                       |
                        |                               |
                        |_______________________________|
                                        |
                                        |
                                ________|________
                                | bind the port |
                                | to address:   |
                                | may be 0.0.0.0|
                                |_______________|
                                        |
                                ________|________
                                | handle -> port|
                                |_______________|




                                 _______________
                                (   connect()   )
                                 ---------------
                                        |
                                        |
                        not bound       |           bound
                        ________________|________________
                        |                               |
                ________|________                       |
                |   bind to     |                       |
                |   0.0.0.0:0   |                       |
                |_______________|                       |
                        |                               |
                        |_______________________________|
                                        |
                                        |
                                        |
                                ________|________
                                |   construct   |
                                |   connection  |
                                |_______________|
                                        |
                                ________|________
                                | copy local net|
                                | address from  |
                                | port socket   |
                                |_______________|
                                        |
                                        |
                                        |
                        local network   |  local network
                        address=0.0.0.0 |address^0.0.0.0
                        ________________|________________
                        |                               |
                        |                               |
                        |                               |
                ________|________                       |
                |local address  |                       |
                |of connection =|                       |
                |default address|                       |
                |of interface on|                       |
                |default route  |                       |
                |to remote host |                       |
                |_______________|                       |
                        |                               |
                        |                               |
                        |_______________________________|
                                        |
                                        |
                                        |
                                        |
                                ________|________
                                |       handle  |
                                | -> connection |
                                |_______________|
                                        |
                                        |
                                ________|________
                                | send TCP_SYN  |
                                |_______________|
                                        |
                                        |
                                ________|________
                                | await SYN_ACK |
                                |_______________|
                                        |
                                        |
                                        |


	<a	name="recv"/>
	<a      style="font-family:optima;font-size:16pt;color:#0000FF">recv</a>

        	c    (recv)  socket_handle   buffer[,,xi]  bytes,,xi   flags,,xi

        socket handle is the integer handle number

        For UDP sockets bit 23 of flags has a PEEK effect
        -the user datagram stays on the input queue

        flag bit 22 has NON_BLOCKING effect.
        recv() is by default BLOCKING

        if a UDP socket has no user datagram available it
        blocks if flag bit 22 = 0

        if a TCP connection has less data available than
        requested it blocks if flag bit 22 = 0

        TCP sockets receiving XDR data require BLOCKING to
        obtain a complete result atomically

        Application protocols with BLOCKING sockets must be
        separate processes or threads from the IP main thread

        recv() returns bytes read in register a

        result -22 means the handle is neither a UDP socket
        nor a TCP connection

        result 0 on a BLOCKING receive means a TCP connection
        has received remote close

        On a NON_BLOCKING receive, result 0 means there
        is no data

	There is no errno in RTA1. If a connection is not
	TCP_ESTABLISHED a negative value file not open is returned


        <a      style="font-family:optima;font-size:16pt;color:#0000FF">receive from</a>

        source addresses of User Datagrams can be retrieved
        on receive from the containing IP datagram


	<a	name="send"/>
	<a      style="font-family:optima;font-size:16pt;color:#0000FF">send</a>

        	c    (send)  socket_handle   buffer[,,xi]  bytes,,xi   flags,,xi

        socket_handle is the integer handle number

        for TCP sockets bit 3 of flags is TCP_PSH which sends
        immediately instead of on full segment

        result in application register a is bytes sent

        If the socket is NON_BLOCKING,
        if the transmission could not be immediately resourced
        actual bytes sent is in register a and outstanding count in register b

        a result of -2 indicates that the handle is neither
        a UDP socket not a TCP connection


        <a      style="font-family:optima;font-size:16pt;color:#0000FF">send to</a>

        destination addresses for User Datagrams can be set
        before send

	<a	name="tcp_listen"/>
	<a      style="font-family:optima;font-size:16pt;color:#0000FF">tcp_listen</a>

        Argument 1 is the socket bound to a TCP port,
        not to a TCP connection

        Argument 2 sets the socket in BLOCKING or in
        NON_BLOCKING mode

        NON_BLOCKING    $equ    0

                la      handle1                         . no limit
                lb, xi  NON_BLOCKING                    . = NON_BLOCKING
                call    (tcp_listen)

                la      handle2                         . nonzero limit
                lb, xi  CONNECTION_WAITQ_MAXIMUM        . = BLOCKING
                call    (tcp_listen)

        there will be an error return in register a if
        the handle in a is not a bound TCP port

        If the socket is BLOCKING, connections are
        only admitted with tcp_accept() which
        always blocks

        If the socket is NON_BLOCKING, connections
        are accepted automatically

	<a	name="tcp_accept"/>
        <a      style="font-family:optima;font-size:16pt;color:#0000FF">tcp_accept</a>

                c       (tcp_accept)    handle

        tcp_accept() awaits an incoming connection
        on a listening socket

        The remote address is in the new transmission control
        block, and if it is required anywhere else it must be
        copied from there

        tcp_accept() is a blocking call

        Incoming connections are accepted automatically on
        NON_BLOCKING sockets


	<a	name="socket_close"/>

	<a	style="font-family:optima;font-size:16pt;color:#0000FF">close</a>

        <a      style="font-family:optima;font-size:16pt;color:#0000FF">close UDP socket</a>

        close() in UDP frees the port and makes
        the socket handle number reassignable within
        the process. The free port accepts no traffic


        <a      style="font-family:optima;font-size:16pt;color:#0000FF">close TCP connection</a>

        close() removes the connection and makes the socket
        handle number free reassignable within the process

        a shareable port remains available for bind()
        and may still have sockets bound to it

        a port not configured for sharing becomes available
        for binding to one socket

        close() returns immediately. There is no blocking


</pre>


<a	name="fs_calls"/>
<h3>2.4: File Systems Call Interface</h3>
<pre	style="font-size:12pt">

<a name="fs_posix"/>
	<a	style="font-family:optima;font-size:16pt;color:#0000FF">Calls by File Handle</a>

	$include	language/stack.def

</pre>
Initially only remote files are in the POSIX framework and other file system types are accessed with
routines in the <a href="#fs_calls">File I/O Libraries</a>

<p>
Remote files addresses are encoded in the open path with with macros
<pre	style="font-size:12pt">

	$include	rta/target.rta/t77.4/ip.def			. for function macro $neta
	$include	rta/target.rta/fs/mntaddrs.def:	mount_path	. for procedural maccro	mount_path

SUSE_NFSD       $equ    $neta(192.168.0.14:2049)        . server enet
SUSE_MOUNTD     $equ    $neta(192.168.0.14:1023)

path_suse       mount_path      SUSE_NFSD::mount_suse:"EXAMPLE_FILENAME"
mount_suse      mount_path      SUSE_MOUNTD:::"/home/laclimpide/online_files/"

		# protocol NFSv3
		# server must have mountd bound to TCP port 1023


</pre>

open() returns a handle identifier unique within the process

<p>
The open file is a stream of RTA1 24-bit words. Argument 3 and return value
of read() and write() plus target-position and result-position of lseek()
are a count of words

<p>
An open flag O_8 makes the open file a stream of octets instead of words.
Return value and length argument of read() and write() are then a count of
octets. So are the target-position and result-position of lseek()

<pre	style="font-size:12pt">

	<a	name="open"/>
	<a	style="font-family:optima;font-size:16pt;color:#0000FF">open</a>

	c	(open)	path,,xi O_FLAGS,,xi
	jna	no_handle
	sa	handle


	<a name="read"/>
	<a	style="font-family:optima;font-size:16pt;color:#0000FF">read</a>

	c	(read)	handle buffer,,xi MAXIMUM_WORDS|OCTETS,,xi	

	<a name="write"/>
	<a	style="font-family:optima;font-size:16pt;color:#0000FF">write</a>

	c	(write)	handle buffer,,xi WORDS|OCTETS,,xi

	<a name="seek"/>
	<a	style="font-family:optima;font-size:16pt;color:#0000FF">seek</a>

	c	(seek)	handle position,,triple HOW,,xi

	<a name="fsync"/>
	<a	style="font-family:optima;font-size:16pt;color:#0000FF">fsync</a>

	c	(fsync)	handle

	fsync pushes buffered output date to physical medium

	<a name="close"/>
	<a	style="font-family:optima;font-size:16pt;color:#0000FF">close</a>

	c	(close)	handle



	<a	name="process"/><a	style="font-family:optima;font-size:16pt;color:#0000FF">Reentrant Shared-Code Applications</a>

	All applications are shared code whether fixed or loadable

	Process instances unpack initial data into process RAM from an embeded file system in the application code image



	<a	name="fs_loadgo"/><a	style="font-family:optima;font-size:16pt;color:#0000FF">Process Load Calls</a>

	<a	name="seg$load"/><a	style="font-family:optima;font-size:16pt;color:#0000FF">seg$load</a>

		c	(seg$load)	<i>FS_START_PAGE_INDEX</i>[,,xi] (<i>FILE_DESCRIPTOR_OFFSET</i>:d),,long

	seg$load loads program sections $(3) data and $(1) private data to process RAM.
	<i>FILE_DESCRIPTOR_OFFSET</i> is a 48-bit linked address in a file system included in application build

	program data sections $(3) and $(1) must be based in the address space

	if <i>FS_START_PAGE_INDEX</i> is zero the file system is the calling instruction frame
	and file system metadata is offset after the instruction code

	<i>FILE_DESCRIPTOR_OFFSET</i> is linked not searched.

	The iframe-included file system is constructed using <a href="masmx7r3.html#1gformat">1gformat</a>
	1gformat minimises file system metadata. The micro-filesystem is linked at any 64-word granule offset

	nonzero <i>FS_START_PAGE_INDEX</i> identifies a core filesystem in separate space constructed using <a href="masmx7r3.html#4kformat">4kformat</a>

	The file system has searchable metadata at <i>FS_START_PAGE_INDEX</i>.
	<i>FILE_DESCRIPTOR_OFFSET</i> is nevertheless linked not searched
	
	
	<a	name="recursive$seg$load"/><a	style="font-family:optima;font-size:16pt;color:#0000FF">recursive$seg$load</a>

		c	(recursive$seg$load)	<i>FS_START_PAGE_INDEX[,,xi]</i> (<i>FILE_DESCRIPTOR_OFFSET</i>:d),,long

	recursive$seg$load loads a program data section to an external stack frame pointed with frame pointer fp

	This allows application subsections to be executed from initial state recursively.
	The load strings of the data section have zero-relative addresses and reference is indexed with fp

	program data section $(3) includes the external stack and must be based in the address space

	input file system for recursive$seg$load is as seg$load


	<a	name="array$seg$load"/><a	style="font-family:optima;font-size:16pt;color:#0000FF">array$seg$load</a>

		c	(array$seg$load)	<i>FS_START_PAGE_INDEX</i>[,,xi]		;
						(<i>FILE_DESCRIPTOR_OFFSET</i>:d),,long)	;
						<i>RAM_ARRAY_START_PAGE_INDEX</i>[,,xi]

	array$seg$load loads initial strings of a large array
	to a buffer of any available size at <i>RAM_ARRAY_START_PAGE_INDEX</i>

	No part of the target array need be initially based in the address space

	input file system for array$seg$load is as seg$load


	<a	name="iframe_load"/><a	style="font-family:optima;font-size:16pt;color:#0000FF">iframe_load</a>

		c	(iframe_load)	(<i>FILE_DESCRIPTOR_DEVICE_OFFSET</i>:d),,long		;
					<i>RUN_PROFILE_RECEIVE_BUFFER</i>[,,i]
	
	iframe_load loads a group of instruction frames constructed with macro $application or $iframe
	from file system device array 1 to executable RAM

        The 48-bit <i>FILE_DESCRIPTOR_DEVICE_OFFSET</i> may be obtained with FS24 kernel routine fspath

	Instruction code is not loaded from any file system which is writeable from networks

	The file system in Device array 1 is <a href="masmx7r3.html#fsformat">constructed offline</a>
	and is not writeable during system operation

	The iframe group may be an application or libraries

	load_iframe returns the application start specification if <i>RUN_PROFILE_RECEIVE_BUFFER</i> is nonzero

	
	<a	name="qstart"/><a	style="font-family:optima;font-size:16pt;color:#0000FF">qstart</a>

		c	(qstart)	<i>FS_START_PAGE_INDEX</i>[,,xi]		;
					(<i>DIRECTORY_DESCRIPTOR_OFFSET</i>:d),,long	;
					<i>CALLNAME_LENGTH_CONTAINING_WORDS</i>	;
					<i>APPLICATION_CALLNAME</i>

	qstart searches a given application callname of a fixed iframe in a known directory of a core file system,
	retrieves an application start specification from the file contents and launches an application process

	The 48-bit value <i>DIRECTORY_DESCRIPTOR_OFFSET</i> may be obtained using kernel routine fsrom_find in advance



	<a	name="fs_stream"/><a	style="font-family:optima;font-size:16pt;color:#0000FF">File Stream Calls</a>

	<a	name="fstream"/><a	style="font-family:optima;font-size:16pt;color:#0000FF">Mapping Streams to Files</a>

	There is no FILE stream structure in RTA1. Every kind of file is buffered
	The names stdin stdout and stderr are equated to automatic handles [ 0 1 2 ]

	These three handles are usually one TCP dialogue leased from telnet

	All stream commands are macros:	sscanf	calls		__sscanf
					sprintf	calls		__sprintf
					scanf and fscanf call	__fscanf
					printf and fprintf call	__fprintf
					fgets calls		read
					fflush calls		fsync
					

	<a	name="format"/><a	style="font-family:optima;font-size:16pt;color:#0000FF">Scan and Format Control Strings</a>

	Available data type tags in format strings are:	%d	an integer in decimal
							%i	input only, an integer in decimal or hex
							%f	a floating number
							%x	an integer in hex
							%c	a character symbol
							%s	a character string
							%:<a style="background-color:#E0E0E0"> </a>	input only, a string terminated by the symbol after %:

	The default size of an integer is one word

	The default size of a floating number is four words
 
	%i does no octal conversion. Leading zero is converted as hex. 0x or 0X is not scanned

	Size overrides are:	%ld %li %lx capture two input words. %ld %lx format two output words from the internal stack

				%lf on input <a href="rta.html#fp">compresses</a> the captured number to two words on storage
				%lf on output expects the <a href="rta.html#fp">compressed floating number</a> to have been promoted to four words in the internal stack

				%jd %ji %jx capture three input words. %jd %jx format three output words from the internal stack

				%qx captures or formats four words in hex
				%qf captures or formats a <a href="rta.html#fp">four-word floating number</a> and is indentical to %f

				%Lx captures or formats eight words in hex
				%Lf captures or formats an <a href="rta.html#fp">eight-word floating number</a>

	<a	name="sscanf"/><a	style="font-family:optima;font-size:16pt;color:#0000FF">sscanf</a>

	__sscanf is called with macro

		sscanf	<i>BUFFER</i>[,,i] <i>FORMAT_STRING</i>[,,xi] <i>POINTER1</i> [ <i>POINTER2</i>... ]

	<a	name="sprintf"/><a	style="font-family:optima;font-size:16pt;color:#0000FF">sprintf</a>

		sprintf	<i>BUFFER</i>[,,i] <i>FORMAT_STRING</i>[,,xi] <i>VALUE1</i> [ <i>VALUE2</i>... ]

	<a	name="fscanf"/><a	style="font-family:optima;font-size:16pt;color:#0000FF">fscanf</a>

	__fscanf is called with macros

		fscanf	<i>FILE_HANDLE</i>[,,i] <i>FORMAT_STRING</i>[,,xi] <i>POINTER1</i> [ <i>POINTER2</i>... ]

		scanf	<i>FORMAT_STRING</i>[,,xi] <i>POINTER1</i> [ <i>POINTER2</i>... ]

	there is no FILE stream structure in RTA1. The name stdin equals handle number zero.  scanf is the same as

		fscanf	stdin <i>FORMAT_STRING</i>[,,xi] <i>POINTER1</i> [ <i>POINTER2</i>... ]
		
	<a	name="fprintf"/><a	style="font-family:optima;font-size:16pt;color:#0000FF">fprintf</a>

	there is no FILE stream structure in RTA1. The name stdout equals handle number 1

	__fprintf is called with the macros

		printf	<i>FORMAT_STRING</i>[,,xi] <i>VALUE1</i> [ <i>VALUE2</i>... ]

		fprintf	<i>handle</i>[,,xi] <i>FORMAT_STRING</i>[,,xi] <i>VALUE1</i> [ <i>VALUE2</i>... ]


</pre>

<a	name="auto"/>
<h2>3: Automatic Events</h2>
<a	name="ii_contingency"/>
<h3>3.1: Contingency Interrupts</h3>
<pre	style="font-size:12pt">

	<a	name="xpo_ii"/>FP_XPO$</a>

	Interrupt FP_XPO$ is generated by underflow or overflow of a floating exponent

	ISR OR-sums the contingency in the thread control block and sets the floating result to -0.0

	The OR-sum is retrieved and restarted with system call interrupt <a href="#xpof_ii">ii FP_XPO$FLAG</a>


	<a  name="#guard_ii"/>GUARD$</a>

	Interrupt GUARD$ is generated by out-of-range and unallowed references

	An interrupt stack frame latent parameter classes the contingency as address-range or authority

	If the contingency is in application code, or arises from a bad parameter passed from application to ISR
	then the thread is withdrawn from scheduling for analysis / deletion

	If the contingency is in an ISR without cause from any application, the system restarts
	in order to eliminate effects of the error and resume service

	Software may also issue <a href="#guard_ii">ii GUARD$</a> for error-tracing

</pre>

<a  name="timeslice"/>
<h3>3.2: TimeSlice</h3>
<pre	style="font-size:12pt">


	TimesSlice is a <a href="#yield_ii">YIELD$</a> interrupt forced at instruction ration runout

	Instruction ration is not applied to highest priority zero and is graded from priorities 1..7 lowest

	Threads are rarely timesliced in practice because of the unusual code efficiency of RTA1.
	An I/O wait happens first and scheduling restarts the instruction ration


</pre>

<a	name="library"/>
<h2>4: Embedded Library</h2>
<a	name="arith_lib"/>
<h3>4.1: Large Arithmetic Library</h3>

	192-bit floating operations are sequences of atomic 96-bit floating instructions

	<p>
	These instruction sequences are embedded as library subroutines for simplicity of use

<pre    style="font-size:12pt">


	<a      name="fp192_lib"/><a    style="font-family:optima;font-size:16pt;color:#0000FF">192-Bit Floating Library</a>

	Arguments referenced by address are shown here with designator ,,i which is available with base+displacement addresses and
	equally with fixed addresses. Designator ,,xi delivers fixed immediate addresses but not addresses with base register

	<a	name="fp192_add"/><a	style="font-family:optima;font-size:16pt;color:#0000FF">fp192_add</a>

		c	(fp192_add)	<i>ADDEND</i>,,i

	the 8-word value at address <i>ADDEND</i> is add to the addend in registers a:b:mantissa2:mantissa3:8:9:10:11

	<a	name="fp192_add_negative"/><a	style="font-family:optima;font-size:16pt;color:#0000FF">fp192_add_negative</a>

		c	(fp192_add_negative)	<i>SUBTRAHEND</i>,,i

	the 1s complement of the 8-word value at adress <i>SUBTRAHEND</i> is added to the minuend in registers a:b:mantissa2:mantissa3:8:9:10:11

	<a	name="fp192_multiply"/><a	style="font-family:optima;font-size:16pt;color:#0000FF">fp192_multiply</a>

		c	(fp192_multiply)	<i>MULTIPLIER</i>,,i

	the multiplicand in registers a:b:mantissa2:mantissa3:8:9:10:11 is multiplied by the 8-word value at address <i>MULTIPLIER</i>

	<a	name="fp192_mfa"/><a	style="font-family:optima;font-size:16pt;color:#0000FF">fp192_mfa</a>

		c	(fp192_mfa)	<i>MULTIPLICAND</i>,,i	<i>MULTIPLIER</i>,,i

	the 8-word value at address <i>MULTIPLICAND</i> is multiplied by the 8-word value at address <i>MULTIPLIER</i>
	the 8-word product is stored at address <i>MULTIPLICAND</i>. Accumulators a:b:mantissa2:mantissa3:8:9:10:11 are overwritten however

	<a	name="fp192_divide"/><a	style="font-family:optima;font-size:16pt;color:#0000FF">fp192_divide</a>

		c	(fp192_divide)	<i>DIVISOR</i>,,i

	the dividend in registers a:b:mantissa2:mantissa3:8:9:10:11 is divided by the 8-word floating value at address <i>DIVISOR</i>

	<a	name="fp192_load"/><a	style="font-family:optima;font-size:16pt;color:#0000FF">fp192_load</a>

		c	(fp192_load)	<i>INPUT</i>,,i

	the 8-word value at address <i>INPUT</i> is returned in registers a:b:mantissa2:mantissa3:8:9:10:11

	<a	name="fp192_load_negative"/><a	 style="font-family:optima;font-size:16pt;color:#0000FF">fp192_load_negative</a>

		c	(fp192_load_negative)	<i>INPUT</i>,,i

	the 1s complement of the value at address <i>INPUT</i> is returned in registers a:b:mantissa2:mantissa3:8:9:10:11

	<a	name="reciprocal192"/><a	style="font-family:optima;font-size:16pt;color:#0000FF">reciprocal192</a>

		c	(reciprocal192)		<i>INPUT_DIVISOR</i>,,float_192

	the reciprocal of the <i>INPUT_DIVISOR</i> is returned in registers a:b:mantissa2:mantissa3:8:9:10:11


	<a      name="i72_lib"/><a    style="font-family:optima;font-size:16pt;color:#0000FF">72-Bit Integer Macro Library</a>

	The command field is not a call because this is a library of macros

	All outputs except comparisons and most inputs are 72 bits



		$include	lib/i72.def

		i72a		<i>ADDEND72</i>	<i>ADDEND72</i>	<i>DESTINATION72</i>		. add

		i72an		<i>MINUEND72</i>	<i>SUBTRAHEND72</i>	<i>DESTINATION72</i>		. difference

		i72compare	<i>MINUEND72</i> 	<i>SUBTRAHEND72</i>				. comparison result in register a

		172a48		<i>ADDEND72</i>	<i>ADDEND48</i>	<i>DESTINATION72</i>		. add

		i72an48		<i>MINUEND72</i> 	<i>SUBTRAHEND48</i>	<i>DESTINATION72</i>		. difference

		i72compare48	<i>MINUEND72</i>	<i>SUBTRAHEND48</i>				. comparison result in register a

		i72a48_48	<i>ADDEND48</i>	<i>ADDEND48</i>	<i>DESTINATION72</i>		. add

		i72an48_48	<i>MINUEND48</i>	<i>SUBTRAHEND48</i>	<i>DESTINATION72</i>		. difference

		i72m		<i>MULTIPLICAND72</i>	<i>MULTIPLIER24</i>	<i>DESTINATION72</i>		. multiply

		i72d		<i>DIVIDEND72</i>	<i>DIVISOR24</i>	<i>QUOTIENT72</i> [ <i>REMAINDER24</i> ] . divide

</pre>

<a	name="app_lib"/>
<h3>4.2: 192-Bit Floating Application Library</h3>
<pre    style="font-size:12pt">


		$include	language/stack.def

	<a	name="square192"/><a    style="font-family:optima;font-size:16pt;color:#0000FF">square192</a>

		c	(square192)	<i>INPUT_ROOT</i>,,float192

	the square of the input is returned in registers a:b:mantissa2:mantissa3:8:9:10:11

	<a      name="root192"/><a    style="font-family:optima;font-size:16pt;color:#0000FF">square_root192</a>

		c	(square_root192)	<i>INPUT_SQUARE</i>,,float192

	the square root of the input is returned in registers a:b:mantissa2:mantissa3:8:9:10:11

	<a      name="cube192"/><a    style="font-family:optima;font-size:16pt;color:#0000FF">cube192</a>

		c	(cube192)	<i>INPUT_ROOT</i>,,float192

	the cube of the input is returned in registers a:b:mantissa2:mantissa3:8:9:10:11

	<a      name="cube_root192"/><a    style="font-family:optima;font-size:16pt;color:#0000FF">cube_root192</a>

		c	(cube_root192)	<i>INPUT_CUBE</i>,,float192

	the cube root of the input is returned in registers a:b:mantissa2:mantissa3:8:9:10:11

	<a      name="integer192"/><a    style="font-family:optima;font-size:16pt;color:#0000FF">integer192</a>

		c	(integer192)	<i>INPUT_FRACTION</i>,,float192

	the integral part of the input fraction is returned in registers a:b:mantissa2:mantissa3:8:9:10:11

	<a      name="fraction192"/><a    style="font-family:optima;font-size:16pt;color:#0000FF">fraction192</a>

		c	(fraction192)	<i>INPUT_FRACTION</i>,,float192

	the fractional part of the input fraction is returned in registers a:b:mantissa2:mantissa3:8:9:10:11

	<a      name="sine192"/><a    style="font-family:optima;font-size:16pt;color:#0000FF">sine192</a>

		c	(sine192)	<i>INPUT_ANGLE</i>,,float192

	the sine of the input angle is returned in registers a:b:mantissa2:mantissa3:8:9:10:11

	<a      name="cosine192"/><a    style="font-family:optima;font-size:16pt;color:#0000FF">cosine192</a>

		c	(cosine192)	<i>INPUT_ANGLE</i>,,float192

	the cosine of the input angle is returned in registers a:b:mantissa2:mantissa3:8:9:10:11

	<a      name="tangent192"/><a    style="font-family:optima;font-size:16pt;color:#0000FF">tangent192</a>

		c	(tangent192)	<i>INPUT_ANGLE</i>,,float192

	the tangent of the input angle is returned in registers a:b:mantissa2:mantissa3:8:9:10:11

        <a      name="cotangent192"/><a    style="font-family:optima;font-size:16pt;color:#0000FF">cotangent192</a>

		c	(cotangent192) <i>INPUT_ANGLE</i>,,float192

	the cotangent of the input angle is returned in registers a:b:mantissa2:mantissa3:8:9:10:11

</pre>

<a      name="app_lib96"/>
<h3>4.3: 96-Bit Floating Application Library</h3>
<pre    style="font-size:12pt">

	<a	name="integer96"/><a	style="font-family:optima;font-size:16pt;color:#0000FF">integer96</a>

		c	(integer96)	<i>INPUT_FRACTION</i>,,float

	the integral part of the input fraction is returned in registers a:b:mantissa2:mantissa3

	<a	name="fraction96"/><a	style="font-family:optima;font-size:16pt;color:#0000FF">fraction96</a>

		c	(fraction96)	<i>INPUT_FRACTION</i>,,float

	the fractional part of the input fraction is returned in registers a:b:mantissa2:mantissa3


        <a      name="sine96"/><a	style="font-family:optima;font-size:16pt;color:#0000FF">sine96</a>

                c       (sine96)	<i>INPUT_ANGLE</i>,,float

        the sine of the input angle is returned in registers a:b:mantissa2:mantissa3

        <a      name="cosine96"/><a    style="font-family:optima;font-size:16pt;color:#0000FF">cosine96</a>

                c       (cosine96)     <i>INPUT_ANGLE</i>,,float

        the cosine of the input angle is returned in registers a:b:mantissa2:mantissa3

        <a      name="tangent96"/><a    style="font-family:optima;font-size:16pt;color:#0000FF">tangent96</a>

                c       (tangent96)    <i>INPUT_ANGLE</i>,,float

        the tangent of the input angle is returned in registers a:b:mantissa2:mantissa3

        <a      name="cotangent96"/><a    style="font-family:optima;font-size:16pt;color:#0000FF">cotangent96</a>

                c       (cotangent96) <i>INPUT_ANGLE</i>,,float

        the cotangent of the input angle is returned in registers a:b:mantissa2:mantissa3


</pre>

</div>

