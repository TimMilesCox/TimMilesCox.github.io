<html>
<div	style="font-size:14pt">

<center>

<h1>Towards Compiler Languages for RTA1 Architecture</h1>


<i>
Copyright Tim Cox, 2012<br>
This document is part of the RTA1 Processor Programmable Architecture Specification<br>
The RTA1 Architecture is freeware licensed with the GNU General Public Licence Version 3<br>
The same licence encompasses all accompanying software and documentation <br>
The full licence text is included with these materials<br>
See also the licensing notice at the foot of this document
</i>

</center>

<p>
There are no compiler languages yet for RTA1. Every instruction in it
has been assembled with the masmx meta-assembler

<p>
This document is about

<ol>
	<li>
	far call targets: $vector macro
	</li>
	<li>
	formal calling sequences used in structured assembly language code
	<ol>
		<li>structured realtime in the internal stack</li>
		<li>calling and constructing the call argument stream</li>
		<li>macro conversion of call arguments</li>
		<li>the called routine: parameters and dynamic data</li>
		<li>recursive programming and zero-net internal stack</li>
		<li>trapping wrong argument lists</li>
	</ol>
	</li>
	<li>
	runtime algorithmic expressions
	</li>

</ol>

<h2>1. Far Call Targets: $vector Macro</h2>

<b>$vector</b> publishes routines which are the target
of a far <b>call</b> instruction. It's a procedural macro coded
at the front of the target bank. It generates the jump
instruction at one of the 64 jump pad positions and labels the
handle value which identifies its bank:vector tuple
<pre>

handle_name*    <b>$vector</b>  bank_internal_name

</pre>
The handle value is the single-word constant or
variable operand of <b>go</b> and <b>call</b> instructions
<pre>


		call	handle


handle		+	handle_name

</pre>
The handle value  encodes the target bank identifier and
six-bit offset location where <b>$vector</b> macro is assembled
<pre>


        <b>$vector</b> goes in the first 64 words of a bank
        on a 4K word bank edge.
        The 64 entries at the bank start are a jump pad

        23  21                 6|5    0
        ________________________|_______
        |00|   bank identifier  |offset|
        |__|____________________|______|


        Instruction banks at addresses from 256 Megawords
        to 16 Gigawords are assigned at a granularity of 32K words
        and have eight entry vectors

        23  21                    3|2 0
        ___________________________|____
        |01|   bank identifier     |off|
        |__|_______________________|set|


</pre>
<p>
The target bank is any size, but
only 64 or 8 vector locations are externally addressable

<h2>2. Formal Calling Sequences used in Structured Assembly Language Code</h2>
<h3>2.1 Structured Realtime in the Internal Stack</h3>
<p>
These calling sequences have made some parts of the kernel simpler to write

<p>
They  construct a non-volatile register list in the internal stack

<p>
They sacrifice no efficiency at all

<p>
Many simpler assembly language subroutines are easier to write without this structuring,
because they then have more freedom for stack manipulation

<p>
These call sequences support development of assembler code especially where
subroutine arguments are several and where register use is hard to remember.

<p>
They are intended to support future C compilers
and to make a single call interface available for any style of
programming language

<h3>2.2 Calling and Constructing the Argument Stream</h3>

<b>c / lc</b> macro embeds far and near call instructions
<b>call</b> and <b>lcal</b>, first pushing parameters on the
internal stack, and afterwards clearing the internal stack

<p>
<b>c / lc</b> finalises the parameter list by pushing a stack walkback before
the <b>call / lcal</b> instruction and popping the internal stack pointer on
return. If there are no parameters, it doesn't. Then the effect is the same
as issuing a <b>call</b> or <b>lcal</b> instruction directly

<pre>


$ masmx ruxample -lnk
MASMX 7r3
3/ruxample.msm
*EOF*
  :                            1        $path           ../def
  :                            2:       $include        rta.def
  :                            3        $path           ../language
  :                            4:       $include        stack.def
  :                            5        $path
  :                            6
  :                            7
  :                            8 $(3:03000)
  :                            9 left   $res    4
  :                            10 right $res    4
  :                            11 centre        $res    4
  :                            12       $lit
  :                            13
  :                            14 $(0:64)
  :                            15
  :                            16
                                        c       (floating_algorithm)    left,,          float           ;
                                                                        (1.875:d),,     floating_packed ;
00:000040 8F3004              +19                                       right,,         float
00:000041 5F300C              +19
00:000042 8F3000              +19
00:000043 FCF00C              +19
00:000044 FF300E              +19
00:000045 38000F              +19
  :                            20
00:000046 473008              +21       qs      centre
  :                            22
  :                            23
  :                            24       $do     $<256,$(0:256)
  :                            25
*EOF*
03:00300c+401F00000000
03:00300e+[0000]18:000000
:$(00):000040:000100 :$(03):003000:00300F
ruxample.msm: object code 174 bytes: 0 errors: 1 undefined labels


</pre>

Between the data name and the data type of each <b>c / lc</b> argument is an index register
subfield which is not always typed
<pre>


	lc	routine	left,,float	;
			right,,float	;
			centre, x, int	;
			36, y, long


</pre>
If the datum is direct-addressed, an index register is not named because
none is used

<p>
The assembly may otherwise already know a base + displacement register
for the data name. If it is in the submacros <b>params() scalars() xframe()</b>
or any other base + displacement section, the assembler does already know the
default index base. Names like this have the masmx label type <b>$equf</b>
which is an equate to a tuple of attributes

<p>
The index field is typed to use indexed addressing, where the
name or value  is not associated with an index register, or in order
to override a default index register

<p>
The third subfield in each argument may be a a type known to RTA1 macro language
<pre>

$ masmx loademup -ln
MASMX 7r3
3/loademup.msm
*EOF*
  :                            1 
  :                            2 	$path		../
  :                            3: 	$include	def/rta.def
  :                            4: 	$include	language/stack.def
  :                            5 
  :                            6 $(3:03000)
  :                            7 data	$res	20
  :                            8 
  :                            9 $(0:64)
  :                            10 
                                	c	(routine_far)	data		;
                                				-10,,xi		;
                                				99, b, i	;
00:000040 F93004              +14 				data+4,,t1
00:000041 FCD063              +14 
00:000042 FDFFF6              +14 
00:000043 F83000              +14 
00:000044 FCF004              +14 
00:000045 FF0100              +14 
00:000046 38000F              +14 
  :                            15 
  :                            16 	$do	$<256,$(0:256)
*EOF*
00:000100+[0000]18:000000
:$(00):000040:000101 :$(03):003000:003014 

</pre>
or parameters may be of type known to <b>c / lc</b> macro
<pre>

$ masmx -ln types
MASMX 7r3
3/types.msm
*EOF*
  :                            1 	$path		../
  :                            2: 	$include	def/rta.def
  :                            3: 	$include	language/stack.def
  :                            4 	$path
  :                            5 $(0:64)
                                inward	$head_far	 params(left, float	;
  :                            7 				right,float	)
  :                            8 
                                        lc      routine left,,float     ;
                                                        right,,float    ;
                                                        centre, x, int  ;
                                                        36, y, long	;
00:000040 5F0106              +13 			(1.875:d),, floating_packed            
00:000041 9FB024              +13 
00:000042 FDA100              +13 
00:000043 8FF00E              +13 
00:000044 8FF00E              +13 
00:000045 FCF00F              +13 
[+0000]0f
00:000046 3E0000              +13 
00:000047 38000F              +13 
  :                            14 
  :                            15 	$do	$<256,$(0:256)
  :                            16 centre
00:000100 000006              +17 ?	$do	6,	7-?
00:000101 000005              +17 
00:000102 000004              +17 
00:000103 000003              +17 
00:000104 000002              +17 
00:000105 000001              +17 
  :                            18 
*EOF*
00:000106+401F00000000
:$(00):000040:000108 

</pre>
<p>
or subfield 3  may be a macro name which processes the parameter as it loads it


<h3>2.3 Macro Conversion of Call Arguments</h3>

<b>c / lc</b> macro can attach macros to individual arguments to
generate, convert or format actual parameters as they are pushed

<p>
The macro name takes the place of the data type subfield 3
<pre>

$ masmx newtotal.msm -ln
MASMX 7r3
3/newtotal.msm
*EOF*
  :                            1 	$path		../
  :                            2: 	$include	def/rta.def
  :                            3: 	$include	language/stack.def
  :                            4 
  :                            5 p		$proc
  :                            6 long2float*	$name	106
  :                            7 		dl	p(1, 1), p(1, 2)
  :                            8 		call	(long2fp)
  :                            9 		$end
  :                            10 
  :                            11 $(0)
00:000000 B60040              +12 newtotal*	$vector	addon
  :                            13 $(0:64)
  :                            14 addon	$head_far	 params(increment, long)
  :                            15 
00:000040 CFF003              +16 	c	(total_up)	increment,,long2float
00:000041 FF0047              +16 
00:000042 8F0004              +16 
00:000043 FCF004              +16 
00:000044 FF0048              +16 
00:000045 38000F              +16 
  :                            17 
00:000046 3D0000              +18 	$ret
  :                            19 
*EOF*
00:000047+[0000]18:000000
00:000048+[0001]18:000000
:$(00):000000:000049 

</pre>

Macro <b>c (total_up)</b>

	<blockquote>
	executed the two instructions of macro <b>long2float</b><br><br>
	pushed four arithmetic registers <b>a:b:mantissa2:mantissa3</b>
	</blockquote>

then pushed an internal stack walkback word, called the target routine, and finally
popped the internal stack walkback word as <b>c / lc</b> macro always does

<p>
Parameter-generating macro <b>long2float</b> belongs to the ring of macros with
<b>$name</b> value <b>106</b>

<p>
<b>c / lc</b> macro follows macros in <b>Ring 106</b> with a quadword push instruction
of arithmetic registers <b>a:b:mantissa2:mantissa3</b>

<p>
<b>c / lc</b> macro restricts which macros may generate actual parameters to
<b>Ring 105</b>, <b>Ring 106</b> and <b>Ring 107</b>

<p>
<b>c / lc</b> is not concerned how many data words these macros read

	<blockquote>
	<b>c / lc</b> adds arithmetic register <b>a</b> to the internal stack
	after a macro with <b>$name</b> value <b>107</b><br><br>

        <b>c / lc</b> adds arithmetic registers <b>a:b</b> to the internal stack
	with a double-push instruction after a macro with <b>$name</b> value <b>105</b><br><br>

	<b>c / lc</b> adds arithmetic registers <b>a:b:mantissa2:mantissa3</b>
	to the internal stack with a quad-push instruction after a macro with
	<b>$name</b> value <b>106</b><br><br>
	
	</blockquote>

A parameter generating macro receives two subfields before its own name as argument,
a value or address with optional index tag. In the example, input name <b>increment</b> is
recognised as being base + displacement on the internal stack pointer

<h3>2.4 The Called Routine: Parameters and Dynamic Data</h3>

<p>
Macro <b>$head_near/far</b> constructs up to three lists of names which
are base+displacement definitions on internal stack pointer <b>sp</b>
or external stack pointer <b>fp</b>

<p>
These lists are called <b>params() scalars() xframe()</b>

<p>
<b>$head_near/far</b> macro constructs data in
two of those lists, <b>scalars</b> in the internal stack
and <b>xframe</b> in the external stack

<p>
A routine without large dynamic data may have <b>params()</b> and <b>scalars()</b> but not <b>xframe()</b>

<pre>


$ masmx rtxample -ln
MASMX 7r3
3/rtxample.msm
*EOF*
  :                            1 	$path		../def
  :                            2: 	$include	rta.def
  :                            3 	$path		../language
  :                            4: 	$include	stack.def
  :                            5: 	$include	fpxpress.def
  :                            6 	$path
  :                            7 $(0:0)
  :                            8 
00:000000 B60040              +9 floating_algorithm*  $vector fp_routine
  :                            10 
  :                            11 $(0:64)
  :                            12 
  :                            13 fp_routine 
                                	$head_far	 params(one,	float		;
                                				two,	float		;
                                				three,	float)		;
                                							;
Note: rtxample.msm Line 18: add $$frame to sp before return
00:000040 F80002              +18 			scalars(temp1,	int,	x)
  :                            19 
00:000041 4FF004              +20 	$xqt_fp		one*1.75*+1200000*two/3.0*-625000-three
00:000042 770100              +20 
00:000043 77F008              +20 
00:000044 7F0104              +20 
00:000045 6FF00C              +20 
  :                            21 
  :                            22 
00:000046 50F000              +23 	lx		temp1
  :                            24 
00:000047 FCF001              +25 	push, i		$$frame, sp
00:000048 38000F              +26 	pop		sp
00:000049 3D0000              +27 	fret		0
  :                            28 
  :                            29 	$do		$<256,$(0:256)
  :                            30 	
*EOF*
00:000100+7CD38BB7B396D7AA20B6E083
00:000104+2051D5B8447B77478A23F5F7
:$(00):000000:000108 
rtxample.msm: object code 229 bytes: 0 errors: 0 undefined labels


</pre>

<p>
<b>params()</b> maps names onto the parameters pushed in <b>c / lc</b>

<p>
<b>scalars()</b> constructs and names dynamic variables in the
internal stack based on <b>sp</b>

<p>
<b>xframe()</b> constructs dynamic variables in the
in the external stack based on <b>fp</b>. <b>xframe()</b> is for
structures and arrays. The internal stack is only large enough for scalars
and pointers
<pre>

$ masmx -ln tempbuff.msm
MASMX 7r3
3/tempbuff.msm
*EOF*
  :                            1 		$path		../def
  :                            2: 		$include	rta.def
  :                            3 		$path		../language
  :                            4: 		$include	stack.def
  :                            5 		$path
  :                            6 
                                routine1        $head_near       params(left,	long		;
                                                                        right,	long)		;
                                								;
                                                                scalars(down,	int,	0	;
                                                                        up,	int,	2048//3-1) ;
                                								;
                                                                 xframe(sorting_buffer, 2048//3	;
Note: tempbuff.msm Line 14: add $$frame to sp before return
00:000000 F80000              +14 			midpoint_cursor, int, 2048//3/2, fp, i)
00:000001 F802AA              +14 
00:000002 FDFD54              +14 
00:000003 2F000E              +14 
00:000004 FCE155              +14 
00:000005 38E2AB              +14 
Note: tempbuff.msm Line 14: add $$xframe to fp before return
  :                            15 
  :                            16 .
  :                            17 .
  :                            18 
  :                            19 
  :                            20 
00:000006 FCE2AC              +21                 push, i         $$xframe, fp
00:000007 38000E              +22                 pop             fp
00:000008 FCF002              +23                 push, i         $$frame, sp
00:000009 38000F              +24                 pop             sp
  :                            25 
00:00000A 350000              +26                 lret            0
  :                            27 
*EOF*
:$(00):000000:00000B :$(46):000000:0002AC 
tempbuff.msm: object code 184 bytes: 0 errors: 0 undefined labels

</pre>
<p>
These macros do not use a cover pointer for internal stack frames
based on <b>sp</b>. The overhead of maintaining a cover pointer has
been eliminated

<p>
<b>$head_near/far</b> and <b>c / lc</b> adjust with the
deepening stack displacement of objects already in the stack
as they add more objects

<p>
Routines constructed with this framework should therefore not change
<b>sp</b> except with <b>c / lc </b> macros

<p>
Very simple assembler routines need not use this framework of macros
at all. They can alter the stack freely

<p>
The practical way within this macro framework to save a register
during a routine is to assign it to a dynamic variable in the
<b>scalars()</b> list. This saves the register at routine start,
because the dynamic frame is constructed by pushing things
<pre>

$ masmx -ln saverlod.msm
MASMX 7r3
3/saverlod.msm
*EOF*
  :                            1 		$path		../def
  :                            2: 		$include	rta.def
  :                            3 		$path		../language
  :                            4: 		$include	stack.def
  :                            5 		$path
  :                            6 
  :                            7 $(0:64)
                                my_name		$head_near	scalars(caller_a, int, a	;
                                					caller_b, int, b	;
Note: saverlod.msm Line 10: add $$frame to sp before return
00:000040 F80004              +10 					caller_x, int, x)
00:000041 F80005              +10 
00:000042 F80002              +10 
  :                            11 
  :                            12 .		a b x of the calling routine are in the internal
  :                            13 .		stack and can be loaded as required
  :                            14 
  :                            15 .
  :                            16 .
00:000043 50F002              +17 		lx              caller_a . reference caller's data
  :                            18 .
  :                            19 .
00:000044 60F001              +20 		la              caller_b . reference caller's data
  :                            21 .
  :                            22 .
00:000045 60F002              +23 		la		caller_a . restore caller's registers
00:000046 68F001              +24 		lb		caller_b
00:000047 50F000              +25 		lx		caller_x
00:000048 FCF003              +26 		push, i		$$frame, sp
00:000049 38000F              +27 		pop		sp
00:00004A 350000              +28 		lret		0
  :                            29 
  :                            30 
  :                            31 
*EOF*
:$(00):000040:00004B 
saverlod.msm: object code 147 bytes: 0 errors: 0 undefined labels


</pre>


<h3>2.5 Recursive Programming and Zero Net Internal Stack</h3>


The RTA1 internal stack is a register array for  realtime programming.
Realtime problem solving typically executes routines to a depth of between
four and eight nested subroutine calls, each with between two and six
parameter words in the stack

<p>
The internal stack contains approaching twice this intended maximum

<p>
Here a routine is called with two  parameter words on the internal stack
<pre>

  :                            242
00:000553 FCF003              +243      lc   ber_sequence_scan a snmp_rseq,,i
00:000554 F80004              +243
00:000555 FCF002              +243
00:000556 3E0755              +243
00:000557 38000F              +243
  :                            244


</pre>
There are also a return address and a stack walkback pointer in each call,
so the stack use in this  call is four words. The application can keep on
like this for a nested depth of 26 calls

<p>
If the the internal stack overflows, the guard interrupt removes the thread
from the switch list

<p>
If that problem has been avoided, all the operands in the instruction path
are in a register array, namely the internal stack

<p>
That's the realtime intention of RTA1

<p>
If applications need more stack, there is no solution in building  a
larger internal stack into RTA1. That would make task switch slower and
applications could still overflow the internal stack

<p>
Some kinds of processing are not realtime, and must go about things in
a different way


<p>
Recursion is a programming technique used rather indiscriminately
because of its popularity in education circles and because of a
widespread reluctance to understand anything in detail

<p>
Nevertheless recursive programming is really needed in some applications.
Macro language supports net-zero internal stack demand applied to individual
routines within a program

<p>
In realtime use, the <b>$head_near/far</b> macro claims and maps internal
stack words at the head of a routine

<p>
The addition of the <b>$zero_stack</b> keyword keeps the internal stack
pointer <b>sp</b> at the same place however many nested calls routines
with <b>$zero_stack</b> make to themselves or to each other

<pre>

$ masmx recursiv -ln
MASMX 7r3
3/recursiv.msm
*EOF*
  :                            1 	$path		freeware/RTA1/rta/def
  :                            2: 	$include	rta.def
  :                            3 	$path
  :                            4: 	$include	stack.def
  :                            5 
  :                            6 $(0:64)
  :                            7 
                                inwego	$head_near,$zero_stack	 params(one,	float	;
                                					two,	float	;
                                					three,	float)	;
                                							;
00:000040 FDFFF2              +12 				 xframe()
00:000041 2F000E              +12 
00:000042 38E000              +12 
00:000043 38E001              +12 
00:000044 87E002              +12 
00:000045 87E006              +12 
00:000046 87E00A              +12 
00:000047 780010              +13 	tp	16
00:000048 B60054              +14 	j	enough
00:000049 1F0010              +15 	dec	16
  :                            16 
00:00004A 4FE002              +17 	ql	one
00:00004B 77E006              +18 	fm	two
00:00004C 770100              +19 	fm	(0.875)
00:00004D 67E00A              +20 	fa	three
  :                            21 
00:00004E 8FE00A              +22 	lc	inwego	a,,float two,,float three,,float
00:00004F 8FE006              +22 
00:000050 8F0004              +22 
00:000051 FCF00C              +22 
00:000052 3E0040              +22 
00:000053 38000F              +22 
  :                            23 
  :                            24 enough
00:000054 9FE000              +25 	$ret
00:000055 FCE00E              +25 
00:000056 38000E              +25 
00:000057 350000              +25 
  :                            26 
  :                            27 	$do	$<256,$(0:256)
*EOF*
00:000100+400000E00000000000000000
:$(00):000040:000104 :$(46):000000:00000E 
recursiv.msm: object code 279 bytes: 0 errors: 0 undefined labels


</pre>
Routines constructed with <b>$zero_stack</b> can interact completely
with routines constructed without

<p>
The external stack pointer <b>fp</b> must point to the high-memory
end of a sufficient buffer

<p>
Call sequences constructed with the <b>c/lc</b> macro push the parameter
list onto the internal stack. This is not different where <b>$zero_stack</b>
is opted. There is no faster or better way of delivering a parameter list
of arbitrary size. The <b>lc</b> macro shown above pushes twelve parameter
words and a walkback pointer, then calls the target routine, itself in
this example
<pre>

	.------>_________________________________________________________________
	|	|   floating parameter three					|
	|	|_______________|_______________|_______________|_______________|
	|	|   floating parameter two					|
	|	|_______________|_______________|_______________|_______________|
	|	|   floating parameter one 					|
	|	|_______________|_______________|_______________|_______________|
	._______| stack walkback| return address|
		|_______________|_______________|


</pre>
If there are no parameters, the <b>c/lc</b> macro does not push a walkback
pointer or pop it afterwards. This follows a principle, that routines which
do not expect parameters can be called with <b>call</b> <b>lcal</b> instructions
without preliminaries. In realtime programming, instructions which
do not do anything are avoided where possible

<p>
A called routine with <b>$zero_stack</b> unloads the call frame that it expects.
Its <b>xframe()</b> is larger than otherwise by the size of the expected call frame

<p>
<b>xframe()</b> must be declared when <b>$zero_stack</b> is opted, even if
<b>xframe()</b> is otherwise void. <b>head_near/far</b> macro uses uppercase <b>-V</b>
option to highlight its path. masmx has not assigned <b>-VUOS</b> for itself
<pre>

                                inwego	$head_near,$zero_stack	 params(one,	float	;
                                					two,	float	;
                                					three,	float)	;
                                							;
Note: recursiv.msm Line 12: buy external $$xframe
00:000040 FDFFF2              +12 				 xframe()
00:000041 2F000E              +12 
Note: recursiv.msm Line 12: internal stack zero net demand
00:000042 38E000              +12 
00:000043 38E001              +12 
00:000044 87E002              +12 
00:000045 87E006              +12 
00:000046 87E00A              +12 


</pre>
The expected call frame is popped in four-word blocks per instruction,
and the parameter names are mapped to the external stack locations

<p>
Without <b>$zero_stack</b> the parameter names are mapped to their internal
stack locations

<p>
If variables are constructed in <b>scalars()</b> they are in the internal stack.
To flat-line the internal stack, dynamic variables must be in <b>xframe()</b>

<p>
The default behaviour of a <b>$zero_stack</b> routine before return is to
push the stack walkback word if parameters were expected and then to push
the return address. Because there is optional behaviour, a <b>$ret</b>
macro is supplied to match the <b>$head_near/far</b> macro
<pre>

  :                            23 
  :                            24 enough
Note: recursiv.msm Line 25: internal stack zero net demand
Note: recursiv.msm Line 25: parameter list walkback
00:000054 9FE000              +25 	$ret
Note: recursiv.msm Line 25: sell external $$xframe
00:000055 FCE00E              +25 
00:000056 38000E              +25 
Note: recursiv.msm Line 25: near return
00:000057 350000              +25 
  :                            26 


</pre>
<p>
Alternatively the <b>-S</b> flag opts to push all of the call frame back
into the internal stack. This mostly makes no difference, because <b>c/lc</b>
macro immediately frees the call frame by popping the walkback word onto the
internal stack pointer
<pre>

  :                            23 
  :                            24 enough
Note: recursiv.msm Line 25: internal stack zero net demand
Note: recursiv.msm Line 25: restore internal stack $$list -S
00:000054 8FE00A              +25 	$ret
00:000055 8FE006              +25 
00:000056 8FE002              +25 
00:000057 9FE000              +25 
Note: recursiv.msm Line 25: sell external $$xframe
00:000058 FCE00E              +25 
00:000059 38000E              +25 
Note: recursiv.msm Line 25: near return
00:00005A 350000              +25 
  :                            26 


</pre
<p>
A difference which <b>-S</b> option does make is that changes which the called
routine makes inside its parameters are written back to the internal stack,
which is also the effect without <b>$zero_stack</b>

<p>
That might be an unorthodox way of passing results which are otherwise passed
in the accumulator registers <b>a:b:mantissa2:mantissa3</b>

<p>
<b>-S</b> restore to the internal stack can also paint over some accidental damage
where a routine  has not been given the correct internal stack frame in the first
place. The <b>$zero_stack</b> routine pops the call frame it thinks it has.

<p>
The internal stack may underflow. The guard interrupt then isolates the wrong call
at this point

<p>
Otherwise <b>sp</b> points some words below (address-wise above) the stack top.
Further call and push activity now overwrites previously stacked words energetically.
If the called <b>$zero_stack</b> routine has <i>not</i> written to its copied
parameters in the external stack frame, the complete restore may undo one consequence
of a problem. If this makes a difference, it should only be done diagnostically and
not used to bring faulty code into service. The parameters which the <b>$zero_stack</b>
routine thinks it has are not the intended parameters until the real problem is fixed


<h3>2.6 Trapping Wrong Argument Lists</h3>
<p>
An initial check  on the call frame can also be opted to isolate problems in code
development and testing

<p>
The check is either for at least enough parameters, or exactly the expected number

<p>
Calls which do not match the called routine prototype will
not function as intended, even if the application appears to run

<p>
Mostly the exact check can be preferred because most assemblies only contain routines
with fixed parameters

<p>
Neither check is certain, because each uses the call frame walk-back word. If there
are inadvertantly no actual parameters, then there is no walkback word either. The
word at the expected stack location has some completely different meaning. The point
of error would be a word on the stack which accidentally has the expected walkback
value. Then the check appears to pass although the parameters are unrelated to the
routine and vital to another routine

<p>
However the chance of trapping a mistake is very high, because the chances of an
accidental match on the walkback word location are very remote. Another good way
of finding this sort of mistake is a grep on references to the routine

<p>
These are problem-finding-options. They cannot make faulty code safe. No
code should go live with non-matching calls on the stack

<p>
The problem-finding options are aimed at two mistakes, too many parameters
and too few

<p>
Too many parameters is a problem if routines are called recursively, because
the called routine only flat-lines the call frame which it knows about. So
unused gaps accumulate in the internal stack. Routines which are not recursively
called will not have this problem, because as soon as return happens instead of
recursion, the walkback word is popped onto internal stack pointer <b>sp</b>
and the call frame is gone whatever size it was

<p>
Too few parameters is a more earnestly hazardous problem. It is equally a problem
for routines with <b>$zero_stack</b> and for the default realtime routines which
work inside the internal stack

<p>
Called routines without their expected arguments may update other internal stack
locations. Even if they don't they're reading the wrong inputs 

<p>
The check for exact parameters is <b>-U</b> assembly flag. The check for enough
parameters is <b>-O</b> 
<pre>

                                inwego	$head_near,$zero_stack	 params(one,	float	;
                                					two,	float	;
                                					three,	float)	;
                                							;
00:000040 60F001              +12 				 xframe()
00:000041 D4F00E              +12 
00:000042 C60044              +12 
00:000043 75005F              +12 
Note: recursiv.msm Line 12: check absolute arguments -U

</pre>
The argument check interrupts to guard interrupt if the call frame appears wrong.
Here it's checking for 14 words beyond the actual stack pointer value
<pre>


	+ a near return address one word in size
	+ the walkback word itself
	+ 12 parameter words
	________________________________________

	= 14


</pre>
<b>-UO</b> checks are not linked with <b>$zero_stack</b>. They are generated at
every <b>$head_near/far</b> in the assembly when opted

<h2>3. Runtime Algorithmic Expressions</h2>

<p>
Assemblers mostly resolve expressions whose tokens are all known at assembly time

<p>
<b>$xqt_fp</b> and <b>$xqt_i</b> directives code an instruction plan in a
compiler-like fashion however, to solve expressions involving run-time variables

<p>
These instruction steps are planned with the support of target-specific macros with
fixed call-names known to masmx 

<p>
<b>$xqt_i</b> processes integers and can resolve all expression steps
between constants at assembly time, planning the fewest possible instructions
for run time calculation

<p>
In this example the subexpression right of the OR operator <b>++</b> has been
resolved at assembly time, but left of <b>++</b> a multiply, two adds and a
shift must take place at runtime


<pre>

$ masmx boolean -lnk
MASMX 7r3
3/boolean.msm
  :                            1 	$path		../
  :                            2: 	$include	def/rta.def
  :                            3: 	$include	language/fpxpress.def
  :                            4: 	$include	language/i_xpress.def
  :                            5 	$path
  :                            6 
  :                            7 $(3:03000)
03:003000 000001              +8 one	1
03:003001 000000000002        +9 two	2d
03:003003 000000000003        +10 three	3d
  :                            11 $(0:64)
00:000040 603000              +12 	$xqt_i	two+one,,w0*4+three*/16++12*/40
00:000041 960018              +12 
00:000042 E00100              +12 
00:000043 D73001              +12 
00:000044 D73003              +12 
00:000045 360010              +12 
00:000046 900101              +12 
00:000047 980102              +12 
  :                            13 	$do	$<256,$(0:256)
  :                            14 	$end
00:000100+000004
00:000101+0C0000000000
:$(00):000040:000103 :$(03):003000:003005 


</pre>
<p>
<b>$xqt_fp</b> by contrast includes constants as well as variables in expressions,
but does not attempt assembly-time calculation of expression steps between floating
constants

<p>
<b>$xqt_fp</b> concerns four-function arithmetic only, and operands are four words
in size

<p>
Here a simple algorithm with five inputs is executed in five instructions, including
operand acquisition from storage
<pre>


$ masmx -ln r2xample.msm
MASMX 7r3
3/r2xample.msm
*EOF*
  :                            1 	$path		../def
  :                            2: 	$include	rta.def
  :                            3 	$path		../language
  :                            4: 	$include	stack.def
  :                            5: 	$include	fpxpress.def
  :                            6 	$path
  :                            7 $(0:0)
  :                            8 
00:000000 B60040              +9 floating_algorithm*  $vector fp_routine
  :                            10 
  :                            11 $(0:64)
  :                            12 
  :                            13 fp_routine 
                                	$head_far	 params(one,	float		;
                                				two,	float		;
  :                            16 				three,	float)
  :                            17 
00:000040 4FF003              +18 	$xqt_fp		one*1.75*+1200000*two/3.0*-625000-three
00:000041 770100              +18 
00:000042 77F007              +18 
00:000043 7F0104              +18 
00:000044 6FF00B              +18 
  :                            19 
  :                            20 
00:000045 3D0000              +21 	fret		0
  :                            22 
  :                            23 	$do		$<256,$(0:256)
  :                            24 	
*EOF*
00:000100+7CD38BB7B396D7AA20B6E083
00:000104+2051D5B8447B77478A23F5F7
:$(00):000000:000108 
r2xample.msm: object code 190 bytes: 0 errors: 0 undefined labels


</pre>
masmx has taken an expression with five operands and four operators, and
turned it into a sequence of five instructions which deliver the four-word
floating result of the operations in the result registers <b>a:b:mantissa2:mantissa3</b>

<p>
Three of these tokens are identifiers whose content is only known at runtime

<p>
<b>$xqt_fp</b> directive scans an expression and calls macro code to write an
instruction plan. The tokens which are constants appear as literals at the foot
of the program

<p>
Other details of <b>$xqt_fp</b> and <b>$xqt_i</b> directives are in the manuals
<b>masmx.7r3</b> and <b>masmx.7r3 for RTA1</b>


<i>
<pre>

_______________________________________________________________________________________


LICENCE NOTE

    Copyright Tim Cox, 2012
    TimMilesCox@gmx.ch

    This document is part of the RTA1 Processor Programmable Architecture.

    RTA1 is a free processor architecture specification. It is licensed
    under the GNU General Public Licence Version 3

    The executable emulation of RTA1 is free software.

    Instruction code for the target RTA1 architecture is free software
    if it is delivered with this software

    Software programs delivered with this software to connect the
    emulated RTA1 with real network interfaces in the emulator host
    are free software

    Scripts and programs delivered with this software for running
    on other computers and interacting with the RTA1 are free software

    The masmx target-independent meta-asembler delivered here
    is free software whether it is used for constructing RTA1 code
    or any other code. masmx is a separate free program by the
    same author and included with this software to save searching for it

    Scripts and utility programs for constructing RTA1 target
    executable software are free software

    You can redistribute it and/or modify RTA1
    under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    RTA1 is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with RTA1.  If not, see &lt;http://www.gnu.org/licenses/&gt;.


</pre>
</i>


</div>
</html>


