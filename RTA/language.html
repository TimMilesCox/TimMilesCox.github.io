<html>
<div	style="font-size:14pt">

<center>

<h1>Towards Compiler Languages for RTA1 Architecture</h1>


<i>
Copyright Tim Cox, 2012<br>
This document is part of the RTA1 Processor Programmable Architecture<br>
The RTA1 Architecture is freeware licensed with the GNU General Public Licence Version 3<br>
The same licence encompasses all accompanying software and documentation <br>
The full licence text is included with these materials<br>
See also the licensing notice at the foot of this document
</i>

</center>

<p>
There are no compiler languages yet for RTA1. Every instruction in it
has been assembled with the masmx meta-assembler

<p>
This document is about

<ol>
	<li>
	formal calling sequences used in structured assembly language code
	</li>
	<li>
	runtime algorithmic expressions
	</li>

</ol>

<h3>1. Formal Calling Sequences used in Structured Assembly Language Code</h3>
<p>
These call sequences have made some parts of the kernel simpler to write

<p>
They  construct a non-volatile register list in the internal stack

<p>
They sacrifice no efficiency at all

<p>
Simpler assembly subroutines are easier to write without this structuring
because they then have more freedom for stack manipulation

<p>
As well as simplifying code development in assembly language,
these calling sequences are intended to support future C compilers
and to make a single call interface available for any style of
programming language

<p>
Macro definition file <b>language/stack.def</b> constructs five services
to "near" routines <b>lcal ... lret</b> and to "far" routines
<b>call ... fret</b>

<p>
The simplest of these five services is <b>$vector</b> which constructs
the compressed routine address value which is used as a handle for calling
a far routine. This value is the storage constant operand of
<b>go</b> and <b>call</b> instructions
<pre>


	<b>$vector</b> goes in the first 64 words of a bank
	on a 4K word bank edge.
	The 64 entries at the bank start are a jump pad

	23  21		       6|5    0
	________________________|_______
	|00|   bank identifier	|offset|
	|__|____________________|______|


	Instruction banks at addresses from 256 Megawords
	to 16 Gigawords are assigned at a granularity of 32K words
	and have eight entry vectors

        23  21                    3|2 0
        ___________________________|____
        |01|   bank identifier	   |off|
        |__|_______________________|set|


</pre>
<p>
The target bank is any size, but
only 64 or 8 vector locations are externally addressable

<p>
Three stack management services are contained in
the macro <b>$head_near/far</b> and one internal stack
management service is contained in the macro <b>c / lc</b>

<p>
Macro <b>$head_near/far</b> constructs up to three lists of names which
are base+displacement definitions on internal stack pointer <b>sp</b>
or external stack pointer <b>fp</b>

<p>
These lists are called <b>params() scalars() xframe()</b>

<p>
<b>$head_near/far</b> macro constructs data in
two of those lists, <b>scalars</b> in the internal stack
and <b>xframe</b> in the external stack

<p>
<b>params()</b> and <b>scalars()</b> feature here:

<pre>



$ masmx rtxample -ln
MASMX 7r3
3/rtxample.msm
*EOF*
  :                            1 	$path		../def
  :                            2: 	$include	rta.def
  :                            3 	$path		../language
  :                            4: 	$include	stack.def
  :                            5: 	$include	fpxpress.def
  :                            6 	$path
  :                            7 $(0:0)
  :                            8 
00:000000 B60040              +9 floating_algorithm*  $vector fp_routine
  :                            10 
  :                            11 $(0:64)
  :                            12 
  :                            13 fp_routine 
                                	$head_far	 params(one,	float		;
                                				two,	float		;
                                				three,	float)		;
                                							;
Note: rtxample.msm Line 18: add $$frame to sp before return
00:000040 F80002              +18 			scalars(temp1,	int,	x)
  :                            19 
00:000041 4FF004              +20 	$xqt_fp		one*1.75*+1200000*two/3.0*-625000-three
00:000042 770100              +20 
00:000043 77F008              +20 
00:000044 7F0104              +20 
00:000045 6FF00C              +20 
  :                            21 
  :                            22 
00:000046 50F000              +23 	lx		temp1
  :                            24 
00:000047 FCF001              +25 	push, i		$$frame, sp
00:000048 38000F              +26 	pop		sp
00:000049 3D0000              +27 	fret		0
  :                            28 
  :                            29 	$do		$<256,$(0:256)
  :                            30 	
*EOF*
00:000100+7CD38BB7B396D7AA20B6E083
00:000104+2051D5B8447B77478A23F5F7
:$(00):000000:000108 
rtxample.msm: object code 229 bytes: 0 errors: 0 undefined labels


</pre>

<p>
The <b>c / lc</b> macro embeds far and near call instructions
<b>call</b> and <b>lcal</b>, first pushing parameters on the
internal stack, and afterwards clearing the internal stack

<p>
<b>c / lc</b> finalises the parameter list by pushing a stack walkback before
the <b>call / lcal</b> instruction and popping the internal stack pointer on
return. If there are no parameters, it doesn't. Then the effect is the same
as issuing a <b>call</b> or <b>lcal</b> instruction directly

<pre>

$ masmx ruxample -lnk
MASMX 7r3
3/ruxample.msm
*EOF*
  :                            1 	$path		../def
  :                            2: 	$include	rta.def
  :                            3 	$path		../language
  :                            4: 	$include	stack.def
  :                            5 	$path
  :                            6 
  :                            7 
  :                            8 $(3:03000)
  :                            9 left	$res	4
  :                            10 right	$res	4
  :                            11 centre	$res	4
  :                            12 	$lit
  :                            13 
  :                            14 $(0:64)
  :                            15 
  :                            16 
                                	c	(fp_algorithm)	left,,		float		;
                                				(1.875:d),,	floating_packed	;
00:000040 8F3004              +19 				right,,		float
00:000041 5F300C              +19 
00:000042 8F3000              +19 
00:000043 FCF00C              +19 
00:000044 FF300E              +19 
00:000045 38000F              +19 
  :                            20 
00:000046 473008              +21 	qs	centre
  :                            22 
  :                            23 
  :                            24 	$do	$<256,$(0:256)
  :                            25 
*EOF*
03:00300c+401F00000000
03:00300e+[0000]18:000000
:$(00):000040:000100 :$(03):003000:00300F 
ruxample.msm: object code 174 bytes: 0 errors: 1 undefined labels


</pre>
<p>
<b>params()</b> maps names onto the parameters pushed in <b>c / lc</b>

<p>
<b>scalars()</b> constructs and names dynamic variables in the
internal stack based on <b>sp</b>

<p>
<b>xframe()</b> constructs dynamic variables in the
in the external stack based on <b>fp</b>. <b>xframe()</b> is for
structures and arrays. The internal stack is only large enough for scalars
and pointers
<pre>

$ masmx tempbuff -ln
MASMX 7r3
3/tempbuff.msm
*EOF*
  :                            1 		$path		../def
  :                            2: 		$include	rta.def
  :                            3 		$path		../language
  :                            4: 		$include	stack.def
  :                            5 		$path
  :                            6 
                                routine1        $head_near       params(left,	long			;
                                                                        right,	long)			;
                                									;
                                                                scalars(down,	int,	0		;
                                                                        up,	int,	2048//3-1)	;
                                									;
Note: tempbuff.msm Line 13: add $$frame to sp before return
00:000000 F80000              +13                                  xframe(sorting_buffer, 2048//3)
00:000001 F802AA              +13 
00:000002 FDFD55              +13 
00:000003 2F000E              +13 
Note: tempbuff.msm Line 13: add $$xframe to fp before return
  :                            14 
  :                            15 .
  :                            16 .
  :                            17 
  :                            18 
  :                            19 
00:000004 FCE2AB              +20                 push, i         $$xframe, fp
00:000005 38000E              +21                 pop             fp
00:000006 FCF002              +22                 push, i         $$frame, sp
00:000007 38000F              +23                 pop             sp
  :                            24 
00:000008 350000              +25                 lret            0
  :                            26 
*EOF*
:$(00):000000:000009 :$(46):000000:0002AB 
tempbuff.msm: object code 159 bytes: 0 errors: 0 undefined labels

</pre>
<p>
These macros do not use a cover pointer for internal stack frames
based on <b>sp</b>. The overhead of maintaining a cover pointer has
been eliminated

<p>
<b>$head_near/far</b> and <b>c / lc</b> adjust with the
deepening stack displacement of objects already in the stack
as they add more objects

<p>
Routines constructed with this framework should therefore not change
<b>sp</b> except with <b>c / lc </b> macros

<p>
Very simple assembler routines need not use this framework of macros
at all. They can alter the stack freely

<p>
The practical way within this macro framework to save a register
during a routine is to assign it to a dynamic variable in the
<b>scalars()</b> list. This saves the register at routine start,
because the dynamic frame is constructed by pushing things
<pre>

$ masmx -ln saverlod.msm
MASMX 7r3
3/saverlod.msm
*EOF*
  :                            1 		$path		../def
  :                            2: 		$include	rta.def
  :                            3 		$path		../language
  :                            4: 		$include	stack.def
  :                            5 		$path
  :                            6 
  :                            7 $(0:64)
                                my_name		$head_near	scalars(caller_a,	int,	a	;
                                					caller_b,	int,	b	;
Note: saverlod.msm Line 10: add $$frame to sp before return
00:000040 F80004              +10 					caller_x,	int,	x)
00:000041 F80005              +10 
00:000042 F80002              +10 
  :                            11 
  :                            12 .		a b x of the calling routine are in the internal
  :                            13 .		stack and can be loaded as required
  :                            14 
  :                            15 .
  :                            16 .
00:000043 50F002              +17 		lx              caller_a	. reference caller's data
  :                            18 .
  :                            19 .
00:000044 60F001              +20 		la              caller_b	. reference caller's data
  :                            21 .
  :                            22 .
00:000045 60F002              +23 		la		caller_a	. restore caller's registers
00:000046 68F001              +24 		lb		caller_b
00:000047 50F000              +25 		lx		caller_x
00:000048 FCF003              +26 		push, i		$$frame, sp
00:000049 38000F              +27 		pop		sp
00:00004A 350000              +28 		lret		0
  :                            29 
  :                            30 
  :                            31 
*EOF*
:$(00):000040:00004B 
saverlod.msm: object code 147 bytes: 0 errors: 0 undefined labels


</pre>

<h3>2. Runtime Algorithmic Expressions</h3>

Here a simple algorithm with five inputs is executed in five instructions, including
operand acquisition from storage
<pre>


$ masmx -ln r2xample.msm
MASMX 7r3
3/r2xample.msm
*EOF*
  :                            1 	$path		../def
  :                            2: 	$include	rta.def
  :                            3 	$path		../language
  :                            4: 	$include	stack.def
  :                            5: 	$include	fpxpress.def
  :                            6 	$path
  :                            7 $(0:0)
  :                            8 
00:000000 B60040              +9 floating_algorithm*  $vector fp_routine
  :                            10 
  :                            11 $(0:64)
  :                            12 
  :                            13 fp_routine 
                                	$head_far	 params(one,	float		;
                                				two,	float		;
  :                            16 				three,	float)
  :                            17 
00:000040 4FF003              +18 	$xqt_fp		one*1.75*+1200000*two/3.0*-625000-three
00:000041 770100              +18 
00:000042 77F007              +18 
00:000043 7F0104              +18 
00:000044 6FF00B              +18 
  :                            19 
  :                            20 
00:000045 3D0000              +21 	fret		0
  :                            22 
  :                            23 	$do		$<256,$(0:256)
  :                            24 	
*EOF*
00:000100+7CD38BB7B396D7AA20B6E083
00:000104+2051D5B8447B77478A23F5F7
:$(00):000000:000108 
r2xample.msm: object code 190 bytes: 0 errors: 0 undefined labels


</pre>
Simply explained, the masmx assembler has taken an expression with five operands and
four operators, and turned it into a sequence of five instructions which deliver the
four-word floating result of the operations in the result registers <b>a:b:6:7</b>

<p>
Assemblers mostly solve expressions whose tokens are all known at assembly time

<p>
But three of these tokens are identifiers whose content is only known at runtime

<p>
<b>$xqt_fp</b> directive scans an expression and calls macro code to write an
instruction plan. The tokens which could be solved at assembly time
appear as literals at the foot of the program

<p>
Run-time expression-solving is required in compilers as distinct from
assemblers. But RTA1 has no compilers at present, so the <b>$xqt_fp</b>
directive supports future compilers and supports run-time expressions
right now

<p>
Exactly five instructions for five operands is as efficient as straight-line
computing can get

<p>
Load-store triadic architectures need at least ten instructions to load
and then compute. RTA1 reduces this to five instructions
with its seamless operand hierarchy of registers and memory

<p>
masmx.7r3 has of course a <b>$xqt_i</b> directive which applies arithmetic, boolean,
shift and comparison operations to integers, at assembly as far as possible
and in an instruction plan thereafter

<p>
<b>$xqt_fp</b> and <b>$xqt_i</b> directives essentially and initially plan
a load to the result registers. If masmx can solve the whole expression at
assembly time, only a constant load instruction is generated

<p>
Macro code to realise each successive operation in the algorithm is target-specific
and described in the manuals <b>masmx for RTA1</b> and <b>masmx.7r3</b>

<i>
<pre>

_______________________________________________________________________________________


LICENCE NOTE

    Copyright Tim Cox, 2012
    TimMilesCox@gmx.ch

    This document is part of the RTA1 Processor Programmable Architecture.

    RTA1 is a free processor architecture design. It is licensed
    under the GNU General Public Licence Version 3

    The executable emulation of RTA1 is free software.

    Instruction code for the target RTA1 architecture is free software
    if it is delivered with this software

    Software programs delivered with this software to connect the
    emulated RTA1 with real network interfaces in the emulator host
    are free software

    Scripts and programs delivered with this software for running
    on other computers and interacting with the RTA1 are free software

    The masmx target-independent meta-asembler delivered here
    is free software whether it is used for constructing RTA1 code
    or any other code. masmx is a separate free program by the
    same author and included with this software to save searching for it

    Scripts and utility programs for constructing RTA1 target
    executable software are free software

    You can redistribute it and/or modify RTA1
    under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    RTA1 is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with RTA1.  If not, see &lt;http://www.gnu.org/licenses/&gt;.


</pre>
</i>


</div>
</html>

