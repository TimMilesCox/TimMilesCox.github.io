<div	style="font-size:14pt">
<h2	style=2"color:0000FF">The Simplest Application Structure</h2>

<div    style="border-radius:10px;width:500pt;background-color:#EFEFEF;font-family:courier">
The small wrapper file listed out below includes a slightly larger one containing the view application

<p>
It's done like this because there are other ways of having this application. <a	style="color:red">viewfile</a> can be included from a different wrapper to have a different environment

<p>
There's a lot of $list 0 here which will stop too much kernel material appearing in any name list you might choose to generate

<p>
At the same time, the wrapper is printed out to show what kind of system headers an application is likely to need. That's those .def files at the top


<p>
The application is assembled straight into absolute code starting address zero, and thats how applications are in RTA1

<p>
There is a <a href="#vector">$vector</a> jump pad with just one entry at the start of the memory page containing viewfile application

<p>
<a href="#vector">$vector</a> macro exports the entry point view* and jumps to the application
</div>

<pre	style="font-size:12pt">

$ cat viewfile.msm
	$list		0
        $path           ../
        $include        def/rta.def
        $include        def/vector.def
        $include        def/ii.def
        $include        language/stack.def
	$include	fs/file_io.def
        $include        stream/stream.def
	$include	language/catalog.def
	$include	def.app/iframes.def
	$path
	$include	../image.app/imports.def
        $list

__BASE	$equ	APPLICATION(3)/*12

$(0:0/$0)

view*	$vector	viewfile

	catalog

viewfile
	$list		2
	$include	../source.app/viewfile.msm

	$do	$<256,$(0:256)	. force literals into operand memory space
				. operand addresses 0..255 are registers

</pre>

<div    style="border-radius:10px;width:500pt;background-color:#EFEFEF;font-family:courier">
Next is what you see if you assemble this wrapper

<p>
Blocks called $(3) and $(1) appear. They are data

<p>
Many automatic constants called literals appear at the end of the code

<p>
Some literals are forced into $3() data space. That's so a different $(0) instruction frame can address these literals as arguments. This is an important matter to understand. RTA1 only addresses one iframe at one time. So if you are calling library, scalars and pointers are in the internal stack, and that's just fine. If a pointer in the internal stack is pointing to something larger, like a string, that string has to be somewhere the called iframe can see it. Like your $(3) data space

<p>

This application encodes NFS remote mount points in file open path strings. Of course there are other ways of doing this, and other ways of doing the remote host search which is coded inline here. Just to show a few instructions can be a powerful thing in RTA1

<p>
C-language number/string style has been opted in order to show escape sequences in a way most developers recognise them

<p>
Macro <a href="#base_d">$base_d</a> places data storage assigned to the process in address window $(3) 003000<sub>16</sub>

<p>
Kernel routine <a href="#seg_load">seg$load</a> is called to unpack initial data values from a read-only file system embedded in the application image. All RTA1 code is shared code
</div>

<pre	style="font-size:12pt">

$ masmx -lnke viewfile
MASMX 7r3A Build 10
3/viewfile.msm
*EOF*
  :                            13         $list
  :                            14 
  :                            15 __BASE	$equ	APPLICATION(3)/*12
  :                            16 
  :                            17 $(0:0/$0)
  :                            18 
00:000000  B60050              +19 view*	$vector	viewfile
  :                            20 
[+0000]18
00:000040  000050 00000B 001000 000000
                              +21 	catalog
00:000044  4D0003              +21 
00:000045  000000              +21 
[+0001]30
00:000046  000000 000000        +21 
[+0000]18*/48
00:000048  800040 000007 001000 FFFFFF 000000 000000 000050 00000B
                              +21 
  :                            22 
  :                            23 viewfile
  :                            24 	$list		2
  :                            25: 	$include	../source.app/viewfile.msm
  :                            1 
  :                            2 $(1:01000/$1)
01:001000  000000 000000        +3 cursor		0L
  :                            4 
  :                            5 $(3:03000/$3)
  :                            6 
  :                            7 BUFFER	$equ	32
  :                            8 
03:003000  000000              +9 handle  0
  :                            10 
  :                            11 command		$res	8
  :                            12 path		$res	120/3
  :                            13 host		$res	8
  :                            14 file		$res	72
  :                            15 
  :                            16 
  :                            17 request $res    72/3
  :                            18 buffer  $res    BUFFER
  :                            19 
  :                            20 $(0)
  :                            21 
  :                            22 	$set_option	"c"		. that makes escape sequences easier to read
  :                            23 					. it means C Language number and string syntax
  :                            24 
00:000050  60207F              +25 	$base_d	$zenith(3)-0x003000 1024*2
00:000051  340003              +25 
00:000052  60012F              +25 
00:000053  75007A              +25 
00:000054  654000              +25 
00:000055  20000E              +25 
  :                            26 
00:000056  9F0130              +27 	c	(seg$load)	0,,xi	(viewfile_data:d),,long
00:000057  FD0000              +27 
00:000058  FCF003              +27 
00:000059  FF0132              +27 
00:00005A  38000F              +27 
00:00005B  FF0133              +28 	call	(dialplan_online)
  :                            29 
  :                            30 
00:00005C  FD00AC              +31 	fgets	request,,i 172 stdin
00:00005D  FC3081              +31 
00:00005E  FD0000              +31 
00:00005F  FCF003              +31 
00:000060  FF0134              +31 
00:000061  38000F              +31 
00:000062  160018              +31 
00:000063  1D0018              +31 
00:000064  EE0067              +31 
00:000065  CE0067              +31 
00:000066  643081              +31 
00:000067  FD3081              +32 	printf	$3("file viewer: %s\n\0"),,xi request,,xi
00:000068  FD30C5              +32 
00:000069  FD0001              +32 
00:00006A  FCF003              +32 
00:00006B  FF0135              +32 
00:00006C  38000F              +32 
  :                            33 
00:00006D  FD3031              +34 	sscanf	request,,xi $3("%s %:@%s":0),,xi command,,xi path+6,,xi host,,xi
00:00006E  FD300F              +34 
00:00006F  FD3001              +34 
00:000070  FD30CB              +34 
00:000071  FD3081              +34 
00:000072  FCF005              +34 
00:000073  FF0136              +34 
00:000074  38000F              +34 
  :                            35 
00:000075  C5FFFD              +36 	aa	-3,,xi			. field @ field acquired?
00:000076  7E0085              +37 	jc	remote_open
00:000077  FD3009              +38 	sscanf	request,,xi $3("%s %s":0),,xi command,,xi path,,xi
00:000078  FD3001              +38 
00:000079  FD30CE              +38 
00:00007A  FD3081              +38 
00:00007B  FCF004              +38 
00:00007C  FF0136              +38 
00:00007D  38000F              +38 
00:00007E  FD3009              +39 	printf	$3("display %s\n":0),,xi path,,xi
00:00007F  FD30D0              +39 
00:000080  FD0001              +39 
00:000081  FCF003              +39 
00:000082  FF0135              +39 
00:000083  38000F              +39 
00:000084  B6009D              +40 	j	open_view
  :                            41 
  :                            42 remote_open
00:000085  FD3031              +43 	printf	$3("speed dial %s@%s\n":0),,xi	path+6,,xi	host,,xi
00:000086  FD300F              +43 
00:000087  FD30D4              +43 
00:000088  FD0001              +43 
00:000089  FCF004              +43 
00:00008A  FF0135              +43 
00:00008B  38000F              +43 
  :                            44 
00:00008C  FD3009              +45 	c	(speed_dial)	host,,long	path,,xi
00:00008D  9F3031              +45 
00:00008E  FCF003              +45 
00:00008F  FF0137              +45 
00:000090  38000F              +45 
  :                            46 
00:000091  4FA000              +47 	ql	0, x
00:000092  473009              +48 	qs	path
00:000093  CFA004              +49 	dl	4, x
00:000094  C7300D              +50 	ds	path+4
  :                            51 
00:000095  FD300F              +52 	c	(strlenx) path+6,,xi	. count the filename bytes -> a containing words -> b
00:000096  FCF001              +52 
00:000097  FF0138              +52 
00:000098  38000F              +52 
  :                            53 
00:000099  260008              +54 	sal	8			. insert name byte count in path preamble header word
00:00009A  903009              +55 	or	path
  :                            56 
00:00009B  C00005              +57 	aa	b			. add containing words of name to path structure length
00:00009C  203009              +58 	sa	path			. update the path preamble
  :                            59 
  :                            60 open_view
                                	c	(open)	path,,xi	;
00:00009D  FD0000              +62 			O_RDONLY,,xi
00:00009E  FD3009              +62 
00:00009F  FCF002              +62 
00:0000A0  FF0139              +62 
00:0000A1  38000F              +62 
  :                            63 
00:0000A2  203000              +64 	sa	handle
00:0000A3  E600DB              +65 	jna	neverdid
  :                            66 
00:0000A4  FD0020              +67 more	c	(read)	handle	buffer,,xi	 BUFFER,,xi
00:0000A5  FD3099              +67 
00:0000A6  F83000              +67 
00:0000A7  FCF003              +67 
00:0000A8  FF013A              +67 
00:0000A9  38000F              +67 
00:0000AA  E600D4              +68 	jna	didsome
  :                            69 
00:0000AB  553099              +70 	lx	buffer,,xi		. calculate display limit pointer
00:0000AC  800004              +71 	ax	a			. = &buffer + data words
00:0000AD  400002              +72 	lr	x
00:0000AE  553099              +73 	lx	buffer,,xi
  :                            74 
00:0000AF  F600B2              +75 owrite	jxge	ocomplete
00:0000B0  3E00F7              +76 	lcal	writealine
00:0000B1  B600AF              +77 	j	owrite
  :                            78 ocomplete
  :                            79 	
  :                            80 
00:0000B2  FD0064              +81 	fgets	request,,i 100 stdin
00:0000B3  FC3081              +81 
00:0000B4  FD0000              +81 
00:0000B5  FCF003              +81 
00:0000B6  FF0134              +81 
00:0000B7  38000F              +81 
00:0000B8  160018              +81 
00:0000B9  1D0018              +81 
00:0000BA  EE00BD              +81 
00:0000BB  CE00BD              +81 
00:0000BC  643081              +81 
00:0000BD  E600E2              +82 	jna	leave_orderly		. if stdin has disconnected just drop out
00:0000BE  603081              +83 	la	request
00:0000BF  E600E2              +84 	jna	leave_orderly		. CTRL_D detected, treat as EOF
00:0000C0  060010              +85 	sar	16
00:0000C1  C5FFD2              +86 	aa	-'.',,xi		. a period means stop
00:0000C2  C600E2              +87 	jza	leave_orderly
00:0000C3  C5FFF4              +88 	aa	'.'-'0'-10,,xi		. a number entered in either decimal or hex
00:0000C4  7E00A4              +89 	jc	more			. means reposition within the target file
00:0000C5  C5000A              +90 	aa	10,,xi			. leading zero = hex, 1..9 = decimal
00:0000C6  5E00A4              +91 	jnc	more			. anything else means carry on
  :                            92 
00:0000C7  FD1000              +93 	sscanf	request,,xi	$3("%li":0),,xi	cursor,,xi	. read 48-bit number
00:0000C8  FD30DA              +93 
00:0000C9  FD3081              +93 
00:0000CA  FCF003              +93 
00:0000CB  FF0136              +93 
00:0000CC  38000F              +93 
00:0000CD  FD0000              +94 	c	(lseek)	handle	cursor,,long	SEEK_SET,,xi
00:0000CE  9F1000              +94 
00:0000CF  F83000              +94 
00:0000D0  FCF004              +94 
00:0000D1  FF013B              +94 
00:0000D2  38000F              +94 
00:0000D3  B600A4              +95 	j	more
  :                            96 
00:0000D4  F80004              +97 didsome	printf	$3("read failed %d\n":0),,xi a
00:0000D5  FD30DC              +97 
00:0000D6  FD0001              +97 
00:0000D7  FCF003              +97 
00:0000D8  FF0135              +97 
00:0000D9  38000F              +97 
00:0000DA  B600E2              +98 	j	leave_orderly
  :                            99 
  :                            100 neverdid
00:0000DB  F80004              +101 	printf	$3("bad open %d\n":0),,xi a
00:0000DC  FD30E2              +101 
00:0000DD  FD0001              +101 
00:0000DE  FCF003              +101 
00:0000DF  FF0135              +101 
00:0000E0  38000F              +101 
00:0000E1  B600E2              +102 	j	leave_orderly
  :                            103 
  :                            104 
  :                            105 leave_orderly
00:0000E2  F83000              +106 	c	(close)	handle		. terminate process
00:0000E3  FCF001              +106 
00:0000E4  FF013C              +106 
00:0000E5  38000F              +106 
00:0000E6  3D0000              +107 	fret	0			. dialogue continues in telnet stub
  :                            108 					. if stdin socket is still connected
  :                            26 
  :                            27 	$do	$<256,$(0:256)	. force literals into operand memory space
  :                            28 				. operand addresses 0..255 are registers
  :                            29 
*EOF*
00:00012f+[0000]18:000000
00:000130+[0002]30:000000000000
00:000132+0001CD
00:000133+0001EE
00:000134+0001E4
00:000135+0001DB
00:000136+0001D8
00:000137+0001EF
00:000138+00019A
00:000139+0001D2
00:00013a+0001D3
00:00013b+0001D5
00:00013c+0001D7
00:00013d+000221
00:00013e+0001D4
00:00013f+0001D6
00:000140+000000
00:000141+600000
03:0030c5+66696C65207669657765723A2025730A0000
03:0030cb+257320253A40257300
03:0030ce+257320257300
03:0030d0+646973706C61792025730A00
03:0030d4+7370656564206469616C2025734025730A00
03:0030da+256C69000000
03:0030dc+72656164206661696C65642025640A000000
03:0030e2+626164206F70656E2025640A000000
:$(00):000000:000142 :$(01):001000:001002 :$(02):002000:003000 :$(03):003000:0030E7 
viewfile.msm: object code 2997 bytes: 0 errors: 3 undefined labels

</pre>

<div    style="border-radius:10px;width:500pt;background-color:#EFEFEF;font-family:courier"><a	name="image.app"/>
You need directory rta/target.rta/image.app in your path to construct applications

<p>
You also need some <a href="masmx7r3.html#binary_utilities">binary utilities</a> in your path. They should be in $RTA_BINARY

<p>
If viewfile is the only fixed application in your lookup path, you do this build
</div>

<pre	style="font-size:12pt">

	cd rta/target.rta/viewfile.app
	./make

</pre>

<div    style="border-radius:10px;width:500pt;background-color:#EFEFEF;font-family:courier">
This constructs viewfile and joins it to the kernel

<p>
This is how it does it. Commands make1 profile1 and lookup are scripts in rta/target.rta/image.app
<p>
A data file lookups must be present in the directory where the the application is developed. lookups guides
the construction of the lookups readonly file system
</div>

<pre	style="font-size:12pt">

$ cat target.rta/viewfile.app/make
rm *.txo
rm *.abs
rm *.fs
rm *.rom
rm storage
rm outrigger
rm viewfile
rm viewfile_profile

make1 viewfile				# assemble the application
profile1 viewfile view 7 1 APPLICATION	# assemble its launch parameters

lookup					# construct the lookup file system
					# join applications to the kernel
cat ../rta.gen/minimal.rom lookup.fs viewfile.rom > sysimage.rom
cmp lookup.zak lookup.fs
cmp viewfile.zak viewfile.rom
cmp sysimage.zak sysimage.rom		# see if anything changed


$ cat target.rta/viewfile.app/lookups
volume apps_interface.fs
tree lookup
file view viewfile_profile.rom

</pre>

<div    style="border-radius:10px;width:500pt;background-color:#EFEFEF;font-family:courier">

The first page where fixed applications go is an address called APPLICATION in a file rta/target.rta/def.sys/banks.def

<p>
If multiple applications and libraries are fixed in the load image, then their position in NVRAM must advance from address APPLICATION as pages are filled

<p>
A header file list defining these addresses, say apps.def, might take the form
</div>

<pre	style="font-size:12pt">

$ cat apps.def

APPLICATION1	$equ	APPLICATION+4096*1
ANOTHER_APP	$equ	APPLICATION+4096*2

</pre>

<div	style="border-radius:10px;width:500pt;background-color:#EFEFEF;font-family:courier">
application1 and another_app would need to be catenated into sysimage and listed in lookups

<p>
Applications need not be exactly one 4K-word page each. They can be larger or less than 4K

<p>
It's likely you want more than a file viewer as a system application

<p>
A simple way to construct applications is to put them in successive one page iframes like viewfile and join them all to the kernel at fixed locations to make a load image, but it's feasible to construct more sparingly

<p>
RTA1 is about miniaturisation and a page of 4096 words can hold several applications like viewfile

<p>
So the prototype of a loader for dynamic application loads has been packed into the same page as viewfile, and the system image is constructed like this
</div>


<pre	style="font-size:12pt">

	cd rta/target.rta/initial.app
	./make

</pre>

<div    style="border-radius:10px;width:500pt;background-color:#EFEFEF;font-family:courier">
This takes some relocatable assembly and some linking, but the difference is all in the ./make script and the different wrapper files initial.app/viewfile.msm and initial.app/loader.msm

<p>
This is how it does it. Commands relt mcombine mprofile and lookup are scripts in rta/target.rta/image.app
<p>
A data file lookups must be present in the directory where the the application is developed. lookups guides
the construction of the lookups readonly file system
</div>

<pre	style="font-size:12pt">

$ cat target.rta/initial.app/make
rm *.abs
rm *.rel
rm *.txo
rm *.rom
rm *.fs
rm outrigger
rm storage
rm loader_profile
rm viewfile_profile
rm apps

relt loader					# assemble applications relocatable
relt viewfile
mcombine apps					# link them in one iframe
mprofile apps load 7 1 APPLICATION loader	# construct the launch parameters
mprofile apps view 7 1 APPLICATION viewfile	# of each application
lookup						# construct the lookup file system
						# join applications to the kernel
cat ../rta.gen/minimal.rom lookup.fs apps.rom > sysimage.rom

cmp sysimage.zak sysimage.rom
cmp apps.zak apps.rom
cmp lookupfs.zak lookup.fs			# see if anything changed


$ cat target.rta/initial.app/lookups
volume apps_interface.fs
tree lookup
file load loader_profile.rom
file view viewfile_profile.rom
.
.

</pre>

<div    style="border-radius:10px;width:500pt;background-color:#EFEFEF;font-family:courier">
If more applications start to need more NVRAM pages then their load profile address advances from address APPLICATION in increments of 4096 words

<p>
Here is the different wrapper to generate viewfile relocatable

<p>
The *1 in $(4:*1 and $(0:*1 means <a href="masmx7r3.html#locator">program section relocatable</a>. These are code and constant sections

<p>
Data sections $(3) $(1) remain absolute in runtime windows 003000 hex and 001000 hex

<p>
The asterisk on viewfile* exports it

</div>

<pre	style="font-size:12pt">

cat rta/target.rta/initial.app/viewfile.msm

        $path           ../
        $list           0
        $include        def/rta.def
        $include        def/vector.def
        $include        def/ii.def
        $include        language/stack.def
        $include        stream/stream.def
        $include        fs/request.def
        $include        fs/mntaddrs.def
        $include        t77.4/ip.def
	$path

	$include	../image.app/imports.def
        $list
        $path

_BASE	$equ	0

	$lit	4

$(4:*1/$4)
$(0:*1)

viewfile*
	$include	../source.app/viewfile.msm


</pre>

<div    style="border-radius:10px;width:500pt;background-color:#EFEFEF;font-family:courier">
<p>
Here is the step that gets back to absolute code and contains the entry point <a href="#vector">vectors</a>

<p>
This file is an assembly language source assembled with masmx

<p>
Link rules from rta/target.rta/def/map1.def are needed
</div>

<pre	style="font-size:12pt">

$ cat target.rta/initial.app/apps.msm
	$include	../def/rta.def
	$include	../language/stack.def
	$include	../def/map1.def

$(0:0)
load*	$vector	loader
view*	$vector	viewfile
 	$list	0
 	$do	64-$,	fret	0
 	$list
 	$include,$binary	loader.rel	$(0)
 	$include,$binary	viewfile.rel	$(0)
 
 	$do	$<256,$(0:256)	. iframe literals here
$(4:$(0))
 	$include,$binary	loader.rel	$(4)
 	$include,$binary	viewfile.rel	$(4)

OUTRIGGER* $set	$zenith+63**-64	. export a link location
				. for the data segments file system

</pre>

<div    style="border-radius:10px;width:500pt;background-color:#EFEFEF;font-family:courier">
Fixed iframes larger than one page may be constructed. They are accessed via <a href="rta.html#gate">gate</a>

<p>
If you update the kernel instead of the application, do ./reload instead of ./make

<p>
./reload builds the kernel, ./make builds the application, both join the kernel and application

<p>
That was application iframes fixed in the system load image

<p>
Construct <a href="rta.html#gate">gate</a> is also used to access <a href="iframe.html">loadable applications</a>

<p>
Application <a href="iframe.html#loader">loader</a> loads these
</div>
</div>
